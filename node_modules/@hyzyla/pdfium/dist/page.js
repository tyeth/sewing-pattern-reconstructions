"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PDFiumPage = void 0;
const constants_1 = require("./constants");
const objects_1 = require("./objects");
const utils_1 = require("./utils");
class PDFiumPage {
    constructor(options) {
        this.module = options.module;
        this.pageIdx = options.pageIdx;
        this.documentIdx = options.documentIdx;
        this.number = options.pageIndex;
    }
    /**
     * Get the size of the page in points (1/72 inch)
     */
    getSize(precisely = false) {
        const width = this.module._FPDF_GetPageWidth(this.pageIdx);
        const height = this.module._FPDF_GetPageHeight(this.pageIdx);
        if (precisely) {
            return {
                width: width,
                height: height,
            };
        }
        return {
            width: Math.floor(width),
            height: Math.floor(height),
        };
    }
    render(options = {
        scale: 1,
        render: "bitmap",
    }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { width: originalWidth, height: originalHeight } = this.getSize();
            // You can specify either the scale or the width and height.
            let width;
            let height;
            if ("scale" in options) {
                width = Math.floor(originalWidth * options.scale);
                height = Math.floor(originalHeight * options.scale);
            }
            else {
                width = options.width;
                height = options.height;
            }
            const buffSize = width * height * constants_1.BYTES_PER_PIXEL;
            // Allocate a block of memory for the bitmap and fill it with zeros.
            const ptr = this.module.wasmExports.malloc(buffSize);
            this.module.HEAPU8.fill(0, ptr, ptr + buffSize);
            const bitmap = this.module._FPDFBitmap_CreateEx(width, height, constants_1.FPDFBitmap.BGRA, ptr, width * constants_1.BYTES_PER_PIXEL);
            this.module._FPDFBitmap_FillRect(bitmap, 0, // left
            0, // top
            width, // width
            height, // height
            0xffffffff);
            this.module._FPDF_RenderPageBitmap(bitmap, this.pageIdx, 0, // start_x
            0, // start_y
            width, // size_x
            height, // size_y
            0, // rotate (0, normal)
            constants_1.FPDFRenderFlag.REVERSE_BYTE_ORDER | constants_1.FPDFRenderFlag.ANNOT | constants_1.FPDFRenderFlag.LCD_TEXT);
            this.module._FPDFBitmap_Destroy(bitmap);
            this.module._FPDF_ClosePage(this.pageIdx);
            const data = Buffer.from(this.module.HEAPU8.subarray(ptr, ptr + buffSize));
            this.module.wasmExports.free(ptr);
            const image = yield this.convertBitmapToImage({
                render: options.render,
                width: width,
                height: height,
                data: data,
            });
            return {
                width: width,
                height: height,
                originalHeight: originalHeight,
                originalWidth: originalWidth,
                data: image,
            };
        });
    }
    convertBitmapToImage(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, utils_1.convertBitmapToImage)(options);
        });
    }
    getObjectCount() {
        return this.module._FPDFPage_CountObjects(this.pageIdx);
    }
    getObject(i) {
        const object = this.module._FPDFPage_GetObject(this.pageIdx, i);
        return objects_1.PDFiumObjectBase.create({
            module: this.module,
            objectIdx: object,
            documentIdx: this.documentIdx,
            pageIdx: this.pageIdx,
        });
    }
    *objects() {
        const objectsCount = this.getObjectCount();
        for (let i = 0; i < objectsCount; i++) {
            yield this.getObject(i);
        }
    }
}
exports.PDFiumPage = PDFiumPage;
