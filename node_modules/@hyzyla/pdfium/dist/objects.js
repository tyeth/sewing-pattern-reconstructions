"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PDFiumFormObject = exports.PDFiumShadingObject = exports.PDFiumImageObject = exports.PDFiumPathObject = exports.PDFiumTextObject = exports.PDFiumObjectBase = void 0;
const constants_1 = require("./constants");
const utils_1 = require("./utils");
class PDFiumObjectBase {
    constructor(options) {
        this.module = options.module;
        this.objectIdx = options.objectIdx;
        this.documentIdx = options.documentIdx;
        this.pageIdx = options.pageIdx;
    }
    static create(options) {
        const type = options.module._FPDFPageObj_GetType(options.objectIdx);
        switch (type) {
            case constants_1.FPDFPageObjectType.TEXT:
                return new PDFiumTextObject(options);
            case constants_1.FPDFPageObjectType.PATH:
                return new PDFiumPathObject(options);
            case constants_1.FPDFPageObjectType.IMAGE:
                return new PDFiumImageObject(options);
            case constants_1.FPDFPageObjectType.SHADING:
                return new PDFiumShadingObject(options);
            case constants_1.FPDFPageObjectType.FORM:
                return new PDFiumFormObject(options);
            default:
                throw new Error(`Unknown object type: ${type}`);
        }
    }
}
exports.PDFiumObjectBase = PDFiumObjectBase;
class PDFiumTextObject extends PDFiumObjectBase {
    constructor() {
        super(...arguments);
        this.type = "text";
    }
}
exports.PDFiumTextObject = PDFiumTextObject;
class PDFiumPathObject extends PDFiumObjectBase {
    constructor() {
        super(...arguments);
        this.type = "path";
    }
}
exports.PDFiumPathObject = PDFiumPathObject;
class PDFiumImageObject extends PDFiumObjectBase {
    constructor() {
        super(...arguments);
        this.type = "image";
    }
    static formatToBPP(format) {
        switch (format) {
            case constants_1.FPDFBitmap.Gray:
                return 1;
            case constants_1.FPDFBitmap.BGR:
                return 3;
            case constants_1.FPDFBitmap.BGRx:
            case constants_1.FPDFBitmap.BGRA:
                return 4;
            default:
                throw new Error(`Unsupported bitmap format: ${format}`);
        }
    }
    /**
     * Return the raw uncompressed image data.
     */
    getImageDataRaw() {
        return __awaiter(this, void 0, void 0, function* () {
            const bufferSize = this.module._FPDFImageObj_GetImageDataRaw(this.objectIdx, 0, 0);
            if (!bufferSize) {
                throw new Error("Failed to get bitmap from image object.");
            }
            const bufferPtr = this.module.wasmExports.malloc(bufferSize);
            if (!this.module._FPDFImageObj_GetImageDataRaw(this.objectIdx, bufferPtr, bufferSize)) {
                throw new Error("Failed to get bitmap buffer.");
            }
            const oData = Buffer.from(this.module.HEAPU8.slice(bufferPtr, bufferPtr + bufferSize));
            this.module.wasmExports.free(bufferPtr);
            // Width and height of the image in pixels will be written to these pointers as 16-bit integers (2 bytes each):
            // [ ... width (2 bytes) ... | ... height (2 bytes) ... ]
            const sizePtr = this.module.wasmExports.malloc(2 + 2);
            const widthPtr = sizePtr;
            const heightPtr = sizePtr + 2;
            if (!this.module._FPDFImageObj_GetImagePixelSize(this.objectIdx, widthPtr, heightPtr)) {
                throw new Error("Failed to get image size.");
            }
            const widthBuffer = Buffer.from(this.module.HEAPU8.slice(widthPtr, widthPtr + 2));
            const heightBuffer = Buffer.from(this.module.HEAPU8.slice(heightPtr, heightPtr + 2));
            this.module.wasmExports.free(sizePtr);
            const width = widthBuffer.readUInt16LE();
            const height = heightBuffer.readUInt16LE();
            const filtersCount = this.module._FPDFImageObj_GetImageFilterCount(this.objectIdx);
            const filters = [];
            for (let i = 0; i < filtersCount; i++) {
                const filterSize = this.module._FPDFImageObj_GetImageFilter(this.objectIdx, i, 0, 0);
                const filterPtr = this.module.wasmExports.malloc(filterSize);
                if (!this.module._FPDFImageObj_GetImageFilter(this.objectIdx, i, filterPtr, filterSize)) {
                    throw new Error("Failed to get image filter.");
                }
                const filterBuffer = Buffer.from(this.module.HEAPU8.slice(filterPtr, filterPtr + filterSize - 1));
                const filter = filterBuffer.toString("utf8").trim();
                this.module.wasmExports.free(filterPtr);
                filters.push(filter);
            }
            return {
                width: width,
                height: height,
                data: oData,
                filters: filters,
            };
        });
    }
    /**
     * Render the image object to a buffer with the specified render function.
     */
    render(options = {
        render: "bitmap",
    }) {
        return __awaiter(this, void 0, void 0, function* () {
            const bitmapIdx = this.module._FPDFImageObj_GetBitmap(this.objectIdx);
            if (!bitmapIdx) {
                throw new Error("Failed to get bitmap from image object.");
            }
            const bufferPtr = this.module._FPDFBitmap_GetBuffer(bitmapIdx);
            if (!bufferPtr) {
                throw new Error("Failed to get bitmap buffer.");
            }
            // Stride is the number of bytes per row, it might be larger than width * bytesPerPixel
            // and is used for alignment in the bitmap buffer (e.g. 4-byte alignment)
            const stride = this.module._FPDFBitmap_GetStride(bitmapIdx);
            // Width and height of the image in pixels
            const width = this.module._FPDFBitmap_GetWidth(bitmapIdx);
            const height = this.module._FPDFBitmap_GetHeight(bitmapIdx);
            // Format of the image: 1 - Gray, 2 - BGR, 3 - BGRx, 4 - BGRA
            const format = this.module._FPDFBitmap_GetFormat(bitmapIdx);
            // Here is BBP (bytes per pixel) for the original image
            const oBPP = PDFiumImageObject.formatToBPP(format);
            // Calculate the buffer size of the original image, stored in the WASM heap
            const bufferSize = height * stride;
            // Get the buffer from the WASM heap to a JS Uint8Array
            const oData = this.module.HEAPU8.slice(bufferPtr, bufferPtr + bufferSize);
            this.module.wasmExports.free(bufferPtr);
            // Currently we only support converting to RGBA (4 bytes per pixel)
            const tBPP = constants_1.BYTES_PER_PIXEL;
            // Create a new buffer for the target image and fill it with white color
            const tData = Buffer.alloc(width * height * tBPP, 255);
            // Iterate over the rows of the original and target images
            for (let rowIndex = 0; rowIndex < height; rowIndex++) {
                const tRowStart = rowIndex * tBPP * width;
                const oRowStart = rowIndex * stride;
                // Iterate over the columns of the original and target images
                for (let columnIndex = 0; columnIndex < width; columnIndex++) {
                    const tPixelStart = tRowStart + columnIndex * tBPP;
                    const oPixelStart = oRowStart + columnIndex * oBPP;
                    // conver from original format to RGBA
                    // =================
                    switch (format) {
                        case constants_1.FPDFBitmap.Gray: {
                            // Grayscale: Copy the gray value to R, G, B, and set A to 255
                            const gray = oData[oPixelStart];
                            tData[tPixelStart + 0] = gray; // R
                            tData[tPixelStart + 1] = gray; // G
                            tData[tPixelStart + 2] = gray; // B
                            // A is already set to 255 by Buffer.alloc
                            break;
                        }
                        case constants_1.FPDFBitmap.BGR: {
                            // BGR: Copy the values to RGB and set A to 255
                            tData[tPixelStart + 0] = oData[oPixelStart + 2]; // R
                            tData[tPixelStart + 1] = oData[oPixelStart + 1]; // G
                            tData[tPixelStart + 2] = oData[oPixelStart + 0]; // B
                            // A is already set to 255 by Buffer.alloc
                            break;
                        }
                        case constants_1.FPDFBitmap.BGRx: {
                            // BGRx: Copy the values to RGB and set A to 255
                            tData[tPixelStart + 0] = oData[oPixelStart + 2]; // R
                            tData[tPixelStart + 1] = oData[oPixelStart + 1]; // G
                            tData[tPixelStart + 2] = oData[oPixelStart + 0]; // B
                            // A is already set to 255 by Buffer.alloc
                            break;
                        }
                        case constants_1.FPDFBitmap.BGRA: {
                            // BGRA: Copy directly
                            tData[tPixelStart + 0] = oData[oPixelStart + 2]; // R
                            tData[tPixelStart + 1] = oData[oPixelStart + 1]; // G
                            tData[tPixelStart + 2] = oData[oPixelStart + 0]; // B
                            tData[tPixelStart + 3] = oData[oPixelStart + 3]; // A
                            break;
                        }
                        default:
                            throw new Error(`Unsupported bitmap format: ${format}`);
                    }
                    // switch case end
                    // =================
                }
            }
            const image = yield (0, utils_1.convertBitmapToImage)({
                render: options.render,
                width: width,
                height: height,
                data: tData,
            });
            return {
                width: width,
                height: height,
                data: image,
            };
        });
    }
}
exports.PDFiumImageObject = PDFiumImageObject;
class PDFiumShadingObject extends PDFiumObjectBase {
    constructor() {
        super(...arguments);
        this.type = "shading";
    }
}
exports.PDFiumShadingObject = PDFiumShadingObject;
class PDFiumFormObject extends PDFiumObjectBase {
    constructor() {
        super(...arguments);
        this.type = "form";
    }
}
exports.PDFiumFormObject = PDFiumFormObject;
