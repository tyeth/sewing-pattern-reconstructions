import {
  __commonJS,
  __require
} from "./chunk-CQXHTUV2.js";

// node_modules/jimp/browser/lib/jimp.js
var require_jimp = __commonJS({
  "node_modules/jimp/browser/lib/jimp.js"(exports, module) {
    if ((typeof window == "undefined" || !window) && typeof self != "undefined")
      var window = self;
    (function(f) {
      if (typeof exports === "object" && typeof module !== "undefined") {
        module.exports = f();
      } else if (typeof define === "function" && define.amd) {
        define([], f);
      } else {
        var g;
        if (typeof window !== "undefined") {
          g = window;
        } else if (typeof global !== "undefined") {
          g = global;
        } else if (typeof self !== "undefined") {
          g = self;
        } else {
          g = this;
        }
        g.jimp = f();
      }
    })(function() {
      var define2, module2, exports2;
      return function() {
        function r(e, n, t) {
          function o(i2, f) {
            if (!n[i2]) {
              if (!e[i2]) {
                var c = "function" == typeof __require && __require;
                if (!f && c)
                  return c(i2, true);
                if (u)
                  return u(i2, true);
                var a = new Error("Cannot find module '" + i2 + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
              }
              var p = n[i2] = { exports: {} };
              e[i2][0].call(p.exports, function(r2) {
                var n2 = e[i2][1][r2];
                return o(n2 || r2);
              }, p, p.exports, r, e, n, t);
            }
            return n[i2].exports;
          }
          for (var u = "function" == typeof __require && __require, i = 0; i < t.length; i++)
            o(t[i]);
          return o;
        }
        return r;
      }()({ 1: [function(require2, module3, exports3) {
        function _arrayWithHoles(arr) {
          if (Array.isArray(arr))
            return arr;
        }
        module3.exports = _arrayWithHoles;
      }, {}], 2: [function(require2, module3, exports3) {
        function _arrayWithoutHoles(arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
              arr2[i] = arr[i];
            }
            return arr2;
          }
        }
        module3.exports = _arrayWithoutHoles;
      }, {}], 3: [function(require2, module3, exports3) {
        function _assertThisInitialized(self2) {
          if (self2 === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self2;
        }
        module3.exports = _assertThisInitialized;
      }, {}], 4: [function(require2, module3, exports3) {
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        module3.exports = _classCallCheck;
      }, {}], 5: [function(require2, module3, exports3) {
        var setPrototypeOf = require2("./setPrototypeOf");
        function isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Date.prototype.toString.call(Reflect.construct(Date, [], function() {
            }));
            return true;
          } catch (e) {
            return false;
          }
        }
        function _construct(Parent, args, Class) {
          if (isNativeReflectConstruct()) {
            module3.exports = _construct = Reflect.construct;
          } else {
            module3.exports = _construct = function _construct2(Parent2, args2, Class2) {
              var a = [null];
              a.push.apply(a, args2);
              var Constructor = Function.bind.apply(Parent2, a);
              var instance = new Constructor();
              if (Class2)
                setPrototypeOf(instance, Class2.prototype);
              return instance;
            };
          }
          return _construct.apply(null, arguments);
        }
        module3.exports = _construct;
      }, { "./setPrototypeOf": 18 }], 6: [function(require2, module3, exports3) {
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties(Constructor, staticProps);
          return Constructor;
        }
        module3.exports = _createClass;
      }, {}], 7: [function(require2, module3, exports3) {
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        module3.exports = _defineProperty;
      }, {}], 8: [function(require2, module3, exports3) {
        function _extends() {
          module3.exports = _extends = Object.assign || function(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i];
              for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          };
          return _extends.apply(this, arguments);
        }
        module3.exports = _extends;
      }, {}], 9: [function(require2, module3, exports3) {
        function _getPrototypeOf(o) {
          module3.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
            return o2.__proto__ || Object.getPrototypeOf(o2);
          };
          return _getPrototypeOf(o);
        }
        module3.exports = _getPrototypeOf;
      }, {}], 10: [function(require2, module3, exports3) {
        var setPrototypeOf = require2("./setPrototypeOf");
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              writable: true,
              configurable: true
            }
          });
          if (superClass)
            setPrototypeOf(subClass, superClass);
        }
        module3.exports = _inherits;
      }, { "./setPrototypeOf": 18 }], 11: [function(require2, module3, exports3) {
        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {
            "default": obj
          };
        }
        module3.exports = _interopRequireDefault;
      }, {}], 12: [function(require2, module3, exports3) {
        var _typeof = require2("../helpers/typeof");
        function _getRequireWildcardCache() {
          if (typeof WeakMap !== "function")
            return null;
          var cache = /* @__PURE__ */ new WeakMap();
          _getRequireWildcardCache = function _getRequireWildcardCache2() {
            return cache;
          };
          return cache;
        }
        function _interopRequireWildcard(obj) {
          if (obj && obj.__esModule) {
            return obj;
          }
          if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
            return {
              "default": obj
            };
          }
          var cache = _getRequireWildcardCache();
          if (cache && cache.has(obj)) {
            return cache.get(obj);
          }
          var newObj = {};
          var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
              if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
          newObj["default"] = obj;
          if (cache) {
            cache.set(obj, newObj);
          }
          return newObj;
        }
        module3.exports = _interopRequireWildcard;
      }, { "../helpers/typeof": 21 }], 13: [function(require2, module3, exports3) {
        function _iterableToArray(iter) {
          if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
            return Array.from(iter);
        }
        module3.exports = _iterableToArray;
      }, {}], 14: [function(require2, module3, exports3) {
        function _iterableToArrayLimit(arr, i) {
          if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
            return;
          }
          var _arr = [];
          var _n = true;
          var _d = false;
          var _e = void 0;
          try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null)
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        module3.exports = _iterableToArrayLimit;
      }, {}], 15: [function(require2, module3, exports3) {
        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
        module3.exports = _nonIterableRest;
      }, {}], 16: [function(require2, module3, exports3) {
        function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance");
        }
        module3.exports = _nonIterableSpread;
      }, {}], 17: [function(require2, module3, exports3) {
        var _typeof = require2("../helpers/typeof");
        var assertThisInitialized = require2("./assertThisInitialized");
        function _possibleConstructorReturn(self2, call) {
          if (call && (_typeof(call) === "object" || typeof call === "function")) {
            return call;
          }
          return assertThisInitialized(self2);
        }
        module3.exports = _possibleConstructorReturn;
      }, { "../helpers/typeof": 21, "./assertThisInitialized": 3 }], 18: [function(require2, module3, exports3) {
        function _setPrototypeOf(o, p) {
          module3.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        module3.exports = _setPrototypeOf;
      }, {}], 19: [function(require2, module3, exports3) {
        var arrayWithHoles = require2("./arrayWithHoles");
        var iterableToArrayLimit = require2("./iterableToArrayLimit");
        var nonIterableRest = require2("./nonIterableRest");
        function _slicedToArray(arr, i) {
          return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
        }
        module3.exports = _slicedToArray;
      }, { "./arrayWithHoles": 1, "./iterableToArrayLimit": 14, "./nonIterableRest": 15 }], 20: [function(require2, module3, exports3) {
        var arrayWithoutHoles = require2("./arrayWithoutHoles");
        var iterableToArray = require2("./iterableToArray");
        var nonIterableSpread = require2("./nonIterableSpread");
        function _toConsumableArray(arr) {
          return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
        }
        module3.exports = _toConsumableArray;
      }, { "./arrayWithoutHoles": 2, "./iterableToArray": 13, "./nonIterableSpread": 16 }], 21: [function(require2, module3, exports3) {
        function _typeof2(obj) {
          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof2 = function _typeof22(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof2 = function _typeof22(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof2(obj);
        }
        function _typeof(obj) {
          if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
            module3.exports = _typeof = function _typeof3(obj2) {
              return _typeof2(obj2);
            };
          } else {
            module3.exports = _typeof = function _typeof3(obj2) {
              return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : _typeof2(obj2);
            };
          }
          return _typeof(obj);
        }
        module3.exports = _typeof;
      }, {}], 22: [function(require2, module3, exports3) {
        module3.exports = require2("regenerator-runtime");
      }, { "regenerator-runtime": 153 }], 23: [function(require2, module3, exports3) {
        var Converter = require2("./src/converter");
        function anyBase(srcAlphabet, dstAlphabet) {
          var converter = new Converter(srcAlphabet, dstAlphabet);
          return function(number) {
            return converter.convert(number);
          };
        }
        ;
        anyBase.BIN = "01";
        anyBase.OCT = "01234567";
        anyBase.DEC = "0123456789";
        anyBase.HEX = "0123456789abcdef";
        module3.exports = anyBase;
      }, { "./src/converter": 24 }], 24: [function(require2, module3, exports3) {
        "use strict";
        function Converter(srcAlphabet, dstAlphabet) {
          if (!srcAlphabet || !dstAlphabet || !srcAlphabet.length || !dstAlphabet.length) {
            throw new Error("Bad alphabet");
          }
          this.srcAlphabet = srcAlphabet;
          this.dstAlphabet = dstAlphabet;
        }
        Converter.prototype.convert = function(number) {
          var i, divide, newlen, numberMap = {}, fromBase = this.srcAlphabet.length, toBase = this.dstAlphabet.length, length = number.length, result = typeof number === "string" ? "" : [];
          if (!this.isValid(number)) {
            throw new Error('Number "' + number + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
          }
          if (this.srcAlphabet === this.dstAlphabet) {
            return number;
          }
          for (i = 0; i < length; i++) {
            numberMap[i] = this.srcAlphabet.indexOf(number[i]);
          }
          do {
            divide = 0;
            newlen = 0;
            for (i = 0; i < length; i++) {
              divide = divide * fromBase + numberMap[i];
              if (divide >= toBase) {
                numberMap[newlen++] = parseInt(divide / toBase, 10);
                divide = divide % toBase;
              } else if (newlen > 0) {
                numberMap[newlen++] = 0;
              }
            }
            length = newlen;
            result = this.dstAlphabet.slice(divide, divide + 1).concat(result);
          } while (newlen !== 0);
          return result;
        };
        Converter.prototype.isValid = function(number) {
          var i = 0;
          for (; i < number.length; ++i) {
            if (this.srcAlphabet.indexOf(number[i]) === -1) {
              return false;
            }
          }
          return true;
        };
        module3.exports = Converter;
      }, {}], 25: [function(require2, module3, exports3) {
        (function(global2) {
          "use strict";
          var objectAssign = require2("object-assign");
          function compare(a, b) {
            if (a === b) {
              return 0;
            }
            var x = a.length;
            var y = b.length;
            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
              }
            }
            if (x < y) {
              return -1;
            }
            if (y < x) {
              return 1;
            }
            return 0;
          }
          function isBuffer(b) {
            if (global2.Buffer && typeof global2.Buffer.isBuffer === "function") {
              return global2.Buffer.isBuffer(b);
            }
            return !!(b != null && b._isBuffer);
          }
          var util = require2("util/");
          var hasOwn = Object.prototype.hasOwnProperty;
          var pSlice = Array.prototype.slice;
          var functionsHaveNames = function() {
            return (function foo() {
            }).name === "foo";
          }();
          function pToString(obj) {
            return Object.prototype.toString.call(obj);
          }
          function isView(arrbuf) {
            if (isBuffer(arrbuf)) {
              return false;
            }
            if (typeof global2.ArrayBuffer !== "function") {
              return false;
            }
            if (typeof ArrayBuffer.isView === "function") {
              return ArrayBuffer.isView(arrbuf);
            }
            if (!arrbuf) {
              return false;
            }
            if (arrbuf instanceof DataView) {
              return true;
            }
            if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
              return true;
            }
            return false;
          }
          var assert = module3.exports = ok;
          var regex = /\s*function\s+([^\(\s]*)\s*/;
          function getName(func) {
            if (!util.isFunction(func)) {
              return;
            }
            if (functionsHaveNames) {
              return func.name;
            }
            var str = func.toString();
            var match = str.match(regex);
            return match && match[1];
          }
          assert.AssertionError = function AssertionError(options) {
            this.name = "AssertionError";
            this.actual = options.actual;
            this.expected = options.expected;
            this.operator = options.operator;
            if (options.message) {
              this.message = options.message;
              this.generatedMessage = false;
            } else {
              this.message = getMessage(this);
              this.generatedMessage = true;
            }
            var stackStartFunction = options.stackStartFunction || fail;
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, stackStartFunction);
            } else {
              var err = new Error();
              if (err.stack) {
                var out = err.stack;
                var fn_name = getName(stackStartFunction);
                var idx = out.indexOf("\n" + fn_name);
                if (idx >= 0) {
                  var next_line = out.indexOf("\n", idx + 1);
                  out = out.substring(next_line + 1);
                }
                this.stack = out;
              }
            }
          };
          util.inherits(assert.AssertionError, Error);
          function truncate(s, n) {
            if (typeof s === "string") {
              return s.length < n ? s : s.slice(0, n);
            } else {
              return s;
            }
          }
          function inspect(something) {
            if (functionsHaveNames || !util.isFunction(something)) {
              return util.inspect(something);
            }
            var rawname = getName(something);
            var name = rawname ? ": " + rawname : "";
            return "[Function" + name + "]";
          }
          function getMessage(self2) {
            return truncate(inspect(self2.actual), 128) + " " + self2.operator + " " + truncate(inspect(self2.expected), 128);
          }
          function fail(actual, expected, message, operator, stackStartFunction) {
            throw new assert.AssertionError({
              message,
              actual,
              expected,
              operator,
              stackStartFunction
            });
          }
          assert.fail = fail;
          function ok(value, message) {
            if (!value)
              fail(value, true, message, "==", assert.ok);
          }
          assert.ok = ok;
          assert.equal = function equal(actual, expected, message) {
            if (actual != expected)
              fail(actual, expected, message, "==", assert.equal);
          };
          assert.notEqual = function notEqual(actual, expected, message) {
            if (actual == expected) {
              fail(actual, expected, message, "!=", assert.notEqual);
            }
          };
          assert.deepEqual = function deepEqual(actual, expected, message) {
            if (!_deepEqual(actual, expected, false)) {
              fail(actual, expected, message, "deepEqual", assert.deepEqual);
            }
          };
          assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
            if (!_deepEqual(actual, expected, true)) {
              fail(actual, expected, message, "deepStrictEqual", assert.deepStrictEqual);
            }
          };
          function _deepEqual(actual, expected, strict2, memos) {
            if (actual === expected) {
              return true;
            } else if (isBuffer(actual) && isBuffer(expected)) {
              return compare(actual, expected) === 0;
            } else if (util.isDate(actual) && util.isDate(expected)) {
              return actual.getTime() === expected.getTime();
            } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
              return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
            } else if ((actual === null || typeof actual !== "object") && (expected === null || typeof expected !== "object")) {
              return strict2 ? actual === expected : actual == expected;
            } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
              return compare(
                new Uint8Array(actual.buffer),
                new Uint8Array(expected.buffer)
              ) === 0;
            } else if (isBuffer(actual) !== isBuffer(expected)) {
              return false;
            } else {
              memos = memos || { actual: [], expected: [] };
              var actualIndex = memos.actual.indexOf(actual);
              if (actualIndex !== -1) {
                if (actualIndex === memos.expected.indexOf(expected)) {
                  return true;
                }
              }
              memos.actual.push(actual);
              memos.expected.push(expected);
              return objEquiv(actual, expected, strict2, memos);
            }
          }
          function isArguments(object) {
            return Object.prototype.toString.call(object) == "[object Arguments]";
          }
          function objEquiv(a, b, strict2, actualVisitedObjects) {
            if (a === null || a === void 0 || b === null || b === void 0)
              return false;
            if (util.isPrimitive(a) || util.isPrimitive(b))
              return a === b;
            if (strict2 && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
              return false;
            var aIsArgs = isArguments(a);
            var bIsArgs = isArguments(b);
            if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs)
              return false;
            if (aIsArgs) {
              a = pSlice.call(a);
              b = pSlice.call(b);
              return _deepEqual(a, b, strict2);
            }
            var ka = objectKeys(a);
            var kb = objectKeys(b);
            var key, i;
            if (ka.length !== kb.length)
              return false;
            ka.sort();
            kb.sort();
            for (i = ka.length - 1; i >= 0; i--) {
              if (ka[i] !== kb[i])
                return false;
            }
            for (i = ka.length - 1; i >= 0; i--) {
              key = ka[i];
              if (!_deepEqual(a[key], b[key], strict2, actualVisitedObjects))
                return false;
            }
            return true;
          }
          assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
            if (_deepEqual(actual, expected, false)) {
              fail(actual, expected, message, "notDeepEqual", assert.notDeepEqual);
            }
          };
          assert.notDeepStrictEqual = notDeepStrictEqual;
          function notDeepStrictEqual(actual, expected, message) {
            if (_deepEqual(actual, expected, true)) {
              fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
            }
          }
          assert.strictEqual = function strictEqual(actual, expected, message) {
            if (actual !== expected) {
              fail(actual, expected, message, "===", assert.strictEqual);
            }
          };
          assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
            if (actual === expected) {
              fail(actual, expected, message, "!==", assert.notStrictEqual);
            }
          };
          function expectedException(actual, expected) {
            if (!actual || !expected) {
              return false;
            }
            if (Object.prototype.toString.call(expected) == "[object RegExp]") {
              return expected.test(actual);
            }
            try {
              if (actual instanceof expected) {
                return true;
              }
            } catch (e) {
            }
            if (Error.isPrototypeOf(expected)) {
              return false;
            }
            return expected.call({}, actual) === true;
          }
          function _tryBlock(block) {
            var error;
            try {
              block();
            } catch (e) {
              error = e;
            }
            return error;
          }
          function _throws(shouldThrow, block, expected, message) {
            var actual;
            if (typeof block !== "function") {
              throw new TypeError('"block" argument must be a function');
            }
            if (typeof expected === "string") {
              message = expected;
              expected = null;
            }
            actual = _tryBlock(block);
            message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : ".");
            if (shouldThrow && !actual) {
              fail(actual, expected, "Missing expected exception" + message);
            }
            var userProvidedMessage = typeof message === "string";
            var isUnwantedException = !shouldThrow && util.isError(actual);
            var isUnexpectedException = !shouldThrow && actual && !expected;
            if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
              fail(actual, expected, "Got unwanted exception" + message);
            }
            if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
              throw actual;
            }
          }
          assert.throws = function(block, error, message) {
            _throws(true, block, error, message);
          };
          assert.doesNotThrow = function(block, error, message) {
            _throws(false, block, error, message);
          };
          assert.ifError = function(err) {
            if (err)
              throw err;
          };
          function strict(value, message) {
            if (!value)
              fail(value, true, message, "==", strict);
          }
          assert.strict = objectAssign(strict, assert, {
            equal: assert.strictEqual,
            deepEqual: assert.deepStrictEqual,
            notEqual: assert.notStrictEqual,
            notDeepEqual: assert.notDeepStrictEqual
          });
          assert.strict.strict = assert.strict;
          var objectKeys = Object.keys || function(obj) {
            var keys = [];
            for (var key in obj) {
              if (hasOwn.call(obj, key))
                keys.push(key);
            }
            return keys;
          };
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "object-assign": 84, "util/": 28 }], 26: [function(require2, module3, exports3) {
        if (typeof Object.create === "function") {
          module3.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          };
        } else {
          module3.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          };
        }
      }, {}], 27: [function(require2, module3, exports3) {
        module3.exports = function isBuffer(arg) {
          return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
        };
      }, {}], 28: [function(require2, module3, exports3) {
        (function(process, global2) {
          var formatRegExp = /%[sdj%]/g;
          exports3.format = function(f) {
            if (!isString(f)) {
              var objects = [];
              for (var i = 0; i < arguments.length; i++) {
                objects.push(inspect(arguments[i]));
              }
              return objects.join(" ");
            }
            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function(x2) {
              if (x2 === "%%")
                return "%";
              if (i >= len)
                return x2;
              switch (x2) {
                case "%s":
                  return String(args[i++]);
                case "%d":
                  return Number(args[i++]);
                case "%j":
                  try {
                    return JSON.stringify(args[i++]);
                  } catch (_) {
                    return "[Circular]";
                  }
                default:
                  return x2;
              }
            });
            for (var x = args[i]; i < len; x = args[++i]) {
              if (isNull(x) || !isObject(x)) {
                str += " " + x;
              } else {
                str += " " + inspect(x);
              }
            }
            return str;
          };
          exports3.deprecate = function(fn, msg) {
            if (isUndefined(global2.process)) {
              return function() {
                return exports3.deprecate(fn, msg).apply(this, arguments);
              };
            }
            if (process.noDeprecation === true) {
              return fn;
            }
            var warned = false;
            function deprecated() {
              if (!warned) {
                if (process.throwDeprecation) {
                  throw new Error(msg);
                } else if (process.traceDeprecation) {
                  console.trace(msg);
                } else {
                  console.error(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }
            return deprecated;
          };
          var debugs = {};
          var debugEnviron;
          exports3.debuglog = function(set) {
            if (isUndefined(debugEnviron))
              debugEnviron = process.env.NODE_DEBUG || "";
            set = set.toUpperCase();
            if (!debugs[set]) {
              if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                var pid = process.pid;
                debugs[set] = function() {
                  var msg = exports3.format.apply(exports3, arguments);
                  console.error("%s %d: %s", set, pid, msg);
                };
              } else {
                debugs[set] = function() {
                };
              }
            }
            return debugs[set];
          };
          function inspect(obj, opts) {
            var ctx = {
              seen: [],
              stylize: stylizeNoColor
            };
            if (arguments.length >= 3)
              ctx.depth = arguments[2];
            if (arguments.length >= 4)
              ctx.colors = arguments[3];
            if (isBoolean(opts)) {
              ctx.showHidden = opts;
            } else if (opts) {
              exports3._extend(ctx, opts);
            }
            if (isUndefined(ctx.showHidden))
              ctx.showHidden = false;
            if (isUndefined(ctx.depth))
              ctx.depth = 2;
            if (isUndefined(ctx.colors))
              ctx.colors = false;
            if (isUndefined(ctx.customInspect))
              ctx.customInspect = true;
            if (ctx.colors)
              ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
          }
          exports3.inspect = inspect;
          inspect.colors = {
            "bold": [1, 22],
            "italic": [3, 23],
            "underline": [4, 24],
            "inverse": [7, 27],
            "white": [37, 39],
            "grey": [90, 39],
            "black": [30, 39],
            "blue": [34, 39],
            "cyan": [36, 39],
            "green": [32, 39],
            "magenta": [35, 39],
            "red": [31, 39],
            "yellow": [33, 39]
          };
          inspect.styles = {
            "special": "cyan",
            "number": "yellow",
            "boolean": "yellow",
            "undefined": "grey",
            "null": "bold",
            "string": "green",
            "date": "magenta",
            // "name": intentionally not styling
            "regexp": "red"
          };
          function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];
            if (style) {
              return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
            } else {
              return str;
            }
          }
          function stylizeNoColor(str, styleType) {
            return str;
          }
          function arrayToHash(array) {
            var hash = {};
            array.forEach(function(val, idx) {
              hash[val] = true;
            });
            return hash;
          }
          function formatValue(ctx, value, recurseTimes) {
            if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
            value.inspect !== exports3.inspect && // Also filter out any prototype objects using the circular check.
            !(value.constructor && value.constructor.prototype === value)) {
              var ret = value.inspect(recurseTimes, ctx);
              if (!isString(ret)) {
                ret = formatValue(ctx, ret, recurseTimes);
              }
              return ret;
            }
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
              return primitive;
            }
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);
            if (ctx.showHidden) {
              keys = Object.getOwnPropertyNames(value);
            }
            if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
              return formatError(value);
            }
            if (keys.length === 0) {
              if (isFunction(value)) {
                var name = value.name ? ": " + value.name : "";
                return ctx.stylize("[Function" + name + "]", "special");
              }
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
              }
              if (isDate(value)) {
                return ctx.stylize(Date.prototype.toString.call(value), "date");
              }
              if (isError(value)) {
                return formatError(value);
              }
            }
            var base = "", array = false, braces = ["{", "}"];
            if (isArray(value)) {
              array = true;
              braces = ["[", "]"];
            }
            if (isFunction(value)) {
              var n = value.name ? ": " + value.name : "";
              base = " [Function" + n + "]";
            }
            if (isRegExp(value)) {
              base = " " + RegExp.prototype.toString.call(value);
            }
            if (isDate(value)) {
              base = " " + Date.prototype.toUTCString.call(value);
            }
            if (isError(value)) {
              base = " " + formatError(value);
            }
            if (keys.length === 0 && (!array || value.length == 0)) {
              return braces[0] + base + braces[1];
            }
            if (recurseTimes < 0) {
              if (isRegExp(value)) {
                return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
              } else {
                return ctx.stylize("[Object]", "special");
              }
            }
            ctx.seen.push(value);
            var output;
            if (array) {
              output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
              output = keys.map(function(key) {
                return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
              });
            }
            ctx.seen.pop();
            return reduceToSingleString(output, base, braces);
          }
          function formatPrimitive(ctx, value) {
            if (isUndefined(value))
              return ctx.stylize("undefined", "undefined");
            if (isString(value)) {
              var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return ctx.stylize(simple, "string");
            }
            if (isNumber(value))
              return ctx.stylize("" + value, "number");
            if (isBoolean(value))
              return ctx.stylize("" + value, "boolean");
            if (isNull(value))
              return ctx.stylize("null", "null");
          }
          function formatError(value) {
            return "[" + Error.prototype.toString.call(value) + "]";
          }
          function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i = 0, l = value.length; i < l; ++i) {
              if (hasOwnProperty(value, String(i))) {
                output.push(formatProperty(
                  ctx,
                  value,
                  recurseTimes,
                  visibleKeys,
                  String(i),
                  true
                ));
              } else {
                output.push("");
              }
            }
            keys.forEach(function(key) {
              if (!key.match(/^\d+$/)) {
                output.push(formatProperty(
                  ctx,
                  value,
                  recurseTimes,
                  visibleKeys,
                  key,
                  true
                ));
              }
            });
            return output;
          }
          function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
            if (desc.get) {
              if (desc.set) {
                str = ctx.stylize("[Getter/Setter]", "special");
              } else {
                str = ctx.stylize("[Getter]", "special");
              }
            } else {
              if (desc.set) {
                str = ctx.stylize("[Setter]", "special");
              }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
              name = "[" + key + "]";
            }
            if (!str) {
              if (ctx.seen.indexOf(desc.value) < 0) {
                if (isNull(recurseTimes)) {
                  str = formatValue(ctx, desc.value, null);
                } else {
                  str = formatValue(ctx, desc.value, recurseTimes - 1);
                }
                if (str.indexOf("\n") > -1) {
                  if (array) {
                    str = str.split("\n").map(function(line) {
                      return "  " + line;
                    }).join("\n").substr(2);
                  } else {
                    str = "\n" + str.split("\n").map(function(line) {
                      return "   " + line;
                    }).join("\n");
                  }
                }
              } else {
                str = ctx.stylize("[Circular]", "special");
              }
            }
            if (isUndefined(name)) {
              if (array && key.match(/^\d+$/)) {
                return str;
              }
              name = JSON.stringify("" + key);
              if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name = name.substr(1, name.length - 2);
                name = ctx.stylize(name, "name");
              } else {
                name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                name = ctx.stylize(name, "string");
              }
            }
            return name + ": " + str;
          }
          function reduceToSingleString(output, base, braces) {
            var numLinesEst = 0;
            var length = output.reduce(function(prev, cur) {
              numLinesEst++;
              if (cur.indexOf("\n") >= 0)
                numLinesEst++;
              return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);
            if (length > 60) {
              return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
            }
            return braces[0] + base + " " + output.join(", ") + " " + braces[1];
          }
          function isArray(ar) {
            return Array.isArray(ar);
          }
          exports3.isArray = isArray;
          function isBoolean(arg) {
            return typeof arg === "boolean";
          }
          exports3.isBoolean = isBoolean;
          function isNull(arg) {
            return arg === null;
          }
          exports3.isNull = isNull;
          function isNullOrUndefined(arg) {
            return arg == null;
          }
          exports3.isNullOrUndefined = isNullOrUndefined;
          function isNumber(arg) {
            return typeof arg === "number";
          }
          exports3.isNumber = isNumber;
          function isString(arg) {
            return typeof arg === "string";
          }
          exports3.isString = isString;
          function isSymbol(arg) {
            return typeof arg === "symbol";
          }
          exports3.isSymbol = isSymbol;
          function isUndefined(arg) {
            return arg === void 0;
          }
          exports3.isUndefined = isUndefined;
          function isRegExp(re) {
            return isObject(re) && objectToString(re) === "[object RegExp]";
          }
          exports3.isRegExp = isRegExp;
          function isObject(arg) {
            return typeof arg === "object" && arg !== null;
          }
          exports3.isObject = isObject;
          function isDate(d) {
            return isObject(d) && objectToString(d) === "[object Date]";
          }
          exports3.isDate = isDate;
          function isError(e) {
            return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
          }
          exports3.isError = isError;
          function isFunction(arg) {
            return typeof arg === "function";
          }
          exports3.isFunction = isFunction;
          function isPrimitive(arg) {
            return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
            typeof arg === "undefined";
          }
          exports3.isPrimitive = isPrimitive;
          exports3.isBuffer = require2("./support/isBuffer");
          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }
          function pad(n) {
            return n < 10 ? "0" + n.toString(10) : n.toString(10);
          }
          var months = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ];
          function timestamp() {
            var d = /* @__PURE__ */ new Date();
            var time = [
              pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())
            ].join(":");
            return [d.getDate(), months[d.getMonth()], time].join(" ");
          }
          exports3.log = function() {
            console.log("%s - %s", timestamp(), exports3.format.apply(exports3, arguments));
          };
          exports3.inherits = require2("inherits");
          exports3._extend = function(origin, add) {
            if (!add || !isObject(add))
              return origin;
            var keys = Object.keys(add);
            var i = keys.length;
            while (i--) {
              origin[keys[i]] = add[keys[i]];
            }
            return origin;
          };
          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }
        }).call(this, require2("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "./support/isBuffer": 27, "_process": 133, "inherits": 26 }], 29: [function(require2, module3, exports3) {
        "use strict";
        exports3.byteLength = byteLength;
        exports3.toByteArray = toByteArray;
        exports3.fromByteArray = fromByteArray;
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup[i] = code[i];
          revLookup[code.charCodeAt(i)] = i;
        }
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
        function getLens(b64) {
          var len2 = b64.length;
          if (len2 % 4 > 0) {
            throw new Error("Invalid string. Length must be a multiple of 4");
          }
          var validLen = b64.indexOf("=");
          if (validLen === -1)
            validLen = len2;
          var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
          return [validLen, placeHoldersLen];
        }
        function byteLength(b64) {
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function _byteLength(b64, validLen, placeHoldersLen) {
          return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function toByteArray(b64) {
          var tmp;
          var lens = getLens(b64);
          var validLen = lens[0];
          var placeHoldersLen = lens[1];
          var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
          var curByte = 0;
          var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
          var i2;
          for (i2 = 0; i2 < len2; i2 += 4) {
            tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
            arr[curByte++] = tmp >> 16 & 255;
            arr[curByte++] = tmp >> 8 & 255;
            arr[curByte++] = tmp & 255;
          }
          if (placeHoldersLen === 2) {
            tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
            arr[curByte++] = tmp & 255;
          }
          if (placeHoldersLen === 1) {
            tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
            arr[curByte++] = tmp >> 8 & 255;
            arr[curByte++] = tmp & 255;
          }
          return arr;
        }
        function tripletToBase64(num) {
          return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
        }
        function encodeChunk(uint8, start, end) {
          var tmp;
          var output = [];
          for (var i2 = start; i2 < end; i2 += 3) {
            tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
            output.push(tripletToBase64(tmp));
          }
          return output.join("");
        }
        function fromByteArray(uint8) {
          var tmp;
          var len2 = uint8.length;
          var extraBytes = len2 % 3;
          var parts = [];
          var maxChunkLength = 16383;
          for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
            parts.push(encodeChunk(
              uint8,
              i2,
              i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength
            ));
          }
          if (extraBytes === 1) {
            tmp = uint8[len2 - 1];
            parts.push(
              lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
            );
          } else if (extraBytes === 2) {
            tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
            parts.push(
              lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
            );
          }
          return parts.join("");
        }
      }, {}], 30: [function(require2, module3, exports3) {
        var encode = require2("./lib/encoder"), decode = require2("./lib/decoder");
        module3.exports = {
          encode,
          decode
        };
      }, { "./lib/decoder": 31, "./lib/encoder": 32 }], 31: [function(require2, module3, exports3) {
        (function(Buffer) {
          function BmpDecoder(buffer, is_with_alpha) {
            this.pos = 0;
            this.buffer = buffer;
            this.is_with_alpha = !!is_with_alpha;
            this.bottom_up = true;
            this.flag = this.buffer.toString("utf-8", 0, this.pos += 2);
            if (this.flag != "BM")
              throw new Error("Invalid BMP File");
            this.parseHeader();
            this.parseRGBA();
          }
          BmpDecoder.prototype.parseHeader = function() {
            this.fileSize = this.buffer.readUInt32LE(this.pos);
            this.pos += 4;
            this.reserved = this.buffer.readUInt32LE(this.pos);
            this.pos += 4;
            this.offset = this.buffer.readUInt32LE(this.pos);
            this.pos += 4;
            this.headerSize = this.buffer.readUInt32LE(this.pos);
            this.pos += 4;
            this.width = this.buffer.readUInt32LE(this.pos);
            this.pos += 4;
            this.height = this.buffer.readInt32LE(this.pos);
            this.pos += 4;
            this.planes = this.buffer.readUInt16LE(this.pos);
            this.pos += 2;
            this.bitPP = this.buffer.readUInt16LE(this.pos);
            this.pos += 2;
            this.compress = this.buffer.readUInt32LE(this.pos);
            this.pos += 4;
            this.rawSize = this.buffer.readUInt32LE(this.pos);
            this.pos += 4;
            this.hr = this.buffer.readUInt32LE(this.pos);
            this.pos += 4;
            this.vr = this.buffer.readUInt32LE(this.pos);
            this.pos += 4;
            this.colors = this.buffer.readUInt32LE(this.pos);
            this.pos += 4;
            this.importantColors = this.buffer.readUInt32LE(this.pos);
            this.pos += 4;
            if (this.bitPP === 16 && this.is_with_alpha) {
              this.bitPP = 15;
            }
            if (this.bitPP < 15) {
              var len = this.colors === 0 ? 1 << this.bitPP : this.colors;
              this.palette = new Array(len);
              for (var i = 0; i < len; i++) {
                var blue = this.buffer.readUInt8(this.pos++);
                var green = this.buffer.readUInt8(this.pos++);
                var red = this.buffer.readUInt8(this.pos++);
                var quad = this.buffer.readUInt8(this.pos++);
                this.palette[i] = {
                  red,
                  green,
                  blue,
                  quad
                };
              }
            }
            if (this.height < 0) {
              this.height *= -1;
              this.bottom_up = false;
            }
          };
          BmpDecoder.prototype.parseRGBA = function() {
            var bitn = "bit" + this.bitPP;
            var len = this.width * this.height * 4;
            this.data = new Buffer(len);
            this[bitn]();
          };
          BmpDecoder.prototype.bit1 = function() {
            var xlen = Math.ceil(this.width / 8);
            var mode = xlen % 4;
            var y = this.height >= 0 ? this.height - 1 : -this.height;
            for (var y = this.height - 1; y >= 0; y--) {
              var line = this.bottom_up ? y : this.height - 1 - y;
              for (var x = 0; x < xlen; x++) {
                var b = this.buffer.readUInt8(this.pos++);
                var location = line * this.width * 4 + x * 8 * 4;
                for (var i = 0; i < 8; i++) {
                  if (x * 8 + i < this.width) {
                    var rgb = this.palette[b >> 7 - i & 1];
                    this.data[location + i * 4] = 0;
                    this.data[location + i * 4 + 1] = rgb.blue;
                    this.data[location + i * 4 + 2] = rgb.green;
                    this.data[location + i * 4 + 3] = rgb.red;
                  } else {
                    break;
                  }
                }
              }
              if (mode != 0) {
                this.pos += 4 - mode;
              }
            }
          };
          BmpDecoder.prototype.bit4 = function() {
            if (this.compress == 2) {
              let setPixelData2 = function(rgbIndex) {
                var rgb2 = this.palette[rgbIndex];
                this.data[location] = 0;
                this.data[location + 1] = rgb2.blue;
                this.data[location + 2] = rgb2.green;
                this.data[location + 3] = rgb2.red;
                location += 4;
              };
              var setPixelData = setPixelData2;
              this.data.fill(255);
              var location = 0;
              var lines = this.bottom_up ? this.height - 1 : 0;
              var low_nibble = false;
              while (location < this.data.length) {
                var a = this.buffer.readUInt8(this.pos++);
                var b = this.buffer.readUInt8(this.pos++);
                if (a == 0) {
                  if (b == 0) {
                    if (this.bottom_up) {
                      lines--;
                    } else {
                      lines++;
                    }
                    location = lines * this.width * 4;
                    low_nibble = false;
                    continue;
                  } else if (b == 1) {
                    break;
                  } else if (b == 2) {
                    var x = this.buffer.readUInt8(this.pos++);
                    var y = this.buffer.readUInt8(this.pos++);
                    if (this.bottom_up) {
                      lines -= y;
                    } else {
                      lines += y;
                    }
                    location += y * this.width * 4 + x * 4;
                  } else {
                    var c = this.buffer.readUInt8(this.pos++);
                    for (var i = 0; i < b; i++) {
                      if (low_nibble) {
                        setPixelData2.call(this, c & 15);
                      } else {
                        setPixelData2.call(this, (c & 240) >> 4);
                      }
                      if (i & 1 && i + 1 < b) {
                        c = this.buffer.readUInt8(this.pos++);
                      }
                      low_nibble = !low_nibble;
                    }
                    if ((b + 1 >> 1 & 1) == 1) {
                      this.pos++;
                    }
                  }
                } else {
                  for (var i = 0; i < a; i++) {
                    if (low_nibble) {
                      setPixelData2.call(this, b & 15);
                    } else {
                      setPixelData2.call(this, (b & 240) >> 4);
                    }
                    low_nibble = !low_nibble;
                  }
                }
              }
            } else {
              var xlen = Math.ceil(this.width / 2);
              var mode = xlen % 4;
              for (var y = this.height - 1; y >= 0; y--) {
                var line = this.bottom_up ? y : this.height - 1 - y;
                for (var x = 0; x < xlen; x++) {
                  var b = this.buffer.readUInt8(this.pos++);
                  var location = line * this.width * 4 + x * 2 * 4;
                  var before = b >> 4;
                  var after = b & 15;
                  var rgb = this.palette[before];
                  this.data[location] = 0;
                  this.data[location + 1] = rgb.blue;
                  this.data[location + 2] = rgb.green;
                  this.data[location + 3] = rgb.red;
                  if (x * 2 + 1 >= this.width)
                    break;
                  rgb = this.palette[after];
                  this.data[location + 4] = 0;
                  this.data[location + 4 + 1] = rgb.blue;
                  this.data[location + 4 + 2] = rgb.green;
                  this.data[location + 4 + 3] = rgb.red;
                }
                if (mode != 0) {
                  this.pos += 4 - mode;
                }
              }
            }
          };
          BmpDecoder.prototype.bit8 = function() {
            if (this.compress == 1) {
              let setPixelData2 = function(rgbIndex) {
                var rgb2 = this.palette[rgbIndex];
                this.data[location] = 0;
                this.data[location + 1] = rgb2.blue;
                this.data[location + 2] = rgb2.green;
                this.data[location + 3] = rgb2.red;
                location += 4;
              };
              var setPixelData = setPixelData2;
              this.data.fill(255);
              var location = 0;
              var lines = this.bottom_up ? this.height - 1 : 0;
              while (location < this.data.length) {
                var a = this.buffer.readUInt8(this.pos++);
                var b = this.buffer.readUInt8(this.pos++);
                if (a == 0) {
                  if (b == 0) {
                    if (this.bottom_up) {
                      lines--;
                    } else {
                      lines++;
                    }
                    location = lines * this.width * 4;
                    continue;
                  } else if (b == 1) {
                    break;
                  } else if (b == 2) {
                    var x = this.buffer.readUInt8(this.pos++);
                    var y = this.buffer.readUInt8(this.pos++);
                    if (this.bottom_up) {
                      lines -= y;
                    } else {
                      lines += y;
                    }
                    location += y * this.width * 4 + x * 4;
                  } else {
                    for (var i = 0; i < b; i++) {
                      var c = this.buffer.readUInt8(this.pos++);
                      setPixelData2.call(this, c);
                    }
                    if (b & true) {
                      this.pos++;
                    }
                  }
                } else {
                  for (var i = 0; i < a; i++) {
                    setPixelData2.call(this, b);
                  }
                }
              }
            } else {
              var mode = this.width % 4;
              for (var y = this.height - 1; y >= 0; y--) {
                var line = this.bottom_up ? y : this.height - 1 - y;
                for (var x = 0; x < this.width; x++) {
                  var b = this.buffer.readUInt8(this.pos++);
                  var location = line * this.width * 4 + x * 4;
                  if (b < this.palette.length) {
                    var rgb = this.palette[b];
                    this.data[location] = 0;
                    this.data[location + 1] = rgb.blue;
                    this.data[location + 2] = rgb.green;
                    this.data[location + 3] = rgb.red;
                  } else {
                    this.data[location] = 0;
                    this.data[location + 1] = 255;
                    this.data[location + 2] = 255;
                    this.data[location + 3] = 255;
                  }
                }
                if (mode != 0) {
                  this.pos += 4 - mode;
                }
              }
            }
          };
          BmpDecoder.prototype.bit15 = function() {
            var dif_w = this.width % 3;
            var _11111 = parseInt("11111", 2), _1_5 = _11111;
            for (var y = this.height - 1; y >= 0; y--) {
              var line = this.bottom_up ? y : this.height - 1 - y;
              for (var x = 0; x < this.width; x++) {
                var B = this.buffer.readUInt16LE(this.pos);
                this.pos += 2;
                var blue = (B & _1_5) / _1_5 * 255 | 0;
                var green = (B >> 5 & _1_5) / _1_5 * 255 | 0;
                var red = (B >> 10 & _1_5) / _1_5 * 255 | 0;
                var alpha = B >> 15 ? 255 : 0;
                var location = line * this.width * 4 + x * 4;
                this.data[location] = alpha;
                this.data[location + 1] = blue;
                this.data[location + 2] = green;
                this.data[location + 3] = red;
              }
              this.pos += dif_w;
            }
          };
          BmpDecoder.prototype.bit16 = function() {
            var dif_w = this.width % 2 * 2;
            this.maskRed = 31744;
            this.maskGreen = 992;
            this.maskBlue = 31;
            this.mask0 = 0;
            if (this.compress == 3) {
              this.maskRed = this.buffer.readUInt32LE(this.pos);
              this.pos += 4;
              this.maskGreen = this.buffer.readUInt32LE(this.pos);
              this.pos += 4;
              this.maskBlue = this.buffer.readUInt32LE(this.pos);
              this.pos += 4;
              this.mask0 = this.buffer.readUInt32LE(this.pos);
              this.pos += 4;
            }
            var ns = [0, 0, 0];
            for (var i = 0; i < 16; i++) {
              if (this.maskRed >> i & 1)
                ns[0]++;
              if (this.maskGreen >> i & 1)
                ns[1]++;
              if (this.maskBlue >> i & 1)
                ns[2]++;
            }
            ns[1] += ns[0];
            ns[2] += ns[1];
            ns[0] = 8 - ns[0];
            ns[1] -= 8;
            ns[2] -= 8;
            for (var y = this.height - 1; y >= 0; y--) {
              var line = this.bottom_up ? y : this.height - 1 - y;
              for (var x = 0; x < this.width; x++) {
                var B = this.buffer.readUInt16LE(this.pos);
                this.pos += 2;
                var blue = (B & this.maskBlue) << ns[0];
                var green = (B & this.maskGreen) >> ns[1];
                var red = (B & this.maskRed) >> ns[2];
                var location = line * this.width * 4 + x * 4;
                this.data[location] = 0;
                this.data[location + 1] = blue;
                this.data[location + 2] = green;
                this.data[location + 3] = red;
              }
              this.pos += dif_w;
            }
          };
          BmpDecoder.prototype.bit24 = function() {
            for (var y = this.height - 1; y >= 0; y--) {
              var line = this.bottom_up ? y : this.height - 1 - y;
              for (var x = 0; x < this.width; x++) {
                var blue = this.buffer.readUInt8(this.pos++);
                var green = this.buffer.readUInt8(this.pos++);
                var red = this.buffer.readUInt8(this.pos++);
                var location = line * this.width * 4 + x * 4;
                this.data[location] = 0;
                this.data[location + 1] = blue;
                this.data[location + 2] = green;
                this.data[location + 3] = red;
              }
              this.pos += this.width % 4;
            }
          };
          BmpDecoder.prototype.bit32 = function() {
            if (this.compress == 3) {
              this.maskRed = this.buffer.readUInt32LE(this.pos);
              this.pos += 4;
              this.maskGreen = this.buffer.readUInt32LE(this.pos);
              this.pos += 4;
              this.maskBlue = this.buffer.readUInt32LE(this.pos);
              this.pos += 4;
              this.mask0 = this.buffer.readUInt32LE(this.pos);
              this.pos += 4;
              for (var y = this.height - 1; y >= 0; y--) {
                var line = this.bottom_up ? y : this.height - 1 - y;
                for (var x = 0; x < this.width; x++) {
                  var alpha = this.buffer.readUInt8(this.pos++);
                  var blue = this.buffer.readUInt8(this.pos++);
                  var green = this.buffer.readUInt8(this.pos++);
                  var red = this.buffer.readUInt8(this.pos++);
                  var location = line * this.width * 4 + x * 4;
                  this.data[location] = alpha;
                  this.data[location + 1] = blue;
                  this.data[location + 2] = green;
                  this.data[location + 3] = red;
                }
              }
            } else {
              for (var y = this.height - 1; y >= 0; y--) {
                var line = this.bottom_up ? y : this.height - 1 - y;
                for (var x = 0; x < this.width; x++) {
                  var blue = this.buffer.readUInt8(this.pos++);
                  var green = this.buffer.readUInt8(this.pos++);
                  var red = this.buffer.readUInt8(this.pos++);
                  var alpha = this.buffer.readUInt8(this.pos++);
                  var location = line * this.width * 4 + x * 4;
                  this.data[location] = alpha;
                  this.data[location + 1] = blue;
                  this.data[location + 2] = green;
                  this.data[location + 3] = red;
                }
              }
            }
          };
          BmpDecoder.prototype.getData = function() {
            return this.data;
          };
          module3.exports = function(bmpData) {
            var decoder = new BmpDecoder(bmpData);
            return decoder;
          };
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 48 }], 32: [function(require2, module3, exports3) {
        (function(Buffer) {
          function BmpEncoder(imgData) {
            this.buffer = imgData.data;
            this.width = imgData.width;
            this.height = imgData.height;
            this.extraBytes = this.width % 4;
            this.rgbSize = this.height * (3 * this.width + this.extraBytes);
            this.headerInfoSize = 40;
            this.data = [];
            this.flag = "BM";
            this.reserved = 0;
            this.offset = 54;
            this.fileSize = this.rgbSize + this.offset;
            this.planes = 1;
            this.bitPP = 24;
            this.compress = 0;
            this.hr = 0;
            this.vr = 0;
            this.colors = 0;
            this.importantColors = 0;
          }
          BmpEncoder.prototype.encode = function() {
            var tempBuffer = new Buffer(this.offset + this.rgbSize);
            this.pos = 0;
            tempBuffer.write(this.flag, this.pos, 2);
            this.pos += 2;
            tempBuffer.writeUInt32LE(this.fileSize, this.pos);
            this.pos += 4;
            tempBuffer.writeUInt32LE(this.reserved, this.pos);
            this.pos += 4;
            tempBuffer.writeUInt32LE(this.offset, this.pos);
            this.pos += 4;
            tempBuffer.writeUInt32LE(this.headerInfoSize, this.pos);
            this.pos += 4;
            tempBuffer.writeUInt32LE(this.width, this.pos);
            this.pos += 4;
            tempBuffer.writeInt32LE(-this.height, this.pos);
            this.pos += 4;
            tempBuffer.writeUInt16LE(this.planes, this.pos);
            this.pos += 2;
            tempBuffer.writeUInt16LE(this.bitPP, this.pos);
            this.pos += 2;
            tempBuffer.writeUInt32LE(this.compress, this.pos);
            this.pos += 4;
            tempBuffer.writeUInt32LE(this.rgbSize, this.pos);
            this.pos += 4;
            tempBuffer.writeUInt32LE(this.hr, this.pos);
            this.pos += 4;
            tempBuffer.writeUInt32LE(this.vr, this.pos);
            this.pos += 4;
            tempBuffer.writeUInt32LE(this.colors, this.pos);
            this.pos += 4;
            tempBuffer.writeUInt32LE(this.importantColors, this.pos);
            this.pos += 4;
            var i = 0;
            var rowBytes = 3 * this.width + this.extraBytes;
            for (var y = 0; y < this.height; y++) {
              for (var x = 0; x < this.width; x++) {
                var p = this.pos + y * rowBytes + x * 3;
                i++;
                tempBuffer[p] = this.buffer[i++];
                tempBuffer[p + 1] = this.buffer[i++];
                tempBuffer[p + 2] = this.buffer[i++];
              }
              if (this.extraBytes > 0) {
                var fillOffset = this.pos + y * rowBytes + this.width * 3;
                tempBuffer.fill(0, fillOffset, fillOffset + this.extraBytes);
              }
            }
            return tempBuffer;
          };
          module3.exports = function(imgData, quality) {
            if (typeof quality === "undefined")
              quality = 100;
            var encoder = new BmpEncoder(imgData);
            var data = encoder.encode();
            return {
              data,
              width: imgData.width,
              height: imgData.height
            };
          };
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 48 }], 33: [function(require2, module3, exports3) {
      }, {}], 34: [function(require2, module3, exports3) {
        (function(process, Buffer) {
          "use strict";
          var assert = require2("assert");
          var Zstream = require2("pako/lib/zlib/zstream");
          var zlib_deflate = require2("pako/lib/zlib/deflate.js");
          var zlib_inflate = require2("pako/lib/zlib/inflate.js");
          var constants = require2("pako/lib/zlib/constants");
          for (var key in constants) {
            exports3[key] = constants[key];
          }
          exports3.NONE = 0;
          exports3.DEFLATE = 1;
          exports3.INFLATE = 2;
          exports3.GZIP = 3;
          exports3.GUNZIP = 4;
          exports3.DEFLATERAW = 5;
          exports3.INFLATERAW = 6;
          exports3.UNZIP = 7;
          var GZIP_HEADER_ID1 = 31;
          var GZIP_HEADER_ID2 = 139;
          function Zlib(mode) {
            if (typeof mode !== "number" || mode < exports3.DEFLATE || mode > exports3.UNZIP) {
              throw new TypeError("Bad argument");
            }
            this.dictionary = null;
            this.err = 0;
            this.flush = 0;
            this.init_done = false;
            this.level = 0;
            this.memLevel = 0;
            this.mode = mode;
            this.strategy = 0;
            this.windowBits = 0;
            this.write_in_progress = false;
            this.pending_close = false;
            this.gzip_id_bytes_read = 0;
          }
          Zlib.prototype.close = function() {
            if (this.write_in_progress) {
              this.pending_close = true;
              return;
            }
            this.pending_close = false;
            assert(this.init_done, "close before init");
            assert(this.mode <= exports3.UNZIP);
            if (this.mode === exports3.DEFLATE || this.mode === exports3.GZIP || this.mode === exports3.DEFLATERAW) {
              zlib_deflate.deflateEnd(this.strm);
            } else if (this.mode === exports3.INFLATE || this.mode === exports3.GUNZIP || this.mode === exports3.INFLATERAW || this.mode === exports3.UNZIP) {
              zlib_inflate.inflateEnd(this.strm);
            }
            this.mode = exports3.NONE;
            this.dictionary = null;
          };
          Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
            return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
          };
          Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
            return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
          };
          Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
            assert.equal(arguments.length, 8);
            assert(this.init_done, "write before init");
            assert(this.mode !== exports3.NONE, "already finalized");
            assert.equal(false, this.write_in_progress, "write already in progress");
            assert.equal(false, this.pending_close, "close is pending");
            this.write_in_progress = true;
            assert.equal(false, flush === void 0, "must provide flush value");
            this.write_in_progress = true;
            if (flush !== exports3.Z_NO_FLUSH && flush !== exports3.Z_PARTIAL_FLUSH && flush !== exports3.Z_SYNC_FLUSH && flush !== exports3.Z_FULL_FLUSH && flush !== exports3.Z_FINISH && flush !== exports3.Z_BLOCK) {
              throw new Error("Invalid flush value");
            }
            if (input == null) {
              input = Buffer.alloc(0);
              in_len = 0;
              in_off = 0;
            }
            this.strm.avail_in = in_len;
            this.strm.input = input;
            this.strm.next_in = in_off;
            this.strm.avail_out = out_len;
            this.strm.output = out;
            this.strm.next_out = out_off;
            this.flush = flush;
            if (!async) {
              this._process();
              if (this._checkError()) {
                return this._afterSync();
              }
              return;
            }
            var self2 = this;
            process.nextTick(function() {
              self2._process();
              self2._after();
            });
            return this;
          };
          Zlib.prototype._afterSync = function() {
            var avail_out = this.strm.avail_out;
            var avail_in = this.strm.avail_in;
            this.write_in_progress = false;
            return [avail_in, avail_out];
          };
          Zlib.prototype._process = function() {
            var next_expected_header_byte = null;
            switch (this.mode) {
              case exports3.DEFLATE:
              case exports3.GZIP:
              case exports3.DEFLATERAW:
                this.err = zlib_deflate.deflate(this.strm, this.flush);
                break;
              case exports3.UNZIP:
                if (this.strm.avail_in > 0) {
                  next_expected_header_byte = this.strm.next_in;
                }
                switch (this.gzip_id_bytes_read) {
                  case 0:
                    if (next_expected_header_byte === null) {
                      break;
                    }
                    if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
                      this.gzip_id_bytes_read = 1;
                      next_expected_header_byte++;
                      if (this.strm.avail_in === 1) {
                        break;
                      }
                    } else {
                      this.mode = exports3.INFLATE;
                      break;
                    }
                  case 1:
                    if (next_expected_header_byte === null) {
                      break;
                    }
                    if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
                      this.gzip_id_bytes_read = 2;
                      this.mode = exports3.GUNZIP;
                    } else {
                      this.mode = exports3.INFLATE;
                    }
                    break;
                  default:
                    throw new Error("invalid number of gzip magic number bytes read");
                }
              case exports3.INFLATE:
              case exports3.GUNZIP:
              case exports3.INFLATERAW:
                this.err = zlib_inflate.inflate(
                  this.strm,
                  this.flush
                  // If data was encoded with dictionary
                );
                if (this.err === exports3.Z_NEED_DICT && this.dictionary) {
                  this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);
                  if (this.err === exports3.Z_OK) {
                    this.err = zlib_inflate.inflate(this.strm, this.flush);
                  } else if (this.err === exports3.Z_DATA_ERROR) {
                    this.err = exports3.Z_NEED_DICT;
                  }
                }
                while (this.strm.avail_in > 0 && this.mode === exports3.GUNZIP && this.err === exports3.Z_STREAM_END && this.strm.next_in[0] !== 0) {
                  this.reset();
                  this.err = zlib_inflate.inflate(this.strm, this.flush);
                }
                break;
              default:
                throw new Error("Unknown mode " + this.mode);
            }
          };
          Zlib.prototype._checkError = function() {
            switch (this.err) {
              case exports3.Z_OK:
              case exports3.Z_BUF_ERROR:
                if (this.strm.avail_out !== 0 && this.flush === exports3.Z_FINISH) {
                  this._error("unexpected end of file");
                  return false;
                }
                break;
              case exports3.Z_STREAM_END:
                break;
              case exports3.Z_NEED_DICT:
                if (this.dictionary == null) {
                  this._error("Missing dictionary");
                } else {
                  this._error("Bad dictionary");
                }
                return false;
              default:
                this._error("Zlib error");
                return false;
            }
            return true;
          };
          Zlib.prototype._after = function() {
            if (!this._checkError()) {
              return;
            }
            var avail_out = this.strm.avail_out;
            var avail_in = this.strm.avail_in;
            this.write_in_progress = false;
            this.callback(avail_in, avail_out);
            if (this.pending_close) {
              this.close();
            }
          };
          Zlib.prototype._error = function(message) {
            if (this.strm.msg) {
              message = this.strm.msg;
            }
            this.onerror(
              message,
              this.err
              // no hope of rescue.
            );
            this.write_in_progress = false;
            if (this.pending_close) {
              this.close();
            }
          };
          Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
            assert(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])");
            assert(windowBits >= 8 && windowBits <= 15, "invalid windowBits");
            assert(level >= -1 && level <= 9, "invalid compression level");
            assert(memLevel >= 1 && memLevel <= 9, "invalid memlevel");
            assert(strategy === exports3.Z_FILTERED || strategy === exports3.Z_HUFFMAN_ONLY || strategy === exports3.Z_RLE || strategy === exports3.Z_FIXED || strategy === exports3.Z_DEFAULT_STRATEGY, "invalid strategy");
            this._init(level, windowBits, memLevel, strategy, dictionary);
            this._setDictionary();
          };
          Zlib.prototype.params = function() {
            throw new Error("deflateParams Not supported");
          };
          Zlib.prototype.reset = function() {
            this._reset();
            this._setDictionary();
          };
          Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
            this.level = level;
            this.windowBits = windowBits;
            this.memLevel = memLevel;
            this.strategy = strategy;
            this.flush = exports3.Z_NO_FLUSH;
            this.err = exports3.Z_OK;
            if (this.mode === exports3.GZIP || this.mode === exports3.GUNZIP) {
              this.windowBits += 16;
            }
            if (this.mode === exports3.UNZIP) {
              this.windowBits += 32;
            }
            if (this.mode === exports3.DEFLATERAW || this.mode === exports3.INFLATERAW) {
              this.windowBits = -1 * this.windowBits;
            }
            this.strm = new Zstream();
            switch (this.mode) {
              case exports3.DEFLATE:
              case exports3.GZIP:
              case exports3.DEFLATERAW:
                this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports3.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
                break;
              case exports3.INFLATE:
              case exports3.GUNZIP:
              case exports3.INFLATERAW:
              case exports3.UNZIP:
                this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
                break;
              default:
                throw new Error("Unknown mode " + this.mode);
            }
            if (this.err !== exports3.Z_OK) {
              this._error("Init error");
            }
            this.dictionary = dictionary;
            this.write_in_progress = false;
            this.init_done = true;
          };
          Zlib.prototype._setDictionary = function() {
            if (this.dictionary == null) {
              return;
            }
            this.err = exports3.Z_OK;
            switch (this.mode) {
              case exports3.DEFLATE:
              case exports3.DEFLATERAW:
                this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
                break;
              default:
                break;
            }
            if (this.err !== exports3.Z_OK) {
              this._error("Failed to set dictionary");
            }
          };
          Zlib.prototype._reset = function() {
            this.err = exports3.Z_OK;
            switch (this.mode) {
              case exports3.DEFLATE:
              case exports3.DEFLATERAW:
              case exports3.GZIP:
                this.err = zlib_deflate.deflateReset(this.strm);
                break;
              case exports3.INFLATE:
              case exports3.INFLATERAW:
              case exports3.GUNZIP:
                this.err = zlib_inflate.inflateReset(this.strm);
                break;
              default:
                break;
            }
            if (this.err !== exports3.Z_OK) {
              this._error("Failed to reset stream");
            }
          };
          exports3.Zlib = Zlib;
        }).call(this, require2("_process"), require2("buffer").Buffer);
      }, { "_process": 133, "assert": 25, "buffer": 48, "pako/lib/zlib/constants": 38, "pako/lib/zlib/deflate.js": 40, "pako/lib/zlib/inflate.js": 42, "pako/lib/zlib/zstream": 46 }], 35: [function(require2, module3, exports3) {
        (function(process) {
          "use strict";
          var Buffer = require2("buffer").Buffer;
          var Transform = require2("stream").Transform;
          var binding = require2("./binding");
          var util = require2("util");
          var assert = require2("assert").ok;
          var kMaxLength = require2("buffer").kMaxLength;
          var kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes";
          binding.Z_MIN_WINDOWBITS = 8;
          binding.Z_MAX_WINDOWBITS = 15;
          binding.Z_DEFAULT_WINDOWBITS = 15;
          binding.Z_MIN_CHUNK = 64;
          binding.Z_MAX_CHUNK = Infinity;
          binding.Z_DEFAULT_CHUNK = 16 * 1024;
          binding.Z_MIN_MEMLEVEL = 1;
          binding.Z_MAX_MEMLEVEL = 9;
          binding.Z_DEFAULT_MEMLEVEL = 8;
          binding.Z_MIN_LEVEL = -1;
          binding.Z_MAX_LEVEL = 9;
          binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
          var bkeys = Object.keys(binding);
          for (var bk = 0; bk < bkeys.length; bk++) {
            var bkey = bkeys[bk];
            if (bkey.match(/^Z/)) {
              Object.defineProperty(exports3, bkey, {
                enumerable: true,
                value: binding[bkey],
                writable: false
              });
            }
          }
          var codes = {
            Z_OK: binding.Z_OK,
            Z_STREAM_END: binding.Z_STREAM_END,
            Z_NEED_DICT: binding.Z_NEED_DICT,
            Z_ERRNO: binding.Z_ERRNO,
            Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
            Z_DATA_ERROR: binding.Z_DATA_ERROR,
            Z_MEM_ERROR: binding.Z_MEM_ERROR,
            Z_BUF_ERROR: binding.Z_BUF_ERROR,
            Z_VERSION_ERROR: binding.Z_VERSION_ERROR
          };
          var ckeys = Object.keys(codes);
          for (var ck = 0; ck < ckeys.length; ck++) {
            var ckey = ckeys[ck];
            codes[codes[ckey]] = ckey;
          }
          Object.defineProperty(exports3, "codes", {
            enumerable: true,
            value: Object.freeze(codes),
            writable: false
          });
          exports3.Deflate = Deflate;
          exports3.Inflate = Inflate;
          exports3.Gzip = Gzip;
          exports3.Gunzip = Gunzip;
          exports3.DeflateRaw = DeflateRaw;
          exports3.InflateRaw = InflateRaw;
          exports3.Unzip = Unzip;
          exports3.createDeflate = function(o) {
            return new Deflate(o);
          };
          exports3.createInflate = function(o) {
            return new Inflate(o);
          };
          exports3.createDeflateRaw = function(o) {
            return new DeflateRaw(o);
          };
          exports3.createInflateRaw = function(o) {
            return new InflateRaw(o);
          };
          exports3.createGzip = function(o) {
            return new Gzip(o);
          };
          exports3.createGunzip = function(o) {
            return new Gunzip(o);
          };
          exports3.createUnzip = function(o) {
            return new Unzip(o);
          };
          exports3.deflate = function(buffer, opts, callback) {
            if (typeof opts === "function") {
              callback = opts;
              opts = {};
            }
            return zlibBuffer(new Deflate(opts), buffer, callback);
          };
          exports3.deflateSync = function(buffer, opts) {
            return zlibBufferSync(new Deflate(opts), buffer);
          };
          exports3.gzip = function(buffer, opts, callback) {
            if (typeof opts === "function") {
              callback = opts;
              opts = {};
            }
            return zlibBuffer(new Gzip(opts), buffer, callback);
          };
          exports3.gzipSync = function(buffer, opts) {
            return zlibBufferSync(new Gzip(opts), buffer);
          };
          exports3.deflateRaw = function(buffer, opts, callback) {
            if (typeof opts === "function") {
              callback = opts;
              opts = {};
            }
            return zlibBuffer(new DeflateRaw(opts), buffer, callback);
          };
          exports3.deflateRawSync = function(buffer, opts) {
            return zlibBufferSync(new DeflateRaw(opts), buffer);
          };
          exports3.unzip = function(buffer, opts, callback) {
            if (typeof opts === "function") {
              callback = opts;
              opts = {};
            }
            return zlibBuffer(new Unzip(opts), buffer, callback);
          };
          exports3.unzipSync = function(buffer, opts) {
            return zlibBufferSync(new Unzip(opts), buffer);
          };
          exports3.inflate = function(buffer, opts, callback) {
            if (typeof opts === "function") {
              callback = opts;
              opts = {};
            }
            return zlibBuffer(new Inflate(opts), buffer, callback);
          };
          exports3.inflateSync = function(buffer, opts) {
            return zlibBufferSync(new Inflate(opts), buffer);
          };
          exports3.gunzip = function(buffer, opts, callback) {
            if (typeof opts === "function") {
              callback = opts;
              opts = {};
            }
            return zlibBuffer(new Gunzip(opts), buffer, callback);
          };
          exports3.gunzipSync = function(buffer, opts) {
            return zlibBufferSync(new Gunzip(opts), buffer);
          };
          exports3.inflateRaw = function(buffer, opts, callback) {
            if (typeof opts === "function") {
              callback = opts;
              opts = {};
            }
            return zlibBuffer(new InflateRaw(opts), buffer, callback);
          };
          exports3.inflateRawSync = function(buffer, opts) {
            return zlibBufferSync(new InflateRaw(opts), buffer);
          };
          function zlibBuffer(engine, buffer, callback) {
            var buffers = [];
            var nread = 0;
            engine.on("error", onError);
            engine.on("end", onEnd);
            engine.end(buffer);
            flow();
            function flow() {
              var chunk;
              while (null !== (chunk = engine.read())) {
                buffers.push(chunk);
                nread += chunk.length;
              }
              engine.once("readable", flow);
            }
            function onError(err) {
              engine.removeListener("end", onEnd);
              engine.removeListener("readable", flow);
              callback(err);
            }
            function onEnd() {
              var buf;
              var err = null;
              if (nread >= kMaxLength) {
                err = new RangeError(kRangeErrorMessage);
              } else {
                buf = Buffer.concat(buffers, nread);
              }
              buffers = [];
              engine.close();
              callback(err, buf);
            }
          }
          function zlibBufferSync(engine, buffer) {
            if (typeof buffer === "string")
              buffer = Buffer.from(buffer);
            if (!Buffer.isBuffer(buffer))
              throw new TypeError("Not a string or buffer");
            var flushFlag = engine._finishFlushFlag;
            return engine._processChunk(buffer, flushFlag);
          }
          function Deflate(opts) {
            if (!(this instanceof Deflate))
              return new Deflate(opts);
            Zlib.call(this, opts, binding.DEFLATE);
          }
          function Inflate(opts) {
            if (!(this instanceof Inflate))
              return new Inflate(opts);
            Zlib.call(this, opts, binding.INFLATE);
          }
          function Gzip(opts) {
            if (!(this instanceof Gzip))
              return new Gzip(opts);
            Zlib.call(this, opts, binding.GZIP);
          }
          function Gunzip(opts) {
            if (!(this instanceof Gunzip))
              return new Gunzip(opts);
            Zlib.call(this, opts, binding.GUNZIP);
          }
          function DeflateRaw(opts) {
            if (!(this instanceof DeflateRaw))
              return new DeflateRaw(opts);
            Zlib.call(this, opts, binding.DEFLATERAW);
          }
          function InflateRaw(opts) {
            if (!(this instanceof InflateRaw))
              return new InflateRaw(opts);
            Zlib.call(this, opts, binding.INFLATERAW);
          }
          function Unzip(opts) {
            if (!(this instanceof Unzip))
              return new Unzip(opts);
            Zlib.call(this, opts, binding.UNZIP);
          }
          function isValidFlushFlag(flag) {
            return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;
          }
          function Zlib(opts, mode) {
            var _this = this;
            this._opts = opts = opts || {};
            this._chunkSize = opts.chunkSize || exports3.Z_DEFAULT_CHUNK;
            Transform.call(this, opts);
            if (opts.flush && !isValidFlushFlag(opts.flush)) {
              throw new Error("Invalid flush flag: " + opts.flush);
            }
            if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
              throw new Error("Invalid flush flag: " + opts.finishFlush);
            }
            this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
            this._finishFlushFlag = typeof opts.finishFlush !== "undefined" ? opts.finishFlush : binding.Z_FINISH;
            if (opts.chunkSize) {
              if (opts.chunkSize < exports3.Z_MIN_CHUNK || opts.chunkSize > exports3.Z_MAX_CHUNK) {
                throw new Error("Invalid chunk size: " + opts.chunkSize);
              }
            }
            if (opts.windowBits) {
              if (opts.windowBits < exports3.Z_MIN_WINDOWBITS || opts.windowBits > exports3.Z_MAX_WINDOWBITS) {
                throw new Error("Invalid windowBits: " + opts.windowBits);
              }
            }
            if (opts.level) {
              if (opts.level < exports3.Z_MIN_LEVEL || opts.level > exports3.Z_MAX_LEVEL) {
                throw new Error("Invalid compression level: " + opts.level);
              }
            }
            if (opts.memLevel) {
              if (opts.memLevel < exports3.Z_MIN_MEMLEVEL || opts.memLevel > exports3.Z_MAX_MEMLEVEL) {
                throw new Error("Invalid memLevel: " + opts.memLevel);
              }
            }
            if (opts.strategy) {
              if (opts.strategy != exports3.Z_FILTERED && opts.strategy != exports3.Z_HUFFMAN_ONLY && opts.strategy != exports3.Z_RLE && opts.strategy != exports3.Z_FIXED && opts.strategy != exports3.Z_DEFAULT_STRATEGY) {
                throw new Error("Invalid strategy: " + opts.strategy);
              }
            }
            if (opts.dictionary) {
              if (!Buffer.isBuffer(opts.dictionary)) {
                throw new Error("Invalid dictionary: it should be a Buffer instance");
              }
            }
            this._handle = new binding.Zlib(mode);
            var self2 = this;
            this._hadError = false;
            this._handle.onerror = function(message, errno) {
              _close(self2);
              self2._hadError = true;
              var error = new Error(message);
              error.errno = errno;
              error.code = exports3.codes[errno];
              self2.emit("error", error);
            };
            var level = exports3.Z_DEFAULT_COMPRESSION;
            if (typeof opts.level === "number")
              level = opts.level;
            var strategy = exports3.Z_DEFAULT_STRATEGY;
            if (typeof opts.strategy === "number")
              strategy = opts.strategy;
            this._handle.init(opts.windowBits || exports3.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports3.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
            this._buffer = Buffer.allocUnsafe(this._chunkSize);
            this._offset = 0;
            this._level = level;
            this._strategy = strategy;
            this.once("end", this.close);
            Object.defineProperty(this, "_closed", {
              get: function() {
                return !_this._handle;
              },
              configurable: true,
              enumerable: true
            });
          }
          util.inherits(Zlib, Transform);
          Zlib.prototype.params = function(level, strategy, callback) {
            if (level < exports3.Z_MIN_LEVEL || level > exports3.Z_MAX_LEVEL) {
              throw new RangeError("Invalid compression level: " + level);
            }
            if (strategy != exports3.Z_FILTERED && strategy != exports3.Z_HUFFMAN_ONLY && strategy != exports3.Z_RLE && strategy != exports3.Z_FIXED && strategy != exports3.Z_DEFAULT_STRATEGY) {
              throw new TypeError("Invalid strategy: " + strategy);
            }
            if (this._level !== level || this._strategy !== strategy) {
              var self2 = this;
              this.flush(binding.Z_SYNC_FLUSH, function() {
                assert(self2._handle, "zlib binding closed");
                self2._handle.params(level, strategy);
                if (!self2._hadError) {
                  self2._level = level;
                  self2._strategy = strategy;
                  if (callback)
                    callback();
                }
              });
            } else {
              process.nextTick(callback);
            }
          };
          Zlib.prototype.reset = function() {
            assert(this._handle, "zlib binding closed");
            return this._handle.reset();
          };
          Zlib.prototype._flush = function(callback) {
            this._transform(Buffer.alloc(0), "", callback);
          };
          Zlib.prototype.flush = function(kind, callback) {
            var _this2 = this;
            var ws = this._writableState;
            if (typeof kind === "function" || kind === void 0 && !callback) {
              callback = kind;
              kind = binding.Z_FULL_FLUSH;
            }
            if (ws.ended) {
              if (callback)
                process.nextTick(callback);
            } else if (ws.ending) {
              if (callback)
                this.once("end", callback);
            } else if (ws.needDrain) {
              if (callback) {
                this.once("drain", function() {
                  return _this2.flush(kind, callback);
                });
              }
            } else {
              this._flushFlag = kind;
              this.write(Buffer.alloc(0), "", callback);
            }
          };
          Zlib.prototype.close = function(callback) {
            _close(this, callback);
            process.nextTick(emitCloseNT, this);
          };
          function _close(engine, callback) {
            if (callback)
              process.nextTick(callback);
            if (!engine._handle)
              return;
            engine._handle.close();
            engine._handle = null;
          }
          function emitCloseNT(self2) {
            self2.emit("close");
          }
          Zlib.prototype._transform = function(chunk, encoding, cb) {
            var flushFlag;
            var ws = this._writableState;
            var ending = ws.ending || ws.ended;
            var last = ending && (!chunk || ws.length === chunk.length);
            if (chunk !== null && !Buffer.isBuffer(chunk))
              return cb(new Error("invalid input"));
            if (!this._handle)
              return cb(new Error("zlib binding closed"));
            if (last)
              flushFlag = this._finishFlushFlag;
            else {
              flushFlag = this._flushFlag;
              if (chunk.length >= ws.length) {
                this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
              }
            }
            this._processChunk(chunk, flushFlag, cb);
          };
          Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
            var availInBefore = chunk && chunk.length;
            var availOutBefore = this._chunkSize - this._offset;
            var inOff = 0;
            var self2 = this;
            var async = typeof cb === "function";
            if (!async) {
              var buffers = [];
              var nread = 0;
              var error;
              this.on("error", function(er) {
                error = er;
              });
              assert(this._handle, "zlib binding closed");
              do {
                var res = this._handle.writeSync(
                  flushFlag,
                  chunk,
                  // in
                  inOff,
                  // in_off
                  availInBefore,
                  // in_len
                  this._buffer,
                  // out
                  this._offset,
                  //out_off
                  availOutBefore
                );
              } while (!this._hadError && callback(res[0], res[1]));
              if (this._hadError) {
                throw error;
              }
              if (nread >= kMaxLength) {
                _close(this);
                throw new RangeError(kRangeErrorMessage);
              }
              var buf = Buffer.concat(buffers, nread);
              _close(this);
              return buf;
            }
            assert(this._handle, "zlib binding closed");
            var req = this._handle.write(
              flushFlag,
              chunk,
              // in
              inOff,
              // in_off
              availInBefore,
              // in_len
              this._buffer,
              // out
              this._offset,
              //out_off
              availOutBefore
            );
            req.buffer = chunk;
            req.callback = callback;
            function callback(availInAfter, availOutAfter) {
              if (this) {
                this.buffer = null;
                this.callback = null;
              }
              if (self2._hadError)
                return;
              var have = availOutBefore - availOutAfter;
              assert(have >= 0, "have should not go down");
              if (have > 0) {
                var out = self2._buffer.slice(self2._offset, self2._offset + have);
                self2._offset += have;
                if (async) {
                  self2.push(out);
                } else {
                  buffers.push(out);
                  nread += out.length;
                }
              }
              if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
                availOutBefore = self2._chunkSize;
                self2._offset = 0;
                self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
              }
              if (availOutAfter === 0) {
                inOff += availInBefore - availInAfter;
                availInBefore = availInAfter;
                if (!async)
                  return true;
                var newReq = self2._handle.write(flushFlag, chunk, inOff, availInBefore, self2._buffer, self2._offset, self2._chunkSize);
                newReq.callback = callback;
                newReq.buffer = chunk;
                return;
              }
              if (!async)
                return false;
              cb();
            }
          };
          util.inherits(Deflate, Zlib);
          util.inherits(Inflate, Zlib);
          util.inherits(Gzip, Zlib);
          util.inherits(Gunzip, Zlib);
          util.inherits(DeflateRaw, Zlib);
          util.inherits(InflateRaw, Zlib);
          util.inherits(Unzip, Zlib);
        }).call(this, require2("_process"));
      }, { "./binding": 34, "_process": 133, "assert": 25, "buffer": 48, "stream": 155, "util": 186 }], 36: [function(require2, module3, exports3) {
        "use strict";
        var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
        function _has(obj, key) {
          return Object.prototype.hasOwnProperty.call(obj, key);
        }
        exports3.assign = function(obj) {
          var sources = Array.prototype.slice.call(arguments, 1);
          while (sources.length) {
            var source = sources.shift();
            if (!source) {
              continue;
            }
            if (typeof source !== "object") {
              throw new TypeError(source + "must be non-object");
            }
            for (var p in source) {
              if (_has(source, p)) {
                obj[p] = source[p];
              }
            }
          }
          return obj;
        };
        exports3.shrinkBuf = function(buf, size) {
          if (buf.length === size) {
            return buf;
          }
          if (buf.subarray) {
            return buf.subarray(0, size);
          }
          buf.length = size;
          return buf;
        };
        var fnTyped = {
          arraySet: function(dest, src, src_offs, len, dest_offs) {
            if (src.subarray && dest.subarray) {
              dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
              return;
            }
            for (var i = 0; i < len; i++) {
              dest[dest_offs + i] = src[src_offs + i];
            }
          },
          // Join array of chunks to single array.
          flattenChunks: function(chunks) {
            var i, l, len, pos, chunk, result;
            len = 0;
            for (i = 0, l = chunks.length; i < l; i++) {
              len += chunks[i].length;
            }
            result = new Uint8Array(len);
            pos = 0;
            for (i = 0, l = chunks.length; i < l; i++) {
              chunk = chunks[i];
              result.set(chunk, pos);
              pos += chunk.length;
            }
            return result;
          }
        };
        var fnUntyped = {
          arraySet: function(dest, src, src_offs, len, dest_offs) {
            for (var i = 0; i < len; i++) {
              dest[dest_offs + i] = src[src_offs + i];
            }
          },
          // Join array of chunks to single array.
          flattenChunks: function(chunks) {
            return [].concat.apply([], chunks);
          }
        };
        exports3.setTyped = function(on) {
          if (on) {
            exports3.Buf8 = Uint8Array;
            exports3.Buf16 = Uint16Array;
            exports3.Buf32 = Int32Array;
            exports3.assign(exports3, fnTyped);
          } else {
            exports3.Buf8 = Array;
            exports3.Buf16 = Array;
            exports3.Buf32 = Array;
            exports3.assign(exports3, fnUntyped);
          }
        };
        exports3.setTyped(TYPED_OK);
      }, {}], 37: [function(require2, module3, exports3) {
        "use strict";
        function adler32(adler, buf, len, pos) {
          var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
          while (len !== 0) {
            n = len > 2e3 ? 2e3 : len;
            len -= n;
            do {
              s1 = s1 + buf[pos++] | 0;
              s2 = s2 + s1 | 0;
            } while (--n);
            s1 %= 65521;
            s2 %= 65521;
          }
          return s1 | s2 << 16 | 0;
        }
        module3.exports = adler32;
      }, {}], 38: [function(require2, module3, exports3) {
        "use strict";
        module3.exports = {
          /* Allowed flush values; see deflate() and inflate() below for details */
          Z_NO_FLUSH: 0,
          Z_PARTIAL_FLUSH: 1,
          Z_SYNC_FLUSH: 2,
          Z_FULL_FLUSH: 3,
          Z_FINISH: 4,
          Z_BLOCK: 5,
          Z_TREES: 6,
          /* Return codes for the compression/decompression functions. Negative values
          * are errors, positive values are used for special but normal events.
          */
          Z_OK: 0,
          Z_STREAM_END: 1,
          Z_NEED_DICT: 2,
          Z_ERRNO: -1,
          Z_STREAM_ERROR: -2,
          Z_DATA_ERROR: -3,
          //Z_MEM_ERROR:     -4,
          Z_BUF_ERROR: -5,
          //Z_VERSION_ERROR: -6,
          /* compression levels */
          Z_NO_COMPRESSION: 0,
          Z_BEST_SPEED: 1,
          Z_BEST_COMPRESSION: 9,
          Z_DEFAULT_COMPRESSION: -1,
          Z_FILTERED: 1,
          Z_HUFFMAN_ONLY: 2,
          Z_RLE: 3,
          Z_FIXED: 4,
          Z_DEFAULT_STRATEGY: 0,
          /* Possible values of the data_type field (though see inflate()) */
          Z_BINARY: 0,
          Z_TEXT: 1,
          //Z_ASCII:                1, // = Z_TEXT (deprecated)
          Z_UNKNOWN: 2,
          /* The deflate compression method */
          Z_DEFLATED: 8
          //Z_NULL:                 null // Use -1 or null inline, depending on var type
        };
      }, {}], 39: [function(require2, module3, exports3) {
        "use strict";
        function makeTable() {
          var c, table = [];
          for (var n = 0; n < 256; n++) {
            c = n;
            for (var k = 0; k < 8; k++) {
              c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
            }
            table[n] = c;
          }
          return table;
        }
        var crcTable = makeTable();
        function crc32(crc, buf, len, pos) {
          var t = crcTable, end = pos + len;
          crc ^= -1;
          for (var i = pos; i < end; i++) {
            crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
          }
          return crc ^ -1;
        }
        module3.exports = crc32;
      }, {}], 40: [function(require2, module3, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var trees = require2("./trees");
        var adler32 = require2("./adler32");
        var crc32 = require2("./crc32");
        var msg = require2("./messages");
        var Z_NO_FLUSH = 0;
        var Z_PARTIAL_FLUSH = 1;
        var Z_FULL_FLUSH = 3;
        var Z_FINISH = 4;
        var Z_BLOCK = 5;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_STREAM_ERROR = -2;
        var Z_DATA_ERROR = -3;
        var Z_BUF_ERROR = -5;
        var Z_DEFAULT_COMPRESSION = -1;
        var Z_FILTERED = 1;
        var Z_HUFFMAN_ONLY = 2;
        var Z_RLE = 3;
        var Z_FIXED = 4;
        var Z_DEFAULT_STRATEGY = 0;
        var Z_UNKNOWN = 2;
        var Z_DEFLATED = 8;
        var MAX_MEM_LEVEL = 9;
        var MAX_WBITS = 15;
        var DEF_MEM_LEVEL = 8;
        var LENGTH_CODES = 29;
        var LITERALS = 256;
        var L_CODES = LITERALS + 1 + LENGTH_CODES;
        var D_CODES = 30;
        var BL_CODES = 19;
        var HEAP_SIZE = 2 * L_CODES + 1;
        var MAX_BITS = 15;
        var MIN_MATCH = 3;
        var MAX_MATCH = 258;
        var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
        var PRESET_DICT = 32;
        var INIT_STATE = 42;
        var EXTRA_STATE = 69;
        var NAME_STATE = 73;
        var COMMENT_STATE = 91;
        var HCRC_STATE = 103;
        var BUSY_STATE = 113;
        var FINISH_STATE = 666;
        var BS_NEED_MORE = 1;
        var BS_BLOCK_DONE = 2;
        var BS_FINISH_STARTED = 3;
        var BS_FINISH_DONE = 4;
        var OS_CODE = 3;
        function err(strm, errorCode) {
          strm.msg = msg[errorCode];
          return errorCode;
        }
        function rank(f) {
          return (f << 1) - (f > 4 ? 9 : 0);
        }
        function zero(buf) {
          var len = buf.length;
          while (--len >= 0) {
            buf[len] = 0;
          }
        }
        function flush_pending(strm) {
          var s = strm.state;
          var len = s.pending;
          if (len > strm.avail_out) {
            len = strm.avail_out;
          }
          if (len === 0) {
            return;
          }
          utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
          strm.next_out += len;
          s.pending_out += len;
          strm.total_out += len;
          strm.avail_out -= len;
          s.pending -= len;
          if (s.pending === 0) {
            s.pending_out = 0;
          }
        }
        function flush_block_only(s, last) {
          trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
          s.block_start = s.strstart;
          flush_pending(s.strm);
        }
        function put_byte(s, b) {
          s.pending_buf[s.pending++] = b;
        }
        function putShortMSB(s, b) {
          s.pending_buf[s.pending++] = b >>> 8 & 255;
          s.pending_buf[s.pending++] = b & 255;
        }
        function read_buf(strm, buf, start, size) {
          var len = strm.avail_in;
          if (len > size) {
            len = size;
          }
          if (len === 0) {
            return 0;
          }
          strm.avail_in -= len;
          utils.arraySet(buf, strm.input, strm.next_in, len, start);
          if (strm.state.wrap === 1) {
            strm.adler = adler32(strm.adler, buf, len, start);
          } else if (strm.state.wrap === 2) {
            strm.adler = crc32(strm.adler, buf, len, start);
          }
          strm.next_in += len;
          strm.total_in += len;
          return len;
        }
        function longest_match(s, cur_match) {
          var chain_length = s.max_chain_length;
          var scan = s.strstart;
          var match;
          var len;
          var best_len = s.prev_length;
          var nice_match = s.nice_match;
          var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
          var _win = s.window;
          var wmask = s.w_mask;
          var prev = s.prev;
          var strend = s.strstart + MAX_MATCH;
          var scan_end1 = _win[scan + best_len - 1];
          var scan_end = _win[scan + best_len];
          if (s.prev_length >= s.good_match) {
            chain_length >>= 2;
          }
          if (nice_match > s.lookahead) {
            nice_match = s.lookahead;
          }
          do {
            match = cur_match;
            if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
              continue;
            }
            scan += 2;
            match++;
            do {
            } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
            len = MAX_MATCH - (strend - scan);
            scan = strend - MAX_MATCH;
            if (len > best_len) {
              s.match_start = cur_match;
              best_len = len;
              if (len >= nice_match) {
                break;
              }
              scan_end1 = _win[scan + best_len - 1];
              scan_end = _win[scan + best_len];
            }
          } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
          if (best_len <= s.lookahead) {
            return best_len;
          }
          return s.lookahead;
        }
        function fill_window(s) {
          var _w_size = s.w_size;
          var p, n, m, more, str;
          do {
            more = s.window_size - s.lookahead - s.strstart;
            if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
              utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
              s.match_start -= _w_size;
              s.strstart -= _w_size;
              s.block_start -= _w_size;
              n = s.hash_size;
              p = n;
              do {
                m = s.head[--p];
                s.head[p] = m >= _w_size ? m - _w_size : 0;
              } while (--n);
              n = _w_size;
              p = n;
              do {
                m = s.prev[--p];
                s.prev[p] = m >= _w_size ? m - _w_size : 0;
              } while (--n);
              more += _w_size;
            }
            if (s.strm.avail_in === 0) {
              break;
            }
            n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
            s.lookahead += n;
            if (s.lookahead + s.insert >= MIN_MATCH) {
              str = s.strstart - s.insert;
              s.ins_h = s.window[str];
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
              while (s.insert) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                s.prev[str & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = str;
                str++;
                s.insert--;
                if (s.lookahead + s.insert < MIN_MATCH) {
                  break;
                }
              }
            }
          } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
        }
        function deflate_stored(s, flush) {
          var max_block_size = 65535;
          if (max_block_size > s.pending_buf_size - 5) {
            max_block_size = s.pending_buf_size - 5;
          }
          for (; ; ) {
            if (s.lookahead <= 1) {
              fill_window(s);
              if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            s.strstart += s.lookahead;
            s.lookahead = 0;
            var max_start = s.block_start + max_block_size;
            if (s.strstart === 0 || s.strstart >= max_start) {
              s.lookahead = s.strstart - max_start;
              s.strstart = max_start;
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
            if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = 0;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.strstart > s.block_start) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_NEED_MORE;
        }
        function deflate_fast(s, flush) {
          var hash_head;
          var bflush;
          for (; ; ) {
            if (s.lookahead < MIN_LOOKAHEAD) {
              fill_window(s);
              if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            hash_head = 0;
            if (s.lookahead >= MIN_MATCH) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
            if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
              s.match_length = longest_match(s, hash_head);
            }
            if (s.match_length >= MIN_MATCH) {
              bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
              s.lookahead -= s.match_length;
              if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                s.match_length--;
                do {
                  s.strstart++;
                  s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                  hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                  s.head[s.ins_h] = s.strstart;
                } while (--s.match_length !== 0);
                s.strstart++;
              } else {
                s.strstart += s.match_length;
                s.match_length = 0;
                s.ins_h = s.window[s.strstart];
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
              }
            } else {
              bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
              s.lookahead--;
              s.strstart++;
            }
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function deflate_slow(s, flush) {
          var hash_head;
          var bflush;
          var max_insert;
          for (; ; ) {
            if (s.lookahead < MIN_LOOKAHEAD) {
              fill_window(s);
              if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            hash_head = 0;
            if (s.lookahead >= MIN_MATCH) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
            s.prev_length = s.match_length;
            s.prev_match = s.match_start;
            s.match_length = MIN_MATCH - 1;
            if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
              s.match_length = longest_match(s, hash_head);
              if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
                s.match_length = MIN_MATCH - 1;
              }
            }
            if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
              max_insert = s.strstart + s.lookahead - MIN_MATCH;
              bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
              s.lookahead -= s.prev_length - 1;
              s.prev_length -= 2;
              do {
                if (++s.strstart <= max_insert) {
                  s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                  hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                  s.head[s.ins_h] = s.strstart;
                }
              } while (--s.prev_length !== 0);
              s.match_available = 0;
              s.match_length = MIN_MATCH - 1;
              s.strstart++;
              if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              }
            } else if (s.match_available) {
              bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
              if (bflush) {
                flush_block_only(s, false);
              }
              s.strstart++;
              s.lookahead--;
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            } else {
              s.match_available = 1;
              s.strstart++;
              s.lookahead--;
            }
          }
          if (s.match_available) {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
            s.match_available = 0;
          }
          s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function deflate_rle(s, flush) {
          var bflush;
          var prev;
          var scan, strend;
          var _win = s.window;
          for (; ; ) {
            if (s.lookahead <= MAX_MATCH) {
              fill_window(s);
              if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            s.match_length = 0;
            if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
              scan = s.strstart - 1;
              prev = _win[scan];
              if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                strend = s.strstart + MAX_MATCH;
                do {
                } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                s.match_length = MAX_MATCH - (strend - scan);
                if (s.match_length > s.lookahead) {
                  s.match_length = s.lookahead;
                }
              }
            }
            if (s.match_length >= MIN_MATCH) {
              bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
              s.lookahead -= s.match_length;
              s.strstart += s.match_length;
              s.match_length = 0;
            } else {
              bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
              s.lookahead--;
              s.strstart++;
            }
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = 0;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function deflate_huff(s, flush) {
          var bflush;
          for (; ; ) {
            if (s.lookahead === 0) {
              fill_window(s);
              if (s.lookahead === 0) {
                if (flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE;
                }
                break;
              }
            }
            s.match_length = 0;
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = 0;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function Config(good_length, max_lazy, nice_length, max_chain, func) {
          this.good_length = good_length;
          this.max_lazy = max_lazy;
          this.nice_length = nice_length;
          this.max_chain = max_chain;
          this.func = func;
        }
        var configuration_table;
        configuration_table = [
          /*      good lazy nice chain */
          new Config(0, 0, 0, 0, deflate_stored),
          /* 0 store only */
          new Config(4, 4, 8, 4, deflate_fast),
          /* 1 max speed, no lazy matches */
          new Config(4, 5, 16, 8, deflate_fast),
          /* 2 */
          new Config(4, 6, 32, 32, deflate_fast),
          /* 3 */
          new Config(4, 4, 16, 16, deflate_slow),
          /* 4 lazy matches */
          new Config(8, 16, 32, 32, deflate_slow),
          /* 5 */
          new Config(8, 16, 128, 128, deflate_slow),
          /* 6 */
          new Config(8, 32, 128, 256, deflate_slow),
          /* 7 */
          new Config(32, 128, 258, 1024, deflate_slow),
          /* 8 */
          new Config(32, 258, 258, 4096, deflate_slow)
          /* 9 max compression */
        ];
        function lm_init(s) {
          s.window_size = 2 * s.w_size;
          zero(s.head);
          s.max_lazy_match = configuration_table[s.level].max_lazy;
          s.good_match = configuration_table[s.level].good_length;
          s.nice_match = configuration_table[s.level].nice_length;
          s.max_chain_length = configuration_table[s.level].max_chain;
          s.strstart = 0;
          s.block_start = 0;
          s.lookahead = 0;
          s.insert = 0;
          s.match_length = s.prev_length = MIN_MATCH - 1;
          s.match_available = 0;
          s.ins_h = 0;
        }
        function DeflateState() {
          this.strm = null;
          this.status = 0;
          this.pending_buf = null;
          this.pending_buf_size = 0;
          this.pending_out = 0;
          this.pending = 0;
          this.wrap = 0;
          this.gzhead = null;
          this.gzindex = 0;
          this.method = Z_DEFLATED;
          this.last_flush = -1;
          this.w_size = 0;
          this.w_bits = 0;
          this.w_mask = 0;
          this.window = null;
          this.window_size = 0;
          this.prev = null;
          this.head = null;
          this.ins_h = 0;
          this.hash_size = 0;
          this.hash_bits = 0;
          this.hash_mask = 0;
          this.hash_shift = 0;
          this.block_start = 0;
          this.match_length = 0;
          this.prev_match = 0;
          this.match_available = 0;
          this.strstart = 0;
          this.match_start = 0;
          this.lookahead = 0;
          this.prev_length = 0;
          this.max_chain_length = 0;
          this.max_lazy_match = 0;
          this.level = 0;
          this.strategy = 0;
          this.good_match = 0;
          this.nice_match = 0;
          this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
          this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
          this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
          zero(this.dyn_ltree);
          zero(this.dyn_dtree);
          zero(this.bl_tree);
          this.l_desc = null;
          this.d_desc = null;
          this.bl_desc = null;
          this.bl_count = new utils.Buf16(MAX_BITS + 1);
          this.heap = new utils.Buf16(2 * L_CODES + 1);
          zero(this.heap);
          this.heap_len = 0;
          this.heap_max = 0;
          this.depth = new utils.Buf16(2 * L_CODES + 1);
          zero(this.depth);
          this.l_buf = 0;
          this.lit_bufsize = 0;
          this.last_lit = 0;
          this.d_buf = 0;
          this.opt_len = 0;
          this.static_len = 0;
          this.matches = 0;
          this.insert = 0;
          this.bi_buf = 0;
          this.bi_valid = 0;
        }
        function deflateResetKeep(strm) {
          var s;
          if (!strm || !strm.state) {
            return err(strm, Z_STREAM_ERROR);
          }
          strm.total_in = strm.total_out = 0;
          strm.data_type = Z_UNKNOWN;
          s = strm.state;
          s.pending = 0;
          s.pending_out = 0;
          if (s.wrap < 0) {
            s.wrap = -s.wrap;
          }
          s.status = s.wrap ? INIT_STATE : BUSY_STATE;
          strm.adler = s.wrap === 2 ? 0 : 1;
          s.last_flush = Z_NO_FLUSH;
          trees._tr_init(s);
          return Z_OK;
        }
        function deflateReset(strm) {
          var ret = deflateResetKeep(strm);
          if (ret === Z_OK) {
            lm_init(strm.state);
          }
          return ret;
        }
        function deflateSetHeader(strm, head) {
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          if (strm.state.wrap !== 2) {
            return Z_STREAM_ERROR;
          }
          strm.state.gzhead = head;
          return Z_OK;
        }
        function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
          if (!strm) {
            return Z_STREAM_ERROR;
          }
          var wrap = 1;
          if (level === Z_DEFAULT_COMPRESSION) {
            level = 6;
          }
          if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
          } else if (windowBits > 15) {
            wrap = 2;
            windowBits -= 16;
          }
          if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
            return err(strm, Z_STREAM_ERROR);
          }
          if (windowBits === 8) {
            windowBits = 9;
          }
          var s = new DeflateState();
          strm.state = s;
          s.strm = strm;
          s.wrap = wrap;
          s.gzhead = null;
          s.w_bits = windowBits;
          s.w_size = 1 << s.w_bits;
          s.w_mask = s.w_size - 1;
          s.hash_bits = memLevel + 7;
          s.hash_size = 1 << s.hash_bits;
          s.hash_mask = s.hash_size - 1;
          s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
          s.window = new utils.Buf8(s.w_size * 2);
          s.head = new utils.Buf16(s.hash_size);
          s.prev = new utils.Buf16(s.w_size);
          s.lit_bufsize = 1 << memLevel + 6;
          s.pending_buf_size = s.lit_bufsize * 4;
          s.pending_buf = new utils.Buf8(s.pending_buf_size);
          s.d_buf = 1 * s.lit_bufsize;
          s.l_buf = (1 + 2) * s.lit_bufsize;
          s.level = level;
          s.strategy = strategy;
          s.method = method;
          return deflateReset(strm);
        }
        function deflateInit(strm, level) {
          return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
        }
        function deflate(strm, flush) {
          var old_flush, s;
          var beg, val;
          if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
            return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
          }
          s = strm.state;
          if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
            return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
          }
          s.strm = strm;
          old_flush = s.last_flush;
          s.last_flush = flush;
          if (s.status === INIT_STATE) {
            if (s.wrap === 2) {
              strm.adler = 0;
              put_byte(s, 31);
              put_byte(s, 139);
              put_byte(s, 8);
              if (!s.gzhead) {
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, OS_CODE);
                s.status = BUSY_STATE;
              } else {
                put_byte(
                  s,
                  (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
                );
                put_byte(s, s.gzhead.time & 255);
                put_byte(s, s.gzhead.time >> 8 & 255);
                put_byte(s, s.gzhead.time >> 16 & 255);
                put_byte(s, s.gzhead.time >> 24 & 255);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, s.gzhead.os & 255);
                if (s.gzhead.extra && s.gzhead.extra.length) {
                  put_byte(s, s.gzhead.extra.length & 255);
                  put_byte(s, s.gzhead.extra.length >> 8 & 255);
                }
                if (s.gzhead.hcrc) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                }
                s.gzindex = 0;
                s.status = EXTRA_STATE;
              }
            } else {
              var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
              var level_flags = -1;
              if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                level_flags = 0;
              } else if (s.level < 6) {
                level_flags = 1;
              } else if (s.level === 6) {
                level_flags = 2;
              } else {
                level_flags = 3;
              }
              header |= level_flags << 6;
              if (s.strstart !== 0) {
                header |= PRESET_DICT;
              }
              header += 31 - header % 31;
              s.status = BUSY_STATE;
              putShortMSB(s, header);
              if (s.strstart !== 0) {
                putShortMSB(s, strm.adler >>> 16);
                putShortMSB(s, strm.adler & 65535);
              }
              strm.adler = 1;
            }
          }
          if (s.status === EXTRA_STATE) {
            if (s.gzhead.extra) {
              beg = s.pending;
              while (s.gzindex < (s.gzhead.extra.length & 65535)) {
                if (s.pending === s.pending_buf_size) {
                  if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s.pending;
                  if (s.pending === s.pending_buf_size) {
                    break;
                  }
                }
                put_byte(s, s.gzhead.extra[s.gzindex] & 255);
                s.gzindex++;
              }
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              if (s.gzindex === s.gzhead.extra.length) {
                s.gzindex = 0;
                s.status = NAME_STATE;
              }
            } else {
              s.status = NAME_STATE;
            }
          }
          if (s.status === NAME_STATE) {
            if (s.gzhead.name) {
              beg = s.pending;
              do {
                if (s.pending === s.pending_buf_size) {
                  if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s.pending;
                  if (s.pending === s.pending_buf_size) {
                    val = 1;
                    break;
                  }
                }
                if (s.gzindex < s.gzhead.name.length) {
                  val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
                } else {
                  val = 0;
                }
                put_byte(s, val);
              } while (val !== 0);
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              if (val === 0) {
                s.gzindex = 0;
                s.status = COMMENT_STATE;
              }
            } else {
              s.status = COMMENT_STATE;
            }
          }
          if (s.status === COMMENT_STATE) {
            if (s.gzhead.comment) {
              beg = s.pending;
              do {
                if (s.pending === s.pending_buf_size) {
                  if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s.pending;
                  if (s.pending === s.pending_buf_size) {
                    val = 1;
                    break;
                  }
                }
                if (s.gzindex < s.gzhead.comment.length) {
                  val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
                } else {
                  val = 0;
                }
                put_byte(s, val);
              } while (val !== 0);
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              if (val === 0) {
                s.status = HCRC_STATE;
              }
            } else {
              s.status = HCRC_STATE;
            }
          }
          if (s.status === HCRC_STATE) {
            if (s.gzhead.hcrc) {
              if (s.pending + 2 > s.pending_buf_size) {
                flush_pending(strm);
              }
              if (s.pending + 2 <= s.pending_buf_size) {
                put_byte(s, strm.adler & 255);
                put_byte(s, strm.adler >> 8 & 255);
                strm.adler = 0;
                s.status = BUSY_STATE;
              }
            } else {
              s.status = BUSY_STATE;
            }
          }
          if (s.pending !== 0) {
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
            return err(strm, Z_BUF_ERROR);
          }
          if (s.status === FINISH_STATE && strm.avail_in !== 0) {
            return err(strm, Z_BUF_ERROR);
          }
          if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
            var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
            if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
              s.status = FINISH_STATE;
            }
            if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
              if (strm.avail_out === 0) {
                s.last_flush = -1;
              }
              return Z_OK;
            }
            if (bstate === BS_BLOCK_DONE) {
              if (flush === Z_PARTIAL_FLUSH) {
                trees._tr_align(s);
              } else if (flush !== Z_BLOCK) {
                trees._tr_stored_block(s, 0, 0, false);
                if (flush === Z_FULL_FLUSH) {
                  zero(s.head);
                  if (s.lookahead === 0) {
                    s.strstart = 0;
                    s.block_start = 0;
                    s.insert = 0;
                  }
                }
              }
              flush_pending(strm);
              if (strm.avail_out === 0) {
                s.last_flush = -1;
                return Z_OK;
              }
            }
          }
          if (flush !== Z_FINISH) {
            return Z_OK;
          }
          if (s.wrap <= 0) {
            return Z_STREAM_END;
          }
          if (s.wrap === 2) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            put_byte(s, strm.adler >> 16 & 255);
            put_byte(s, strm.adler >> 24 & 255);
            put_byte(s, strm.total_in & 255);
            put_byte(s, strm.total_in >> 8 & 255);
            put_byte(s, strm.total_in >> 16 & 255);
            put_byte(s, strm.total_in >> 24 & 255);
          } else {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          flush_pending(strm);
          if (s.wrap > 0) {
            s.wrap = -s.wrap;
          }
          return s.pending !== 0 ? Z_OK : Z_STREAM_END;
        }
        function deflateEnd(strm) {
          var status;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          status = strm.state.status;
          if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
            return err(strm, Z_STREAM_ERROR);
          }
          strm.state = null;
          return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
        }
        function deflateSetDictionary(strm, dictionary) {
          var dictLength = dictionary.length;
          var s;
          var str, n;
          var wrap;
          var avail;
          var next;
          var input;
          var tmpDict;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          s = strm.state;
          wrap = s.wrap;
          if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
            return Z_STREAM_ERROR;
          }
          if (wrap === 1) {
            strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
          }
          s.wrap = 0;
          if (dictLength >= s.w_size) {
            if (wrap === 0) {
              zero(s.head);
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
            tmpDict = new utils.Buf8(s.w_size);
            utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
            dictionary = tmpDict;
            dictLength = s.w_size;
          }
          avail = strm.avail_in;
          next = strm.next_in;
          input = strm.input;
          strm.avail_in = dictLength;
          strm.next_in = 0;
          strm.input = dictionary;
          fill_window(s);
          while (s.lookahead >= MIN_MATCH) {
            str = s.strstart;
            n = s.lookahead - (MIN_MATCH - 1);
            do {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
              s.prev[str & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str;
              str++;
            } while (--n);
            s.strstart = str;
            s.lookahead = MIN_MATCH - 1;
            fill_window(s);
          }
          s.strstart += s.lookahead;
          s.block_start = s.strstart;
          s.insert = s.lookahead;
          s.lookahead = 0;
          s.match_length = s.prev_length = MIN_MATCH - 1;
          s.match_available = 0;
          strm.next_in = next;
          strm.input = input;
          strm.avail_in = avail;
          s.wrap = wrap;
          return Z_OK;
        }
        exports3.deflateInit = deflateInit;
        exports3.deflateInit2 = deflateInit2;
        exports3.deflateReset = deflateReset;
        exports3.deflateResetKeep = deflateResetKeep;
        exports3.deflateSetHeader = deflateSetHeader;
        exports3.deflate = deflate;
        exports3.deflateEnd = deflateEnd;
        exports3.deflateSetDictionary = deflateSetDictionary;
        exports3.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 36, "./adler32": 37, "./crc32": 39, "./messages": 44, "./trees": 45 }], 41: [function(require2, module3, exports3) {
        "use strict";
        var BAD = 30;
        var TYPE = 12;
        module3.exports = function inflate_fast(strm, start) {
          var state;
          var _in;
          var last;
          var _out;
          var beg;
          var end;
          var dmax;
          var wsize;
          var whave;
          var wnext;
          var s_window;
          var hold;
          var bits;
          var lcode;
          var dcode;
          var lmask;
          var dmask;
          var here;
          var op;
          var len;
          var dist;
          var from;
          var from_source;
          var input, output;
          state = strm.state;
          _in = strm.next_in;
          input = strm.input;
          last = _in + (strm.avail_in - 5);
          _out = strm.next_out;
          output = strm.output;
          beg = _out - (start - strm.avail_out);
          end = _out + (strm.avail_out - 257);
          dmax = state.dmax;
          wsize = state.wsize;
          whave = state.whave;
          wnext = state.wnext;
          s_window = state.window;
          hold = state.hold;
          bits = state.bits;
          lcode = state.lencode;
          dcode = state.distcode;
          lmask = (1 << state.lenbits) - 1;
          dmask = (1 << state.distbits) - 1;
          top:
            do {
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = lcode[hold & lmask];
              dolen:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op === 0) {
                    output[_out++] = here & 65535;
                  } else if (op & 16) {
                    len = here & 65535;
                    op &= 15;
                    if (op) {
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                      len += hold & (1 << op) - 1;
                      hold >>>= op;
                      bits -= op;
                    }
                    if (bits < 15) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    here = dcode[hold & dmask];
                    dodist:
                      for (; ; ) {
                        op = here >>> 24;
                        hold >>>= op;
                        bits -= op;
                        op = here >>> 16 & 255;
                        if (op & 16) {
                          dist = here & 65535;
                          op &= 15;
                          if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                            if (bits < op) {
                              hold += input[_in++] << bits;
                              bits += 8;
                            }
                          }
                          dist += hold & (1 << op) - 1;
                          if (dist > dmax) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                          hold >>>= op;
                          bits -= op;
                          op = _out - beg;
                          if (dist > op) {
                            op = dist - op;
                            if (op > whave) {
                              if (state.sane) {
                                strm.msg = "invalid distance too far back";
                                state.mode = BAD;
                                break top;
                              }
                            }
                            from = 0;
                            from_source = s_window;
                            if (wnext === 0) {
                              from += wsize - op;
                              if (op < len) {
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output;
                              }
                            } else if (wnext < op) {
                              from += wsize + wnext - op;
                              op -= wnext;
                              if (op < len) {
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = 0;
                                if (wnext < len) {
                                  op = wnext;
                                  len -= op;
                                  do {
                                    output[_out++] = s_window[from++];
                                  } while (--op);
                                  from = _out - dist;
                                  from_source = output;
                                }
                              }
                            } else {
                              from += wnext - op;
                              if (op < len) {
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output;
                              }
                            }
                            while (len > 2) {
                              output[_out++] = from_source[from++];
                              output[_out++] = from_source[from++];
                              output[_out++] = from_source[from++];
                              len -= 3;
                            }
                            if (len) {
                              output[_out++] = from_source[from++];
                              if (len > 1) {
                                output[_out++] = from_source[from++];
                              }
                            }
                          } else {
                            from = _out - dist;
                            do {
                              output[_out++] = output[from++];
                              output[_out++] = output[from++];
                              output[_out++] = output[from++];
                              len -= 3;
                            } while (len > 2);
                            if (len) {
                              output[_out++] = output[from++];
                              if (len > 1) {
                                output[_out++] = output[from++];
                              }
                            }
                          }
                        } else if ((op & 64) === 0) {
                          here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                          continue dodist;
                        } else {
                          strm.msg = "invalid distance code";
                          state.mode = BAD;
                          break top;
                        }
                        break;
                      }
                  } else if ((op & 64) === 0) {
                    here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dolen;
                  } else if (op & 32) {
                    state.mode = TYPE;
                    break top;
                  } else {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD;
                    break top;
                  }
                  break;
                }
            } while (_in < last && _out < end);
          len = bits >> 3;
          _in -= len;
          bits -= len << 3;
          hold &= (1 << bits) - 1;
          strm.next_in = _in;
          strm.next_out = _out;
          strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
          strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
          state.hold = hold;
          state.bits = bits;
          return;
        };
      }, {}], 42: [function(require2, module3, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var adler32 = require2("./adler32");
        var crc32 = require2("./crc32");
        var inflate_fast = require2("./inffast");
        var inflate_table = require2("./inftrees");
        var CODES = 0;
        var LENS = 1;
        var DISTS = 2;
        var Z_FINISH = 4;
        var Z_BLOCK = 5;
        var Z_TREES = 6;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_NEED_DICT = 2;
        var Z_STREAM_ERROR = -2;
        var Z_DATA_ERROR = -3;
        var Z_MEM_ERROR = -4;
        var Z_BUF_ERROR = -5;
        var Z_DEFLATED = 8;
        var HEAD = 1;
        var FLAGS = 2;
        var TIME = 3;
        var OS = 4;
        var EXLEN = 5;
        var EXTRA = 6;
        var NAME = 7;
        var COMMENT = 8;
        var HCRC = 9;
        var DICTID = 10;
        var DICT = 11;
        var TYPE = 12;
        var TYPEDO = 13;
        var STORED = 14;
        var COPY_ = 15;
        var COPY = 16;
        var TABLE = 17;
        var LENLENS = 18;
        var CODELENS = 19;
        var LEN_ = 20;
        var LEN = 21;
        var LENEXT = 22;
        var DIST = 23;
        var DISTEXT = 24;
        var MATCH = 25;
        var LIT = 26;
        var CHECK = 27;
        var LENGTH = 28;
        var DONE = 29;
        var BAD = 30;
        var MEM = 31;
        var SYNC = 32;
        var ENOUGH_LENS = 852;
        var ENOUGH_DISTS = 592;
        var MAX_WBITS = 15;
        var DEF_WBITS = MAX_WBITS;
        function zswap32(q) {
          return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
        }
        function InflateState() {
          this.mode = 0;
          this.last = false;
          this.wrap = 0;
          this.havedict = false;
          this.flags = 0;
          this.dmax = 0;
          this.check = 0;
          this.total = 0;
          this.head = null;
          this.wbits = 0;
          this.wsize = 0;
          this.whave = 0;
          this.wnext = 0;
          this.window = null;
          this.hold = 0;
          this.bits = 0;
          this.length = 0;
          this.offset = 0;
          this.extra = 0;
          this.lencode = null;
          this.distcode = null;
          this.lenbits = 0;
          this.distbits = 0;
          this.ncode = 0;
          this.nlen = 0;
          this.ndist = 0;
          this.have = 0;
          this.next = null;
          this.lens = new utils.Buf16(320);
          this.work = new utils.Buf16(288);
          this.lendyn = null;
          this.distdyn = null;
          this.sane = 0;
          this.back = 0;
          this.was = 0;
        }
        function inflateResetKeep(strm) {
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          strm.total_in = strm.total_out = state.total = 0;
          strm.msg = "";
          if (state.wrap) {
            strm.adler = state.wrap & 1;
          }
          state.mode = HEAD;
          state.last = 0;
          state.havedict = 0;
          state.dmax = 32768;
          state.head = null;
          state.hold = 0;
          state.bits = 0;
          state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
          state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
          state.sane = 1;
          state.back = -1;
          return Z_OK;
        }
        function inflateReset(strm) {
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          state.wsize = 0;
          state.whave = 0;
          state.wnext = 0;
          return inflateResetKeep(strm);
        }
        function inflateReset2(strm, windowBits) {
          var wrap;
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
          } else {
            wrap = (windowBits >> 4) + 1;
            if (windowBits < 48) {
              windowBits &= 15;
            }
          }
          if (windowBits && (windowBits < 8 || windowBits > 15)) {
            return Z_STREAM_ERROR;
          }
          if (state.window !== null && state.wbits !== windowBits) {
            state.window = null;
          }
          state.wrap = wrap;
          state.wbits = windowBits;
          return inflateReset(strm);
        }
        function inflateInit2(strm, windowBits) {
          var ret;
          var state;
          if (!strm) {
            return Z_STREAM_ERROR;
          }
          state = new InflateState();
          strm.state = state;
          state.window = null;
          ret = inflateReset2(strm, windowBits);
          if (ret !== Z_OK) {
            strm.state = null;
          }
          return ret;
        }
        function inflateInit(strm) {
          return inflateInit2(strm, DEF_WBITS);
        }
        var virgin = true;
        var lenfix, distfix;
        function fixedtables(state) {
          if (virgin) {
            var sym;
            lenfix = new utils.Buf32(512);
            distfix = new utils.Buf32(32);
            sym = 0;
            while (sym < 144) {
              state.lens[sym++] = 8;
            }
            while (sym < 256) {
              state.lens[sym++] = 9;
            }
            while (sym < 280) {
              state.lens[sym++] = 7;
            }
            while (sym < 288) {
              state.lens[sym++] = 8;
            }
            inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
            sym = 0;
            while (sym < 32) {
              state.lens[sym++] = 5;
            }
            inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
            virgin = false;
          }
          state.lencode = lenfix;
          state.lenbits = 9;
          state.distcode = distfix;
          state.distbits = 5;
        }
        function updatewindow(strm, src, end, copy) {
          var dist;
          var state = strm.state;
          if (state.window === null) {
            state.wsize = 1 << state.wbits;
            state.wnext = 0;
            state.whave = 0;
            state.window = new utils.Buf8(state.wsize);
          }
          if (copy >= state.wsize) {
            utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
            state.wnext = 0;
            state.whave = state.wsize;
          } else {
            dist = state.wsize - state.wnext;
            if (dist > copy) {
              dist = copy;
            }
            utils.arraySet(state.window, src, end - copy, dist, state.wnext);
            copy -= dist;
            if (copy) {
              utils.arraySet(state.window, src, end - copy, copy, 0);
              state.wnext = copy;
              state.whave = state.wsize;
            } else {
              state.wnext += dist;
              if (state.wnext === state.wsize) {
                state.wnext = 0;
              }
              if (state.whave < state.wsize) {
                state.whave += dist;
              }
            }
          }
          return 0;
        }
        function inflate(strm, flush) {
          var state;
          var input, output;
          var next;
          var put;
          var have, left;
          var hold;
          var bits;
          var _in, _out;
          var copy;
          var from;
          var from_source;
          var here = 0;
          var here_bits, here_op, here_val;
          var last_bits, last_op, last_val;
          var len;
          var ret;
          var hbuf = new utils.Buf8(4);
          var opts;
          var n;
          var order = (
            /* permutation of code lengths */
            [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
          );
          if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if (state.mode === TYPE) {
            state.mode = TYPEDO;
          }
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          _in = have;
          _out = left;
          ret = Z_OK;
          inf_leave:
            for (; ; ) {
              switch (state.mode) {
                case HEAD:
                  if (state.wrap === 0) {
                    state.mode = TYPEDO;
                    break;
                  }
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.wrap & 2 && hold === 35615) {
                    state.check = 0;
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                    hold = 0;
                    bits = 0;
                    state.mode = FLAGS;
                    break;
                  }
                  state.flags = 0;
                  if (state.head) {
                    state.head.done = false;
                  }
                  if (!(state.wrap & 1) || /* check if zlib header allowed */
                  (((hold & 255) << 8) + (hold >> 8)) % 31) {
                    strm.msg = "incorrect header check";
                    state.mode = BAD;
                    break;
                  }
                  if ((hold & 15) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                  }
                  hold >>>= 4;
                  bits -= 4;
                  len = (hold & 15) + 8;
                  if (state.wbits === 0) {
                    state.wbits = len;
                  } else if (len > state.wbits) {
                    strm.msg = "invalid window size";
                    state.mode = BAD;
                    break;
                  }
                  state.dmax = 1 << len;
                  strm.adler = state.check = 1;
                  state.mode = hold & 512 ? DICTID : TYPE;
                  hold = 0;
                  bits = 0;
                  break;
                case FLAGS:
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.flags = hold;
                  if ((state.flags & 255) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                  }
                  if (state.flags & 57344) {
                    strm.msg = "unknown header flags set";
                    state.mode = BAD;
                    break;
                  }
                  if (state.head) {
                    state.head.text = hold >> 8 & 1;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = TIME;
                case TIME:
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.head) {
                    state.head.time = hold;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    hbuf[2] = hold >>> 16 & 255;
                    hbuf[3] = hold >>> 24 & 255;
                    state.check = crc32(state.check, hbuf, 4, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = OS;
                case OS:
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.head) {
                    state.head.xflags = hold & 255;
                    state.head.os = hold >> 8;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = EXLEN;
                case EXLEN:
                  if (state.flags & 1024) {
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.length = hold;
                    if (state.head) {
                      state.head.extra_len = hold;
                    }
                    if (state.flags & 512) {
                      hbuf[0] = hold & 255;
                      hbuf[1] = hold >>> 8 & 255;
                      state.check = crc32(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                  } else if (state.head) {
                    state.head.extra = null;
                  }
                  state.mode = EXTRA;
                case EXTRA:
                  if (state.flags & 1024) {
                    copy = state.length;
                    if (copy > have) {
                      copy = have;
                    }
                    if (copy) {
                      if (state.head) {
                        len = state.head.extra_len - state.length;
                        if (!state.head.extra) {
                          state.head.extra = new Array(state.head.extra_len);
                        }
                        utils.arraySet(
                          state.head.extra,
                          input,
                          next,
                          // extra field is limited to 65536 bytes
                          // - no need for additional size check
                          copy,
                          /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                          len
                        );
                      }
                      if (state.flags & 512) {
                        state.check = crc32(state.check, input, copy, next);
                      }
                      have -= copy;
                      next += copy;
                      state.length -= copy;
                    }
                    if (state.length) {
                      break inf_leave;
                    }
                  }
                  state.length = 0;
                  state.mode = NAME;
                case NAME:
                  if (state.flags & 2048) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    copy = 0;
                    do {
                      len = input[next + copy++];
                      if (state.head && len && state.length < 65536) {
                        state.head.name += String.fromCharCode(len);
                      }
                    } while (len && copy < have);
                    if (state.flags & 512) {
                      state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                      break inf_leave;
                    }
                  } else if (state.head) {
                    state.head.name = null;
                  }
                  state.length = 0;
                  state.mode = COMMENT;
                case COMMENT:
                  if (state.flags & 4096) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    copy = 0;
                    do {
                      len = input[next + copy++];
                      if (state.head && len && state.length < 65536) {
                        state.head.comment += String.fromCharCode(len);
                      }
                    } while (len && copy < have);
                    if (state.flags & 512) {
                      state.check = crc32(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                      break inf_leave;
                    }
                  } else if (state.head) {
                    state.head.comment = null;
                  }
                  state.mode = HCRC;
                case HCRC:
                  if (state.flags & 512) {
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (hold !== (state.check & 65535)) {
                      strm.msg = "header crc mismatch";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  if (state.head) {
                    state.head.hcrc = state.flags >> 9 & 1;
                    state.head.done = true;
                  }
                  strm.adler = state.check = 0;
                  state.mode = TYPE;
                  break;
                case DICTID:
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  strm.adler = state.check = zswap32(hold);
                  hold = 0;
                  bits = 0;
                  state.mode = DICT;
                case DICT:
                  if (state.havedict === 0) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    return Z_NEED_DICT;
                  }
                  strm.adler = state.check = 1;
                  state.mode = TYPE;
                case TYPE:
                  if (flush === Z_BLOCK || flush === Z_TREES) {
                    break inf_leave;
                  }
                case TYPEDO:
                  if (state.last) {
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    state.mode = CHECK;
                    break;
                  }
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.last = hold & 1;
                  hold >>>= 1;
                  bits -= 1;
                  switch (hold & 3) {
                    case 0:
                      state.mode = STORED;
                      break;
                    case 1:
                      fixedtables(state);
                      state.mode = LEN_;
                      if (flush === Z_TREES) {
                        hold >>>= 2;
                        bits -= 2;
                        break inf_leave;
                      }
                      break;
                    case 2:
                      state.mode = TABLE;
                      break;
                    case 3:
                      strm.msg = "invalid block type";
                      state.mode = BAD;
                  }
                  hold >>>= 2;
                  bits -= 2;
                  break;
                case STORED:
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                    strm.msg = "invalid stored block lengths";
                    state.mode = BAD;
                    break;
                  }
                  state.length = hold & 65535;
                  hold = 0;
                  bits = 0;
                  state.mode = COPY_;
                  if (flush === Z_TREES) {
                    break inf_leave;
                  }
                case COPY_:
                  state.mode = COPY;
                case COPY:
                  copy = state.length;
                  if (copy) {
                    if (copy > have) {
                      copy = have;
                    }
                    if (copy > left) {
                      copy = left;
                    }
                    if (copy === 0) {
                      break inf_leave;
                    }
                    utils.arraySet(output, input, next, copy, put);
                    have -= copy;
                    next += copy;
                    left -= copy;
                    put += copy;
                    state.length -= copy;
                    break;
                  }
                  state.mode = TYPE;
                  break;
                case TABLE:
                  while (bits < 14) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.nlen = (hold & 31) + 257;
                  hold >>>= 5;
                  bits -= 5;
                  state.ndist = (hold & 31) + 1;
                  hold >>>= 5;
                  bits -= 5;
                  state.ncode = (hold & 15) + 4;
                  hold >>>= 4;
                  bits -= 4;
                  if (state.nlen > 286 || state.ndist > 30) {
                    strm.msg = "too many length or distance symbols";
                    state.mode = BAD;
                    break;
                  }
                  state.have = 0;
                  state.mode = LENLENS;
                case LENLENS:
                  while (state.have < state.ncode) {
                    while (bits < 3) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.lens[order[state.have++]] = hold & 7;
                    hold >>>= 3;
                    bits -= 3;
                  }
                  while (state.have < 19) {
                    state.lens[order[state.have++]] = 0;
                  }
                  state.lencode = state.lendyn;
                  state.lenbits = 7;
                  opts = { bits: state.lenbits };
                  ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                  state.lenbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid code lengths set";
                    state.mode = BAD;
                    break;
                  }
                  state.have = 0;
                  state.mode = CODELENS;
                case CODELENS:
                  while (state.have < state.nlen + state.ndist) {
                    for (; ; ) {
                      here = state.lencode[hold & (1 << state.lenbits) - 1];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (here_val < 16) {
                      hold >>>= here_bits;
                      bits -= here_bits;
                      state.lens[state.have++] = here_val;
                    } else {
                      if (here_val === 16) {
                        n = here_bits + 2;
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        if (state.have === 0) {
                          strm.msg = "invalid bit length repeat";
                          state.mode = BAD;
                          break;
                        }
                        len = state.lens[state.have - 1];
                        copy = 3 + (hold & 3);
                        hold >>>= 2;
                        bits -= 2;
                      } else if (here_val === 17) {
                        n = here_bits + 3;
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        len = 0;
                        copy = 3 + (hold & 7);
                        hold >>>= 3;
                        bits -= 3;
                      } else {
                        n = here_bits + 7;
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        len = 0;
                        copy = 11 + (hold & 127);
                        hold >>>= 7;
                        bits -= 7;
                      }
                      if (state.have + copy > state.nlen + state.ndist) {
                        strm.msg = "invalid bit length repeat";
                        state.mode = BAD;
                        break;
                      }
                      while (copy--) {
                        state.lens[state.have++] = len;
                      }
                    }
                  }
                  if (state.mode === BAD) {
                    break;
                  }
                  if (state.lens[256] === 0) {
                    strm.msg = "invalid code -- missing end-of-block";
                    state.mode = BAD;
                    break;
                  }
                  state.lenbits = 9;
                  opts = { bits: state.lenbits };
                  ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                  state.lenbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid literal/lengths set";
                    state.mode = BAD;
                    break;
                  }
                  state.distbits = 6;
                  state.distcode = state.distdyn;
                  opts = { bits: state.distbits };
                  ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                  state.distbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid distances set";
                    state.mode = BAD;
                    break;
                  }
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    break inf_leave;
                  }
                case LEN_:
                  state.mode = LEN;
                case LEN:
                  if (have >= 6 && left >= 258) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    inflate_fast(strm, _out);
                    put = strm.next_out;
                    output = strm.output;
                    left = strm.avail_out;
                    next = strm.next_in;
                    input = strm.input;
                    have = strm.avail_in;
                    hold = state.hold;
                    bits = state.bits;
                    if (state.mode === TYPE) {
                      state.back = -1;
                    }
                    break;
                  }
                  state.back = 0;
                  for (; ; ) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (here_op && (here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (; ; ) {
                      here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (last_bits + here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.back += here_bits;
                  state.length = here_val;
                  if (here_op === 0) {
                    state.mode = LIT;
                    break;
                  }
                  if (here_op & 32) {
                    state.back = -1;
                    state.mode = TYPE;
                    break;
                  }
                  if (here_op & 64) {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD;
                    break;
                  }
                  state.extra = here_op & 15;
                  state.mode = LENEXT;
                case LENEXT:
                  if (state.extra) {
                    n = state.extra;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.length += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                  }
                  state.was = state.length;
                  state.mode = DIST;
                case DIST:
                  for (; ; ) {
                    here = state.distcode[hold & (1 << state.distbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if ((here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (; ; ) {
                      here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (last_bits + here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.back += here_bits;
                  if (here_op & 64) {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break;
                  }
                  state.offset = here_val;
                  state.extra = here_op & 15;
                  state.mode = DISTEXT;
                case DISTEXT:
                  if (state.extra) {
                    n = state.extra;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.offset += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                  }
                  if (state.offset > state.dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                  state.mode = MATCH;
                case MATCH:
                  if (left === 0) {
                    break inf_leave;
                  }
                  copy = _out - left;
                  if (state.offset > copy) {
                    copy = state.offset - copy;
                    if (copy > state.whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break;
                      }
                    }
                    if (copy > state.wnext) {
                      copy -= state.wnext;
                      from = state.wsize - copy;
                    } else {
                      from = state.wnext - copy;
                    }
                    if (copy > state.length) {
                      copy = state.length;
                    }
                    from_source = state.window;
                  } else {
                    from_source = output;
                    from = put - state.offset;
                    copy = state.length;
                  }
                  if (copy > left) {
                    copy = left;
                  }
                  left -= copy;
                  state.length -= copy;
                  do {
                    output[put++] = from_source[from++];
                  } while (--copy);
                  if (state.length === 0) {
                    state.mode = LEN;
                  }
                  break;
                case LIT:
                  if (left === 0) {
                    break inf_leave;
                  }
                  output[put++] = state.length;
                  left--;
                  state.mode = LEN;
                  break;
                case CHECK:
                  if (state.wrap) {
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold |= input[next++] << bits;
                      bits += 8;
                    }
                    _out -= left;
                    strm.total_out += _out;
                    state.total += _out;
                    if (_out) {
                      strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                      state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                    }
                    _out = left;
                    if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                      strm.msg = "incorrect data check";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  state.mode = LENGTH;
                case LENGTH:
                  if (state.wrap && state.flags) {
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (hold !== (state.total & 4294967295)) {
                      strm.msg = "incorrect length check";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  state.mode = DONE;
                case DONE:
                  ret = Z_STREAM_END;
                  break inf_leave;
                case BAD:
                  ret = Z_DATA_ERROR;
                  break inf_leave;
                case MEM:
                  return Z_MEM_ERROR;
                case SYNC:
                default:
                  return Z_STREAM_ERROR;
              }
            }
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
            if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
              state.mode = MEM;
              return Z_MEM_ERROR;
            }
          }
          _in -= strm.avail_in;
          _out -= strm.avail_out;
          strm.total_in += _in;
          strm.total_out += _out;
          state.total += _out;
          if (state.wrap && _out) {
            strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
            state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
          }
          strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
          if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
            ret = Z_BUF_ERROR;
          }
          return ret;
        }
        function inflateEnd(strm) {
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          var state = strm.state;
          if (state.window) {
            state.window = null;
          }
          strm.state = null;
          return Z_OK;
        }
        function inflateGetHeader(strm, head) {
          var state;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if ((state.wrap & 2) === 0) {
            return Z_STREAM_ERROR;
          }
          state.head = head;
          head.done = false;
          return Z_OK;
        }
        function inflateSetDictionary(strm, dictionary) {
          var dictLength = dictionary.length;
          var state;
          var dictid;
          var ret;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          state = strm.state;
          if (state.wrap !== 0 && state.mode !== DICT) {
            return Z_STREAM_ERROR;
          }
          if (state.mode === DICT) {
            dictid = 1;
            dictid = adler32(dictid, dictionary, dictLength, 0);
            if (dictid !== state.check) {
              return Z_DATA_ERROR;
            }
          }
          ret = updatewindow(strm, dictionary, dictLength, dictLength);
          if (ret) {
            state.mode = MEM;
            return Z_MEM_ERROR;
          }
          state.havedict = 1;
          return Z_OK;
        }
        exports3.inflateReset = inflateReset;
        exports3.inflateReset2 = inflateReset2;
        exports3.inflateResetKeep = inflateResetKeep;
        exports3.inflateInit = inflateInit;
        exports3.inflateInit2 = inflateInit2;
        exports3.inflate = inflate;
        exports3.inflateEnd = inflateEnd;
        exports3.inflateGetHeader = inflateGetHeader;
        exports3.inflateSetDictionary = inflateSetDictionary;
        exports3.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 36, "./adler32": 37, "./crc32": 39, "./inffast": 41, "./inftrees": 43 }], 43: [function(require2, module3, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var MAXBITS = 15;
        var ENOUGH_LENS = 852;
        var ENOUGH_DISTS = 592;
        var CODES = 0;
        var LENS = 1;
        var DISTS = 2;
        var lbase = [
          /* Length codes 257..285 base */
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          13,
          15,
          17,
          19,
          23,
          27,
          31,
          35,
          43,
          51,
          59,
          67,
          83,
          99,
          115,
          131,
          163,
          195,
          227,
          258,
          0,
          0
        ];
        var lext = [
          /* Length codes 257..285 extra */
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          17,
          17,
          17,
          17,
          18,
          18,
          18,
          18,
          19,
          19,
          19,
          19,
          20,
          20,
          20,
          20,
          21,
          21,
          21,
          21,
          16,
          72,
          78
        ];
        var dbase = [
          /* Distance codes 0..29 base */
          1,
          2,
          3,
          4,
          5,
          7,
          9,
          13,
          17,
          25,
          33,
          49,
          65,
          97,
          129,
          193,
          257,
          385,
          513,
          769,
          1025,
          1537,
          2049,
          3073,
          4097,
          6145,
          8193,
          12289,
          16385,
          24577,
          0,
          0
        ];
        var dext = [
          /* Distance codes 0..29 extra */
          16,
          16,
          16,
          16,
          17,
          17,
          18,
          18,
          19,
          19,
          20,
          20,
          21,
          21,
          22,
          22,
          23,
          23,
          24,
          24,
          25,
          25,
          26,
          26,
          27,
          27,
          28,
          28,
          29,
          29,
          64,
          64
        ];
        module3.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
          var bits = opts.bits;
          var len = 0;
          var sym = 0;
          var min = 0, max = 0;
          var root = 0;
          var curr = 0;
          var drop = 0;
          var left = 0;
          var used = 0;
          var huff = 0;
          var incr;
          var fill;
          var low;
          var mask;
          var next;
          var base = null;
          var base_index = 0;
          var end;
          var count = new utils.Buf16(MAXBITS + 1);
          var offs = new utils.Buf16(MAXBITS + 1);
          var extra = null;
          var extra_index = 0;
          var here_bits, here_op, here_val;
          for (len = 0; len <= MAXBITS; len++) {
            count[len] = 0;
          }
          for (sym = 0; sym < codes; sym++) {
            count[lens[lens_index + sym]]++;
          }
          root = bits;
          for (max = MAXBITS; max >= 1; max--) {
            if (count[max] !== 0) {
              break;
            }
          }
          if (root > max) {
            root = max;
          }
          if (max === 0) {
            table[table_index++] = 1 << 24 | 64 << 16 | 0;
            table[table_index++] = 1 << 24 | 64 << 16 | 0;
            opts.bits = 1;
            return 0;
          }
          for (min = 1; min < max; min++) {
            if (count[min] !== 0) {
              break;
            }
          }
          if (root < min) {
            root = min;
          }
          left = 1;
          for (len = 1; len <= MAXBITS; len++) {
            left <<= 1;
            left -= count[len];
            if (left < 0) {
              return -1;
            }
          }
          if (left > 0 && (type === CODES || max !== 1)) {
            return -1;
          }
          offs[1] = 0;
          for (len = 1; len < MAXBITS; len++) {
            offs[len + 1] = offs[len] + count[len];
          }
          for (sym = 0; sym < codes; sym++) {
            if (lens[lens_index + sym] !== 0) {
              work[offs[lens[lens_index + sym]]++] = sym;
            }
          }
          if (type === CODES) {
            base = extra = work;
            end = 19;
          } else if (type === LENS) {
            base = lbase;
            base_index -= 257;
            extra = lext;
            extra_index -= 257;
            end = 256;
          } else {
            base = dbase;
            extra = dext;
            end = -1;
          }
          huff = 0;
          sym = 0;
          len = min;
          next = table_index;
          curr = root;
          drop = 0;
          low = -1;
          used = 1 << root;
          mask = used - 1;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          for (; ; ) {
            here_bits = len - drop;
            if (work[sym] < end) {
              here_op = 0;
              here_val = work[sym];
            } else if (work[sym] > end) {
              here_op = extra[extra_index + work[sym]];
              here_val = base[base_index + work[sym]];
            } else {
              here_op = 32 + 64;
              here_val = 0;
            }
            incr = 1 << len - drop;
            fill = 1 << curr;
            min = fill;
            do {
              fill -= incr;
              table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
            } while (fill !== 0);
            incr = 1 << len - 1;
            while (huff & incr) {
              incr >>= 1;
            }
            if (incr !== 0) {
              huff &= incr - 1;
              huff += incr;
            } else {
              huff = 0;
            }
            sym++;
            if (--count[len] === 0) {
              if (len === max) {
                break;
              }
              len = lens[lens_index + work[sym]];
            }
            if (len > root && (huff & mask) !== low) {
              if (drop === 0) {
                drop = root;
              }
              next += min;
              curr = len - drop;
              left = 1 << curr;
              while (curr + drop < max) {
                left -= count[curr + drop];
                if (left <= 0) {
                  break;
                }
                curr++;
                left <<= 1;
              }
              used += 1 << curr;
              if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
                return 1;
              }
              low = huff & mask;
              table[low] = root << 24 | curr << 16 | next - table_index | 0;
            }
          }
          if (huff !== 0) {
            table[next + huff] = len - drop << 24 | 64 << 16 | 0;
          }
          opts.bits = root;
          return 0;
        };
      }, { "../utils/common": 36 }], 44: [function(require2, module3, exports3) {
        "use strict";
        module3.exports = {
          2: "need dictionary",
          /* Z_NEED_DICT       2  */
          1: "stream end",
          /* Z_STREAM_END      1  */
          0: "",
          /* Z_OK              0  */
          "-1": "file error",
          /* Z_ERRNO         (-1) */
          "-2": "stream error",
          /* Z_STREAM_ERROR  (-2) */
          "-3": "data error",
          /* Z_DATA_ERROR    (-3) */
          "-4": "insufficient memory",
          /* Z_MEM_ERROR     (-4) */
          "-5": "buffer error",
          /* Z_BUF_ERROR     (-5) */
          "-6": "incompatible version"
          /* Z_VERSION_ERROR (-6) */
        };
      }, {}], 45: [function(require2, module3, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var Z_FIXED = 4;
        var Z_BINARY = 0;
        var Z_TEXT = 1;
        var Z_UNKNOWN = 2;
        function zero(buf) {
          var len = buf.length;
          while (--len >= 0) {
            buf[len] = 0;
          }
        }
        var STORED_BLOCK = 0;
        var STATIC_TREES = 1;
        var DYN_TREES = 2;
        var MIN_MATCH = 3;
        var MAX_MATCH = 258;
        var LENGTH_CODES = 29;
        var LITERALS = 256;
        var L_CODES = LITERALS + 1 + LENGTH_CODES;
        var D_CODES = 30;
        var BL_CODES = 19;
        var HEAP_SIZE = 2 * L_CODES + 1;
        var MAX_BITS = 15;
        var Buf_size = 16;
        var MAX_BL_BITS = 7;
        var END_BLOCK = 256;
        var REP_3_6 = 16;
        var REPZ_3_10 = 17;
        var REPZ_11_138 = 18;
        var extra_lbits = (
          /* extra bits for each length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
        );
        var extra_dbits = (
          /* extra bits for each distance code */
          [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
        );
        var extra_blbits = (
          /* extra bits for each bit length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
        );
        var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        var DIST_CODE_LEN = 512;
        var static_ltree = new Array((L_CODES + 2) * 2);
        zero(static_ltree);
        var static_dtree = new Array(D_CODES * 2);
        zero(static_dtree);
        var _dist_code = new Array(DIST_CODE_LEN);
        zero(_dist_code);
        var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
        zero(_length_code);
        var base_length = new Array(LENGTH_CODES);
        zero(base_length);
        var base_dist = new Array(D_CODES);
        zero(base_dist);
        function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
          this.static_tree = static_tree;
          this.extra_bits = extra_bits;
          this.extra_base = extra_base;
          this.elems = elems;
          this.max_length = max_length;
          this.has_stree = static_tree && static_tree.length;
        }
        var static_l_desc;
        var static_d_desc;
        var static_bl_desc;
        function TreeDesc(dyn_tree, stat_desc) {
          this.dyn_tree = dyn_tree;
          this.max_code = 0;
          this.stat_desc = stat_desc;
        }
        function d_code(dist) {
          return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
        }
        function put_short(s, w) {
          s.pending_buf[s.pending++] = w & 255;
          s.pending_buf[s.pending++] = w >>> 8 & 255;
        }
        function send_bits(s, value, length) {
          if (s.bi_valid > Buf_size - length) {
            s.bi_buf |= value << s.bi_valid & 65535;
            put_short(s, s.bi_buf);
            s.bi_buf = value >> Buf_size - s.bi_valid;
            s.bi_valid += length - Buf_size;
          } else {
            s.bi_buf |= value << s.bi_valid & 65535;
            s.bi_valid += length;
          }
        }
        function send_code(s, c, tree) {
          send_bits(
            s,
            tree[c * 2],
            tree[c * 2 + 1]
            /*.Len*/
          );
        }
        function bi_reverse(code, len) {
          var res = 0;
          do {
            res |= code & 1;
            code >>>= 1;
            res <<= 1;
          } while (--len > 0);
          return res >>> 1;
        }
        function bi_flush(s) {
          if (s.bi_valid === 16) {
            put_short(s, s.bi_buf);
            s.bi_buf = 0;
            s.bi_valid = 0;
          } else if (s.bi_valid >= 8) {
            s.pending_buf[s.pending++] = s.bi_buf & 255;
            s.bi_buf >>= 8;
            s.bi_valid -= 8;
          }
        }
        function gen_bitlen(s, desc) {
          var tree = desc.dyn_tree;
          var max_code = desc.max_code;
          var stree = desc.stat_desc.static_tree;
          var has_stree = desc.stat_desc.has_stree;
          var extra = desc.stat_desc.extra_bits;
          var base = desc.stat_desc.extra_base;
          var max_length = desc.stat_desc.max_length;
          var h;
          var n, m;
          var bits;
          var xbits;
          var f;
          var overflow = 0;
          for (bits = 0; bits <= MAX_BITS; bits++) {
            s.bl_count[bits] = 0;
          }
          tree[s.heap[s.heap_max] * 2 + 1] = 0;
          for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
            n = s.heap[h];
            bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
            if (bits > max_length) {
              bits = max_length;
              overflow++;
            }
            tree[n * 2 + 1] = bits;
            if (n > max_code) {
              continue;
            }
            s.bl_count[bits]++;
            xbits = 0;
            if (n >= base) {
              xbits = extra[n - base];
            }
            f = tree[n * 2];
            s.opt_len += f * (bits + xbits);
            if (has_stree) {
              s.static_len += f * (stree[n * 2 + 1] + xbits);
            }
          }
          if (overflow === 0) {
            return;
          }
          do {
            bits = max_length - 1;
            while (s.bl_count[bits] === 0) {
              bits--;
            }
            s.bl_count[bits]--;
            s.bl_count[bits + 1] += 2;
            s.bl_count[max_length]--;
            overflow -= 2;
          } while (overflow > 0);
          for (bits = max_length; bits !== 0; bits--) {
            n = s.bl_count[bits];
            while (n !== 0) {
              m = s.heap[--h];
              if (m > max_code) {
                continue;
              }
              if (tree[m * 2 + 1] !== bits) {
                s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                tree[m * 2 + 1] = bits;
              }
              n--;
            }
          }
        }
        function gen_codes(tree, max_code, bl_count) {
          var next_code = new Array(MAX_BITS + 1);
          var code = 0;
          var bits;
          var n;
          for (bits = 1; bits <= MAX_BITS; bits++) {
            next_code[bits] = code = code + bl_count[bits - 1] << 1;
          }
          for (n = 0; n <= max_code; n++) {
            var len = tree[n * 2 + 1];
            if (len === 0) {
              continue;
            }
            tree[n * 2] = bi_reverse(next_code[len]++, len);
          }
        }
        function tr_static_init() {
          var n;
          var bits;
          var length;
          var code;
          var dist;
          var bl_count = new Array(MAX_BITS + 1);
          length = 0;
          for (code = 0; code < LENGTH_CODES - 1; code++) {
            base_length[code] = length;
            for (n = 0; n < 1 << extra_lbits[code]; n++) {
              _length_code[length++] = code;
            }
          }
          _length_code[length - 1] = code;
          dist = 0;
          for (code = 0; code < 16; code++) {
            base_dist[code] = dist;
            for (n = 0; n < 1 << extra_dbits[code]; n++) {
              _dist_code[dist++] = code;
            }
          }
          dist >>= 7;
          for (; code < D_CODES; code++) {
            base_dist[code] = dist << 7;
            for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
              _dist_code[256 + dist++] = code;
            }
          }
          for (bits = 0; bits <= MAX_BITS; bits++) {
            bl_count[bits] = 0;
          }
          n = 0;
          while (n <= 143) {
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
          }
          while (n <= 255) {
            static_ltree[n * 2 + 1] = 9;
            n++;
            bl_count[9]++;
          }
          while (n <= 279) {
            static_ltree[n * 2 + 1] = 7;
            n++;
            bl_count[7]++;
          }
          while (n <= 287) {
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
          }
          gen_codes(static_ltree, L_CODES + 1, bl_count);
          for (n = 0; n < D_CODES; n++) {
            static_dtree[n * 2 + 1] = 5;
            static_dtree[n * 2] = bi_reverse(n, 5);
          }
          static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
          static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
          static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
        }
        function init_block(s) {
          var n;
          for (n = 0; n < L_CODES; n++) {
            s.dyn_ltree[n * 2] = 0;
          }
          for (n = 0; n < D_CODES; n++) {
            s.dyn_dtree[n * 2] = 0;
          }
          for (n = 0; n < BL_CODES; n++) {
            s.bl_tree[n * 2] = 0;
          }
          s.dyn_ltree[END_BLOCK * 2] = 1;
          s.opt_len = s.static_len = 0;
          s.last_lit = s.matches = 0;
        }
        function bi_windup(s) {
          if (s.bi_valid > 8) {
            put_short(s, s.bi_buf);
          } else if (s.bi_valid > 0) {
            s.pending_buf[s.pending++] = s.bi_buf;
          }
          s.bi_buf = 0;
          s.bi_valid = 0;
        }
        function copy_block(s, buf, len, header) {
          bi_windup(s);
          if (header) {
            put_short(s, len);
            put_short(s, ~len);
          }
          utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
          s.pending += len;
        }
        function smaller(tree, n, m, depth) {
          var _n2 = n * 2;
          var _m2 = m * 2;
          return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
        }
        function pqdownheap(s, tree, k) {
          var v = s.heap[k];
          var j = k << 1;
          while (j <= s.heap_len) {
            if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
              j++;
            }
            if (smaller(tree, v, s.heap[j], s.depth)) {
              break;
            }
            s.heap[k] = s.heap[j];
            k = j;
            j <<= 1;
          }
          s.heap[k] = v;
        }
        function compress_block(s, ltree, dtree) {
          var dist;
          var lc;
          var lx = 0;
          var code;
          var extra;
          if (s.last_lit !== 0) {
            do {
              dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
              lc = s.pending_buf[s.l_buf + lx];
              lx++;
              if (dist === 0) {
                send_code(s, lc, ltree);
              } else {
                code = _length_code[lc];
                send_code(s, code + LITERALS + 1, ltree);
                extra = extra_lbits[code];
                if (extra !== 0) {
                  lc -= base_length[code];
                  send_bits(s, lc, extra);
                }
                dist--;
                code = d_code(dist);
                send_code(s, code, dtree);
                extra = extra_dbits[code];
                if (extra !== 0) {
                  dist -= base_dist[code];
                  send_bits(s, dist, extra);
                }
              }
            } while (lx < s.last_lit);
          }
          send_code(s, END_BLOCK, ltree);
        }
        function build_tree(s, desc) {
          var tree = desc.dyn_tree;
          var stree = desc.stat_desc.static_tree;
          var has_stree = desc.stat_desc.has_stree;
          var elems = desc.stat_desc.elems;
          var n, m;
          var max_code = -1;
          var node;
          s.heap_len = 0;
          s.heap_max = HEAP_SIZE;
          for (n = 0; n < elems; n++) {
            if (tree[n * 2] !== 0) {
              s.heap[++s.heap_len] = max_code = n;
              s.depth[n] = 0;
            } else {
              tree[n * 2 + 1] = 0;
            }
          }
          while (s.heap_len < 2) {
            node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
            tree[node * 2] = 1;
            s.depth[node] = 0;
            s.opt_len--;
            if (has_stree) {
              s.static_len -= stree[node * 2 + 1];
            }
          }
          desc.max_code = max_code;
          for (n = s.heap_len >> 1; n >= 1; n--) {
            pqdownheap(s, tree, n);
          }
          node = elems;
          do {
            n = s.heap[
              1
              /*SMALLEST*/
            ];
            s.heap[
              1
              /*SMALLEST*/
            ] = s.heap[s.heap_len--];
            pqdownheap(
              s,
              tree,
              1
              /*SMALLEST*/
            );
            m = s.heap[
              1
              /*SMALLEST*/
            ];
            s.heap[--s.heap_max] = n;
            s.heap[--s.heap_max] = m;
            tree[node * 2] = tree[n * 2] + tree[m * 2];
            s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
            tree[n * 2 + 1] = tree[m * 2 + 1] = node;
            s.heap[
              1
              /*SMALLEST*/
            ] = node++;
            pqdownheap(
              s,
              tree,
              1
              /*SMALLEST*/
            );
          } while (s.heap_len >= 2);
          s.heap[--s.heap_max] = s.heap[
            1
            /*SMALLEST*/
          ];
          gen_bitlen(s, desc);
          gen_codes(tree, max_code, s.bl_count);
        }
        function scan_tree(s, tree, max_code) {
          var n;
          var prevlen = -1;
          var curlen;
          var nextlen = tree[0 * 2 + 1];
          var count = 0;
          var max_count = 7;
          var min_count = 4;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          }
          tree[(max_code + 1) * 2 + 1] = 65535;
          for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
              continue;
            } else if (count < min_count) {
              s.bl_tree[curlen * 2] += count;
            } else if (curlen !== 0) {
              if (curlen !== prevlen) {
                s.bl_tree[curlen * 2]++;
              }
              s.bl_tree[REP_3_6 * 2]++;
            } else if (count <= 10) {
              s.bl_tree[REPZ_3_10 * 2]++;
            } else {
              s.bl_tree[REPZ_11_138 * 2]++;
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            } else if (curlen === nextlen) {
              max_count = 6;
              min_count = 3;
            } else {
              max_count = 7;
              min_count = 4;
            }
          }
        }
        function send_tree(s, tree, max_code) {
          var n;
          var prevlen = -1;
          var curlen;
          var nextlen = tree[0 * 2 + 1];
          var count = 0;
          var max_count = 7;
          var min_count = 4;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          }
          for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
              continue;
            } else if (count < min_count) {
              do {
                send_code(s, curlen, s.bl_tree);
              } while (--count !== 0);
            } else if (curlen !== 0) {
              if (curlen !== prevlen) {
                send_code(s, curlen, s.bl_tree);
                count--;
              }
              send_code(s, REP_3_6, s.bl_tree);
              send_bits(s, count - 3, 2);
            } else if (count <= 10) {
              send_code(s, REPZ_3_10, s.bl_tree);
              send_bits(s, count - 3, 3);
            } else {
              send_code(s, REPZ_11_138, s.bl_tree);
              send_bits(s, count - 11, 7);
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            } else if (curlen === nextlen) {
              max_count = 6;
              min_count = 3;
            } else {
              max_count = 7;
              min_count = 4;
            }
          }
        }
        function build_bl_tree(s) {
          var max_blindex;
          scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
          scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
          build_tree(s, s.bl_desc);
          for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
            if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
              break;
            }
          }
          s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
          return max_blindex;
        }
        function send_all_trees(s, lcodes, dcodes, blcodes) {
          var rank;
          send_bits(s, lcodes - 257, 5);
          send_bits(s, dcodes - 1, 5);
          send_bits(s, blcodes - 4, 4);
          for (rank = 0; rank < blcodes; rank++) {
            send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
          }
          send_tree(s, s.dyn_ltree, lcodes - 1);
          send_tree(s, s.dyn_dtree, dcodes - 1);
        }
        function detect_data_type(s) {
          var black_mask = 4093624447;
          var n;
          for (n = 0; n <= 31; n++, black_mask >>>= 1) {
            if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
              return Z_BINARY;
            }
          }
          if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
            return Z_TEXT;
          }
          for (n = 32; n < LITERALS; n++) {
            if (s.dyn_ltree[n * 2] !== 0) {
              return Z_TEXT;
            }
          }
          return Z_BINARY;
        }
        var static_init_done = false;
        function _tr_init(s) {
          if (!static_init_done) {
            tr_static_init();
            static_init_done = true;
          }
          s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
          s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
          s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
          s.bi_buf = 0;
          s.bi_valid = 0;
          init_block(s);
        }
        function _tr_stored_block(s, buf, stored_len, last) {
          send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
          copy_block(s, buf, stored_len, true);
        }
        function _tr_align(s) {
          send_bits(s, STATIC_TREES << 1, 3);
          send_code(s, END_BLOCK, static_ltree);
          bi_flush(s);
        }
        function _tr_flush_block(s, buf, stored_len, last) {
          var opt_lenb, static_lenb;
          var max_blindex = 0;
          if (s.level > 0) {
            if (s.strm.data_type === Z_UNKNOWN) {
              s.strm.data_type = detect_data_type(s);
            }
            build_tree(s, s.l_desc);
            build_tree(s, s.d_desc);
            max_blindex = build_bl_tree(s);
            opt_lenb = s.opt_len + 3 + 7 >>> 3;
            static_lenb = s.static_len + 3 + 7 >>> 3;
            if (static_lenb <= opt_lenb) {
              opt_lenb = static_lenb;
            }
          } else {
            opt_lenb = static_lenb = stored_len + 5;
          }
          if (stored_len + 4 <= opt_lenb && buf !== -1) {
            _tr_stored_block(s, buf, stored_len, last);
          } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
            send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
            compress_block(s, static_ltree, static_dtree);
          } else {
            send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
            send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
            compress_block(s, s.dyn_ltree, s.dyn_dtree);
          }
          init_block(s);
          if (last) {
            bi_windup(s);
          }
        }
        function _tr_tally(s, dist, lc) {
          s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
          s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
          s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
          s.last_lit++;
          if (dist === 0) {
            s.dyn_ltree[lc * 2]++;
          } else {
            s.matches++;
            dist--;
            s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
            s.dyn_dtree[d_code(dist) * 2]++;
          }
          return s.last_lit === s.lit_bufsize - 1;
        }
        exports3._tr_init = _tr_init;
        exports3._tr_stored_block = _tr_stored_block;
        exports3._tr_flush_block = _tr_flush_block;
        exports3._tr_tally = _tr_tally;
        exports3._tr_align = _tr_align;
      }, { "../utils/common": 36 }], 46: [function(require2, module3, exports3) {
        "use strict";
        function ZStream() {
          this.input = null;
          this.next_in = 0;
          this.avail_in = 0;
          this.total_in = 0;
          this.output = null;
          this.next_out = 0;
          this.avail_out = 0;
          this.total_out = 0;
          this.msg = "";
          this.state = null;
          this.data_type = 2;
          this.adler = 0;
        }
        module3.exports = ZStream;
      }, {}], 47: [function(require2, module3, exports3) {
        arguments[4][33][0].apply(exports3, arguments);
      }, { "dup": 33 }], 48: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var base64 = require2("base64-js");
          var ieee754 = require2("ieee754");
          var customInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
          exports3.Buffer = Buffer;
          exports3.SlowBuffer = SlowBuffer;
          exports3.INSPECT_MAX_BYTES = 50;
          var K_MAX_LENGTH = 2147483647;
          exports3.kMaxLength = K_MAX_LENGTH;
          Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
          if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
            console.error(
              "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
            );
          }
          function typedArraySupport() {
            try {
              var arr = new Uint8Array(1);
              var proto = { foo: function() {
                return 42;
              } };
              Object.setPrototypeOf(proto, Uint8Array.prototype);
              Object.setPrototypeOf(arr, proto);
              return arr.foo() === 42;
            } catch (e) {
              return false;
            }
          }
          Object.defineProperty(Buffer.prototype, "parent", {
            enumerable: true,
            get: function() {
              if (!Buffer.isBuffer(this))
                return void 0;
              return this.buffer;
            }
          });
          Object.defineProperty(Buffer.prototype, "offset", {
            enumerable: true,
            get: function() {
              if (!Buffer.isBuffer(this))
                return void 0;
              return this.byteOffset;
            }
          });
          function createBuffer(length) {
            if (length > K_MAX_LENGTH) {
              throw new RangeError('The value "' + length + '" is invalid for option "size"');
            }
            var buf = new Uint8Array(length);
            Object.setPrototypeOf(buf, Buffer.prototype);
            return buf;
          }
          function Buffer(arg, encodingOrOffset, length) {
            if (typeof arg === "number") {
              if (typeof encodingOrOffset === "string") {
                throw new TypeError(
                  'The "string" argument must be of type string. Received type number'
                );
              }
              return allocUnsafe(arg);
            }
            return from(arg, encodingOrOffset, length);
          }
          if (typeof Symbol !== "undefined" && Symbol.species != null && Buffer[Symbol.species] === Buffer) {
            Object.defineProperty(Buffer, Symbol.species, {
              value: null,
              configurable: true,
              enumerable: false,
              writable: false
            });
          }
          Buffer.poolSize = 8192;
          function from(value, encodingOrOffset, length) {
            if (typeof value === "string") {
              return fromString(value, encodingOrOffset);
            }
            if (ArrayBuffer.isView(value)) {
              return fromArrayLike(value);
            }
            if (value == null) {
              throw new TypeError(
                "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
              );
            }
            if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
              return fromArrayBuffer(value, encodingOrOffset, length);
            }
            if (typeof value === "number") {
              throw new TypeError(
                'The "value" argument must not be of type number. Received type number'
              );
            }
            var valueOf = value.valueOf && value.valueOf();
            if (valueOf != null && valueOf !== value) {
              return Buffer.from(valueOf, encodingOrOffset, length);
            }
            var b = fromObject(value);
            if (b)
              return b;
            if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
              return Buffer.from(
                value[Symbol.toPrimitive]("string"),
                encodingOrOffset,
                length
              );
            }
            throw new TypeError(
              "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
            );
          }
          Buffer.from = function(value, encodingOrOffset, length) {
            return from(value, encodingOrOffset, length);
          };
          Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
          Object.setPrototypeOf(Buffer, Uint8Array);
          function assertSize(size) {
            if (typeof size !== "number") {
              throw new TypeError('"size" argument must be of type number');
            } else if (size < 0) {
              throw new RangeError('The value "' + size + '" is invalid for option "size"');
            }
          }
          function alloc(size, fill, encoding) {
            assertSize(size);
            if (size <= 0) {
              return createBuffer(size);
            }
            if (fill !== void 0) {
              return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
            }
            return createBuffer(size);
          }
          Buffer.alloc = function(size, fill, encoding) {
            return alloc(size, fill, encoding);
          };
          function allocUnsafe(size) {
            assertSize(size);
            return createBuffer(size < 0 ? 0 : checked(size) | 0);
          }
          Buffer.allocUnsafe = function(size) {
            return allocUnsafe(size);
          };
          Buffer.allocUnsafeSlow = function(size) {
            return allocUnsafe(size);
          };
          function fromString(string, encoding) {
            if (typeof encoding !== "string" || encoding === "") {
              encoding = "utf8";
            }
            if (!Buffer.isEncoding(encoding)) {
              throw new TypeError("Unknown encoding: " + encoding);
            }
            var length = byteLength(string, encoding) | 0;
            var buf = createBuffer(length);
            var actual = buf.write(string, encoding);
            if (actual !== length) {
              buf = buf.slice(0, actual);
            }
            return buf;
          }
          function fromArrayLike(array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0;
            var buf = createBuffer(length);
            for (var i = 0; i < length; i += 1) {
              buf[i] = array[i] & 255;
            }
            return buf;
          }
          function fromArrayBuffer(array, byteOffset, length) {
            if (byteOffset < 0 || array.byteLength < byteOffset) {
              throw new RangeError('"offset" is outside of buffer bounds');
            }
            if (array.byteLength < byteOffset + (length || 0)) {
              throw new RangeError('"length" is outside of buffer bounds');
            }
            var buf;
            if (byteOffset === void 0 && length === void 0) {
              buf = new Uint8Array(array);
            } else if (length === void 0) {
              buf = new Uint8Array(array, byteOffset);
            } else {
              buf = new Uint8Array(array, byteOffset, length);
            }
            Object.setPrototypeOf(buf, Buffer.prototype);
            return buf;
          }
          function fromObject(obj) {
            if (Buffer.isBuffer(obj)) {
              var len = checked(obj.length) | 0;
              var buf = createBuffer(len);
              if (buf.length === 0) {
                return buf;
              }
              obj.copy(buf, 0, 0, len);
              return buf;
            }
            if (obj.length !== void 0) {
              if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                return createBuffer(0);
              }
              return fromArrayLike(obj);
            }
            if (obj.type === "Buffer" && Array.isArray(obj.data)) {
              return fromArrayLike(obj.data);
            }
          }
          function checked(length) {
            if (length >= K_MAX_LENGTH) {
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
            }
            return length | 0;
          }
          function SlowBuffer(length) {
            if (+length != length) {
              length = 0;
            }
            return Buffer.alloc(+length);
          }
          Buffer.isBuffer = function isBuffer(b) {
            return b != null && b._isBuffer === true && b !== Buffer.prototype;
          };
          Buffer.compare = function compare(a, b) {
            if (isInstance(a, Uint8Array))
              a = Buffer.from(a, a.offset, a.byteLength);
            if (isInstance(b, Uint8Array))
              b = Buffer.from(b, b.offset, b.byteLength);
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError(
                'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
              );
            }
            if (a === b)
              return 0;
            var x = a.length;
            var y = b.length;
            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i];
                y = b[i];
                break;
              }
            }
            if (x < y)
              return -1;
            if (y < x)
              return 1;
            return 0;
          };
          Buffer.isEncoding = function isEncoding(encoding) {
            switch (String(encoding).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return true;
              default:
                return false;
            }
          };
          Buffer.concat = function concat(list, length) {
            if (!Array.isArray(list)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }
            if (list.length === 0) {
              return Buffer.alloc(0);
            }
            var i;
            if (length === void 0) {
              length = 0;
              for (i = 0; i < list.length; ++i) {
                length += list[i].length;
              }
            }
            var buffer = Buffer.allocUnsafe(length);
            var pos = 0;
            for (i = 0; i < list.length; ++i) {
              var buf = list[i];
              if (isInstance(buf, Uint8Array)) {
                buf = Buffer.from(buf);
              }
              if (!Buffer.isBuffer(buf)) {
                throw new TypeError('"list" argument must be an Array of Buffers');
              }
              buf.copy(buffer, pos);
              pos += buf.length;
            }
            return buffer;
          };
          function byteLength(string, encoding) {
            if (Buffer.isBuffer(string)) {
              return string.length;
            }
            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
              return string.byteLength;
            }
            if (typeof string !== "string") {
              throw new TypeError(
                'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
              );
            }
            var len = string.length;
            var mustMatch = arguments.length > 2 && arguments[2] === true;
            if (!mustMatch && len === 0)
              return 0;
            var loweredCase = false;
            for (; ; ) {
              switch (encoding) {
                case "ascii":
                case "latin1":
                case "binary":
                  return len;
                case "utf8":
                case "utf-8":
                  return utf8ToBytes(string).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return len * 2;
                case "hex":
                  return len >>> 1;
                case "base64":
                  return base64ToBytes(string).length;
                default:
                  if (loweredCase) {
                    return mustMatch ? -1 : utf8ToBytes(string).length;
                  }
                  encoding = ("" + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer.byteLength = byteLength;
          function slowToString(encoding, start, end) {
            var loweredCase = false;
            if (start === void 0 || start < 0) {
              start = 0;
            }
            if (start > this.length) {
              return "";
            }
            if (end === void 0 || end > this.length) {
              end = this.length;
            }
            if (end <= 0) {
              return "";
            }
            end >>>= 0;
            start >>>= 0;
            if (end <= start) {
              return "";
            }
            if (!encoding)
              encoding = "utf8";
            while (true) {
              switch (encoding) {
                case "hex":
                  return hexSlice(this, start, end);
                case "utf8":
                case "utf-8":
                  return utf8Slice(this, start, end);
                case "ascii":
                  return asciiSlice(this, start, end);
                case "latin1":
                case "binary":
                  return latin1Slice(this, start, end);
                case "base64":
                  return base64Slice(this, start, end);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return utf16leSlice(this, start, end);
                default:
                  if (loweredCase)
                    throw new TypeError("Unknown encoding: " + encoding);
                  encoding = (encoding + "").toLowerCase();
                  loweredCase = true;
              }
            }
          }
          Buffer.prototype._isBuffer = true;
          function swap(b, n, m) {
            var i = b[n];
            b[n] = b[m];
            b[m] = i;
          }
          Buffer.prototype.swap16 = function swap16() {
            var len = this.length;
            if (len % 2 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            }
            for (var i = 0; i < len; i += 2) {
              swap(this, i, i + 1);
            }
            return this;
          };
          Buffer.prototype.swap32 = function swap32() {
            var len = this.length;
            if (len % 4 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            }
            for (var i = 0; i < len; i += 4) {
              swap(this, i, i + 3);
              swap(this, i + 1, i + 2);
            }
            return this;
          };
          Buffer.prototype.swap64 = function swap64() {
            var len = this.length;
            if (len % 8 !== 0) {
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            }
            for (var i = 0; i < len; i += 8) {
              swap(this, i, i + 7);
              swap(this, i + 1, i + 6);
              swap(this, i + 2, i + 5);
              swap(this, i + 3, i + 4);
            }
            return this;
          };
          Buffer.prototype.toString = function toString() {
            var length = this.length;
            if (length === 0)
              return "";
            if (arguments.length === 0)
              return utf8Slice(this, 0, length);
            return slowToString.apply(this, arguments);
          };
          Buffer.prototype.toLocaleString = Buffer.prototype.toString;
          Buffer.prototype.equals = function equals(b) {
            if (!Buffer.isBuffer(b))
              throw new TypeError("Argument must be a Buffer");
            if (this === b)
              return true;
            return Buffer.compare(this, b) === 0;
          };
          Buffer.prototype.inspect = function inspect() {
            var str = "";
            var max = exports3.INSPECT_MAX_BYTES;
            str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
            if (this.length > max)
              str += " ... ";
            return "<Buffer " + str + ">";
          };
          if (customInspectSymbol) {
            Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
          }
          Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
            if (isInstance(target, Uint8Array)) {
              target = Buffer.from(target, target.offset, target.byteLength);
            }
            if (!Buffer.isBuffer(target)) {
              throw new TypeError(
                'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
              );
            }
            if (start === void 0) {
              start = 0;
            }
            if (end === void 0) {
              end = target ? target.length : 0;
            }
            if (thisStart === void 0) {
              thisStart = 0;
            }
            if (thisEnd === void 0) {
              thisEnd = this.length;
            }
            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
              throw new RangeError("out of range index");
            }
            if (thisStart >= thisEnd && start >= end) {
              return 0;
            }
            if (thisStart >= thisEnd) {
              return -1;
            }
            if (start >= end) {
              return 1;
            }
            start >>>= 0;
            end >>>= 0;
            thisStart >>>= 0;
            thisEnd >>>= 0;
            if (this === target)
              return 0;
            var x = thisEnd - thisStart;
            var y = end - start;
            var len = Math.min(x, y);
            var thisCopy = this.slice(thisStart, thisEnd);
            var targetCopy = target.slice(start, end);
            for (var i = 0; i < len; ++i) {
              if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i];
                y = targetCopy[i];
                break;
              }
            }
            if (x < y)
              return -1;
            if (y < x)
              return 1;
            return 0;
          };
          function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
            if (buffer.length === 0)
              return -1;
            if (typeof byteOffset === "string") {
              encoding = byteOffset;
              byteOffset = 0;
            } else if (byteOffset > 2147483647) {
              byteOffset = 2147483647;
            } else if (byteOffset < -2147483648) {
              byteOffset = -2147483648;
            }
            byteOffset = +byteOffset;
            if (numberIsNaN(byteOffset)) {
              byteOffset = dir ? 0 : buffer.length - 1;
            }
            if (byteOffset < 0)
              byteOffset = buffer.length + byteOffset;
            if (byteOffset >= buffer.length) {
              if (dir)
                return -1;
              else
                byteOffset = buffer.length - 1;
            } else if (byteOffset < 0) {
              if (dir)
                byteOffset = 0;
              else
                return -1;
            }
            if (typeof val === "string") {
              val = Buffer.from(val, encoding);
            }
            if (Buffer.isBuffer(val)) {
              if (val.length === 0) {
                return -1;
              }
              return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            } else if (typeof val === "number") {
              val = val & 255;
              if (typeof Uint8Array.prototype.indexOf === "function") {
                if (dir) {
                  return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                } else {
                  return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                }
              }
              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
            }
            throw new TypeError("val must be string, number or Buffer");
          }
          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            var indexSize = 1;
            var arrLength = arr.length;
            var valLength = val.length;
            if (encoding !== void 0) {
              encoding = String(encoding).toLowerCase();
              if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                if (arr.length < 2 || val.length < 2) {
                  return -1;
                }
                indexSize = 2;
                arrLength /= 2;
                valLength /= 2;
                byteOffset /= 2;
              }
            }
            function read(buf, i2) {
              if (indexSize === 1) {
                return buf[i2];
              } else {
                return buf.readUInt16BE(i2 * indexSize);
              }
            }
            var i;
            if (dir) {
              var foundIndex = -1;
              for (i = byteOffset; i < arrLength; i++) {
                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                  if (foundIndex === -1)
                    foundIndex = i;
                  if (i - foundIndex + 1 === valLength)
                    return foundIndex * indexSize;
                } else {
                  if (foundIndex !== -1)
                    i -= i - foundIndex;
                  foundIndex = -1;
                }
              }
            } else {
              if (byteOffset + valLength > arrLength)
                byteOffset = arrLength - valLength;
              for (i = byteOffset; i >= 0; i--) {
                var found = true;
                for (var j = 0; j < valLength; j++) {
                  if (read(arr, i + j) !== read(val, j)) {
                    found = false;
                    break;
                  }
                }
                if (found)
                  return i;
              }
            }
            return -1;
          }
          Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1;
          };
          Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
          };
          Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
          };
          function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            if (!length) {
              length = remaining;
            } else {
              length = Number(length);
              if (length > remaining) {
                length = remaining;
              }
            }
            var strLen = string.length;
            if (length > strLen / 2) {
              length = strLen / 2;
            }
            for (var i = 0; i < length; ++i) {
              var parsed = parseInt(string.substr(i * 2, 2), 16);
              if (numberIsNaN(parsed))
                return i;
              buf[offset + i] = parsed;
            }
            return i;
          }
          function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
          }
          function asciiWrite(buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length);
          }
          function latin1Write(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
          }
          function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
          }
          function ucs2Write(buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
          }
          Buffer.prototype.write = function write(string, offset, length, encoding) {
            if (offset === void 0) {
              encoding = "utf8";
              length = this.length;
              offset = 0;
            } else if (length === void 0 && typeof offset === "string") {
              encoding = offset;
              length = this.length;
              offset = 0;
            } else if (isFinite(offset)) {
              offset = offset >>> 0;
              if (isFinite(length)) {
                length = length >>> 0;
                if (encoding === void 0)
                  encoding = "utf8";
              } else {
                encoding = length;
                length = void 0;
              }
            } else {
              throw new Error(
                "Buffer.write(string, encoding, offset[, length]) is no longer supported"
              );
            }
            var remaining = this.length - offset;
            if (length === void 0 || length > remaining)
              length = remaining;
            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
              throw new RangeError("Attempt to write outside buffer bounds");
            }
            if (!encoding)
              encoding = "utf8";
            var loweredCase = false;
            for (; ; ) {
              switch (encoding) {
                case "hex":
                  return hexWrite(this, string, offset, length);
                case "utf8":
                case "utf-8":
                  return utf8Write(this, string, offset, length);
                case "ascii":
                  return asciiWrite(this, string, offset, length);
                case "latin1":
                case "binary":
                  return latin1Write(this, string, offset, length);
                case "base64":
                  return base64Write(this, string, offset, length);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return ucs2Write(this, string, offset, length);
                default:
                  if (loweredCase)
                    throw new TypeError("Unknown encoding: " + encoding);
                  encoding = ("" + encoding).toLowerCase();
                  loweredCase = true;
              }
            }
          };
          Buffer.prototype.toJSON = function toJSON() {
            return {
              type: "Buffer",
              data: Array.prototype.slice.call(this._arr || this, 0)
            };
          };
          function base64Slice(buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf);
            } else {
              return base64.fromByteArray(buf.slice(start, end));
            }
          }
          function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            var res = [];
            var i = start;
            while (i < end) {
              var firstByte = buf[i];
              var codePoint = null;
              var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
              if (i + bytesPerSequence <= end) {
                var secondByte, thirdByte, fourthByte, tempCodePoint;
                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 128) {
                      codePoint = firstByte;
                    }
                    break;
                  case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                      tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                      if (tempCodePoint > 127) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                      tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                      if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                        codePoint = tempCodePoint;
                      }
                    }
                    break;
                  case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                      tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                      if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                        codePoint = tempCodePoint;
                      }
                    }
                }
              }
              if (codePoint === null) {
                codePoint = 65533;
                bytesPerSequence = 1;
              } else if (codePoint > 65535) {
                codePoint -= 65536;
                res.push(codePoint >>> 10 & 1023 | 55296);
                codePoint = 56320 | codePoint & 1023;
              }
              res.push(codePoint);
              i += bytesPerSequence;
            }
            return decodeCodePointsArray(res);
          }
          var MAX_ARGUMENTS_LENGTH = 4096;
          function decodeCodePointsArray(codePoints) {
            var len = codePoints.length;
            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints);
            }
            var res = "";
            var i = 0;
            while (i < len) {
              res += String.fromCharCode.apply(
                String,
                codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
              );
            }
            return res;
          }
          function asciiSlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i] & 127);
            }
            return ret;
          }
          function latin1Slice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i]);
            }
            return ret;
          }
          function hexSlice(buf, start, end) {
            var len = buf.length;
            if (!start || start < 0)
              start = 0;
            if (!end || end < 0 || end > len)
              end = len;
            var out = "";
            for (var i = start; i < end; ++i) {
              out += hexSliceLookupTable[buf[i]];
            }
            return out;
          }
          function utf16leSlice(buf, start, end) {
            var bytes = buf.slice(start, end);
            var res = "";
            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
            }
            return res;
          }
          Buffer.prototype.slice = function slice(start, end) {
            var len = this.length;
            start = ~~start;
            end = end === void 0 ? len : ~~end;
            if (start < 0) {
              start += len;
              if (start < 0)
                start = 0;
            } else if (start > len) {
              start = len;
            }
            if (end < 0) {
              end += len;
              if (end < 0)
                end = 0;
            } else if (end > len) {
              end = len;
            }
            if (end < start)
              end = start;
            var newBuf = this.subarray(start, end);
            Object.setPrototypeOf(newBuf, Buffer.prototype);
            return newBuf;
          };
          function checkOffset(offset, ext, length) {
            if (offset % 1 !== 0 || offset < 0)
              throw new RangeError("offset is not uint");
            if (offset + ext > length)
              throw new RangeError("Trying to access beyond buffer length");
          }
          Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert)
              checkOffset(offset, byteLength2, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength2 && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            return val;
          };
          Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) {
              checkOffset(offset, byteLength2, this.length);
            }
            var val = this[offset + --byteLength2];
            var mul = 1;
            while (byteLength2 > 0 && (mul *= 256)) {
              val += this[offset + --byteLength2] * mul;
            }
            return val;
          };
          Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 1, this.length);
            return this[offset];
          };
          Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            return this[offset] | this[offset + 1] << 8;
          };
          Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            return this[offset] << 8 | this[offset + 1];
          };
          Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
          };
          Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
          };
          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert)
              checkOffset(offset, byteLength2, this.length);
            var val = this[offset];
            var mul = 1;
            var i = 0;
            while (++i < byteLength2 && (mul *= 256)) {
              val += this[offset + i] * mul;
            }
            mul *= 128;
            if (val >= mul)
              val -= Math.pow(2, 8 * byteLength2);
            return val;
          };
          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert)
              checkOffset(offset, byteLength2, this.length);
            var i = byteLength2;
            var mul = 1;
            var val = this[offset + --i];
            while (i > 0 && (mul *= 256)) {
              val += this[offset + --i] * mul;
            }
            mul *= 128;
            if (val >= mul)
              val -= Math.pow(2, 8 * byteLength2);
            return val;
          };
          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 1, this.length);
            if (!(this[offset] & 128))
              return this[offset];
            return (255 - this[offset] + 1) * -1;
          };
          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return val & 32768 ? val | 4294901760 : val;
          };
          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
          };
          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
          };
          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, true, 23, 4);
          };
          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 4, this.length);
            return ieee754.read(this, offset, false, 23, 4);
          };
          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, true, 52, 8);
          };
          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
            offset = offset >>> 0;
            if (!noAssert)
              checkOffset(offset, 8, this.length);
            return ieee754.read(this, offset, false, 52, 8);
          };
          function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf))
              throw new TypeError('"buffer" argument must be a Buffer instance');
            if (value > max || value < min)
              throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length)
              throw new RangeError("Index out of range");
          }
          Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
              checkInt(this, value, offset, byteLength2, maxBytes, 0);
            }
            var mul = 1;
            var i = 0;
            this[offset] = value & 255;
            while (++i < byteLength2 && (mul *= 256)) {
              this[offset + i] = value / mul & 255;
            }
            return offset + byteLength2;
          };
          Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            byteLength2 = byteLength2 >>> 0;
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
              checkInt(this, value, offset, byteLength2, maxBytes, 0);
            }
            var i = byteLength2 - 1;
            var mul = 1;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              this[offset + i] = value / mul & 255;
            }
            return offset + byteLength2;
          };
          Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 1, 255, 0);
            this[offset] = value & 255;
            return offset + 1;
          };
          Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 65535, 0);
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };
          Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 65535, 0);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255;
            return offset + 2;
          };
          Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 4294967295, 0);
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 255;
            return offset + 4;
          };
          Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 4294967295, 0);
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255;
            return offset + 4;
          };
          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength2 - 1);
              checkInt(this, value, offset, byteLength2, limit - 1, -limit);
            }
            var i = 0;
            var mul = 1;
            var sub = 0;
            this[offset] = value & 255;
            while (++i < byteLength2 && (mul *= 256)) {
              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength2;
          };
          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength2 - 1);
              checkInt(this, value, offset, byteLength2, limit - 1, -limit);
            }
            var i = byteLength2 - 1;
            var mul = 1;
            var sub = 0;
            this[offset + i] = value & 255;
            while (--i >= 0 && (mul *= 256)) {
              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                sub = 1;
              }
              this[offset + i] = (value / mul >> 0) - sub & 255;
            }
            return offset + byteLength2;
          };
          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 1, 127, -128);
            if (value < 0)
              value = 255 + value + 1;
            this[offset] = value & 255;
            return offset + 1;
          };
          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 32767, -32768);
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            return offset + 2;
          };
          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 2, 32767, -32768);
            this[offset] = value >>> 8;
            this[offset + 1] = value & 255;
            return offset + 2;
          };
          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 2147483647, -2147483648);
            this[offset] = value & 255;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
            return offset + 4;
          };
          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert)
              checkInt(this, value, offset, 4, 2147483647, -2147483648);
            if (value < 0)
              value = 4294967295 + value + 1;
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 255;
            return offset + 4;
          };
          function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length)
              throw new RangeError("Index out of range");
            if (offset < 0)
              throw new RangeError("Index out of range");
          }
          function writeFloat(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4);
            return offset + 4;
          }
          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert);
          };
          function writeDouble(buf, value, offset, littleEndian, noAssert) {
            value = +value;
            offset = offset >>> 0;
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8);
            return offset + 8;
          }
          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert);
          };
          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert);
          };
          Buffer.prototype.copy = function copy(target, targetStart, start, end) {
            if (!Buffer.isBuffer(target))
              throw new TypeError("argument should be a Buffer");
            if (!start)
              start = 0;
            if (!end && end !== 0)
              end = this.length;
            if (targetStart >= target.length)
              targetStart = target.length;
            if (!targetStart)
              targetStart = 0;
            if (end > 0 && end < start)
              end = start;
            if (end === start)
              return 0;
            if (target.length === 0 || this.length === 0)
              return 0;
            if (targetStart < 0) {
              throw new RangeError("targetStart out of bounds");
            }
            if (start < 0 || start >= this.length)
              throw new RangeError("Index out of range");
            if (end < 0)
              throw new RangeError("sourceEnd out of bounds");
            if (end > this.length)
              end = this.length;
            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start;
            }
            var len = end - start;
            if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
              this.copyWithin(targetStart, start, end);
            } else if (this === target && start < targetStart && targetStart < end) {
              for (var i = len - 1; i >= 0; --i) {
                target[i + targetStart] = this[i + start];
              }
            } else {
              Uint8Array.prototype.set.call(
                target,
                this.subarray(start, end),
                targetStart
              );
            }
            return len;
          };
          Buffer.prototype.fill = function fill(val, start, end, encoding) {
            if (typeof val === "string") {
              if (typeof start === "string") {
                encoding = start;
                start = 0;
                end = this.length;
              } else if (typeof end === "string") {
                encoding = end;
                end = this.length;
              }
              if (encoding !== void 0 && typeof encoding !== "string") {
                throw new TypeError("encoding must be a string");
              }
              if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
                throw new TypeError("Unknown encoding: " + encoding);
              }
              if (val.length === 1) {
                var code = val.charCodeAt(0);
                if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                  val = code;
                }
              }
            } else if (typeof val === "number") {
              val = val & 255;
            } else if (typeof val === "boolean") {
              val = Number(val);
            }
            if (start < 0 || this.length < start || this.length < end) {
              throw new RangeError("Out of range index");
            }
            if (end <= start) {
              return this;
            }
            start = start >>> 0;
            end = end === void 0 ? this.length : end >>> 0;
            if (!val)
              val = 0;
            var i;
            if (typeof val === "number") {
              for (i = start; i < end; ++i) {
                this[i] = val;
              }
            } else {
              var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
              var len = bytes.length;
              if (len === 0) {
                throw new TypeError('The value "' + val + '" is invalid for argument "value"');
              }
              for (i = 0; i < end - start; ++i) {
                this[i + start] = bytes[i % len];
              }
            }
            return this;
          };
          var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
          function base64clean(str) {
            str = str.split("=")[0];
            str = str.trim().replace(INVALID_BASE64_RE, "");
            if (str.length < 2)
              return "";
            while (str.length % 4 !== 0) {
              str = str + "=";
            }
            return str;
          }
          function utf8ToBytes(string, units) {
            units = units || Infinity;
            var codePoint;
            var length = string.length;
            var leadSurrogate = null;
            var bytes = [];
            for (var i = 0; i < length; ++i) {
              codePoint = string.charCodeAt(i);
              if (codePoint > 55295 && codePoint < 57344) {
                if (!leadSurrogate) {
                  if (codePoint > 56319) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    continue;
                  } else if (i + 1 === length) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                    continue;
                  }
                  leadSurrogate = codePoint;
                  continue;
                }
                if (codePoint < 56320) {
                  if ((units -= 3) > -1)
                    bytes.push(239, 191, 189);
                  leadSurrogate = codePoint;
                  continue;
                }
                codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
              } else if (leadSurrogate) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
              }
              leadSurrogate = null;
              if (codePoint < 128) {
                if ((units -= 1) < 0)
                  break;
                bytes.push(codePoint);
              } else if (codePoint < 2048) {
                if ((units -= 2) < 0)
                  break;
                bytes.push(
                  codePoint >> 6 | 192,
                  codePoint & 63 | 128
                );
              } else if (codePoint < 65536) {
                if ((units -= 3) < 0)
                  break;
                bytes.push(
                  codePoint >> 12 | 224,
                  codePoint >> 6 & 63 | 128,
                  codePoint & 63 | 128
                );
              } else if (codePoint < 1114112) {
                if ((units -= 4) < 0)
                  break;
                bytes.push(
                  codePoint >> 18 | 240,
                  codePoint >> 12 & 63 | 128,
                  codePoint >> 6 & 63 | 128,
                  codePoint & 63 | 128
                );
              } else {
                throw new Error("Invalid code point");
              }
            }
            return bytes;
          }
          function asciiToBytes(str) {
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              byteArray.push(str.charCodeAt(i) & 255);
            }
            return byteArray;
          }
          function utf16leToBytes(str, units) {
            var c, hi, lo;
            var byteArray = [];
            for (var i = 0; i < str.length; ++i) {
              if ((units -= 2) < 0)
                break;
              c = str.charCodeAt(i);
              hi = c >> 8;
              lo = c % 256;
              byteArray.push(lo);
              byteArray.push(hi);
            }
            return byteArray;
          }
          function base64ToBytes(str) {
            return base64.toByteArray(base64clean(str));
          }
          function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length; ++i) {
              if (i + offset >= dst.length || i >= src.length)
                break;
              dst[i + offset] = src[i];
            }
            return i;
          }
          function isInstance(obj, type) {
            return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
          }
          function numberIsNaN(obj) {
            return obj !== obj;
          }
          var hexSliceLookupTable = function() {
            var alphabet = "0123456789abcdef";
            var table = new Array(256);
            for (var i = 0; i < 16; ++i) {
              var i16 = i * 16;
              for (var j = 0; j < 16; ++j) {
                table[i16 + j] = alphabet[i] + alphabet[j];
              }
            }
            return table;
          }();
        }).call(this, require2("buffer").Buffer);
      }, { "base64-js": 29, "buffer": 48, "ieee754": 73 }], 49: [function(require2, module3, exports3) {
        var Buffer = require2("buffer").Buffer;
        module3.exports = function(a, b) {
          if (!Buffer.isBuffer(a))
            return void 0;
          if (!Buffer.isBuffer(b))
            return void 0;
          if (typeof a.equals === "function")
            return a.equals(b);
          if (a.length !== b.length)
            return false;
          for (var i = 0; i < a.length; i++) {
            if (a[i] !== b[i])
              return false;
          }
          return true;
        };
      }, { "buffer": 48 }], 50: [function(require2, module3, exports3) {
        module3.exports = {
          "100": "Continue",
          "101": "Switching Protocols",
          "102": "Processing",
          "200": "OK",
          "201": "Created",
          "202": "Accepted",
          "203": "Non-Authoritative Information",
          "204": "No Content",
          "205": "Reset Content",
          "206": "Partial Content",
          "207": "Multi-Status",
          "208": "Already Reported",
          "226": "IM Used",
          "300": "Multiple Choices",
          "301": "Moved Permanently",
          "302": "Found",
          "303": "See Other",
          "304": "Not Modified",
          "305": "Use Proxy",
          "307": "Temporary Redirect",
          "308": "Permanent Redirect",
          "400": "Bad Request",
          "401": "Unauthorized",
          "402": "Payment Required",
          "403": "Forbidden",
          "404": "Not Found",
          "405": "Method Not Allowed",
          "406": "Not Acceptable",
          "407": "Proxy Authentication Required",
          "408": "Request Timeout",
          "409": "Conflict",
          "410": "Gone",
          "411": "Length Required",
          "412": "Precondition Failed",
          "413": "Payload Too Large",
          "414": "URI Too Long",
          "415": "Unsupported Media Type",
          "416": "Range Not Satisfiable",
          "417": "Expectation Failed",
          "418": "I'm a teapot",
          "421": "Misdirected Request",
          "422": "Unprocessable Entity",
          "423": "Locked",
          "424": "Failed Dependency",
          "425": "Unordered Collection",
          "426": "Upgrade Required",
          "428": "Precondition Required",
          "429": "Too Many Requests",
          "431": "Request Header Fields Too Large",
          "451": "Unavailable For Legal Reasons",
          "500": "Internal Server Error",
          "501": "Not Implemented",
          "502": "Bad Gateway",
          "503": "Service Unavailable",
          "504": "Gateway Timeout",
          "505": "HTTP Version Not Supported",
          "506": "Variant Also Negotiates",
          "507": "Insufficient Storage",
          "508": "Loop Detected",
          "509": "Bandwidth Limit Exceeded",
          "510": "Not Extended",
          "511": "Network Authentication Required"
        };
      }, {}], 51: [function(require2, module3, exports3) {
        (function(Buffer) {
          function isArray(arg) {
            if (Array.isArray) {
              return Array.isArray(arg);
            }
            return objectToString(arg) === "[object Array]";
          }
          exports3.isArray = isArray;
          function isBoolean(arg) {
            return typeof arg === "boolean";
          }
          exports3.isBoolean = isBoolean;
          function isNull(arg) {
            return arg === null;
          }
          exports3.isNull = isNull;
          function isNullOrUndefined(arg) {
            return arg == null;
          }
          exports3.isNullOrUndefined = isNullOrUndefined;
          function isNumber(arg) {
            return typeof arg === "number";
          }
          exports3.isNumber = isNumber;
          function isString(arg) {
            return typeof arg === "string";
          }
          exports3.isString = isString;
          function isSymbol(arg) {
            return typeof arg === "symbol";
          }
          exports3.isSymbol = isSymbol;
          function isUndefined(arg) {
            return arg === void 0;
          }
          exports3.isUndefined = isUndefined;
          function isRegExp(re) {
            return objectToString(re) === "[object RegExp]";
          }
          exports3.isRegExp = isRegExp;
          function isObject(arg) {
            return typeof arg === "object" && arg !== null;
          }
          exports3.isObject = isObject;
          function isDate(d) {
            return objectToString(d) === "[object Date]";
          }
          exports3.isDate = isDate;
          function isError(e) {
            return objectToString(e) === "[object Error]" || e instanceof Error;
          }
          exports3.isError = isError;
          function isFunction(arg) {
            return typeof arg === "function";
          }
          exports3.isFunction = isFunction;
          function isPrimitive(arg) {
            return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
            typeof arg === "undefined";
          }
          exports3.isPrimitive = isPrimitive;
          exports3.isBuffer = Buffer.isBuffer;
          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }
        }).call(this, { "isBuffer": require2("../../is-buffer/index.js") });
      }, { "../../is-buffer/index.js": 76 }], 52: [function(require2, module3, exports3) {
        var objectCreate = Object.create || objectCreatePolyfill;
        var objectKeys = Object.keys || objectKeysPolyfill;
        var bind = Function.prototype.bind || functionBindPolyfill;
        function EventEmitter() {
          if (!this._events || !Object.prototype.hasOwnProperty.call(this, "_events")) {
            this._events = objectCreate(null);
            this._eventsCount = 0;
          }
          this._maxListeners = this._maxListeners || void 0;
        }
        module3.exports = EventEmitter;
        EventEmitter.EventEmitter = EventEmitter;
        EventEmitter.prototype._events = void 0;
        EventEmitter.prototype._maxListeners = void 0;
        var defaultMaxListeners = 10;
        var hasDefineProperty;
        try {
          var o = {};
          if (Object.defineProperty)
            Object.defineProperty(o, "x", { value: 0 });
          hasDefineProperty = o.x === 0;
        } catch (err) {
          hasDefineProperty = false;
        }
        if (hasDefineProperty) {
          Object.defineProperty(EventEmitter, "defaultMaxListeners", {
            enumerable: true,
            get: function() {
              return defaultMaxListeners;
            },
            set: function(arg) {
              if (typeof arg !== "number" || arg < 0 || arg !== arg)
                throw new TypeError('"defaultMaxListeners" must be a positive number');
              defaultMaxListeners = arg;
            }
          });
        } else {
          EventEmitter.defaultMaxListeners = defaultMaxListeners;
        }
        EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
          if (typeof n !== "number" || n < 0 || isNaN(n))
            throw new TypeError('"n" argument must be a positive number');
          this._maxListeners = n;
          return this;
        };
        function $getMaxListeners(that) {
          if (that._maxListeners === void 0)
            return EventEmitter.defaultMaxListeners;
          return that._maxListeners;
        }
        EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
          return $getMaxListeners(this);
        };
        function emitNone(handler, isFn, self2) {
          if (isFn)
            handler.call(self2);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i)
              listeners[i].call(self2);
          }
        }
        function emitOne(handler, isFn, self2, arg1) {
          if (isFn)
            handler.call(self2, arg1);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i)
              listeners[i].call(self2, arg1);
          }
        }
        function emitTwo(handler, isFn, self2, arg1, arg2) {
          if (isFn)
            handler.call(self2, arg1, arg2);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i)
              listeners[i].call(self2, arg1, arg2);
          }
        }
        function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
          if (isFn)
            handler.call(self2, arg1, arg2, arg3);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i)
              listeners[i].call(self2, arg1, arg2, arg3);
          }
        }
        function emitMany(handler, isFn, self2, args) {
          if (isFn)
            handler.apply(self2, args);
          else {
            var len = handler.length;
            var listeners = arrayClone(handler, len);
            for (var i = 0; i < len; ++i)
              listeners[i].apply(self2, args);
          }
        }
        EventEmitter.prototype.emit = function emit(type) {
          var er, handler, len, args, i, events;
          var doError = type === "error";
          events = this._events;
          if (events)
            doError = doError && events.error == null;
          else if (!doError)
            return false;
          if (doError) {
            if (arguments.length > 1)
              er = arguments[1];
            if (er instanceof Error) {
              throw er;
            } else {
              var err = new Error('Unhandled "error" event. (' + er + ")");
              err.context = er;
              throw err;
            }
            return false;
          }
          handler = events[type];
          if (!handler)
            return false;
          var isFn = typeof handler === "function";
          len = arguments.length;
          switch (len) {
            case 1:
              emitNone(handler, isFn, this);
              break;
            case 2:
              emitOne(handler, isFn, this, arguments[1]);
              break;
            case 3:
              emitTwo(handler, isFn, this, arguments[1], arguments[2]);
              break;
            case 4:
              emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
              break;
            default:
              args = new Array(len - 1);
              for (i = 1; i < len; i++)
                args[i - 1] = arguments[i];
              emitMany(handler, isFn, this, args);
          }
          return true;
        };
        function _addListener(target, type, listener, prepend) {
          var m;
          var events;
          var existing;
          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function');
          events = target._events;
          if (!events) {
            events = target._events = objectCreate(null);
            target._eventsCount = 0;
          } else {
            if (events.newListener) {
              target.emit(
                "newListener",
                type,
                listener.listener ? listener.listener : listener
              );
              events = target._events;
            }
            existing = events[type];
          }
          if (!existing) {
            existing = events[type] = listener;
            ++target._eventsCount;
          } else {
            if (typeof existing === "function") {
              existing = events[type] = prepend ? [listener, existing] : [existing, listener];
            } else {
              if (prepend) {
                existing.unshift(listener);
              } else {
                existing.push(listener);
              }
            }
            if (!existing.warned) {
              m = $getMaxListeners(target);
              if (m && m > 0 && existing.length > m) {
                existing.warned = true;
                var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + ' "' + String(type) + '" listeners added. Use emitter.setMaxListeners() to increase limit.');
                w.name = "MaxListenersExceededWarning";
                w.emitter = target;
                w.type = type;
                w.count = existing.length;
                if (typeof console === "object" && console.warn) {
                  console.warn("%s: %s", w.name, w.message);
                }
              }
            }
          }
          return target;
        }
        EventEmitter.prototype.addListener = function addListener(type, listener) {
          return _addListener(this, type, listener, false);
        };
        EventEmitter.prototype.on = EventEmitter.prototype.addListener;
        EventEmitter.prototype.prependListener = function prependListener(type, listener) {
          return _addListener(this, type, listener, true);
        };
        function onceWrapper() {
          if (!this.fired) {
            this.target.removeListener(this.type, this.wrapFn);
            this.fired = true;
            switch (arguments.length) {
              case 0:
                return this.listener.call(this.target);
              case 1:
                return this.listener.call(this.target, arguments[0]);
              case 2:
                return this.listener.call(this.target, arguments[0], arguments[1]);
              case 3:
                return this.listener.call(
                  this.target,
                  arguments[0],
                  arguments[1],
                  arguments[2]
                );
              default:
                var args = new Array(arguments.length);
                for (var i = 0; i < args.length; ++i)
                  args[i] = arguments[i];
                this.listener.apply(this.target, args);
            }
          }
        }
        function _onceWrap(target, type, listener) {
          var state = { fired: false, wrapFn: void 0, target, type, listener };
          var wrapped = bind.call(onceWrapper, state);
          wrapped.listener = listener;
          state.wrapFn = wrapped;
          return wrapped;
        }
        EventEmitter.prototype.once = function once(type, listener) {
          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function');
          this.on(type, _onceWrap(this, type, listener));
          return this;
        };
        EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function');
          this.prependListener(type, _onceWrap(this, type, listener));
          return this;
        };
        EventEmitter.prototype.removeListener = function removeListener(type, listener) {
          var list, events, position, i, originalListener;
          if (typeof listener !== "function")
            throw new TypeError('"listener" argument must be a function');
          events = this._events;
          if (!events)
            return this;
          list = events[type];
          if (!list)
            return this;
          if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0)
              this._events = objectCreate(null);
            else {
              delete events[type];
              if (events.removeListener)
                this.emit("removeListener", type, list.listener || listener);
            }
          } else if (typeof list !== "function") {
            position = -1;
            for (i = list.length - 1; i >= 0; i--) {
              if (list[i] === listener || list[i].listener === listener) {
                originalListener = list[i].listener;
                position = i;
                break;
              }
            }
            if (position < 0)
              return this;
            if (position === 0)
              list.shift();
            else
              spliceOne(list, position);
            if (list.length === 1)
              events[type] = list[0];
            if (events.removeListener)
              this.emit("removeListener", type, originalListener || listener);
          }
          return this;
        };
        EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
          var listeners, events, i;
          events = this._events;
          if (!events)
            return this;
          if (!events.removeListener) {
            if (arguments.length === 0) {
              this._events = objectCreate(null);
              this._eventsCount = 0;
            } else if (events[type]) {
              if (--this._eventsCount === 0)
                this._events = objectCreate(null);
              else
                delete events[type];
            }
            return this;
          }
          if (arguments.length === 0) {
            var keys = objectKeys(events);
            var key;
            for (i = 0; i < keys.length; ++i) {
              key = keys[i];
              if (key === "removeListener")
                continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners("removeListener");
            this._events = objectCreate(null);
            this._eventsCount = 0;
            return this;
          }
          listeners = events[type];
          if (typeof listeners === "function") {
            this.removeListener(type, listeners);
          } else if (listeners) {
            for (i = listeners.length - 1; i >= 0; i--) {
              this.removeListener(type, listeners[i]);
            }
          }
          return this;
        };
        function _listeners(target, type, unwrap) {
          var events = target._events;
          if (!events)
            return [];
          var evlistener = events[type];
          if (!evlistener)
            return [];
          if (typeof evlistener === "function")
            return unwrap ? [evlistener.listener || evlistener] : [evlistener];
          return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
        }
        EventEmitter.prototype.listeners = function listeners(type) {
          return _listeners(this, type, true);
        };
        EventEmitter.prototype.rawListeners = function rawListeners(type) {
          return _listeners(this, type, false);
        };
        EventEmitter.listenerCount = function(emitter, type) {
          if (typeof emitter.listenerCount === "function") {
            return emitter.listenerCount(type);
          } else {
            return listenerCount.call(emitter, type);
          }
        };
        EventEmitter.prototype.listenerCount = listenerCount;
        function listenerCount(type) {
          var events = this._events;
          if (events) {
            var evlistener = events[type];
            if (typeof evlistener === "function") {
              return 1;
            } else if (evlistener) {
              return evlistener.length;
            }
          }
          return 0;
        }
        EventEmitter.prototype.eventNames = function eventNames() {
          return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
        };
        function spliceOne(list, index) {
          for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
            list[i] = list[k];
          list.pop();
        }
        function arrayClone(arr, n) {
          var copy = new Array(n);
          for (var i = 0; i < n; ++i)
            copy[i] = arr[i];
          return copy;
        }
        function unwrapListeners(arr) {
          var ret = new Array(arr.length);
          for (var i = 0; i < ret.length; ++i) {
            ret[i] = arr[i].listener || arr[i];
          }
          return ret;
        }
        function objectCreatePolyfill(proto) {
          var F = function() {
          };
          F.prototype = proto;
          return new F();
        }
        function objectKeysPolyfill(obj) {
          var keys = [];
          for (var k in obj)
            if (Object.prototype.hasOwnProperty.call(obj, k)) {
              keys.push(k);
            }
          return k;
        }
        function functionBindPolyfill(context) {
          var fn = this;
          return function() {
            return fn.apply(context, arguments);
          };
        }
      }, {}], 53: [function(require2, module3, exports3) {
        var Parser = require2("./lib/parser");
        function getGlobal() {
          return (1, eval)("this");
        }
        module3.exports = {
          create: function(buffer, global2) {
            global2 = global2 || getGlobal();
            if (buffer instanceof global2.ArrayBuffer) {
              var DOMBufferStream = require2("./lib/dom-bufferstream");
              return new Parser(new DOMBufferStream(buffer, 0, buffer.byteLength, true, global2));
            } else {
              var NodeBufferStream = require2("./lib/bufferstream");
              return new Parser(new NodeBufferStream(buffer, 0, buffer.length, true));
            }
          }
        };
      }, { "./lib/bufferstream": 54, "./lib/dom-bufferstream": 56, "./lib/parser": 60 }], 54: [function(require2, module3, exports3) {
        function BufferStream(buffer, offset, length, bigEndian) {
          this.buffer = buffer;
          this.offset = offset || 0;
          length = typeof length === "number" ? length : buffer.length;
          this.endPosition = this.offset + length;
          this.setBigEndian(bigEndian);
        }
        BufferStream.prototype = {
          setBigEndian: function(bigEndian) {
            this.bigEndian = !!bigEndian;
          },
          nextUInt8: function() {
            var value = this.buffer.readUInt8(this.offset);
            this.offset += 1;
            return value;
          },
          nextInt8: function() {
            var value = this.buffer.readInt8(this.offset);
            this.offset += 1;
            return value;
          },
          nextUInt16: function() {
            var value = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
            this.offset += 2;
            return value;
          },
          nextUInt32: function() {
            var value = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
            this.offset += 4;
            return value;
          },
          nextInt16: function() {
            var value = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
            this.offset += 2;
            return value;
          },
          nextInt32: function() {
            var value = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
            this.offset += 4;
            return value;
          },
          nextFloat: function() {
            var value = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
            this.offset += 4;
            return value;
          },
          nextDouble: function() {
            var value = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
            this.offset += 8;
            return value;
          },
          nextBuffer: function(length) {
            var value = this.buffer.slice(this.offset, this.offset + length);
            this.offset += length;
            return value;
          },
          remainingLength: function() {
            return this.endPosition - this.offset;
          },
          nextString: function(length) {
            var value = this.buffer.toString("utf8", this.offset, this.offset + length);
            this.offset += length;
            return value;
          },
          mark: function() {
            var self2 = this;
            return {
              openWithOffset: function(offset) {
                offset = (offset || 0) + this.offset;
                return new BufferStream(self2.buffer, offset, self2.endPosition - offset, self2.bigEndian);
              },
              offset: this.offset
            };
          },
          offsetFrom: function(marker) {
            return this.offset - marker.offset;
          },
          skip: function(amount) {
            this.offset += amount;
          },
          branch: function(offset, length) {
            length = typeof length === "number" ? length : this.endPosition - (this.offset + offset);
            return new BufferStream(this.buffer, this.offset + offset, length, this.bigEndian);
          }
        };
        module3.exports = BufferStream;
      }, {}], 55: [function(require2, module3, exports3) {
        function parseNumber(s) {
          return parseInt(s, 10);
        }
        var hours = 3600;
        var minutes = 60;
        function parseDateTimeParts(dateParts, timeParts) {
          dateParts = dateParts.map(parseNumber);
          timeParts = timeParts.map(parseNumber);
          var year = dateParts[0];
          var month = dateParts[1] - 1;
          var day = dateParts[2];
          var hours2 = timeParts[0];
          var minutes2 = timeParts[1];
          var seconds = timeParts[2];
          var date = Date.UTC(year, month, day, hours2, minutes2, seconds, 0);
          var timestamp = date / 1e3;
          return timestamp;
        }
        function parseDateWithTimezoneFormat(dateTimeStr) {
          var dateParts = dateTimeStr.substr(0, 10).split("-");
          var timeParts = dateTimeStr.substr(11, 8).split(":");
          var timezoneStr = dateTimeStr.substr(19, 6);
          var timezoneParts = timezoneStr.split(":").map(parseNumber);
          var timezoneOffset = timezoneParts[0] * hours + timezoneParts[1] * minutes;
          var timestamp = parseDateTimeParts(dateParts, timeParts);
          timestamp -= timezoneOffset;
          if (typeof timestamp === "number" && !isNaN(timestamp)) {
            return timestamp;
          }
        }
        function parseDateWithSpecFormat(dateTimeStr) {
          var parts = dateTimeStr.split(" "), dateParts = parts[0].split(":"), timeParts = parts[1].split(":");
          var timestamp = parseDateTimeParts(dateParts, timeParts);
          if (typeof timestamp === "number" && !isNaN(timestamp)) {
            return timestamp;
          }
        }
        function parseExifDate(dateTimeStr) {
          var isSpecFormat = dateTimeStr.length === 19 && dateTimeStr.charAt(4) === ":";
          var isTimezoneFormat = dateTimeStr.length === 25 && dateTimeStr.charAt(10) === "T";
          var timestamp;
          if (isTimezoneFormat) {
            return parseDateWithTimezoneFormat(dateTimeStr);
          } else if (isSpecFormat) {
            return parseDateWithSpecFormat(dateTimeStr);
          }
        }
        module3.exports = {
          parseDateWithSpecFormat,
          parseDateWithTimezoneFormat,
          parseExifDate
        };
      }, {}], 56: [function(require2, module3, exports3) {
        function DOMBufferStream(arrayBuffer, offset, length, bigEndian, global2, parentOffset) {
          this.global = global2;
          offset = offset || 0;
          length = length || arrayBuffer.byteLength - offset;
          this.arrayBuffer = arrayBuffer.slice(offset, offset + length);
          this.view = new global2.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength);
          this.setBigEndian(bigEndian);
          this.offset = 0;
          this.parentOffset = (parentOffset || 0) + offset;
        }
        DOMBufferStream.prototype = {
          setBigEndian: function(bigEndian) {
            this.littleEndian = !bigEndian;
          },
          nextUInt8: function() {
            var value = this.view.getUint8(this.offset);
            this.offset += 1;
            return value;
          },
          nextInt8: function() {
            var value = this.view.getInt8(this.offset);
            this.offset += 1;
            return value;
          },
          nextUInt16: function() {
            var value = this.view.getUint16(this.offset, this.littleEndian);
            this.offset += 2;
            return value;
          },
          nextUInt32: function() {
            var value = this.view.getUint32(this.offset, this.littleEndian);
            this.offset += 4;
            return value;
          },
          nextInt16: function() {
            var value = this.view.getInt16(this.offset, this.littleEndian);
            this.offset += 2;
            return value;
          },
          nextInt32: function() {
            var value = this.view.getInt32(this.offset, this.littleEndian);
            this.offset += 4;
            return value;
          },
          nextFloat: function() {
            var value = this.view.getFloat32(this.offset, this.littleEndian);
            this.offset += 4;
            return value;
          },
          nextDouble: function() {
            var value = this.view.getFloat64(this.offset, this.littleEndian);
            this.offset += 8;
            return value;
          },
          nextBuffer: function(length) {
            var value = this.arrayBuffer.slice(this.offset, this.offset + length);
            this.offset += length;
            return value;
          },
          remainingLength: function() {
            return this.arrayBuffer.byteLength - this.offset;
          },
          nextString: function(length) {
            var value = this.arrayBuffer.slice(this.offset, this.offset + length);
            value = String.fromCharCode.apply(null, new this.global.Uint8Array(value));
            this.offset += length;
            return value;
          },
          mark: function() {
            var self2 = this;
            return {
              openWithOffset: function(offset) {
                offset = (offset || 0) + this.offset;
                return new DOMBufferStream(self2.arrayBuffer, offset, self2.arrayBuffer.byteLength - offset, !self2.littleEndian, self2.global, self2.parentOffset);
              },
              offset: this.offset,
              getParentOffset: function() {
                return self2.parentOffset;
              }
            };
          },
          offsetFrom: function(marker) {
            return this.parentOffset + this.offset - (marker.offset + marker.getParentOffset());
          },
          skip: function(amount) {
            this.offset += amount;
          },
          branch: function(offset, length) {
            length = typeof length === "number" ? length : this.arrayBuffer.byteLength - (this.offset + offset);
            return new DOMBufferStream(this.arrayBuffer, this.offset + offset, length, !this.littleEndian, this.global, this.parentOffset);
          }
        };
        module3.exports = DOMBufferStream;
      }, {}], 57: [function(require2, module3, exports3) {
        module3.exports = {
          exif: {
            1: "InteropIndex",
            2: "InteropVersion",
            11: "ProcessingSoftware",
            254: "SubfileType",
            255: "OldSubfileType",
            256: "ImageWidth",
            257: "ImageHeight",
            258: "BitsPerSample",
            259: "Compression",
            262: "PhotometricInterpretation",
            263: "Thresholding",
            264: "CellWidth",
            265: "CellLength",
            266: "FillOrder",
            269: "DocumentName",
            270: "ImageDescription",
            271: "Make",
            272: "Model",
            273: "StripOffsets",
            274: "Orientation",
            277: "SamplesPerPixel",
            278: "RowsPerStrip",
            279: "StripByteCounts",
            280: "MinSampleValue",
            281: "MaxSampleValue",
            282: "XResolution",
            283: "YResolution",
            284: "PlanarConfiguration",
            285: "PageName",
            286: "XPosition",
            287: "YPosition",
            288: "FreeOffsets",
            289: "FreeByteCounts",
            290: "GrayResponseUnit",
            291: "GrayResponseCurve",
            292: "T4Options",
            293: "T6Options",
            296: "ResolutionUnit",
            297: "PageNumber",
            300: "ColorResponseUnit",
            301: "TransferFunction",
            305: "Software",
            306: "ModifyDate",
            315: "Artist",
            316: "HostComputer",
            317: "Predictor",
            318: "WhitePoint",
            319: "PrimaryChromaticities",
            320: "ColorMap",
            321: "HalftoneHints",
            322: "TileWidth",
            323: "TileLength",
            324: "TileOffsets",
            325: "TileByteCounts",
            326: "BadFaxLines",
            327: "CleanFaxData",
            328: "ConsecutiveBadFaxLines",
            330: "SubIFD",
            332: "InkSet",
            333: "InkNames",
            334: "NumberofInks",
            336: "DotRange",
            337: "TargetPrinter",
            338: "ExtraSamples",
            339: "SampleFormat",
            340: "SMinSampleValue",
            341: "SMaxSampleValue",
            342: "TransferRange",
            343: "ClipPath",
            344: "XClipPathUnits",
            345: "YClipPathUnits",
            346: "Indexed",
            347: "JPEGTables",
            351: "OPIProxy",
            400: "GlobalParametersIFD",
            401: "ProfileType",
            402: "FaxProfile",
            403: "CodingMethods",
            404: "VersionYear",
            405: "ModeNumber",
            433: "Decode",
            434: "DefaultImageColor",
            435: "T82Options",
            437: "JPEGTables",
            512: "JPEGProc",
            513: "ThumbnailOffset",
            514: "ThumbnailLength",
            515: "JPEGRestartInterval",
            517: "JPEGLosslessPredictors",
            518: "JPEGPointTransforms",
            519: "JPEGQTables",
            520: "JPEGDCTables",
            521: "JPEGACTables",
            529: "YCbCrCoefficients",
            530: "YCbCrSubSampling",
            531: "YCbCrPositioning",
            532: "ReferenceBlackWhite",
            559: "StripRowCounts",
            700: "ApplicationNotes",
            999: "USPTOMiscellaneous",
            4096: "RelatedImageFileFormat",
            4097: "RelatedImageWidth",
            4098: "RelatedImageHeight",
            18246: "Rating",
            18247: "XP_DIP_XML",
            18248: "StitchInfo",
            18249: "RatingPercent",
            32781: "ImageID",
            32931: "WangTag1",
            32932: "WangAnnotation",
            32933: "WangTag3",
            32934: "WangTag4",
            32995: "Matteing",
            32996: "DataType",
            32997: "ImageDepth",
            32998: "TileDepth",
            33405: "Model2",
            33421: "CFARepeatPatternDim",
            33422: "CFAPattern2",
            33423: "BatteryLevel",
            33424: "KodakIFD",
            33432: "Copyright",
            33434: "ExposureTime",
            33437: "FNumber",
            33445: "MDFileTag",
            33446: "MDScalePixel",
            33447: "MDColorTable",
            33448: "MDLabName",
            33449: "MDSampleInfo",
            33450: "MDPrepDate",
            33451: "MDPrepTime",
            33452: "MDFileUnits",
            33550: "PixelScale",
            33589: "AdventScale",
            33590: "AdventRevision",
            33628: "UIC1Tag",
            33629: "UIC2Tag",
            33630: "UIC3Tag",
            33631: "UIC4Tag",
            33723: "IPTC-NAA",
            33918: "IntergraphPacketData",
            33919: "IntergraphFlagRegisters",
            33920: "IntergraphMatrix",
            33921: "INGRReserved",
            33922: "ModelTiePoint",
            34016: "Site",
            34017: "ColorSequence",
            34018: "IT8Header",
            34019: "RasterPadding",
            34020: "BitsPerRunLength",
            34021: "BitsPerExtendedRunLength",
            34022: "ColorTable",
            34023: "ImageColorIndicator",
            34024: "BackgroundColorIndicator",
            34025: "ImageColorValue",
            34026: "BackgroundColorValue",
            34027: "PixelIntensityRange",
            34028: "TransparencyIndicator",
            34029: "ColorCharacterization",
            34030: "HCUsage",
            34031: "TrapIndicator",
            34032: "CMYKEquivalent",
            34118: "SEMInfo",
            34152: "AFCP_IPTC",
            34232: "PixelMagicJBIGOptions",
            34264: "ModelTransform",
            34306: "WB_GRGBLevels",
            34310: "LeafData",
            34377: "PhotoshopSettings",
            34665: "ExifOffset",
            34675: "ICC_Profile",
            34687: "TIFF_FXExtensions",
            34688: "MultiProfiles",
            34689: "SharedData",
            34690: "T88Options",
            34732: "ImageLayer",
            34735: "GeoTiffDirectory",
            34736: "GeoTiffDoubleParams",
            34737: "GeoTiffAsciiParams",
            34850: "ExposureProgram",
            34852: "SpectralSensitivity",
            34853: "GPSInfo",
            34855: "ISO",
            34856: "Opto-ElectricConvFactor",
            34857: "Interlace",
            34858: "TimeZoneOffset",
            34859: "SelfTimerMode",
            34864: "SensitivityType",
            34865: "StandardOutputSensitivity",
            34866: "RecommendedExposureIndex",
            34867: "ISOSpeed",
            34868: "ISOSpeedLatitudeyyy",
            34869: "ISOSpeedLatitudezzz",
            34908: "FaxRecvParams",
            34909: "FaxSubAddress",
            34910: "FaxRecvTime",
            34954: "LeafSubIFD",
            36864: "ExifVersion",
            36867: "DateTimeOriginal",
            36868: "CreateDate",
            37121: "ComponentsConfiguration",
            37122: "CompressedBitsPerPixel",
            37377: "ShutterSpeedValue",
            37378: "ApertureValue",
            37379: "BrightnessValue",
            37380: "ExposureCompensation",
            37381: "MaxApertureValue",
            37382: "SubjectDistance",
            37383: "MeteringMode",
            37384: "LightSource",
            37385: "Flash",
            37386: "FocalLength",
            37387: "FlashEnergy",
            37388: "SpatialFrequencyResponse",
            37389: "Noise",
            37390: "FocalPlaneXResolution",
            37391: "FocalPlaneYResolution",
            37392: "FocalPlaneResolutionUnit",
            37393: "ImageNumber",
            37394: "SecurityClassification",
            37395: "ImageHistory",
            37396: "SubjectArea",
            37397: "ExposureIndex",
            37398: "TIFF-EPStandardID",
            37399: "SensingMethod",
            37434: "CIP3DataFile",
            37435: "CIP3Sheet",
            37436: "CIP3Side",
            37439: "StoNits",
            37500: "MakerNote",
            37510: "UserComment",
            37520: "SubSecTime",
            37521: "SubSecTimeOriginal",
            37522: "SubSecTimeDigitized",
            37679: "MSDocumentText",
            37680: "MSPropertySetStorage",
            37681: "MSDocumentTextPosition",
            37724: "ImageSourceData",
            40091: "XPTitle",
            40092: "XPComment",
            40093: "XPAuthor",
            40094: "XPKeywords",
            40095: "XPSubject",
            40960: "FlashpixVersion",
            40961: "ColorSpace",
            40962: "ExifImageWidth",
            40963: "ExifImageHeight",
            40964: "RelatedSoundFile",
            40965: "InteropOffset",
            41483: "FlashEnergy",
            41484: "SpatialFrequencyResponse",
            41485: "Noise",
            41486: "FocalPlaneXResolution",
            41487: "FocalPlaneYResolution",
            41488: "FocalPlaneResolutionUnit",
            41489: "ImageNumber",
            41490: "SecurityClassification",
            41491: "ImageHistory",
            41492: "SubjectLocation",
            41493: "ExposureIndex",
            41494: "TIFF-EPStandardID",
            41495: "SensingMethod",
            41728: "FileSource",
            41729: "SceneType",
            41730: "CFAPattern",
            41985: "CustomRendered",
            41986: "ExposureMode",
            41987: "WhiteBalance",
            41988: "DigitalZoomRatio",
            41989: "FocalLengthIn35mmFormat",
            41990: "SceneCaptureType",
            41991: "GainControl",
            41992: "Contrast",
            41993: "Saturation",
            41994: "Sharpness",
            41995: "DeviceSettingDescription",
            41996: "SubjectDistanceRange",
            42016: "ImageUniqueID",
            42032: "OwnerName",
            42033: "SerialNumber",
            42034: "LensInfo",
            42035: "LensMake",
            42036: "LensModel",
            42037: "LensSerialNumber",
            42112: "GDALMetadata",
            42113: "GDALNoData",
            42240: "Gamma",
            44992: "ExpandSoftware",
            44993: "ExpandLens",
            44994: "ExpandFilm",
            44995: "ExpandFilterLens",
            44996: "ExpandScanner",
            44997: "ExpandFlashLamp",
            48129: "PixelFormat",
            48130: "Transformation",
            48131: "Uncompressed",
            48132: "ImageType",
            48256: "ImageWidth",
            48257: "ImageHeight",
            48258: "WidthResolution",
            48259: "HeightResolution",
            48320: "ImageOffset",
            48321: "ImageByteCount",
            48322: "AlphaOffset",
            48323: "AlphaByteCount",
            48324: "ImageDataDiscard",
            48325: "AlphaDataDiscard",
            50215: "OceScanjobDesc",
            50216: "OceApplicationSelector",
            50217: "OceIDNumber",
            50218: "OceImageLogic",
            50255: "Annotations",
            50341: "PrintIM",
            50560: "USPTOOriginalContentType",
            50706: "DNGVersion",
            50707: "DNGBackwardVersion",
            50708: "UniqueCameraModel",
            50709: "LocalizedCameraModel",
            50710: "CFAPlaneColor",
            50711: "CFALayout",
            50712: "LinearizationTable",
            50713: "BlackLevelRepeatDim",
            50714: "BlackLevel",
            50715: "BlackLevelDeltaH",
            50716: "BlackLevelDeltaV",
            50717: "WhiteLevel",
            50718: "DefaultScale",
            50719: "DefaultCropOrigin",
            50720: "DefaultCropSize",
            50721: "ColorMatrix1",
            50722: "ColorMatrix2",
            50723: "CameraCalibration1",
            50724: "CameraCalibration2",
            50725: "ReductionMatrix1",
            50726: "ReductionMatrix2",
            50727: "AnalogBalance",
            50728: "AsShotNeutral",
            50729: "AsShotWhiteXY",
            50730: "BaselineExposure",
            50731: "BaselineNoise",
            50732: "BaselineSharpness",
            50733: "BayerGreenSplit",
            50734: "LinearResponseLimit",
            50735: "CameraSerialNumber",
            50736: "DNGLensInfo",
            50737: "ChromaBlurRadius",
            50738: "AntiAliasStrength",
            50739: "ShadowScale",
            50740: "DNGPrivateData",
            50741: "MakerNoteSafety",
            50752: "RawImageSegmentation",
            50778: "CalibrationIlluminant1",
            50779: "CalibrationIlluminant2",
            50780: "BestQualityScale",
            50781: "RawDataUniqueID",
            50784: "AliasLayerMetadata",
            50827: "OriginalRawFileName",
            50828: "OriginalRawFileData",
            50829: "ActiveArea",
            50830: "MaskedAreas",
            50831: "AsShotICCProfile",
            50832: "AsShotPreProfileMatrix",
            50833: "CurrentICCProfile",
            50834: "CurrentPreProfileMatrix",
            50879: "ColorimetricReference",
            50898: "PanasonicTitle",
            50899: "PanasonicTitle2",
            50931: "CameraCalibrationSig",
            50932: "ProfileCalibrationSig",
            50933: "ProfileIFD",
            50934: "AsShotProfileName",
            50935: "NoiseReductionApplied",
            50936: "ProfileName",
            50937: "ProfileHueSatMapDims",
            50938: "ProfileHueSatMapData1",
            50939: "ProfileHueSatMapData2",
            50940: "ProfileToneCurve",
            50941: "ProfileEmbedPolicy",
            50942: "ProfileCopyright",
            50964: "ForwardMatrix1",
            50965: "ForwardMatrix2",
            50966: "PreviewApplicationName",
            50967: "PreviewApplicationVersion",
            50968: "PreviewSettingsName",
            50969: "PreviewSettingsDigest",
            50970: "PreviewColorSpace",
            50971: "PreviewDateTime",
            50972: "RawImageDigest",
            50973: "OriginalRawFileDigest",
            50974: "SubTileBlockSize",
            50975: "RowInterleaveFactor",
            50981: "ProfileLookTableDims",
            50982: "ProfileLookTableData",
            51008: "OpcodeList1",
            51009: "OpcodeList2",
            51022: "OpcodeList3",
            51041: "NoiseProfile",
            51043: "TimeCodes",
            51044: "FrameRate",
            51058: "TStop",
            51081: "ReelName",
            51089: "OriginalDefaultFinalSize",
            51090: "OriginalBestQualitySize",
            51091: "OriginalDefaultCropSize",
            51105: "CameraLabel",
            51107: "ProfileHueSatMapEncoding",
            51108: "ProfileLookTableEncoding",
            51109: "BaselineExposureOffset",
            51110: "DefaultBlackRender",
            51111: "NewRawImageDigest",
            51112: "RawToPreviewGain",
            51125: "DefaultUserCrop",
            59932: "Padding",
            59933: "OffsetSchema",
            65e3: "OwnerName",
            65001: "SerialNumber",
            65002: "Lens",
            65024: "KDC_IFD",
            65100: "RawFile",
            65101: "Converter",
            65102: "WhiteBalance",
            65105: "Exposure",
            65106: "Shadows",
            65107: "Brightness",
            65108: "Contrast",
            65109: "Saturation",
            65110: "Sharpness",
            65111: "Smoothness",
            65112: "MoireFilter"
          },
          gps: {
            0: "GPSVersionID",
            1: "GPSLatitudeRef",
            2: "GPSLatitude",
            3: "GPSLongitudeRef",
            4: "GPSLongitude",
            5: "GPSAltitudeRef",
            6: "GPSAltitude",
            7: "GPSTimeStamp",
            8: "GPSSatellites",
            9: "GPSStatus",
            10: "GPSMeasureMode",
            11: "GPSDOP",
            12: "GPSSpeedRef",
            13: "GPSSpeed",
            14: "GPSTrackRef",
            15: "GPSTrack",
            16: "GPSImgDirectionRef",
            17: "GPSImgDirection",
            18: "GPSMapDatum",
            19: "GPSDestLatitudeRef",
            20: "GPSDestLatitude",
            21: "GPSDestLongitudeRef",
            22: "GPSDestLongitude",
            23: "GPSDestBearingRef",
            24: "GPSDestBearing",
            25: "GPSDestDistanceRef",
            26: "GPSDestDistance",
            27: "GPSProcessingMethod",
            28: "GPSAreaInformation",
            29: "GPSDateStamp",
            30: "GPSDifferential",
            31: "GPSHPositioningError"
          }
        };
      }, {}], 58: [function(require2, module3, exports3) {
        function readExifValue(format, stream) {
          switch (format) {
            case 1:
              return stream.nextUInt8();
            case 3:
              return stream.nextUInt16();
            case 4:
              return stream.nextUInt32();
            case 5:
              return [stream.nextUInt32(), stream.nextUInt32()];
            case 6:
              return stream.nextInt8();
            case 8:
              return stream.nextUInt16();
            case 9:
              return stream.nextUInt32();
            case 10:
              return [stream.nextInt32(), stream.nextInt32()];
            case 11:
              return stream.nextFloat();
            case 12:
              return stream.nextDouble();
            default:
              throw new Error("Invalid format while decoding: " + format);
          }
        }
        function getBytesPerComponent(format) {
          switch (format) {
            case 1:
            case 2:
            case 6:
            case 7:
              return 1;
            case 3:
            case 8:
              return 2;
            case 4:
            case 9:
            case 11:
              return 4;
            case 5:
            case 10:
            case 12:
              return 8;
            default:
              return 0;
          }
        }
        function readExifTag(tiffMarker, stream) {
          var tagType = stream.nextUInt16(), format = stream.nextUInt16(), bytesPerComponent = getBytesPerComponent(format), components = stream.nextUInt32(), valueBytes = bytesPerComponent * components, values, value, c;
          if (valueBytes > 4) {
            stream = tiffMarker.openWithOffset(stream.nextUInt32());
          }
          if (format === 2) {
            values = stream.nextString(components);
            var lastNull = values.indexOf("\0");
            if (lastNull !== -1) {
              values = values.substr(0, lastNull);
            }
          } else if (format === 7) {
            values = stream.nextBuffer(components);
          } else if (format !== 0) {
            values = [];
            for (c = 0; c < components; ++c) {
              values.push(readExifValue(format, stream));
            }
          }
          if (valueBytes < 4) {
            stream.skip(4 - valueBytes);
          }
          return [tagType, values, format];
        }
        function readIFDSection(tiffMarker, stream, iterator) {
          var numberOfEntries = stream.nextUInt16(), tag, i;
          for (i = 0; i < numberOfEntries; ++i) {
            tag = readExifTag(tiffMarker, stream);
            iterator(tag[0], tag[1], tag[2]);
          }
        }
        function readHeader(stream) {
          var exifHeader = stream.nextString(6);
          if (exifHeader !== "Exif\0\0") {
            throw new Error("Invalid EXIF header");
          }
          var tiffMarker = stream.mark();
          var tiffHeader = stream.nextUInt16();
          if (tiffHeader === 18761) {
            stream.setBigEndian(false);
          } else if (tiffHeader === 19789) {
            stream.setBigEndian(true);
          } else {
            throw new Error("Invalid TIFF header");
          }
          if (stream.nextUInt16() !== 42) {
            throw new Error("Invalid TIFF data");
          }
          return tiffMarker;
        }
        module3.exports = {
          IFD0: 1,
          IFD1: 2,
          GPSIFD: 3,
          SubIFD: 4,
          InteropIFD: 5,
          parseTags: function(stream, iterator) {
            var tiffMarker;
            try {
              tiffMarker = readHeader(stream);
            } catch (e) {
              return false;
            }
            var subIfdOffset, gpsOffset, interopOffset;
            var ifd0Stream = tiffMarker.openWithOffset(stream.nextUInt32()), IFD0 = this.IFD0;
            readIFDSection(tiffMarker, ifd0Stream, function(tagType, value, format) {
              switch (tagType) {
                case 34853:
                  gpsOffset = value[0];
                  break;
                case 34665:
                  subIfdOffset = value[0];
                  break;
                default:
                  iterator(IFD0, tagType, value, format);
                  break;
              }
            });
            var ifd1Offset = ifd0Stream.nextUInt32();
            if (ifd1Offset !== 0) {
              var ifd1Stream = tiffMarker.openWithOffset(ifd1Offset);
              readIFDSection(tiffMarker, ifd1Stream, iterator.bind(null, this.IFD1));
            }
            if (gpsOffset) {
              var gpsStream = tiffMarker.openWithOffset(gpsOffset);
              readIFDSection(tiffMarker, gpsStream, iterator.bind(null, this.GPSIFD));
            }
            if (subIfdOffset) {
              var subIfdStream = tiffMarker.openWithOffset(subIfdOffset), InteropIFD = this.InteropIFD;
              readIFDSection(tiffMarker, subIfdStream, function(tagType, value, format) {
                if (tagType === 40965) {
                  interopOffset = value[0];
                } else {
                  iterator(InteropIFD, tagType, value, format);
                }
              });
            }
            if (interopOffset) {
              var interopStream = tiffMarker.openWithOffset(interopOffset);
              readIFDSection(tiffMarker, interopStream, iterator.bind(null, this.InteropIFD));
            }
            return true;
          }
        };
      }, {}], 59: [function(require2, module3, exports3) {
        module3.exports = {
          parseSections: function(stream, iterator) {
            var len, markerType;
            stream.setBigEndian(true);
            while (stream.remainingLength() > 0 && markerType !== 218) {
              if (stream.nextUInt8() !== 255) {
                throw new Error("Invalid JPEG section offset");
              }
              markerType = stream.nextUInt8();
              if (markerType >= 208 && markerType <= 217 || markerType === 218) {
                len = 0;
              } else {
                len = stream.nextUInt16() - 2;
              }
              iterator(markerType, stream.branch(0, len));
              stream.skip(len);
            }
          },
          //stream should be located after SOF section size and in big endian mode, like passed to parseSections iterator
          getSizeFromSOFSection: function(stream) {
            stream.skip(1);
            return {
              height: stream.nextUInt16(),
              width: stream.nextUInt16()
            };
          },
          getSectionName: function(markerType) {
            var name, index;
            switch (markerType) {
              case 216:
                name = "SOI";
                break;
              case 196:
                name = "DHT";
                break;
              case 219:
                name = "DQT";
                break;
              case 221:
                name = "DRI";
                break;
              case 218:
                name = "SOS";
                break;
              case 254:
                name = "COM";
                break;
              case 217:
                name = "EOI";
                break;
              default:
                if (markerType >= 224 && markerType <= 239) {
                  name = "APP";
                  index = markerType - 224;
                } else if (markerType >= 192 && markerType <= 207 && markerType !== 196 && markerType !== 200 && markerType !== 204) {
                  name = "SOF";
                  index = markerType - 192;
                } else if (markerType >= 208 && markerType <= 215) {
                  name = "RST";
                  index = markerType - 208;
                }
                break;
            }
            var nameStruct = {
              name
            };
            if (typeof index === "number") {
              nameStruct.index = index;
            }
            return nameStruct;
          }
        };
      }, {}], 60: [function(require2, module3, exports3) {
        var jpeg = require2("./jpeg"), exif = require2("./exif"), simplify = require2("./simplify");
        function ExifResult(startMarker, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset) {
          this.startMarker = startMarker;
          this.tags = tags;
          this.imageSize = imageSize;
          this.thumbnailOffset = thumbnailOffset;
          this.thumbnailLength = thumbnailLength;
          this.thumbnailType = thumbnailType;
          this.app1Offset = app1Offset;
        }
        ExifResult.prototype = {
          hasThumbnail: function(mime) {
            if (!this.thumbnailOffset || !this.thumbnailLength) {
              return false;
            }
            if (typeof mime !== "string") {
              return true;
            }
            if (mime.toLowerCase().trim() === "image/jpeg") {
              return this.thumbnailType === 6;
            }
            if (mime.toLowerCase().trim() === "image/tiff") {
              return this.thumbnailType === 1;
            }
            return false;
          },
          getThumbnailOffset: function() {
            return this.app1Offset + 6 + this.thumbnailOffset;
          },
          getThumbnailLength: function() {
            return this.thumbnailLength;
          },
          getThumbnailBuffer: function() {
            return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
          },
          _getThumbnailStream: function() {
            return this.startMarker.openWithOffset(this.getThumbnailOffset());
          },
          getImageSize: function() {
            return this.imageSize;
          },
          getThumbnailSize: function() {
            var stream = this._getThumbnailStream(), size;
            jpeg.parseSections(stream, function(sectionType, sectionStream) {
              if (jpeg.getSectionName(sectionType).name === "SOF") {
                size = jpeg.getSizeFromSOFSection(sectionStream);
              }
            });
            return size;
          }
        };
        function Parser(stream) {
          this.stream = stream;
          this.flags = {
            readBinaryTags: false,
            resolveTagNames: true,
            simplifyValues: true,
            imageSize: true,
            hidePointers: true,
            returnTags: true
          };
        }
        Parser.prototype = {
          enableBinaryFields: function(enable) {
            this.flags.readBinaryTags = !!enable;
            return this;
          },
          enablePointers: function(enable) {
            this.flags.hidePointers = !enable;
            return this;
          },
          enableTagNames: function(enable) {
            this.flags.resolveTagNames = !!enable;
            return this;
          },
          enableImageSize: function(enable) {
            this.flags.imageSize = !!enable;
            return this;
          },
          enableReturnTags: function(enable) {
            this.flags.returnTags = !!enable;
            return this;
          },
          enableSimpleValues: function(enable) {
            this.flags.simplifyValues = !!enable;
            return this;
          },
          parse: function() {
            var start = this.stream.mark(), stream = start.openWithOffset(0), flags = this.flags, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset, tagNames, getTagValue, setTagValue;
            if (flags.resolveTagNames) {
              tagNames = require2("./exif-tags");
            }
            if (flags.resolveTagNames) {
              tags = {};
              getTagValue = function(t) {
                return tags[t.name];
              };
              setTagValue = function(t, value) {
                tags[t.name] = value;
              };
            } else {
              tags = [];
              getTagValue = function(t) {
                var i;
                for (i = 0; i < tags.length; ++i) {
                  if (tags[i].type === t.type && tags[i].section === t.section) {
                    return tags.value;
                  }
                }
              };
              setTagValue = function(t, value) {
                var i;
                for (i = 0; i < tags.length; ++i) {
                  if (tags[i].type === t.type && tags[i].section === t.section) {
                    tags.value = value;
                    return;
                  }
                }
              };
            }
            jpeg.parseSections(stream, function(sectionType, sectionStream) {
              var validExifHeaders, sectionOffset = sectionStream.offsetFrom(start);
              if (sectionType === 225) {
                validExifHeaders = exif.parseTags(sectionStream, function(ifdSection, tagType, value, format) {
                  if (!flags.readBinaryTags && format === 7) {
                    return;
                  }
                  if (tagType === 513) {
                    thumbnailOffset = value[0];
                    if (flags.hidePointers) {
                      return;
                    }
                  } else if (tagType === 514) {
                    thumbnailLength = value[0];
                    if (flags.hidePointers) {
                      return;
                    }
                  } else if (tagType === 259) {
                    thumbnailType = value[0];
                    if (flags.hidePointers) {
                      return;
                    }
                  }
                  if (!flags.returnTags) {
                    return;
                  }
                  if (flags.simplifyValues) {
                    value = simplify.simplifyValue(value, format);
                  }
                  if (flags.resolveTagNames) {
                    var sectionTagNames = ifdSection === exif.GPSIFD ? tagNames.gps : tagNames.exif;
                    var name = sectionTagNames[tagType];
                    if (!name) {
                      name = tagNames.exif[tagType];
                    }
                    if (!tags.hasOwnProperty(name)) {
                      tags[name] = value;
                    }
                  } else {
                    tags.push({
                      section: ifdSection,
                      type: tagType,
                      value
                    });
                  }
                });
                if (validExifHeaders) {
                  app1Offset = sectionOffset;
                }
              } else if (flags.imageSize && jpeg.getSectionName(sectionType).name === "SOF") {
                imageSize = jpeg.getSizeFromSOFSection(sectionStream);
              }
            });
            if (flags.simplifyValues) {
              simplify.castDegreeValues(getTagValue, setTagValue);
              simplify.castDateValues(getTagValue, setTagValue);
            }
            return new ExifResult(start, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset);
          }
        };
        module3.exports = Parser;
      }, { "./exif": 58, "./exif-tags": 57, "./jpeg": 59, "./simplify": 61 }], 61: [function(require2, module3, exports3) {
        var exif = require2("./exif");
        var date = require2("./date");
        var degreeTags = [
          {
            section: exif.GPSIFD,
            type: 2,
            name: "GPSLatitude",
            refType: 1,
            refName: "GPSLatitudeRef",
            posVal: "N"
          },
          {
            section: exif.GPSIFD,
            type: 4,
            name: "GPSLongitude",
            refType: 3,
            refName: "GPSLongitudeRef",
            posVal: "E"
          }
        ];
        var dateTags = [
          {
            section: exif.SubIFD,
            type: 306,
            name: "ModifyDate"
          },
          {
            section: exif.SubIFD,
            type: 36867,
            name: "DateTimeOriginal"
          },
          {
            section: exif.SubIFD,
            type: 36868,
            name: "CreateDate"
          },
          {
            section: exif.SubIFD,
            type: 306,
            name: "ModifyDate"
          }
        ];
        module3.exports = {
          castDegreeValues: function(getTagValue, setTagValue) {
            degreeTags.forEach(function(t) {
              var degreeVal = getTagValue(t);
              if (degreeVal) {
                var degreeRef = getTagValue({ section: t.section, type: t.refType, name: t.refName });
                var degreeNumRef = degreeRef === t.posVal ? 1 : -1;
                var degree = (degreeVal[0] + degreeVal[1] / 60 + degreeVal[2] / 3600) * degreeNumRef;
                setTagValue(t, degree);
              }
            });
          },
          castDateValues: function(getTagValue, setTagValue) {
            dateTags.forEach(function(t) {
              var dateStrVal = getTagValue(t);
              if (dateStrVal) {
                var timestamp = date.parseExifDate(dateStrVal);
                if (typeof timestamp !== "undefined") {
                  setTagValue(t, timestamp);
                }
              }
            });
          },
          simplifyValue: function(values, format) {
            if (Array.isArray(values)) {
              values = values.map(function(value) {
                if (format === 10 || format === 5) {
                  return value[0] / value[1];
                }
                return value;
              });
              if (values.length === 1) {
                values = values[0];
              }
            }
            return values;
          }
        };
      }, { "./date": 55, "./exif": 58 }], 62: [function(require2, module3, exports3) {
        "use strict";
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        var _toConsumableArray2 = _interopRequireDefault(require2("@babel/runtime/helpers/toConsumableArray"));
        var toBytes = function toBytes2(s) {
          return (0, _toConsumableArray2["default"])(s).map(function(c) {
            return c.charCodeAt(0);
          });
        };
        var xpiZipFilename = toBytes("META-INF/mozilla.rsa");
        var oxmlContentTypes = toBytes("[Content_Types].xml");
        var oxmlRels = toBytes("_rels/.rels");
        module3.exports = function(input) {
          var buf = input instanceof Uint8Array ? input : new Uint8Array(input);
          if (!(buf && buf.length > 1)) {
            return null;
          }
          var check = function check2(header, options) {
            options = Object.assign({
              offset: 0
            }, options);
            for (var i = 0; i < header.length; i++) {
              if (options.mask) {
                if (header[i] !== (options.mask[i] & buf[i + options.offset])) {
                  return false;
                }
              } else if (header[i] !== buf[i + options.offset]) {
                return false;
              }
            }
            return true;
          };
          var checkString = function checkString2(header, options) {
            return check(toBytes(header), options);
          };
          if (check([255, 216, 255])) {
            return {
              ext: "jpg",
              mime: "image/jpeg"
            };
          }
          if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
            return {
              ext: "png",
              mime: "image/png"
            };
          }
          if (check([71, 73, 70])) {
            return {
              ext: "gif",
              mime: "image/gif"
            };
          }
          if (check([87, 69, 66, 80], {
            offset: 8
          })) {
            return {
              ext: "webp",
              mime: "image/webp"
            };
          }
          if (check([70, 76, 73, 70])) {
            return {
              ext: "flif",
              mime: "image/flif"
            };
          }
          if ((check([73, 73, 42, 0]) || check([77, 77, 0, 42])) && check([67, 82], {
            offset: 8
          })) {
            return {
              ext: "cr2",
              mime: "image/x-canon-cr2"
            };
          }
          if (check([73, 73, 42, 0]) || check([77, 77, 0, 42])) {
            return {
              ext: "tif",
              mime: "image/tiff"
            };
          }
          if (check([66, 77])) {
            return {
              ext: "bmp",
              mime: "image/bmp"
            };
          }
          if (check([73, 73, 188])) {
            return {
              ext: "jxr",
              mime: "image/vnd.ms-photo"
            };
          }
          if (check([56, 66, 80, 83])) {
            return {
              ext: "psd",
              mime: "image/vnd.adobe.photoshop"
            };
          }
          if (check([80, 75, 3, 4])) {
            if (check([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], {
              offset: 30
            })) {
              return {
                ext: "epub",
                mime: "application/epub+zip"
              };
            }
            if (check(xpiZipFilename, {
              offset: 30
            })) {
              return {
                ext: "xpi",
                mime: "application/x-xpinstall"
              };
            }
            if (checkString("mimetypeapplication/vnd.oasis.opendocument.text", {
              offset: 30
            })) {
              return {
                ext: "odt",
                mime: "application/vnd.oasis.opendocument.text"
              };
            }
            if (checkString("mimetypeapplication/vnd.oasis.opendocument.spreadsheet", {
              offset: 30
            })) {
              return {
                ext: "ods",
                mime: "application/vnd.oasis.opendocument.spreadsheet"
              };
            }
            if (checkString("mimetypeapplication/vnd.oasis.opendocument.presentation", {
              offset: 30
            })) {
              return {
                ext: "odp",
                mime: "application/vnd.oasis.opendocument.presentation"
              };
            }
            var findNextZipHeaderIndex = function findNextZipHeaderIndex2(arr) {
              var startAt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              return arr.findIndex(function(el, i, arr2) {
                return i >= startAt && arr2[i] === 80 && arr2[i + 1] === 75 && arr2[i + 2] === 3 && arr2[i + 3] === 4;
              });
            };
            var zipHeaderIndex = 0;
            var oxmlFound = false;
            var type = null;
            do {
              var offset = zipHeaderIndex + 30;
              if (!oxmlFound) {
                oxmlFound = check(oxmlContentTypes, {
                  offset
                }) || check(oxmlRels, {
                  offset
                });
              }
              if (!type) {
                if (checkString("word/", {
                  offset
                })) {
                  type = {
                    ext: "docx",
                    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                  };
                } else if (checkString("ppt/", {
                  offset
                })) {
                  type = {
                    ext: "pptx",
                    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                  };
                } else if (checkString("xl/", {
                  offset
                })) {
                  type = {
                    ext: "xlsx",
                    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                  };
                }
              }
              if (oxmlFound && type) {
                return type;
              }
              zipHeaderIndex = findNextZipHeaderIndex(buf, offset);
            } while (zipHeaderIndex >= 0);
            if (type) {
              return type;
            }
          }
          if (check([80, 75]) && (buf[2] === 3 || buf[2] === 5 || buf[2] === 7) && (buf[3] === 4 || buf[3] === 6 || buf[3] === 8)) {
            return {
              ext: "zip",
              mime: "application/zip"
            };
          }
          if (check([117, 115, 116, 97, 114], {
            offset: 257
          })) {
            return {
              ext: "tar",
              mime: "application/x-tar"
            };
          }
          if (check([82, 97, 114, 33, 26, 7]) && (buf[6] === 0 || buf[6] === 1)) {
            return {
              ext: "rar",
              mime: "application/x-rar-compressed"
            };
          }
          if (check([31, 139, 8])) {
            return {
              ext: "gz",
              mime: "application/gzip"
            };
          }
          if (check([66, 90, 104])) {
            return {
              ext: "bz2",
              mime: "application/x-bzip2"
            };
          }
          if (check([55, 122, 188, 175, 39, 28])) {
            return {
              ext: "7z",
              mime: "application/x-7z-compressed"
            };
          }
          if (check([120, 1])) {
            return {
              ext: "dmg",
              mime: "application/x-apple-diskimage"
            };
          }
          if (check([51, 103, 112, 53]) || // 3gp5
          check([0, 0, 0]) && check([102, 116, 121, 112], {
            offset: 4
          }) && (check([109, 112, 52, 49], {
            offset: 8
          }) || // MP41
          check([109, 112, 52, 50], {
            offset: 8
          }) || // MP42
          check([105, 115, 111, 109], {
            offset: 8
          }) || // ISOM
          check([105, 115, 111, 50], {
            offset: 8
          }) || // ISO2
          check([109, 109, 112, 52], {
            offset: 8
          }) || // MMP4
          check([77, 52, 86], {
            offset: 8
          }) || // M4V
          check([100, 97, 115, 104], {
            offset: 8
          }))) {
            return {
              ext: "mp4",
              mime: "video/mp4"
            };
          }
          if (check([77, 84, 104, 100])) {
            return {
              ext: "mid",
              mime: "audio/midi"
            };
          }
          if (check([26, 69, 223, 163])) {
            var sliced = buf.subarray(4, 4 + 4096);
            var idPos = sliced.findIndex(function(el, i, arr) {
              return arr[i] === 66 && arr[i + 1] === 130;
            });
            if (idPos !== -1) {
              var docTypePos = idPos + 3;
              var findDocType = function findDocType2(type2) {
                return (0, _toConsumableArray2["default"])(type2).every(function(c, i) {
                  return sliced[docTypePos + i] === c.charCodeAt(0);
                });
              };
              if (findDocType("matroska")) {
                return {
                  ext: "mkv",
                  mime: "video/x-matroska"
                };
              }
              if (findDocType("webm")) {
                return {
                  ext: "webm",
                  mime: "video/webm"
                };
              }
            }
          }
          if (check([0, 0, 0, 20, 102, 116, 121, 112, 113, 116, 32, 32]) || check([102, 114, 101, 101], {
            offset: 4
          }) || check([102, 116, 121, 112, 113, 116, 32, 32], {
            offset: 4
          }) || check([109, 100, 97, 116], {
            offset: 4
          }) || // MJPEG
          check([119, 105, 100, 101], {
            offset: 4
          })) {
            return {
              ext: "mov",
              mime: "video/quicktime"
            };
          }
          if (check([82, 73, 70, 70])) {
            if (check([65, 86, 73], {
              offset: 8
            })) {
              return {
                ext: "avi",
                mime: "video/vnd.avi"
              };
            }
            if (check([87, 65, 86, 69], {
              offset: 8
            })) {
              return {
                ext: "wav",
                mime: "audio/vnd.wave"
              };
            }
            if (check([81, 76, 67, 77], {
              offset: 8
            })) {
              return {
                ext: "qcp",
                mime: "audio/qcelp"
              };
            }
          }
          if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
            return {
              ext: "wmv",
              mime: "video/x-ms-wmv"
            };
          }
          if (check([0, 0, 1, 186]) || check([0, 0, 1, 179])) {
            return {
              ext: "mpg",
              mime: "video/mpeg"
            };
          }
          if (check([102, 116, 121, 112, 51, 103], {
            offset: 4
          })) {
            return {
              ext: "3gp",
              mime: "video/3gpp"
            };
          }
          for (var start = 0; start < 2 && start < buf.length - 16; start++) {
            if (check([73, 68, 51], {
              offset: start
            }) || // ID3 header
            check([255, 226], {
              offset: start,
              mask: [255, 226]
            })) {
              return {
                ext: "mp3",
                mime: "audio/mpeg"
              };
            }
            if (check([255, 228], {
              offset: start,
              mask: [255, 228]
            })) {
              return {
                ext: "mp2",
                mime: "audio/mpeg"
              };
            }
            if (check([255, 248], {
              offset: start,
              mask: [255, 252]
            })) {
              return {
                ext: "mp2",
                mime: "audio/mpeg"
              };
            }
            if (check([255, 240], {
              offset: start,
              mask: [255, 252]
            })) {
              return {
                ext: "mp4",
                mime: "audio/mpeg"
              };
            }
          }
          if (check([102, 116, 121, 112, 77, 52, 65], {
            offset: 4
          }) || check([77, 52, 65, 32])) {
            return {
              // MPEG-4 layer 3 (audio)
              ext: "m4a",
              mime: "audio/mp4"
              // RFC 4337
            };
          }
          if (check([79, 112, 117, 115, 72, 101, 97, 100], {
            offset: 28
          })) {
            return {
              ext: "opus",
              mime: "audio/opus"
            };
          }
          if (check([79, 103, 103, 83])) {
            if (check([128, 116, 104, 101, 111, 114, 97], {
              offset: 28
            })) {
              return {
                ext: "ogv",
                mime: "video/ogg"
              };
            }
            if (check([1, 118, 105, 100, 101, 111, 0], {
              offset: 28
            })) {
              return {
                ext: "ogm",
                mime: "video/ogg"
              };
            }
            if (check([127, 70, 76, 65, 67], {
              offset: 28
            })) {
              return {
                ext: "oga",
                mime: "audio/ogg"
              };
            }
            if (check([83, 112, 101, 101, 120, 32, 32], {
              offset: 28
            })) {
              return {
                ext: "spx",
                mime: "audio/ogg"
              };
            }
            if (check([1, 118, 111, 114, 98, 105, 115], {
              offset: 28
            })) {
              return {
                ext: "ogg",
                mime: "audio/ogg"
              };
            }
            return {
              ext: "ogx",
              mime: "application/ogg"
            };
          }
          if (check([102, 76, 97, 67])) {
            return {
              ext: "flac",
              mime: "audio/x-flac"
            };
          }
          if (check([77, 65, 67, 32])) {
            return {
              ext: "ape",
              mime: "audio/ape"
            };
          }
          if (check([119, 118, 112, 107])) {
            return {
              ext: "wv",
              mime: "audio/wavpack"
            };
          }
          if (check([35, 33, 65, 77, 82, 10])) {
            return {
              ext: "amr",
              mime: "audio/amr"
            };
          }
          if (check([37, 80, 68, 70])) {
            return {
              ext: "pdf",
              mime: "application/pdf"
            };
          }
          if (check([77, 90])) {
            return {
              ext: "exe",
              mime: "application/x-msdownload"
            };
          }
          if ((buf[0] === 67 || buf[0] === 70) && check([87, 83], {
            offset: 1
          })) {
            return {
              ext: "swf",
              mime: "application/x-shockwave-flash"
            };
          }
          if (check([123, 92, 114, 116, 102])) {
            return {
              ext: "rtf",
              mime: "application/rtf"
            };
          }
          if (check([0, 97, 115, 109])) {
            return {
              ext: "wasm",
              mime: "application/wasm"
            };
          }
          if (check([119, 79, 70, 70]) && (check([0, 1, 0, 0], {
            offset: 4
          }) || check([79, 84, 84, 79], {
            offset: 4
          }))) {
            return {
              ext: "woff",
              mime: "font/woff"
            };
          }
          if (check([119, 79, 70, 50]) && (check([0, 1, 0, 0], {
            offset: 4
          }) || check([79, 84, 84, 79], {
            offset: 4
          }))) {
            return {
              ext: "woff2",
              mime: "font/woff2"
            };
          }
          if (check([76, 80], {
            offset: 34
          }) && (check([0, 0, 1], {
            offset: 8
          }) || check([1, 0, 2], {
            offset: 8
          }) || check([2, 0, 2], {
            offset: 8
          }))) {
            return {
              ext: "eot",
              mime: "application/vnd.ms-fontobject"
            };
          }
          if (check([0, 1, 0, 0, 0])) {
            return {
              ext: "ttf",
              mime: "font/ttf"
            };
          }
          if (check([79, 84, 84, 79, 0])) {
            return {
              ext: "otf",
              mime: "font/otf"
            };
          }
          if (check([0, 0, 1, 0])) {
            return {
              ext: "ico",
              mime: "image/x-icon"
            };
          }
          if (check([0, 0, 2, 0])) {
            return {
              ext: "cur",
              mime: "image/x-icon"
            };
          }
          if (check([70, 76, 86, 1])) {
            return {
              ext: "flv",
              mime: "video/x-flv"
            };
          }
          if (check([37, 33])) {
            return {
              ext: "ps",
              mime: "application/postscript"
            };
          }
          if (check([253, 55, 122, 88, 90, 0])) {
            return {
              ext: "xz",
              mime: "application/x-xz"
            };
          }
          if (check([83, 81, 76, 105])) {
            return {
              ext: "sqlite",
              mime: "application/x-sqlite3"
            };
          }
          if (check([78, 69, 83, 26])) {
            return {
              ext: "nes",
              mime: "application/x-nintendo-nes-rom"
            };
          }
          if (check([67, 114, 50, 52])) {
            return {
              ext: "crx",
              mime: "application/x-google-chrome-extension"
            };
          }
          if (check([77, 83, 67, 70]) || check([73, 83, 99, 40])) {
            return {
              ext: "cab",
              mime: "application/vnd.ms-cab-compressed"
            };
          }
          if (check([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121])) {
            return {
              ext: "deb",
              mime: "application/x-deb"
            };
          }
          if (check([33, 60, 97, 114, 99, 104, 62])) {
            return {
              ext: "ar",
              mime: "application/x-unix-archive"
            };
          }
          if (check([237, 171, 238, 219])) {
            return {
              ext: "rpm",
              mime: "application/x-rpm"
            };
          }
          if (check([31, 160]) || check([31, 157])) {
            return {
              ext: "Z",
              mime: "application/x-compress"
            };
          }
          if (check([76, 90, 73, 80])) {
            return {
              ext: "lz",
              mime: "application/x-lzip"
            };
          }
          if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
            return {
              ext: "msi",
              mime: "application/x-msi"
            };
          }
          if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
            return {
              ext: "mxf",
              mime: "application/mxf"
            };
          }
          if (check([71], {
            offset: 4
          }) && (check([71], {
            offset: 192
          }) || check([71], {
            offset: 196
          }))) {
            return {
              ext: "mts",
              mime: "video/mp2t"
            };
          }
          if (check([66, 76, 69, 78, 68, 69, 82])) {
            return {
              ext: "blend",
              mime: "application/x-blender"
            };
          }
          if (check([66, 80, 71, 251])) {
            return {
              ext: "bpg",
              mime: "image/bpg"
            };
          }
          if (check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
            if (check([106, 112, 50, 32], {
              offset: 20
            })) {
              return {
                ext: "jp2",
                mime: "image/jp2"
              };
            }
            if (check([106, 112, 120, 32], {
              offset: 20
            })) {
              return {
                ext: "jpx",
                mime: "image/jpx"
              };
            }
            if (check([106, 112, 109, 32], {
              offset: 20
            })) {
              return {
                ext: "jpm",
                mime: "image/jpm"
              };
            }
            if (check([109, 106, 112, 50], {
              offset: 20
            })) {
              return {
                ext: "mj2",
                mime: "image/mj2"
              };
            }
          }
          if (check([70, 79, 82, 77, 0])) {
            return {
              ext: "aif",
              mime: "audio/aiff"
            };
          }
          if (checkString("<?xml ")) {
            return {
              ext: "xml",
              mime: "application/xml"
            };
          }
          if (check([66, 79, 79, 75, 77, 79, 66, 73], {
            offset: 60
          })) {
            return {
              ext: "mobi",
              mime: "application/x-mobipocket-ebook"
            };
          }
          if (check([102, 116, 121, 112], {
            offset: 4
          })) {
            if (check([109, 105, 102, 49], {
              offset: 8
            })) {
              return {
                ext: "heic",
                mime: "image/heif"
              };
            }
            if (check([109, 115, 102, 49], {
              offset: 8
            })) {
              return {
                ext: "heic",
                mime: "image/heif-sequence"
              };
            }
            if (check([104, 101, 105, 99], {
              offset: 8
            }) || check([104, 101, 105, 120], {
              offset: 8
            })) {
              return {
                ext: "heic",
                mime: "image/heic"
              };
            }
            if (check([104, 101, 118, 99], {
              offset: 8
            }) || check([104, 101, 118, 120], {
              offset: 8
            })) {
              return {
                ext: "heic",
                mime: "image/heic-sequence"
              };
            }
          }
          if (check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
            return {
              ext: "ktx",
              mime: "image/ktx"
            };
          }
          return null;
        };
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/toConsumableArray": 20 }], 63: [function(require2, module3, exports3) {
        "use strict";
        var isCallable = require2("is-callable");
        var toStr = Object.prototype.toString;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var forEachArray = function forEachArray2(array, iterator, receiver) {
          for (var i = 0, len = array.length; i < len; i++) {
            if (hasOwnProperty.call(array, i)) {
              if (receiver == null) {
                iterator(array[i], i, array);
              } else {
                iterator.call(receiver, array[i], i, array);
              }
            }
          }
        };
        var forEachString = function forEachString2(string, iterator, receiver) {
          for (var i = 0, len = string.length; i < len; i++) {
            if (receiver == null) {
              iterator(string.charAt(i), i, string);
            } else {
              iterator.call(receiver, string.charAt(i), i, string);
            }
          }
        };
        var forEachObject = function forEachObject2(object, iterator, receiver) {
          for (var k in object) {
            if (hasOwnProperty.call(object, k)) {
              if (receiver == null) {
                iterator(object[k], k, object);
              } else {
                iterator.call(receiver, object[k], k, object);
              }
            }
          }
        };
        var forEach = function forEach2(list, iterator, thisArg) {
          if (!isCallable(iterator)) {
            throw new TypeError("iterator must be a function");
          }
          var receiver;
          if (arguments.length >= 3) {
            receiver = thisArg;
          }
          if (toStr.call(list) === "[object Array]") {
            forEachArray(list, iterator, receiver);
          } else if (typeof list === "string") {
            forEachString(list, iterator, receiver);
          } else {
            forEachObject(list, iterator, receiver);
          }
        };
        module3.exports = forEach;
      }, { "is-callable": 77 }], 64: [function(require2, module3, exports3) {
        "use strict";
        function GifWriter(buf, width, height, gopts) {
          var p = 0;
          var gopts = gopts === void 0 ? {} : gopts;
          var loop_count = gopts.loop === void 0 ? null : gopts.loop;
          var global_palette = gopts.palette === void 0 ? null : gopts.palette;
          if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
            throw new Error("Width/Height invalid.");
          function check_palette_and_num_colors(palette) {
            var num_colors = palette.length;
            if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) {
              throw new Error(
                "Invalid code/color length, must be power of 2 and 2 .. 256."
              );
            }
            return num_colors;
          }
          buf[p++] = 71;
          buf[p++] = 73;
          buf[p++] = 70;
          buf[p++] = 56;
          buf[p++] = 57;
          buf[p++] = 97;
          var gp_num_colors_pow2 = 0;
          var background = 0;
          if (global_palette !== null) {
            var gp_num_colors = check_palette_and_num_colors(global_palette);
            while (gp_num_colors >>= 1)
              ++gp_num_colors_pow2;
            gp_num_colors = 1 << gp_num_colors_pow2;
            --gp_num_colors_pow2;
            if (gopts.background !== void 0) {
              background = gopts.background;
              if (background >= gp_num_colors)
                throw new Error("Background index out of range.");
              if (background === 0)
                throw new Error("Background index explicitly passed as 0.");
            }
          }
          buf[p++] = width & 255;
          buf[p++] = width >> 8 & 255;
          buf[p++] = height & 255;
          buf[p++] = height >> 8 & 255;
          buf[p++] = (global_palette !== null ? 128 : 0) | // Global Color Table Flag.
          gp_num_colors_pow2;
          buf[p++] = background;
          buf[p++] = 0;
          if (global_palette !== null) {
            for (var i = 0, il = global_palette.length; i < il; ++i) {
              var rgb = global_palette[i];
              buf[p++] = rgb >> 16 & 255;
              buf[p++] = rgb >> 8 & 255;
              buf[p++] = rgb & 255;
            }
          }
          if (loop_count !== null) {
            if (loop_count < 0 || loop_count > 65535)
              throw new Error("Loop count invalid.");
            buf[p++] = 33;
            buf[p++] = 255;
            buf[p++] = 11;
            buf[p++] = 78;
            buf[p++] = 69;
            buf[p++] = 84;
            buf[p++] = 83;
            buf[p++] = 67;
            buf[p++] = 65;
            buf[p++] = 80;
            buf[p++] = 69;
            buf[p++] = 50;
            buf[p++] = 46;
            buf[p++] = 48;
            buf[p++] = 3;
            buf[p++] = 1;
            buf[p++] = loop_count & 255;
            buf[p++] = loop_count >> 8 & 255;
            buf[p++] = 0;
          }
          var ended = false;
          this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
            if (ended === true) {
              --p;
              ended = false;
            }
            opts = opts === void 0 ? {} : opts;
            if (x < 0 || y < 0 || x > 65535 || y > 65535)
              throw new Error("x/y invalid.");
            if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
              throw new Error("Width/Height invalid.");
            if (indexed_pixels.length < w * h)
              throw new Error("Not enough pixels for the frame size.");
            var using_local_palette = true;
            var palette = opts.palette;
            if (palette === void 0 || palette === null) {
              using_local_palette = false;
              palette = global_palette;
            }
            if (palette === void 0 || palette === null)
              throw new Error("Must supply either a local or global palette.");
            var num_colors = check_palette_and_num_colors(palette);
            var min_code_size = 0;
            while (num_colors >>= 1)
              ++min_code_size;
            num_colors = 1 << min_code_size;
            var delay = opts.delay === void 0 ? 0 : opts.delay;
            var disposal = opts.disposal === void 0 ? 0 : opts.disposal;
            if (disposal < 0 || disposal > 3)
              throw new Error("Disposal out of range.");
            var use_transparency = false;
            var transparent_index = 0;
            if (opts.transparent !== void 0 && opts.transparent !== null) {
              use_transparency = true;
              transparent_index = opts.transparent;
              if (transparent_index < 0 || transparent_index >= num_colors)
                throw new Error("Transparent color index.");
            }
            if (disposal !== 0 || use_transparency || delay !== 0) {
              buf[p++] = 33;
              buf[p++] = 249;
              buf[p++] = 4;
              buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
              buf[p++] = delay & 255;
              buf[p++] = delay >> 8 & 255;
              buf[p++] = transparent_index;
              buf[p++] = 0;
            }
            buf[p++] = 44;
            buf[p++] = x & 255;
            buf[p++] = x >> 8 & 255;
            buf[p++] = y & 255;
            buf[p++] = y >> 8 & 255;
            buf[p++] = w & 255;
            buf[p++] = w >> 8 & 255;
            buf[p++] = h & 255;
            buf[p++] = h >> 8 & 255;
            buf[p++] = using_local_palette === true ? 128 | min_code_size - 1 : 0;
            if (using_local_palette === true) {
              for (var i2 = 0, il2 = palette.length; i2 < il2; ++i2) {
                var rgb2 = palette[i2];
                buf[p++] = rgb2 >> 16 & 255;
                buf[p++] = rgb2 >> 8 & 255;
                buf[p++] = rgb2 & 255;
              }
            }
            p = GifWriterOutputLZWCodeStream(
              buf,
              p,
              min_code_size < 2 ? 2 : min_code_size,
              indexed_pixels
            );
            return p;
          };
          this.end = function() {
            if (ended === false) {
              buf[p++] = 59;
              ended = true;
            }
            return p;
          };
          this.getOutputBuffer = function() {
            return buf;
          };
          this.setOutputBuffer = function(v) {
            buf = v;
          };
          this.getOutputBufferPosition = function() {
            return p;
          };
          this.setOutputBufferPosition = function(v) {
            p = v;
          };
        }
        function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
          buf[p++] = min_code_size;
          var cur_subblock = p++;
          var clear_code = 1 << min_code_size;
          var code_mask = clear_code - 1;
          var eoi_code = clear_code + 1;
          var next_code = eoi_code + 1;
          var cur_code_size = min_code_size + 1;
          var cur_shift = 0;
          var cur = 0;
          function emit_bytes_to_buffer(bit_block_size) {
            while (cur_shift >= bit_block_size) {
              buf[p++] = cur & 255;
              cur >>= 8;
              cur_shift -= 8;
              if (p === cur_subblock + 256) {
                buf[cur_subblock] = 255;
                cur_subblock = p++;
              }
            }
          }
          function emit_code(c) {
            cur |= c << cur_shift;
            cur_shift += cur_code_size;
            emit_bytes_to_buffer(8);
          }
          var ib_code = index_stream[0] & code_mask;
          var code_table = {};
          emit_code(clear_code);
          for (var i = 1, il = index_stream.length; i < il; ++i) {
            var k = index_stream[i] & code_mask;
            var cur_key = ib_code << 8 | k;
            var cur_code = code_table[cur_key];
            if (cur_code === void 0) {
              cur |= ib_code << cur_shift;
              cur_shift += cur_code_size;
              while (cur_shift >= 8) {
                buf[p++] = cur & 255;
                cur >>= 8;
                cur_shift -= 8;
                if (p === cur_subblock + 256) {
                  buf[cur_subblock] = 255;
                  cur_subblock = p++;
                }
              }
              if (next_code === 4096) {
                emit_code(clear_code);
                next_code = eoi_code + 1;
                cur_code_size = min_code_size + 1;
                code_table = {};
              } else {
                if (next_code >= 1 << cur_code_size)
                  ++cur_code_size;
                code_table[cur_key] = next_code++;
              }
              ib_code = k;
            } else {
              ib_code = cur_code;
            }
          }
          emit_code(ib_code);
          emit_code(eoi_code);
          emit_bytes_to_buffer(1);
          if (cur_subblock + 1 === p) {
            buf[cur_subblock] = 0;
          } else {
            buf[cur_subblock] = p - cur_subblock - 1;
            buf[p++] = 0;
          }
          return p;
        }
        function GifReader(buf) {
          var p = 0;
          if (buf[p++] !== 71 || buf[p++] !== 73 || buf[p++] !== 70 || buf[p++] !== 56 || (buf[p++] + 1 & 253) !== 56 || buf[p++] !== 97) {
            throw new Error("Invalid GIF 87a/89a header.");
          }
          var width = buf[p++] | buf[p++] << 8;
          var height = buf[p++] | buf[p++] << 8;
          var pf0 = buf[p++];
          var global_palette_flag = pf0 >> 7;
          var num_global_colors_pow2 = pf0 & 7;
          var num_global_colors = 1 << num_global_colors_pow2 + 1;
          var background = buf[p++];
          buf[p++];
          var global_palette_offset = null;
          var global_palette_size = null;
          if (global_palette_flag) {
            global_palette_offset = p;
            global_palette_size = num_global_colors;
            p += num_global_colors * 3;
          }
          var no_eof = true;
          var frames = [];
          var delay = 0;
          var transparent_index = null;
          var disposal = 0;
          var loop_count = null;
          this.width = width;
          this.height = height;
          while (no_eof && p < buf.length) {
            switch (buf[p++]) {
              case 33:
                switch (buf[p++]) {
                  case 255:
                    if (buf[p] !== 11 || // 21 FF already read, check block size.
                    // NETSCAPE2.0
                    buf[p + 1] == 78 && buf[p + 2] == 69 && buf[p + 3] == 84 && buf[p + 4] == 83 && buf[p + 5] == 67 && buf[p + 6] == 65 && buf[p + 7] == 80 && buf[p + 8] == 69 && buf[p + 9] == 50 && buf[p + 10] == 46 && buf[p + 11] == 48 && // Sub-block
                    buf[p + 12] == 3 && buf[p + 13] == 1 && buf[p + 16] == 0) {
                      p += 14;
                      loop_count = buf[p++] | buf[p++] << 8;
                      p++;
                    } else {
                      p += 12;
                      while (true) {
                        var block_size = buf[p++];
                        if (!(block_size >= 0))
                          throw Error("Invalid block size");
                        if (block_size === 0)
                          break;
                        p += block_size;
                      }
                    }
                    break;
                  case 249:
                    if (buf[p++] !== 4 || buf[p + 4] !== 0)
                      throw new Error("Invalid graphics extension block.");
                    var pf1 = buf[p++];
                    delay = buf[p++] | buf[p++] << 8;
                    transparent_index = buf[p++];
                    if ((pf1 & 1) === 0)
                      transparent_index = null;
                    disposal = pf1 >> 2 & 7;
                    p++;
                    break;
                  case 254:
                    while (true) {
                      var block_size = buf[p++];
                      if (!(block_size >= 0))
                        throw Error("Invalid block size");
                      if (block_size === 0)
                        break;
                      p += block_size;
                    }
                    break;
                  default:
                    throw new Error(
                      "Unknown graphic control label: 0x" + buf[p - 1].toString(16)
                    );
                }
                break;
              case 44:
                var x = buf[p++] | buf[p++] << 8;
                var y = buf[p++] | buf[p++] << 8;
                var w = buf[p++] | buf[p++] << 8;
                var h = buf[p++] | buf[p++] << 8;
                var pf2 = buf[p++];
                var local_palette_flag = pf2 >> 7;
                var interlace_flag = pf2 >> 6 & 1;
                var num_local_colors_pow2 = pf2 & 7;
                var num_local_colors = 1 << num_local_colors_pow2 + 1;
                var palette_offset = global_palette_offset;
                var palette_size = global_palette_size;
                var has_local_palette = false;
                if (local_palette_flag) {
                  var has_local_palette = true;
                  palette_offset = p;
                  palette_size = num_local_colors;
                  p += num_local_colors * 3;
                }
                var data_offset = p;
                p++;
                while (true) {
                  var block_size = buf[p++];
                  if (!(block_size >= 0))
                    throw Error("Invalid block size");
                  if (block_size === 0)
                    break;
                  p += block_size;
                }
                frames.push({
                  x,
                  y,
                  width: w,
                  height: h,
                  has_local_palette,
                  palette_offset,
                  palette_size,
                  data_offset,
                  data_length: p - data_offset,
                  transparent_index,
                  interlaced: !!interlace_flag,
                  delay,
                  disposal
                });
                break;
              case 59:
                no_eof = false;
                break;
              default:
                throw new Error("Unknown gif block: 0x" + buf[p - 1].toString(16));
                break;
            }
          }
          this.numFrames = function() {
            return frames.length;
          };
          this.loopCount = function() {
            return loop_count;
          };
          this.frameInfo = function(frame_num) {
            if (frame_num < 0 || frame_num >= frames.length)
              throw new Error("Frame index out of range.");
            return frames[frame_num];
          };
          this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
            var frame = this.frameInfo(frame_num);
            var num_pixels = frame.width * frame.height;
            var index_stream = new Uint8Array(num_pixels);
            GifReaderLZWOutputIndexStream(
              buf,
              frame.data_offset,
              index_stream,
              num_pixels
            );
            var palette_offset2 = frame.palette_offset;
            var trans = frame.transparent_index;
            if (trans === null)
              trans = 256;
            var framewidth = frame.width;
            var framestride = width - framewidth;
            var xleft = framewidth;
            var opbeg = (frame.y * width + frame.x) * 4;
            var opend = ((frame.y + frame.height) * width + frame.x) * 4;
            var op = opbeg;
            var scanstride = framestride * 4;
            if (frame.interlaced === true) {
              scanstride += width * 4 * 7;
            }
            var interlaceskip = 8;
            for (var i = 0, il = index_stream.length; i < il; ++i) {
              var index = index_stream[i];
              if (xleft === 0) {
                op += scanstride;
                xleft = framewidth;
                if (op >= opend) {
                  scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
                  op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
                  interlaceskip >>= 1;
                }
              }
              if (index === trans) {
                op += 4;
              } else {
                var r = buf[palette_offset2 + index * 3];
                var g = buf[palette_offset2 + index * 3 + 1];
                var b = buf[palette_offset2 + index * 3 + 2];
                pixels[op++] = b;
                pixels[op++] = g;
                pixels[op++] = r;
                pixels[op++] = 255;
              }
              --xleft;
            }
          };
          this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
            var frame = this.frameInfo(frame_num);
            var num_pixels = frame.width * frame.height;
            var index_stream = new Uint8Array(num_pixels);
            GifReaderLZWOutputIndexStream(
              buf,
              frame.data_offset,
              index_stream,
              num_pixels
            );
            var palette_offset2 = frame.palette_offset;
            var trans = frame.transparent_index;
            if (trans === null)
              trans = 256;
            var framewidth = frame.width;
            var framestride = width - framewidth;
            var xleft = framewidth;
            var opbeg = (frame.y * width + frame.x) * 4;
            var opend = ((frame.y + frame.height) * width + frame.x) * 4;
            var op = opbeg;
            var scanstride = framestride * 4;
            if (frame.interlaced === true) {
              scanstride += width * 4 * 7;
            }
            var interlaceskip = 8;
            for (var i = 0, il = index_stream.length; i < il; ++i) {
              var index = index_stream[i];
              if (xleft === 0) {
                op += scanstride;
                xleft = framewidth;
                if (op >= opend) {
                  scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
                  op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
                  interlaceskip >>= 1;
                }
              }
              if (index === trans) {
                op += 4;
              } else {
                var r = buf[palette_offset2 + index * 3];
                var g = buf[palette_offset2 + index * 3 + 1];
                var b = buf[palette_offset2 + index * 3 + 2];
                pixels[op++] = r;
                pixels[op++] = g;
                pixels[op++] = b;
                pixels[op++] = 255;
              }
              --xleft;
            }
          };
        }
        function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
          var min_code_size = code_stream[p++];
          var clear_code = 1 << min_code_size;
          var eoi_code = clear_code + 1;
          var next_code = eoi_code + 1;
          var cur_code_size = min_code_size + 1;
          var code_mask = (1 << cur_code_size) - 1;
          var cur_shift = 0;
          var cur = 0;
          var op = 0;
          var subblock_size = code_stream[p++];
          var code_table = new Int32Array(4096);
          var prev_code = null;
          while (true) {
            while (cur_shift < 16) {
              if (subblock_size === 0)
                break;
              cur |= code_stream[p++] << cur_shift;
              cur_shift += 8;
              if (subblock_size === 1) {
                subblock_size = code_stream[p++];
              } else {
                --subblock_size;
              }
            }
            if (cur_shift < cur_code_size)
              break;
            var code = cur & code_mask;
            cur >>= cur_code_size;
            cur_shift -= cur_code_size;
            if (code === clear_code) {
              next_code = eoi_code + 1;
              cur_code_size = min_code_size + 1;
              code_mask = (1 << cur_code_size) - 1;
              prev_code = null;
              continue;
            } else if (code === eoi_code) {
              break;
            }
            var chase_code = code < next_code ? code : prev_code;
            var chase_length = 0;
            var chase = chase_code;
            while (chase > clear_code) {
              chase = code_table[chase] >> 8;
              ++chase_length;
            }
            var k = chase;
            var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
            if (op_end > output_length) {
              console.log("Warning, gif stream longer than expected.");
              return;
            }
            output[op++] = k;
            op += chase_length;
            var b = op;
            if (chase_code !== code)
              output[op++] = k;
            chase = chase_code;
            while (chase_length--) {
              chase = code_table[chase];
              output[--b] = chase & 255;
              chase >>= 8;
            }
            if (prev_code !== null && next_code < 4096) {
              code_table[next_code++] = prev_code << 8 | k;
              if (next_code >= code_mask + 1 && cur_code_size < 12) {
                ++cur_code_size;
                code_mask = code_mask << 1 | 1;
              }
            }
            prev_code = code;
          }
          if (op !== output_length) {
            console.log("Warning, gif stream shorter than expected.");
          }
          return output;
        }
        try {
          exports3.GifWriter = GifWriter;
          exports3.GifReader = GifReader;
        } catch (e) {
        }
      }, {}], 65: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          class BitmapImage {
            /**
             * BitmapImage is a class that hold an RGBA (red, green, blue, alpha) representation of an image. It's shape is borrowed from the Jimp package to make it easy to transfer GIF image frames into Jimp and Jimp images into GIF image frames. Each instance has a `bitmap` property having the following properties:
             * 
             * Property | Description
             * --- | ---
             * bitmap.width | width of image in pixels
             * bitmap.height | height of image in pixels
             * bitmap.data | a Buffer whose every four bytes represents a pixel, each sequential byte of a pixel corresponding to the red, green, blue, and alpha values of the pixel
             *
             * Its constructor supports the following signatures:
             *
             * * new BitmapImage(bitmap: { width: number, height: number, data: Buffer })
             * * new BitmapImage(bitmapImage: BitmapImage)
             * * new BitmapImage(width: number, height: number, buffer: Buffer)
             * * new BitmapImage(width: number, height: number, backgroundRGBA?: number)
             * 
             * When a `BitmapImage` is provided, the constructed `BitmapImage` is a deep clone of the provided one, so that each image's pixel data can subsequently be modified without affecting each other.
             *
             * `backgroundRGBA` is an optional parameter representing a pixel as a single number. In hex, the number is as follows: 0xRRGGBBAA, where RR is the red byte, GG the green byte, BB, the blue byte, and AA the alpha value. An AA of 0x00 is considered transparent, and all non-zero AA values are treated as opaque.
             */
            constructor(...args) {
              if (args.length === 0) {
                throw new Error("constructor requires parameters");
              }
              const firstArg = args[0];
              if (firstArg !== null && typeof firstArg === "object") {
                if (firstArg instanceof BitmapImage) {
                  const sourceBitmap = firstArg.bitmap;
                  this.bitmap = {
                    width: sourceBitmap.width,
                    height: sourceBitmap.height,
                    data: new Buffer(sourceBitmap.width * sourceBitmap.height * 4)
                  };
                  sourceBitmap.data.copy(this.bitmap.data);
                } else if (firstArg.width && firstArg.height && firstArg.data) {
                  this.bitmap = firstArg;
                } else {
                  throw new Error("unrecognized constructor parameters");
                }
              } else if (typeof firstArg === "number" && typeof args[1] === "number") {
                const width = firstArg;
                const height = args[1];
                const thirdArg = args[2];
                this.bitmap = { width, height };
                if (Buffer.isBuffer(thirdArg)) {
                  this.bitmap.data = thirdArg;
                } else {
                  this.bitmap.data = new Buffer(width * height * 4);
                  if (typeof thirdArg === "number") {
                    this.fillRGBA(thirdArg);
                  }
                }
              } else {
                throw new Error("unrecognized constructor parameters");
              }
            }
            /**
             * Copy a square portion of this image into another image. 
             * 
             * @param {BitmapImage} toImage Image into which to copy the square
             * @param {number} toX x-coord in toImage of upper-left corner of receiving square
             * @param {number} toY y-coord in toImage of upper-left corner of receiving square
             * @param {number} fromX x-coord in this image of upper-left corner of source square
             * @param {number} fromY y-coord in this image of upper-left corner of source square
             * @return {BitmapImage} The present image to allow for chaining.
             */
            blit(toImage, toX, toY, fromX, fromY, fromWidth, fromHeight) {
              if (fromX + fromWidth > this.bitmap.width) {
                throw new Error("copy exceeds width of source bitmap");
              }
              if (toX + fromWidth > toImage.bitmap.width) {
                throw new Error("copy exceeds width of target bitmap");
              }
              if (fromY + fromHeight > this.bitmap.height) {
                throw new Error("copy exceeds height of source bitmap");
              }
              if (toY + fromHeight > toImage.bitmap.height) {
                throw new Erro("copy exceeds height of target bitmap");
              }
              const sourceBuf = this.bitmap.data;
              const targetBuf = toImage.bitmap.data;
              const sourceByteWidth = this.bitmap.width * 4;
              const targetByteWidth = toImage.bitmap.width * 4;
              const copyByteWidth = fromWidth * 4;
              let si = fromY * sourceByteWidth + fromX * 4;
              let ti = toY * targetByteWidth + toX * 4;
              while (--fromHeight >= 0) {
                sourceBuf.copy(targetBuf, ti, si, si + copyByteWidth);
                si += sourceByteWidth;
                ti += targetByteWidth;
              }
              return this;
            }
            /**
             * Fills the image with a single color.
             * 
             * @param {number} rgba Color with which to fill image, expressed as a singlenumber in the form 0xRRGGBBAA, where AA is 0x00 for transparent and any other value for opaque.
             * @return {BitmapImage} The present image to allow for chaining.
             */
            fillRGBA(rgba) {
              const buf = this.bitmap.data;
              const bufByteWidth = this.bitmap.height * 4;
              let bi = 0;
              while (bi < bufByteWidth) {
                buf.writeUInt32BE(rgba, bi);
                bi += 4;
              }
              while (bi < buf.length) {
                buf.copy(buf, bi, 0, bufByteWidth);
                bi += bufByteWidth;
              }
              return this;
            }
            /**
             * Gets the RGBA number of the pixel at the given coordinate in the form 0xRRGGBBAA, where AA is the alpha value, with alpha 0x00 encoding to transparency in GIFs.
             * 
             * @param {number} x x-coord of pixel
             * @param {number} y y-coord of pixel
             * @return {number} RGBA of pixel in 0xRRGGBBAA form
             */
            getRGBA(x, y) {
              const bi = (y * this.bitmap.width + x) * 4;
              return this.bitmap.data.readUInt32BE(bi);
            }
            /**
             * Gets a set of all RGBA colors found within the image.
             * 
             * @return {Set} Set of all RGBA colors that the image contains.
             */
            getRGBASet() {
              const rgbaSet = /* @__PURE__ */ new Set();
              const buf = this.bitmap.data;
              for (let bi = 0; bi < buf.length; bi += 4) {
                rgbaSet.add(buf.readUInt32BE(bi, true));
              }
              return rgbaSet;
            }
            /**
             * Converts the image to greyscale using inferred Adobe metrics.
             * 
             * @return {BitmapImage} The present image to allow for chaining.
             */
            greyscale() {
              const buf = this.bitmap.data;
              this.scan(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {
                const grey = Math.round(
                  0.299 * buf[idx] + 0.587 * buf[idx + 1] + 0.114 * buf[idx + 2]
                );
                buf[idx] = grey;
                buf[idx + 1] = grey;
                buf[idx + 2] = grey;
              });
              return this;
            }
            /**
             * Reframes the image as if placing a frame around the original image and replacing the original image with the newly framed image. When the new frame is strictly within the boundaries of the original image, this method crops the image. When any of the new boundaries exceed those of the original image, the `fillRGBA` must be provided to indicate the color with which to fill the extra space added to the image.
             * 
             * @param {number} xOffset The x-coord offset of the upper-left pixel of the desired image relative to the present image.
             * @param {number} yOffset The y-coord offset of the upper-left pixel of the desired image relative to the present image.
             * @param {number} width The width of the new image after reframing
             * @param {number} height The height of the new image after reframing
             * @param {number} fillRGBA The color with which to fill space added to the image as a result of the reframing, in 0xRRGGBBAA format, where AA is 0x00 to indicate transparent and a non-zero value to indicate opaque. This parameter is only required when the reframing exceeds the original boundaries (i.e. does not simply perform a crop).
             * @return {BitmapImage} The present image to allow for chaining.
             */
            reframe(xOffset, yOffset, width, height, fillRGBA) {
              const cropX = xOffset < 0 ? 0 : xOffset;
              const cropY = yOffset < 0 ? 0 : yOffset;
              const cropWidth = width + cropX > this.bitmap.width ? this.bitmap.width - cropX : width;
              const cropHeight = height + cropY > this.bitmap.height ? this.bitmap.height - cropY : height;
              const newX = xOffset < 0 ? -xOffset : 0;
              const newY = yOffset < 0 ? -yOffset : 0;
              let image;
              if (fillRGBA === void 0) {
                if (cropX !== xOffset || cropY != yOffset || cropWidth !== width || cropHeight !== height) {
                  throw new GifError(`fillRGBA required for this reframing`);
                }
                image = new BitmapImage(width, height);
              } else {
                image = new BitmapImage(width, height, fillRGBA);
              }
              this.blit(image, newX, newY, cropX, cropY, cropWidth, cropHeight);
              this.bitmap = image.bitmap;
              return this;
            }
            /**
             * Scales the image size up by an integer factor. Each pixel of the original image becomes a square of the same color in the new image having a size of `factor` x `factor` pixels.
             * 
             * @param {number} factor The factor by which to scale up the image. Must be an integer >= 1.
             * @return {BitmapImage} The present image to allow for chaining.
             */
            scale(factor) {
              if (factor === 1) {
                return;
              }
              if (!Number.isInteger(factor) || factor < 1) {
                throw new Error("the scale must be an integer >= 1");
              }
              const sourceWidth = this.bitmap.width;
              const sourceHeight = this.bitmap.height;
              const destByteWidth = sourceWidth * factor * 4;
              const sourceBuf = this.bitmap.data;
              const destBuf = new Buffer(sourceHeight * destByteWidth * factor);
              let sourceIndex = 0;
              let priorDestRowIndex;
              let destIndex = 0;
              for (let y = 0; y < sourceHeight; ++y) {
                priorDestRowIndex = destIndex;
                for (let x = 0; x < sourceWidth; ++x) {
                  const color = sourceBuf.readUInt32BE(sourceIndex, true);
                  for (let cx = 0; cx < factor; ++cx) {
                    destBuf.writeUInt32BE(color, destIndex);
                    destIndex += 4;
                  }
                  sourceIndex += 4;
                }
                for (let cy = 1; cy < factor; ++cy) {
                  destBuf.copy(destBuf, destIndex, priorDestRowIndex, destIndex);
                  destIndex += destByteWidth;
                  priorDestRowIndex += destByteWidth;
                }
              }
              this.bitmap = {
                width: sourceWidth * factor,
                height: sourceHeight * factor,
                data: destBuf
              };
              return this;
            }
            /**
             * Scans all coordinates of the image, handing each in turn to the provided handler function.
             *
             * @param {function} scanHandler A function(x: number, y: number, bi: number) to be called for each pixel of the image with that pixel's x-coord, y-coord, and index into the `data` buffer. The function accesses the pixel at this coordinate by accessing the `this.data` at index `bi`.
             * @see scanAllIndexes
             */
            scanAllCoords(scanHandler) {
              const width = this.bitmap.width;
              const bufferLength = this.bitmap.data.length;
              let x = 0;
              let y = 0;
              for (let bi = 0; bi < bufferLength; bi += 4) {
                scanHandler(x, y, bi);
                if (++x === width) {
                  x = 0;
                  ++y;
                }
              }
            }
            /**
             * Scans all pixels of the image, handing the index of each in turn to the provided handler function. Runs a bit faster than `scanAllCoords()`, should the handler not need pixel coordinates.
             *
             * @param {function} scanHandler A function(bi: number) to be called for each pixel of the image with that pixel's index into the `data` buffer. The pixels is found at index 'bi' within `this.data`.
             * @see scanAllCoords
             */
            scanAllIndexes(scanHandler) {
              const bufferLength = this.bitmap.data.length;
              for (let bi = 0; bi < bufferLength; bi += 4) {
                scanHandler(bi);
              }
            }
          }
          module3.exports = BitmapImage;
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 48 }], 66: [function(require2, module3, exports3) {
        "use strict";
        class Gif {
          // width - width of GIF in pixels
          // height - height of GIF in pixels
          // loops - 0 = unending; (n > 0) = iterate n times
          // usesTransparency - whether any frames have transparent pixels
          // colorScope - scope of color tables in GIF
          // frames - array of frames
          // buffer - GIF-formatted data
          /**
           * Gif is a class representing an encoded GIF. It is intended to be a read-only representation of a byte-encoded GIF. Only encoders and decoders should be creating instances of this class.
           * 
           * Property | Description
           * --- | ---
           * width | width of the GIF at its widest
           * height | height of the GIF at its highest
           * loops | the number of times the GIF should loop before stopping; 0 => loop indefinately
           * usesTransparency | boolean indicating whether at least one frame contains at least one transparent pixel
           * colorScope | the scope of the color tables as encoded within the GIF; either Gif.GlobalColorsOnly (== 1) or Gif.LocalColorsOnly (== 2).
           * frames | a array of GifFrame instances, one for each frame of the GIF
           * buffer | a Buffer holding the encoding's byte data
           * 
           * Its constructor should only ever be called by the GIF encoder or decoder.
           *
           * @param {Buffer} buffer A Buffer containing the encoded bytes
           * @param {GifFrame[]} frames Array of frames found in the encoding
           * @param {object} spec Properties of the encoding as listed above
           */
          constructor(buffer, frames, spec) {
            this.width = spec.width;
            this.height = spec.height;
            this.loops = spec.loops;
            this.usesTransparency = spec.usesTransparency;
            this.colorScope = spec.colorScope;
            this.frames = frames;
            this.buffer = buffer;
          }
        }
        Gif.GlobalColorsPreferred = 0;
        Gif.GlobalColorsOnly = 1;
        Gif.LocalColorsOnly = 2;
        class GifError2 extends Error {
          /**
           * GifError is a class representing a GIF-related error
           * 
           * @param {string|Error} messageOrError
           */
          constructor(messageOrError) {
            super(messageOrError);
            if (messageOrError instanceof Error) {
              this.stack = "Gif" + messageOrError.stack;
            }
          }
        }
        exports3.Gif = Gif;
        exports3.GifError = GifError2;
      }, {}], 67: [function(require2, module3, exports3) {
        (function(process, Buffer) {
          "use strict";
          const Omggif = require2("omggif");
          const { Gif, GifError: GifError2 } = require2("./gif");
          let GifUtil;
          process.nextTick(() => {
            GifUtil = require2("./gifutil");
          });
          const { GifFrame } = require2("./gifframe");
          const PER_GIF_OVERHEAD = 200;
          const PER_FRAME_OVERHEAD = 100;
          class GifCodec {
            // _transparentRGBA - RGB given to transparent pixels (alpha=0) on decode; defaults to null indicating 0x000000, which is fastest
            /**
             * GifCodec is a class that both encodes and decodes GIFs. It implements both the `encode()` method expected of an encoder and the `decode()` method expected of a decoder, and it wraps the `omggif` GIF encoder/decoder package. GifCodec serves as this library's default encoder and decoder, but it's possible to wrap other GIF encoders and decoders for use by `gifwrap` as well. GifCodec will not encode GIFs with interlacing.
             * 
             * Instances of this class are stateless and can be shared across multiple encodings and decodings.
             * 
             * Its constructor takes one option argument:
             * 
             * @param {object} options Optionally takes an objection whose only possible property is `transparentRGB`. Images are internally represented in RGBA format, where A is the alpha value of a pixel. When `transparentRGB` is provided, this RGB value (excluding alpha) is assigned to transparent pixels, which are also given alpha value 0x00. (All opaque pixels are given alpha value 0xFF). The RGB color of transparent pixels shouldn't matter for most applications. Defaults to 0x000000.
             */
            constructor(options = {}) {
              this._transparentRGB = null;
              if (typeof options.transparentRGB === "number" && options.transparentRGB !== 0) {
                this._transparentRGBA = options.transparentRGB * 256;
              }
              this._testInitialBufferSize = 0;
            }
            /**
             * Decodes a GIF from a Buffer to yield an instance of Gif. Transparent pixels of the GIF are given alpha values of 0x00, and opaque pixels are given alpha values of 0xFF. The RGB values of transparent pixels default to 0x000000 but can be overridden by the constructor's `transparentRGB` option.
             * 
             * @param {Buffer} buffer Bytes of an encoded GIF to decode.
             * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.
             * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.
             */
            decodeGif(buffer) {
              try {
                let reader;
                try {
                  reader = new Omggif.GifReader(buffer);
                } catch (err) {
                  throw new GifError2(err);
                }
                const frameCount = reader.numFrames();
                const frames = [];
                const spec = {
                  width: reader.width,
                  height: reader.height,
                  loops: reader.loopCount()
                };
                spec.usesTransparency = false;
                for (let i = 0; i < frameCount; ++i) {
                  const frameInfo = this._decodeFrame(reader, i, spec.usesTransparency);
                  frames.push(frameInfo.frame);
                  if (frameInfo.usesTransparency) {
                    spec.usesTransparency = true;
                  }
                }
                return Promise.resolve(new Gif(buffer, frames, spec));
              } catch (err) {
                return Promise.reject(err);
              }
            }
            /**
             * Encodes a GIF from provided frames. Each pixel having an alpha value of 0x00 renders as transparent within the encoding, while all pixels of non-zero alpha value render as opaque.
             * 
             * @param {GifFrame[]} frames Array of frames to encode
             * @param {object} spec An optional object that may provide values for `loops` and `colorScope`, as defined for the Gif class. However, `colorSpace` may also take the value Gif.GlobalColorsPreferred (== 0) to indicate that the encoder should attempt to create only a global color table. `loop` defaults to 0, looping indefinitely, and `colorScope` defaults to Gif.GlobalColorsPreferred.
             * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.
             * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.
             */
            encodeGif(frames, spec = {}) {
              try {
                if (frames === null || frames.length === 0) {
                  throw new GifError2("there are no frames");
                }
                const dims = GifUtil.getMaxDimensions(frames);
                spec = Object.assign({}, spec);
                spec.width = dims.maxWidth;
                spec.height = dims.maxHeight;
                spec.loops = spec.loops || 0;
                spec.colorScope = spec.colorScope || Gif.GlobalColorsPreferred;
                return Promise.resolve(this._encodeGif(frames, spec));
              } catch (err) {
                return Promise.reject(err);
              }
            }
            _decodeFrame(reader, frameIndex, alreadyUsedTransparency) {
              let info, buffer;
              try {
                info = reader.frameInfo(frameIndex);
                buffer = new Buffer(reader.width * reader.height * 4);
                reader.decodeAndBlitFrameRGBA(frameIndex, buffer);
                if (info.width !== reader.width || info.height !== reader.height) {
                  if (info.y) {
                    buffer = buffer.slice(info.y * reader.width * 4);
                  }
                  if (reader.width > info.width) {
                    for (let ii = 0; ii < info.height; ++ii) {
                      buffer.copy(
                        buffer,
                        ii * info.width * 4,
                        (info.x + ii * reader.width) * 4,
                        (info.x + ii * reader.width) * 4 + info.width * 4
                      );
                    }
                  }
                  buffer = buffer.slice(0, info.width * info.height * 4);
                }
              } catch (err) {
                throw new GifError2(err);
              }
              let usesTransparency = false;
              if (this._transparentRGBA === null) {
                if (!alreadyUsedTransparency) {
                  for (let i = 3; i < buffer.length; i += 4) {
                    if (buffer[i] === 0) {
                      usesTransparency = true;
                      i = buffer.length;
                    }
                  }
                }
              } else {
                for (let i = 3; i < buffer.length; i += 4) {
                  if (buffer[i] === 0) {
                    buffer.writeUInt32BE(this._transparentRGBA, i - 3);
                    usesTransparency = true;
                  }
                }
              }
              const frame = new GifFrame(info.width, info.height, buffer, {
                xOffset: info.x,
                yOffset: info.y,
                disposalMethod: info.disposal,
                interlaced: info.interlaced,
                delayCentisecs: info.delay
              });
              return { frame, usesTransparency };
            }
            _encodeGif(frames, spec) {
              let colorInfo;
              if (spec.colorScope === Gif.LocalColorsOnly) {
                colorInfo = GifUtil.getColorInfo(frames, 0);
              } else {
                colorInfo = GifUtil.getColorInfo(frames, 256);
                if (!colorInfo.colors) {
                  if (spec.colorScope === Gif.GlobalColorsOnly) {
                    throw new GifError2(
                      "Too many color indexes for global color table"
                    );
                  }
                  spec.colorScope = Gif.LocalColorsOnly;
                }
              }
              spec.usesTransparency = colorInfo.usesTransparency;
              const localPalettes = colorInfo.palettes;
              if (spec.colorScope === Gif.LocalColorsOnly) {
                const localSizeEst = 2e3;
                return _encodeLocal(frames, spec, localSizeEst, localPalettes);
              }
              const globalSizeEst = 2e3;
              return _encodeGlobal(frames, spec, globalSizeEst, colorInfo);
            }
            _getSizeEstimateGlobal(globalPalette, frames) {
              if (this._testInitialBufferSize > 0) {
                return this._testInitialBufferSize;
              }
              let sizeEst = PER_GIF_OVERHEAD + 3 * 256;
              const pixelBitWidth = _getPixelBitWidth(globalPalette);
              frames.forEach((frame) => {
                sizeEst += _getFrameSizeEst(frame, pixelBitWidth);
              });
              return sizeEst;
            }
            _getSizeEstimateLocal(palettes, frames) {
              if (this._testInitialBufferSize > 0) {
                return this._testInitialBufferSize;
              }
              let sizeEst = PER_GIF_OVERHEAD;
              for (let i = 0; i < frames.length; ++i) {
                const palette = palettes[i];
                const pixelBitWidth = _getPixelBitWidth(palette);
                sizeEst += _getFrameSizeEst(frames[i], pixelBitWidth);
              }
              return sizeEst;
            }
          }
          exports3.GifCodec = GifCodec;
          function _colorLookupLinear(colors, color) {
            const index = colors.indexOf(color);
            return index === -1 ? null : index;
          }
          function _colorLookupBinary(colors, color) {
            var lo = 0, hi = colors.length - 1, mid;
            while (lo <= hi) {
              mid = Math.floor((lo + hi) / 2);
              if (colors[mid] > color)
                hi = mid - 1;
              else if (colors[mid] < color)
                lo = mid + 1;
              else
                return mid;
            }
            return null;
          }
          function _encodeGlobal(frames, spec, bufferSizeEst, globalPalette) {
            const extendedGlobalPalette = {
              colors: globalPalette.colors.slice(),
              usesTransparency: globalPalette.usesTransparency
            };
            _extendPaletteToPowerOf2(extendedGlobalPalette);
            const options = {
              palette: extendedGlobalPalette.colors,
              loop: spec.loops
            };
            let buffer = new Buffer(bufferSizeEst);
            let gifWriter;
            try {
              gifWriter = new Omggif.GifWriter(
                buffer,
                spec.width,
                spec.height,
                options
              );
            } catch (err) {
              throw new GifError2(err);
            }
            for (let i = 0; i < frames.length; ++i) {
              buffer = _writeFrame(gifWriter, i, frames[i], globalPalette, false);
            }
            return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
          }
          function _encodeLocal(frames, spec, bufferSizeEst, localPalettes) {
            const options = {
              loop: spec.loops
            };
            let buffer = new Buffer(bufferSizeEst);
            let gifWriter;
            try {
              gifWriter = new Omggif.GifWriter(
                buffer,
                spec.width,
                spec.height,
                options
              );
            } catch (err) {
              throw new GifError2(err);
            }
            for (let i = 0; i < frames.length; ++i) {
              buffer = _writeFrame(gifWriter, i, frames[i], localPalettes[i], true);
            }
            return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
          }
          function _extendPaletteToPowerOf2(palette) {
            const colors = palette.colors;
            if (palette.usesTransparency) {
              colors.push(0);
            }
            const colorCount = colors.length;
            let powerOf2 = 2;
            while (colorCount > powerOf2) {
              powerOf2 <<= 1;
            }
            colors.length = powerOf2;
            colors.fill(0, colorCount);
          }
          function _getFrameSizeEst(frame, pixelBitWidth) {
            let byteLength = frame.bitmap.width * frame.bitmap.height;
            byteLength = Math.ceil(byteLength * pixelBitWidth / 8);
            byteLength += Math.ceil(byteLength / 255);
            return PER_FRAME_OVERHEAD + byteLength + 3 * 256;
          }
          function _getIndexedImage(frameIndex, frame, palette) {
            const colors = palette.colors;
            const colorToIndexFunc = colors.length <= 8 ? (
              // guess at the break-even
              _colorLookupLinear
            ) : _colorLookupBinary;
            const colorBuffer = frame.bitmap.data;
            const indexBuffer = new Buffer(colorBuffer.length / 4);
            let transparentIndex = colors.length;
            let i = 0, j = 0;
            while (i < colorBuffer.length) {
              if (colorBuffer[i + 3] !== 0) {
                const color = colorBuffer.readUInt32BE(i, true) >> 8 & 16777215;
                indexBuffer[j] = colorToIndexFunc(colors, color);
              } else {
                indexBuffer[j] = transparentIndex;
              }
              i += 4;
              ++j;
            }
            if (palette.usesTransparency) {
              if (transparentIndex === 256) {
                throw new GifError2(`Frame ${frameIndex} already has 256 colorsand so can't use transparency`);
              }
            } else {
              transparentIndex = null;
            }
            return { buffer: indexBuffer, transparentIndex };
          }
          function _getPixelBitWidth(palette) {
            let indexCount = palette.indexCount;
            let pixelBitWidth = 0;
            --indexCount;
            while (indexCount) {
              ++pixelBitWidth;
              indexCount >>= 1;
            }
            return pixelBitWidth > 0 ? pixelBitWidth : 1;
          }
          function _writeFrame(gifWriter, frameIndex, frame, palette, isLocalPalette) {
            if (frame.interlaced) {
              throw new GifError2("writing interlaced GIFs is not supported");
            }
            const frameInfo = _getIndexedImage(frameIndex, frame, palette);
            const options = {
              delay: frame.delayCentisecs,
              disposal: frame.disposalMethod,
              transparent: frameInfo.transparentIndex
            };
            if (isLocalPalette) {
              _extendPaletteToPowerOf2(palette);
              options.palette = palette.colors;
            }
            try {
              let buffer = gifWriter.getOutputBuffer();
              let startOfFrame = gifWriter.getOutputBufferPosition();
              let endOfFrame;
              let tryAgain = true;
              while (tryAgain) {
                endOfFrame = gifWriter.addFrame(
                  frame.xOffset,
                  frame.yOffset,
                  frame.bitmap.width,
                  frame.bitmap.height,
                  frameInfo.buffer,
                  options
                );
                tryAgain = false;
                if (endOfFrame >= buffer.length - 1) {
                  const biggerBuffer = new Buffer(buffer.length * 1.5);
                  buffer.copy(biggerBuffer);
                  gifWriter.setOutputBuffer(biggerBuffer);
                  gifWriter.setOutputBufferPosition(startOfFrame);
                  buffer = biggerBuffer;
                  tryAgain = true;
                }
              }
              return buffer;
            } catch (err) {
              throw new GifError2(err);
            }
          }
        }).call(this, require2("_process"), require2("buffer").Buffer);
      }, { "./gif": 66, "./gifframe": 68, "./gifutil": 69, "_process": 133, "buffer": 48, "omggif": 64 }], 68: [function(require2, module3, exports3) {
        "use strict";
        const BitmapImage = require2("./bitmapimage");
        const { GifError: GifError2 } = require2("./gif");
        class GifFrame extends BitmapImage {
          // xOffset - x offset of bitmap on GIF (defaults to 0)
          // yOffset - y offset of bitmap on GIF (defaults to 0)
          // disposalMethod - pixel disposal method when handling partial images
          // delayCentisecs - duration of frame in hundredths of a second
          // interlaced - whether the image is interlaced (defaults to false)
          /**
           * GifFrame is a class representing an image frame of a GIF. GIFs contain one or more instances of GifFrame.
           * 
           * Property | Description
           * --- | ---
           * xOffset | x-coord of position within GIF at which to render the image (defaults to 0)
           * yOffset | y-coord of position within GIF at which to render the image (defaults to 0)
           * disposalMethod | GIF disposal method; only relevant when the frames aren't all the same size (defaults to 2, disposing to background color)
           * delayCentisecs | duration of the frame in hundreths of a second
           * interlaced | boolean indicating whether the frame renders interlaced
           * 
           * Its constructor supports the following signatures:
           * 
           * * new GifFrame(bitmap: {width: number, height: number, data: Buffer}, options?)
           * * new GifFrame(bitmapImage: BitmapImage, options?)
           * * new GifFrame(width: number, height: number, buffer: Buffer, options?)
           * * new GifFrame(width: number, height: number, backgroundRGBA?: number, options?)
           * * new GifFrame(frame: GifFrame)
           * 
           * See the base class BitmapImage for a discussion of all parameters but `options` and `frame`. `options` is an optional argument providing initial values for the above-listed GifFrame properties. Each property within option is itself optional.
           * 
           * Provide a `frame` to the constructor to create a clone of the provided frame. The new frame includes a copy of the provided frame's pixel data so that each can subsequently be modified without affecting each other.
           */
          constructor(...args) {
            super(...args);
            if (args[0] instanceof GifFrame) {
              const source = args[0];
              this.xOffset = source.xOffset;
              this.yOffset = source.yOffset;
              this.disposalMethod = source.disposalMethod;
              this.delayCentisecs = source.delayCentisecs;
              this.interlaced = source.interlaced;
            } else {
              const lastArg = args[args.length - 1];
              let options = {};
              if (typeof lastArg === "object" && !(lastArg instanceof BitmapImage)) {
                options = lastArg;
              }
              this.xOffset = options.xOffset || 0;
              this.yOffset = options.yOffset || 0;
              this.disposalMethod = options.disposalMethod !== void 0 ? options.disposalMethod : GifFrame.DisposeToBackgroundColor;
              this.delayCentisecs = options.delayCentisecs || 8;
              this.interlaced = options.interlaced || false;
            }
          }
          /**
           * Get a summary of the colors found within the frame. The return value is an object of the following form:
           * 
           * Property | Description
           * --- | ---
           * colors | An array of all the opaque colors found within the frame. Each color is given as an RGB number of the form 0xRRGGBB. The array is sorted by increasing number. Will be an empty array when the image is completely transparent.
           * usesTransparency | boolean indicating whether there are any transparent pixels within the frame. A pixel is considered transparent if its alpha value is 0x00.
           * indexCount | The number of color indexes required to represent this palette of colors. It is equal to the number of opaque colors plus one if the image includes transparency.
           * 
           * @return {object} An object representing a color palette as described above.
           */
          getPalette() {
            const colorSet = /* @__PURE__ */ new Set();
            const buf = this.bitmap.data;
            let i = 0;
            let usesTransparency = false;
            while (i < buf.length) {
              if (buf[i + 3] === 0) {
                usesTransparency = true;
              } else {
                const color = buf.readUInt32BE(i, true) >> 8 & 16777215;
                colorSet.add(color);
              }
              i += 4;
            }
            const colors = new Array(colorSet.size);
            const iter = colorSet.values();
            for (i = 0; i < colors.length; ++i) {
              colors[i] = iter.next().value;
            }
            colors.sort((a, b) => a - b);
            let indexCount = colors.length;
            if (usesTransparency) {
              ++indexCount;
            }
            return { colors, usesTransparency, indexCount };
          }
        }
        GifFrame.DisposeToAnything = 0;
        GifFrame.DisposeNothing = 1;
        GifFrame.DisposeToBackgroundColor = 2;
        GifFrame.DisposeToPrevious = 3;
        exports3.GifFrame = GifFrame;
      }, { "./bitmapimage": 65, "./gif": 66 }], 69: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          const fs = require2("fs");
          const ImageQ = require2("image-q");
          const BitmapImage = require2("./bitmapimage");
          const { GifFrame } = require2("./gifframe");
          const { GifError: GifError2 } = require2("./gif");
          const { GifCodec } = require2("./gifcodec");
          const INVALID_SUFFIXES = [".jpg", ".jpeg", ".png", ".bmp"];
          const defaultCodec = new GifCodec();
          exports3.cloneFrames = function(frames) {
            let clones = [];
            frames.forEach((frame) => {
              clones.push(new GifFrame(frame));
            });
            return clones;
          };
          exports3.getColorInfo = function(frames, maxGlobalIndex) {
            let usesTransparency = false;
            const palettes = [];
            for (let i = 0; i < frames.length; ++i) {
              let palette = frames[i].getPalette();
              if (palette.usesTransparency) {
                usesTransparency = true;
              }
              if (palette.indexCount > 256) {
                throw new GifError2(`Frame ${i} uses more than 256 color indexes`);
              }
              palettes.push(palette);
            }
            if (maxGlobalIndex === 0) {
              return { usesTransparency, palettes };
            }
            const globalColorSet = /* @__PURE__ */ new Set();
            palettes.forEach((palette) => {
              palette.colors.forEach((color) => {
                globalColorSet.add(color);
              });
            });
            let indexCount = globalColorSet.size;
            if (usesTransparency) {
              ++indexCount;
            }
            if (maxGlobalIndex && indexCount > maxGlobalIndex) {
              return { usesTransparency, palettes };
            }
            const colors = new Array(globalColorSet.size);
            const iter = globalColorSet.values();
            for (let i = 0; i < colors.length; ++i) {
              colors[i] = iter.next().value;
            }
            colors.sort((a, b) => a - b);
            return { colors, indexCount, usesTransparency, palettes };
          };
          exports3.copyAsJimp = function(jimp, bitmapImageToCopy) {
            return exports3.shareAsJimp(jimp, new BitmapImage(bitmapImageToCopy));
          };
          exports3.getMaxDimensions = function(frames) {
            let maxWidth = 0, maxHeight = 0;
            frames.forEach((frame) => {
              const width = frame.xOffset + frame.bitmap.width;
              if (width > maxWidth) {
                maxWidth = width;
              }
              const height = frame.yOffset + frame.bitmap.height;
              if (height > maxHeight) {
                maxHeight = height;
              }
            });
            return { maxWidth, maxHeight };
          };
          exports3.quantizeDekker = function(imageOrImages, maxColorIndexes, dither) {
            maxColorIndexes = maxColorIndexes || 256;
            _quantize(imageOrImages, "NeuQuantFloat", maxColorIndexes, 0, dither);
          };
          exports3.quantizeSorokin = function(imageOrImages, maxColorIndexes, histogram, dither) {
            maxColorIndexes = maxColorIndexes || 256;
            histogram = histogram || "min-pop";
            let histogramID;
            switch (histogram) {
              case "min-pop":
                histogramID = 2;
                break;
              case "top-pop":
                histogramID = 1;
                break;
              default:
                throw new Error(`Invalid quantizeSorokin histogram '${histogram}'`);
            }
            _quantize(imageOrImages, "RGBQuant", maxColorIndexes, histogramID, dither);
          };
          exports3.quantizeWu = function(imageOrImages, maxColorIndexes, significantBits, dither) {
            maxColorIndexes = maxColorIndexes || 256;
            significantBits = significantBits || 5;
            if (significantBits < 1 || significantBits > 8) {
              throw new Error("Invalid quantization quality");
            }
            _quantize(imageOrImages, "WuQuant", maxColorIndexes, significantBits, dither);
          };
          exports3.read = function(source, decoder) {
            decoder = decoder || defaultCodec;
            if (Buffer.isBuffer(source)) {
              return decoder.decodeGif(source);
            }
            return _readBinary(source).then((buffer) => {
              return decoder.decodeGif(buffer);
            });
          };
          exports3.shareAsJimp = function(jimp, bitmapImageToShare) {
            const jimpImage = new jimp(
              bitmapImageToShare.bitmap.width,
              bitmapImageToShare.bitmap.height,
              0
            );
            jimpImage.bitmap.data = bitmapImageToShare.bitmap.data;
            return jimpImage;
          };
          exports3.write = function(path, frames, spec, encoder) {
            encoder = encoder || defaultCodec;
            const matches = path.match(/\.[a-zA-Z]+$/);
            if (matches !== null && INVALID_SUFFIXES.includes(matches[0].toLowerCase())) {
              throw new Error(`GIF '${path}' has an unexpected suffix`);
            }
            return encoder.encodeGif(frames, spec).then((gif) => {
              return _writeBinary(path, gif.buffer).then(() => {
                return gif;
              });
            });
          };
          function _quantize(imageOrImages, method, maxColorIndexes, modifier, dither) {
            const images = Array.isArray(imageOrImages) ? imageOrImages : [imageOrImages];
            const ditherAlgs = [
              "FloydSteinberg",
              "FalseFloydSteinberg",
              "Stucki",
              "Atkinson",
              "Jarvis",
              "Burkes",
              "Sierra",
              "TwoSierra",
              "SierraLite"
            ];
            if (dither) {
              if (ditherAlgs.indexOf(dither.ditherAlgorithm) < 0) {
                throw new Error(`Invalid ditherAlgorithm '${dither.ditherAlgorithm}'`);
              }
              if (dither.serpentine === void 0) {
                dither.serpentine = true;
              }
              if (dither.minimumColorDistanceToDither === void 0) {
                dither.minimumColorDistanceToDither = 0;
              }
              if (dither.calculateErrorLikeGIMP === void 0) {
                dither.calculateErrorLikeGIMP = false;
              }
            }
            const distCalculator = new ImageQ.distance.Euclidean();
            const quantizer = new ImageQ.palette[method](distCalculator, maxColorIndexes, modifier);
            let imageMaker;
            if (dither) {
              imageMaker = new ImageQ.image.ErrorDiffusionArray(
                distCalculator,
                ImageQ.image.ErrorDiffusionArrayKernel[dither.ditherAlgorithm],
                dither.serpentine,
                dither.minimumColorDistanceToDither,
                dither.calculateErrorLikeGIMP
              );
            } else {
              imageMaker = new ImageQ.image.NearestColor(distCalculator);
            }
            const inputContainers = [];
            images.forEach((image) => {
              const imageBuf = image.bitmap.data;
              const inputBuf = new ArrayBuffer(imageBuf.length);
              const inputArray = new Uint32Array(inputBuf);
              for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) {
                inputArray[ai] = imageBuf.readUInt32LE(bi, true);
              }
              const inputContainer = ImageQ.utils.PointContainer.fromUint32Array(
                inputArray,
                image.bitmap.width,
                image.bitmap.height
              );
              quantizer.sample(inputContainer);
              inputContainers.push(inputContainer);
            });
            const limitedPalette = quantizer.quantize();
            for (let i = 0; i < images.length; ++i) {
              const imageBuf = images[i].bitmap.data;
              const outputContainer = imageMaker.quantize(inputContainers[i], limitedPalette);
              const outputArray = outputContainer.toUint32Array();
              for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) {
                imageBuf.writeUInt32LE(outputArray[ai], bi);
              }
            }
          }
          function _readBinary(path) {
            return new Promise((resolve, reject) => {
              fs.readFile(path, (err, buffer) => {
                if (err) {
                  return reject(err);
                }
                return resolve(buffer);
              });
            });
          }
          function _writeBinary(path, buffer) {
            return new Promise((resolve, reject) => {
              fs.writeFile(path, buffer, (err) => {
                if (err) {
                  return reject(err);
                }
                return resolve();
              });
            });
          }
        }).call(this, { "isBuffer": require2("../../is-buffer/index.js") });
      }, { "../../is-buffer/index.js": 76, "./bitmapimage": 65, "./gif": 66, "./gifcodec": 67, "./gifframe": 68, "fs": 47, "image-q": 74 }], 70: [function(require2, module3, exports3) {
        "use strict";
        const BitmapImage = require2("./bitmapimage");
        const { Gif, GifError: GifError2 } = require2("./gif");
        const { GifCodec } = require2("./gifcodec");
        const { GifFrame } = require2("./gifframe");
        const GifUtil = require2("./gifutil");
        module3.exports = {
          BitmapImage,
          Gif,
          GifCodec,
          GifFrame,
          GifUtil,
          GifError: GifError2
        };
      }, { "./bitmapimage": 65, "./gif": 66, "./gifcodec": 67, "./gifframe": 68, "./gifutil": 69 }], 71: [function(require2, module3, exports3) {
        (function(global2) {
          var win;
          if (typeof window !== "undefined") {
            win = window;
          } else if (typeof global2 !== "undefined") {
            win = global2;
          } else if (typeof self !== "undefined") {
            win = self;
          } else {
            win = {};
          }
          module3.exports = win;
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 72: [function(require2, module3, exports3) {
        var http = require2("http");
        var url = require2("url");
        var https = module3.exports;
        for (var key in http) {
          if (http.hasOwnProperty(key))
            https[key] = http[key];
        }
        https.request = function(params, cb) {
          params = validateParams(params);
          return http.request.call(this, params, cb);
        };
        https.get = function(params, cb) {
          params = validateParams(params);
          return http.get.call(this, params, cb);
        };
        function validateParams(params) {
          if (typeof params === "string") {
            params = url.parse(params);
          }
          if (!params.protocol) {
            params.protocol = "https:";
          }
          if (params.protocol !== "https:") {
            throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
          }
          return params;
        }
      }, { "http": 156, "url": 180 }], 73: [function(require2, module3, exports3) {
        exports3.read = function(buffer, offset, isLE, mLen, nBytes) {
          var e, m;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var nBits = -7;
          var i = isLE ? nBytes - 1 : 0;
          var d = isLE ? -1 : 1;
          var s = buffer[offset + i];
          i += d;
          e = s & (1 << -nBits) - 1;
          s >>= -nBits;
          nBits += eLen;
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          m = e & (1 << -nBits) - 1;
          e >>= -nBits;
          nBits += mLen;
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
          }
          if (e === 0) {
            e = 1 - eBias;
          } else if (e === eMax) {
            return m ? NaN : (s ? -1 : 1) * Infinity;
          } else {
            m = m + Math.pow(2, mLen);
            e = e - eBias;
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        };
        exports3.write = function(buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c;
          var eLen = nBytes * 8 - mLen - 1;
          var eMax = (1 << eLen) - 1;
          var eBias = eMax >> 1;
          var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
          var i = isLE ? 0 : nBytes - 1;
          var d = isLE ? 1 : -1;
          var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
          value = Math.abs(value);
          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0;
            e = eMax;
          } else {
            e = Math.floor(Math.log(value) / Math.LN2);
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--;
              c *= 2;
            }
            if (e + eBias >= 1) {
              value += rt / c;
            } else {
              value += rt * Math.pow(2, 1 - eBias);
            }
            if (value * c >= 2) {
              e++;
              c /= 2;
            }
            if (e + eBias >= eMax) {
              m = 0;
              e = eMax;
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen);
              e = e + eBias;
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
              e = 0;
            }
          }
          for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
          }
          e = e << mLen | m;
          eLen += mLen;
          for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
          }
          buffer[offset + i - d] |= s * 128;
        };
      }, {}], 74: [function(require2, module3, exports3) {
        (function webpackUniversalModuleDefinition(root, factory) {
          if (typeof exports3 === "object" && typeof module3 === "object")
            module3.exports = factory();
          else if (typeof define2 === "function" && define2.amd)
            define2("iq", [], factory);
          else if (typeof exports3 === "object")
            exports3["iq"] = factory();
          else
            root["iq"] = factory();
        })(this, function() {
          return (
            /******/
            function(modules) {
              var installedModules = {};
              function __webpack_require__(moduleId) {
                if (installedModules[moduleId])
                  return installedModules[moduleId].exports;
                var module4 = installedModules[moduleId] = {
                  /******/
                  exports: {},
                  /******/
                  id: moduleId,
                  /******/
                  loaded: false
                  /******/
                };
                modules[moduleId].call(module4.exports, module4, module4.exports, __webpack_require__);
                module4.loaded = true;
                return module4.exports;
              }
              __webpack_require__.m = modules;
              __webpack_require__.c = installedModules;
              __webpack_require__.p = "";
              return __webpack_require__(0);
            }([
              /* 0 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var constants = __webpack_require__(1);
                exports4.constants = constants;
                var conversion = __webpack_require__(3);
                exports4.conversion = conversion;
                var distance = __webpack_require__(12);
                exports4.distance = distance;
                var palette = __webpack_require__(20);
                exports4.palette = palette;
                var image = __webpack_require__(30);
                exports4.image = image;
                var quality = __webpack_require__(35);
                exports4.quality = quality;
                var utils = __webpack_require__(37);
                exports4.utils = utils;
              },
              /* 1 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var bt709 = __webpack_require__(2);
                exports4.bt709 = bt709;
              },
              /* 2 */
              /***/
              function(module4, exports4) {
                "use strict";
                var Y;
                (function(Y2) {
                  Y2[Y2["RED"] = 0.2126] = "RED";
                  Y2[Y2["GREEN"] = 0.7152] = "GREEN";
                  Y2[Y2["BLUE"] = 0.0722] = "BLUE";
                  Y2[Y2["WHITE"] = 1] = "WHITE";
                })(Y || (Y = {}));
                exports4.Y = Y;
                var x;
                (function(x2) {
                  x2[x2["RED"] = 0.64] = "RED";
                  x2[x2["GREEN"] = 0.3] = "GREEN";
                  x2[x2["BLUE"] = 0.15] = "BLUE";
                  x2[x2["WHITE"] = 0.3127] = "WHITE";
                })(x || (x = {}));
                exports4.x = x;
                var y;
                (function(y2) {
                  y2[y2["RED"] = 0.33] = "RED";
                  y2[y2["GREEN"] = 0.6] = "GREEN";
                  y2[y2["BLUE"] = 0.06] = "BLUE";
                  y2[y2["WHITE"] = 0.329] = "WHITE";
                })(y || (y = {}));
                exports4.y = y;
              },
              /* 3 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var rgb2xyz_1 = __webpack_require__(4);
                exports4.rgb2xyz = rgb2xyz_1.rgb2xyz;
                var rgb2hsl_1 = __webpack_require__(5);
                exports4.rgb2hsl = rgb2hsl_1.rgb2hsl;
                var rgb2lab_1 = __webpack_require__(7);
                exports4.rgb2lab = rgb2lab_1.rgb2lab;
                var lab2xyz_1 = __webpack_require__(9);
                exports4.lab2xyz = lab2xyz_1.lab2xyz;
                var lab2rgb_1 = __webpack_require__(10);
                exports4.lab2rgb = lab2rgb_1.lab2rgb;
                var xyz2lab_1 = __webpack_require__(8);
                exports4.xyz2lab = xyz2lab_1.xyz2lab;
                var xyz2rgb_1 = __webpack_require__(11);
                exports4.xyz2rgb = xyz2rgb_1.xyz2rgb;
              },
              /* 4 */
              /***/
              function(module4, exports4) {
                "use strict";
                function correctGamma(n) {
                  return n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92;
                }
                function rgb2xyz(r, g, b) {
                  r = correctGamma(r / 255);
                  g = correctGamma(g / 255);
                  b = correctGamma(b / 255);
                  return {
                    x: r * 0.4124 + g * 0.3576 + b * 0.1805,
                    y: r * 0.2126 + g * 0.7152 + b * 0.0722,
                    z: r * 0.0193 + g * 0.1192 + b * 0.9505
                  };
                }
                exports4.rgb2xyz = rgb2xyz;
              },
              /* 5 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var arithmetic_1 = __webpack_require__(6);
                function rgb2hsl(r, g, b) {
                  var min = arithmetic_1.min3(r, g, b), max = arithmetic_1.max3(r, g, b), delta = max - min, l = (min + max) / 510;
                  var s = 0;
                  if (l > 0 && l < 1)
                    s = delta / (l < 0.5 ? max + min : 510 - max - min);
                  var h = 0;
                  if (delta > 0) {
                    if (max === r) {
                      h = (g - b) / delta;
                    } else if (max === g) {
                      h = 2 + (b - r) / delta;
                    } else {
                      h = 4 + (r - g) / delta;
                    }
                    h *= 60;
                    if (h < 0)
                      h += 360;
                  }
                  return { h, s, l };
                }
                exports4.rgb2hsl = rgb2hsl;
              },
              /* 6 */
              /***/
              function(module4, exports4) {
                "use strict";
                function degrees2radians(n) {
                  return n * (Math.PI / 180);
                }
                exports4.degrees2radians = degrees2radians;
                function max3(a, b, c) {
                  var m = a;
                  m < b && (m = b);
                  m < c && (m = c);
                  return m;
                }
                exports4.max3 = max3;
                function min3(a, b, c) {
                  var m = a;
                  m > b && (m = b);
                  m > c && (m = c);
                  return m;
                }
                exports4.min3 = min3;
                function intInRange(value, low, high) {
                  if (value > high)
                    value = high;
                  if (value < low)
                    value = low;
                  return value | 0;
                }
                exports4.intInRange = intInRange;
                function inRange0to255Rounded(n) {
                  n = Math.round(n);
                  if (n > 255)
                    n = 255;
                  else if (n < 0)
                    n = 0;
                  return n;
                }
                exports4.inRange0to255Rounded = inRange0to255Rounded;
                function inRange0to255(n) {
                  if (n > 255)
                    n = 255;
                  else if (n < 0)
                    n = 0;
                  return n;
                }
                exports4.inRange0to255 = inRange0to255;
                function stableSort(arrayToSort, callback) {
                  var type = typeof arrayToSort[0];
                  var sorted;
                  if (type === "number" || type === "string") {
                    var ord_1 = /* @__PURE__ */ Object.create(null);
                    for (var i = 0, l = arrayToSort.length; i < l; i++) {
                      var val = arrayToSort[i];
                      if (ord_1[val] || ord_1[val] === 0)
                        continue;
                      ord_1[val] = i;
                    }
                    sorted = arrayToSort.sort(function(a, b) {
                      return callback(a, b) || ord_1[a] - ord_1[b];
                    });
                  } else {
                    var ord2_1 = arrayToSort.slice(0);
                    sorted = arrayToSort.sort(function(a, b) {
                      return callback(a, b) || ord2_1.indexOf(a) - ord2_1.indexOf(b);
                    });
                  }
                  return sorted;
                }
                exports4.stableSort = stableSort;
              },
              /* 7 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var rgb2xyz_1 = __webpack_require__(4);
                var xyz2lab_1 = __webpack_require__(8);
                function rgb2lab(r, g, b) {
                  var xyz = rgb2xyz_1.rgb2xyz(r, g, b);
                  return xyz2lab_1.xyz2lab(xyz.x, xyz.y, xyz.z);
                }
                exports4.rgb2lab = rgb2lab;
              },
              /* 8 */
              /***/
              function(module4, exports4) {
                "use strict";
                var refX = 0.95047, refY = 1, refZ = 1.08883;
                function pivot(n) {
                  return n > 8856e-6 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116;
                }
                function xyz2lab(x, y, z) {
                  x = pivot(x / refX);
                  y = pivot(y / refY);
                  z = pivot(z / refZ);
                  if (116 * y - 16 < 0)
                    throw new Error("xxx");
                  return {
                    L: Math.max(0, 116 * y - 16),
                    a: 500 * (x - y),
                    b: 200 * (y - z)
                  };
                }
                exports4.xyz2lab = xyz2lab;
              },
              /* 9 */
              /***/
              function(module4, exports4) {
                "use strict";
                var refX = 0.95047, refY = 1, refZ = 1.08883;
                function pivot(n) {
                  return n > 0.206893034 ? Math.pow(n, 3) : (n - 16 / 116) / 7.787;
                }
                function lab2xyz(L, a, b) {
                  var y = (L + 16) / 116, x = a / 500 + y, z = y - b / 200;
                  return {
                    x: refX * pivot(x),
                    y: refY * pivot(y),
                    z: refZ * pivot(z)
                  };
                }
                exports4.lab2xyz = lab2xyz;
              },
              /* 10 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var lab2xyz_1 = __webpack_require__(9);
                var xyz2rgb_1 = __webpack_require__(11);
                function lab2rgb(L, a, b) {
                  var xyz = lab2xyz_1.lab2xyz(L, a, b);
                  return xyz2rgb_1.xyz2rgb(xyz.x, xyz.y, xyz.z);
                }
                exports4.lab2rgb = lab2rgb;
              },
              /* 11 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var arithmetic_1 = __webpack_require__(6);
                function correctGamma(n) {
                  return n > 31308e-7 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n;
                }
                function xyz2rgb(x, y, z) {
                  var r = correctGamma(x * 3.2406 + y * -1.5372 + z * -0.4986), g = correctGamma(x * -0.9689 + y * 1.8758 + z * 0.0415), b = correctGamma(x * 0.0557 + y * -0.204 + z * 1.057);
                  return {
                    r: arithmetic_1.inRange0to255Rounded(r * 255),
                    g: arithmetic_1.inRange0to255Rounded(g * 255),
                    b: arithmetic_1.inRange0to255Rounded(b * 255)
                  };
                }
                exports4.xyz2rgb = xyz2rgb;
              },
              /* 12 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var abstractDistanceCalculator_1 = __webpack_require__(13);
                exports4.AbstractDistanceCalculator = abstractDistanceCalculator_1.AbstractDistanceCalculator;
                var cie94_1 = __webpack_require__(14);
                exports4.CIE94Textiles = cie94_1.CIE94Textiles;
                exports4.CIE94GraphicArts = cie94_1.CIE94GraphicArts;
                var ciede2000_1 = __webpack_require__(15);
                exports4.CIEDE2000 = ciede2000_1.CIEDE2000;
                var cmetric_1 = __webpack_require__(16);
                exports4.CMETRIC = cmetric_1.CMETRIC;
                var euclidean_1 = __webpack_require__(17);
                exports4.AbstractEuclidean = euclidean_1.AbstractEuclidean;
                exports4.Euclidean = euclidean_1.Euclidean;
                exports4.EuclideanRgbQuantWOAlpha = euclidean_1.EuclideanRgbQuantWOAlpha;
                exports4.EuclideanRgbQuantWithAlpha = euclidean_1.EuclideanRgbQuantWithAlpha;
                var manhattan_1 = __webpack_require__(18);
                exports4.AbstractManhattan = manhattan_1.AbstractManhattan;
                exports4.Manhattan = manhattan_1.Manhattan;
                exports4.ManhattanSRGB = manhattan_1.ManhattanSRGB;
                exports4.ManhattanNommyde = manhattan_1.ManhattanNommyde;
                var pngQuant_1 = __webpack_require__(19);
                exports4.PNGQUANT = pngQuant_1.PNGQUANT;
              },
              /* 13 */
              /***/
              function(module4, exports4) {
                "use strict";
                var AbstractDistanceCalculator = function() {
                  function AbstractDistanceCalculator2() {
                    this._setDefaults();
                    this.setWhitePoint(255, 255, 255, 255);
                  }
                  AbstractDistanceCalculator2.prototype.setWhitePoint = function(r, g, b, a) {
                    this._whitePoint = {
                      r: r > 0 ? 255 / r : 0,
                      g: g > 0 ? 255 / g : 0,
                      b: b > 0 ? 255 / b : 0,
                      a: a > 0 ? 255 / a : 0
                    };
                    this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);
                  };
                  AbstractDistanceCalculator2.prototype.calculateNormalized = function(colorA, colorB) {
                    return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;
                  };
                  AbstractDistanceCalculator2.prototype._setDefaults = function() {
                  };
                  return AbstractDistanceCalculator2;
                }();
                exports4.AbstractDistanceCalculator = AbstractDistanceCalculator;
              },
              /* 14 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var __extends = this && this.__extends || function(d, b) {
                  for (var p in b)
                    if (b.hasOwnProperty(p))
                      d[p] = b[p];
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
                var abstractDistanceCalculator_1 = __webpack_require__(13);
                var rgb2lab_1 = __webpack_require__(7);
                var arithmetic_1 = __webpack_require__(6);
                var AbstractCIE94 = function(_super) {
                  __extends(AbstractCIE942, _super);
                  function AbstractCIE942() {
                    _super.apply(this, arguments);
                  }
                  AbstractCIE942.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
                    var lab1 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r1 * this._whitePoint.r), arithmetic_1.inRange0to255(g1 * this._whitePoint.g), arithmetic_1.inRange0to255(b1 * this._whitePoint.b)), lab2 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r2 * this._whitePoint.r), arithmetic_1.inRange0to255(g2 * this._whitePoint.g), arithmetic_1.inRange0to255(b2 * this._whitePoint.b));
                    var dL = lab1.L - lab2.L, dA = lab1.a - lab2.a, dB = lab1.b - lab2.b, c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b), c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b), dC = c1 - c2;
                    var deltaH = dA * dA + dB * dB - dC * dC;
                    deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
                    var dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;
                    return Math.sqrt(Math.pow(dL / this._Kl, 2) + Math.pow(dC / (1 + this._K1 * c1), 2) + Math.pow(deltaH / (1 + this._K2 * c1), 2) + Math.pow(dAlpha, 2));
                  };
                  return AbstractCIE942;
                }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
                exports4.AbstractCIE94 = AbstractCIE94;
                var CIE94Textiles = function(_super) {
                  __extends(CIE94Textiles2, _super);
                  function CIE94Textiles2() {
                    _super.apply(this, arguments);
                  }
                  CIE94Textiles2.prototype._setDefaults = function() {
                    this._Kl = 2;
                    this._K1 = 0.048;
                    this._K2 = 0.014;
                    this._kA = 0.25 * 50 / 255;
                  };
                  return CIE94Textiles2;
                }(AbstractCIE94);
                exports4.CIE94Textiles = CIE94Textiles;
                var CIE94GraphicArts = function(_super) {
                  __extends(CIE94GraphicArts2, _super);
                  function CIE94GraphicArts2() {
                    _super.apply(this, arguments);
                  }
                  CIE94GraphicArts2.prototype._setDefaults = function() {
                    this._Kl = 1;
                    this._K1 = 0.045;
                    this._K2 = 0.015;
                    this._kA = 0.25 * 100 / 255;
                  };
                  return CIE94GraphicArts2;
                }(AbstractCIE94);
                exports4.CIE94GraphicArts = CIE94GraphicArts;
              },
              /* 15 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var __extends = this && this.__extends || function(d, b) {
                  for (var p in b)
                    if (b.hasOwnProperty(p))
                      d[p] = b[p];
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
                var abstractDistanceCalculator_1 = __webpack_require__(13);
                var rgb2lab_1 = __webpack_require__(7);
                var arithmetic_1 = __webpack_require__(6);
                var CIEDE2000 = function(_super) {
                  __extends(CIEDE20002, _super);
                  function CIEDE20002() {
                    _super.apply(this, arguments);
                  }
                  CIEDE20002.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
                    var lab1 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r1 * this._whitePoint.r), arithmetic_1.inRange0to255(g1 * this._whitePoint.g), arithmetic_1.inRange0to255(b1 * this._whitePoint.b)), lab2 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r2 * this._whitePoint.r), arithmetic_1.inRange0to255(g2 * this._whitePoint.g), arithmetic_1.inRange0to255(b2 * this._whitePoint.b)), dA = (a2 - a1) * this._whitePoint.a * CIEDE20002._kA, dE2 = this.calculateRawInLab(lab1, lab2);
                    return Math.sqrt(dE2 + dA * dA);
                  };
                  CIEDE20002.prototype.calculateRawInLab = function(Lab1, Lab2) {
                    var L1 = Lab1.L, a1 = Lab1.a, b1 = Lab1.b;
                    var L2 = Lab2.L, a2 = Lab2.a, b2 = Lab2.b;
                    var C1 = Math.sqrt(a1 * a1 + b1 * b1), C2 = Math.sqrt(a2 * a2 + b2 * b2), pow_a_C1_C2_to_7 = Math.pow((C1 + C2) / 2, 7), G = 0.5 * (1 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + CIEDE20002._pow25to7))), a1p = (1 + G) * a1, a2p = (1 + G) * a2, C1p = Math.sqrt(a1p * a1p + b1 * b1), C2p = Math.sqrt(a2p * a2p + b2 * b2), C1pC2p = C1p * C2p, h1p = CIEDE20002._calculatehp(b1, a1p), h2p = CIEDE20002._calculatehp(b2, a2p), h_bar = Math.abs(h1p - h2p), dLp = L2 - L1, dCp = C2p - C1p, dHp = CIEDE20002._calculate_dHp(C1pC2p, h_bar, h2p, h1p), ahp = CIEDE20002._calculate_ahp(C1pC2p, h_bar, h1p, h2p), T = CIEDE20002._calculateT(ahp), aCp = (C1p + C2p) / 2, aLp_minus_50_square = Math.pow((L1 + L2) / 2 - 50, 2), S_L = 1 + 0.015 * aLp_minus_50_square / Math.sqrt(20 + aLp_minus_50_square), S_C = 1 + 0.045 * aCp, S_H = 1 + 0.015 * T * aCp, R_T = CIEDE20002._calculateRT(ahp, aCp), dLpSL = dLp / S_L, dCpSC = dCp / S_C, dHpSH = dHp / S_H;
                    return Math.pow(dLpSL, 2) + Math.pow(dCpSC, 2) + Math.pow(dHpSH, 2) + R_T * dCpSC * dHpSH;
                  };
                  CIEDE20002._calculatehp = function(b, ap) {
                    var hp = Math.atan2(b, ap);
                    if (hp >= 0)
                      return hp;
                    return hp + CIEDE20002._deg360InRad;
                  };
                  CIEDE20002._calculateRT = function(ahp, aCp) {
                    var aCp_to_7 = Math.pow(aCp, 7), R_C = 2 * Math.sqrt(aCp_to_7 / (aCp_to_7 + CIEDE20002._pow25to7)), delta_theta = CIEDE20002._deg30InRad * Math.exp(-Math.pow((ahp - CIEDE20002._deg275InRad) / CIEDE20002._deg25InRad, 2));
                    return -Math.sin(2 * delta_theta) * R_C;
                  };
                  CIEDE20002._calculateT = function(ahp) {
                    return 1 - 0.17 * Math.cos(ahp - CIEDE20002._deg30InRad) + 0.24 * Math.cos(ahp * 2) + 0.32 * Math.cos(ahp * 3 + CIEDE20002._deg6InRad) - 0.2 * Math.cos(ahp * 4 - CIEDE20002._deg63InRad);
                  };
                  CIEDE20002._calculate_ahp = function(C1pC2p, h_bar, h1p, h2p) {
                    var hpSum = h1p + h2p;
                    if (C1pC2p == 0)
                      return hpSum;
                    if (h_bar <= CIEDE20002._deg180InRad)
                      return hpSum / 2;
                    if (hpSum < CIEDE20002._deg360InRad)
                      return (hpSum + CIEDE20002._deg360InRad) / 2;
                    return (hpSum - CIEDE20002._deg360InRad) / 2;
                  };
                  CIEDE20002._calculate_dHp = function(C1pC2p, h_bar, h2p, h1p) {
                    var dhp;
                    if (C1pC2p == 0) {
                      dhp = 0;
                    } else if (h_bar <= CIEDE20002._deg180InRad) {
                      dhp = h2p - h1p;
                    } else if (h2p <= h1p) {
                      dhp = h2p - h1p + CIEDE20002._deg360InRad;
                    } else {
                      dhp = h2p - h1p - CIEDE20002._deg360InRad;
                    }
                    return 2 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2);
                  };
                  CIEDE20002._kA = 0.25 * 100 / 255;
                  CIEDE20002._pow25to7 = Math.pow(25, 7);
                  CIEDE20002._deg360InRad = arithmetic_1.degrees2radians(360);
                  CIEDE20002._deg180InRad = arithmetic_1.degrees2radians(180);
                  CIEDE20002._deg30InRad = arithmetic_1.degrees2radians(30);
                  CIEDE20002._deg6InRad = arithmetic_1.degrees2radians(6);
                  CIEDE20002._deg63InRad = arithmetic_1.degrees2radians(63);
                  CIEDE20002._deg275InRad = arithmetic_1.degrees2radians(275);
                  CIEDE20002._deg25InRad = arithmetic_1.degrees2radians(25);
                  return CIEDE20002;
                }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
                exports4.CIEDE2000 = CIEDE2000;
              },
              /* 16 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var __extends = this && this.__extends || function(d, b) {
                  for (var p in b)
                    if (b.hasOwnProperty(p))
                      d[p] = b[p];
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
                var abstractDistanceCalculator_1 = __webpack_require__(13);
                var CMETRIC = function(_super) {
                  __extends(CMETRIC2, _super);
                  function CMETRIC2() {
                    _super.apply(this, arguments);
                  }
                  CMETRIC2.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
                    var rmean = (r1 + r2) / 2 * this._whitePoint.r, r = (r1 - r2) * this._whitePoint.r, g = (g1 - g2) * this._whitePoint.g, b = (b1 - b2) * this._whitePoint.b, dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8), dA = (a2 - a1) * this._whitePoint.a;
                    return Math.sqrt(dE + dA * dA);
                  };
                  return CMETRIC2;
                }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
                exports4.CMETRIC = CMETRIC;
              },
              /* 17 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var __extends = this && this.__extends || function(d, b) {
                  for (var p in b)
                    if (b.hasOwnProperty(p))
                      d[p] = b[p];
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
                var abstractDistanceCalculator_1 = __webpack_require__(13);
                var bt709_1 = __webpack_require__(2);
                var AbstractEuclidean = function(_super) {
                  __extends(AbstractEuclidean2, _super);
                  function AbstractEuclidean2() {
                    _super.apply(this, arguments);
                  }
                  AbstractEuclidean2.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
                    var dR = r2 - r1, dG = g2 - g1, dB = b2 - b1, dA = a2 - a1;
                    return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);
                  };
                  return AbstractEuclidean2;
                }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
                exports4.AbstractEuclidean = AbstractEuclidean;
                var Euclidean = function(_super) {
                  __extends(Euclidean2, _super);
                  function Euclidean2() {
                    _super.apply(this, arguments);
                  }
                  Euclidean2.prototype._setDefaults = function() {
                    this._kR = 1;
                    this._kG = 1;
                    this._kB = 1;
                    this._kA = 1;
                  };
                  return Euclidean2;
                }(AbstractEuclidean);
                exports4.Euclidean = Euclidean;
                var EuclideanRgbQuantWithAlpha = function(_super) {
                  __extends(EuclideanRgbQuantWithAlpha2, _super);
                  function EuclideanRgbQuantWithAlpha2() {
                    _super.apply(this, arguments);
                  }
                  EuclideanRgbQuantWithAlpha2.prototype._setDefaults = function() {
                    this._kR = bt709_1.Y.RED;
                    this._kG = bt709_1.Y.GREEN;
                    this._kB = bt709_1.Y.BLUE;
                    this._kA = 1;
                  };
                  return EuclideanRgbQuantWithAlpha2;
                }(AbstractEuclidean);
                exports4.EuclideanRgbQuantWithAlpha = EuclideanRgbQuantWithAlpha;
                var EuclideanRgbQuantWOAlpha = function(_super) {
                  __extends(EuclideanRgbQuantWOAlpha2, _super);
                  function EuclideanRgbQuantWOAlpha2() {
                    _super.apply(this, arguments);
                  }
                  EuclideanRgbQuantWOAlpha2.prototype._setDefaults = function() {
                    this._kR = bt709_1.Y.RED;
                    this._kG = bt709_1.Y.GREEN;
                    this._kB = bt709_1.Y.BLUE;
                    this._kA = 0;
                  };
                  return EuclideanRgbQuantWOAlpha2;
                }(AbstractEuclidean);
                exports4.EuclideanRgbQuantWOAlpha = EuclideanRgbQuantWOAlpha;
              },
              /* 18 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var __extends = this && this.__extends || function(d, b) {
                  for (var p in b)
                    if (b.hasOwnProperty(p))
                      d[p] = b[p];
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
                var abstractDistanceCalculator_1 = __webpack_require__(13);
                var bt709_1 = __webpack_require__(2);
                var AbstractManhattan = function(_super) {
                  __extends(AbstractManhattan2, _super);
                  function AbstractManhattan2() {
                    _super.apply(this, arguments);
                  }
                  AbstractManhattan2.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
                    var dR = r2 - r1, dG = g2 - g1, dB = b2 - b1, dA = a2 - a1;
                    if (dR < 0)
                      dR = 0 - dR;
                    if (dG < 0)
                      dG = 0 - dG;
                    if (dB < 0)
                      dB = 0 - dB;
                    if (dA < 0)
                      dA = 0 - dA;
                    return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;
                  };
                  return AbstractManhattan2;
                }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
                exports4.AbstractManhattan = AbstractManhattan;
                var Manhattan = function(_super) {
                  __extends(Manhattan2, _super);
                  function Manhattan2() {
                    _super.apply(this, arguments);
                  }
                  Manhattan2.prototype._setDefaults = function() {
                    this._kR = 1;
                    this._kG = 1;
                    this._kB = 1;
                    this._kA = 1;
                  };
                  return Manhattan2;
                }(AbstractManhattan);
                exports4.Manhattan = Manhattan;
                var ManhattanNommyde = function(_super) {
                  __extends(ManhattanNommyde2, _super);
                  function ManhattanNommyde2() {
                    _super.apply(this, arguments);
                  }
                  ManhattanNommyde2.prototype._setDefaults = function() {
                    this._kR = 0.4984;
                    this._kG = 0.8625;
                    this._kB = 0.2979;
                    this._kA = 1;
                  };
                  return ManhattanNommyde2;
                }(AbstractManhattan);
                exports4.ManhattanNommyde = ManhattanNommyde;
                var ManhattanSRGB = function(_super) {
                  __extends(ManhattanSRGB2, _super);
                  function ManhattanSRGB2() {
                    _super.apply(this, arguments);
                  }
                  ManhattanSRGB2.prototype._setDefaults = function() {
                    this._kR = bt709_1.Y.RED;
                    this._kG = bt709_1.Y.GREEN;
                    this._kB = bt709_1.Y.BLUE;
                    this._kA = 1;
                  };
                  return ManhattanSRGB2;
                }(AbstractManhattan);
                exports4.ManhattanSRGB = ManhattanSRGB;
              },
              /* 19 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var __extends = this && this.__extends || function(d, b) {
                  for (var p in b)
                    if (b.hasOwnProperty(p))
                      d[p] = b[p];
                  function __() {
                    this.constructor = d;
                  }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
                var abstractDistanceCalculator_1 = __webpack_require__(13);
                var PNGQUANT = function(_super) {
                  __extends(PNGQUANT2, _super);
                  function PNGQUANT2() {
                    _super.apply(this, arguments);
                  }
                  PNGQUANT2.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
                    var alphas = (a2 - a1) * this._whitePoint.a;
                    return this._colordifference_ch(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifference_ch(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifference_ch(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);
                  };
                  PNGQUANT2.prototype._colordifference_ch = function(x, y, alphas) {
                    var black = x - y, white = black + alphas;
                    return black * black + white * white;
                  };
                  return PNGQUANT2;
                }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
                exports4.PNGQUANT = PNGQUANT;
              },
              /* 20 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var neuquant_1 = __webpack_require__(21);
                exports4.NeuQuant = neuquant_1.NeuQuant;
                var neuquantFloat_1 = __webpack_require__(25);
                exports4.NeuQuantFloat = neuquantFloat_1.NeuQuantFloat;
                var rgbquant_1 = __webpack_require__(26);
                exports4.RGBQuant = rgbquant_1.RGBQuant;
                var colorHistogram_1 = __webpack_require__(27);
                exports4.ColorHistogram = colorHistogram_1.ColorHistogram;
                var wuQuant_1 = __webpack_require__(29);
                exports4.WuQuant = wuQuant_1.WuQuant;
                exports4.WuColorCube = wuQuant_1.WuColorCube;
              },
              /* 21 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var palette_1 = __webpack_require__(22);
                var point_1 = __webpack_require__(24);
                var networkBiasShift = 3;
                var Neuron = function() {
                  function Neuron2(defaultValue) {
                    this.r = this.g = this.b = this.a = defaultValue;
                  }
                  Neuron2.prototype.toPoint = function() {
                    return point_1.Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
                  };
                  Neuron2.prototype.subtract = function(r, g, b, a) {
                    this.r -= r | 0;
                    this.g -= g | 0;
                    this.b -= b | 0;
                    this.a -= a | 0;
                  };
                  return Neuron2;
                }();
                var NeuQuant = function() {
                  function NeuQuant2(colorDistanceCalculator, colors) {
                    if (colors === void 0) {
                      colors = 256;
                    }
                    this._distance = colorDistanceCalculator;
                    this._pointArray = [];
                    this._sampleFactor = 1;
                    this._networkSize = colors;
                    this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
                  }
                  NeuQuant2.prototype.sample = function(pointBuffer) {
                    this._pointArray = this._pointArray.concat(pointBuffer.getPointArray());
                  };
                  NeuQuant2.prototype.quantize = function() {
                    this._init();
                    this._learn();
                    return this._buildPalette();
                  };
                  NeuQuant2.prototype._init = function() {
                    this._freq = [];
                    this._bias = [];
                    this._radPower = [];
                    this._network = [];
                    for (var i = 0; i < this._networkSize; i++) {
                      this._network[i] = new Neuron((i << networkBiasShift + 8) / this._networkSize | 0);
                      this._freq[i] = NeuQuant2._initialBias / this._networkSize | 0;
                      this._bias[i] = 0;
                    }
                  };
                  NeuQuant2.prototype._learn = function() {
                    var sampleFactor = this._sampleFactor;
                    var pointsNumber = this._pointArray.length;
                    if (pointsNumber < NeuQuant2._minpicturebytes)
                      sampleFactor = 1;
                    var alphadec = 30 + (sampleFactor - 1) / 3 | 0, pointsToSample = pointsNumber / sampleFactor | 0;
                    var delta = pointsToSample / NeuQuant2._nCycles | 0, alpha = NeuQuant2._initAlpha, radius = (this._networkSize >> 3) * NeuQuant2._radiusBias;
                    var rad = radius >> NeuQuant2._radiusBiasShift;
                    if (rad <= 1)
                      rad = 0;
                    for (var i = 0; i < rad; i++) {
                      this._radPower[i] = alpha * ((rad * rad - i * i) * NeuQuant2._radBias / (rad * rad)) >>> 0;
                    }
                    var step;
                    if (pointsNumber < NeuQuant2._minpicturebytes) {
                      step = 1;
                    } else if (pointsNumber % NeuQuant2._prime1 != 0) {
                      step = NeuQuant2._prime1;
                    } else if (pointsNumber % NeuQuant2._prime2 != 0) {
                      step = NeuQuant2._prime2;
                    } else if (pointsNumber % NeuQuant2._prime3 != 0) {
                      step = NeuQuant2._prime3;
                    } else {
                      step = NeuQuant2._prime4;
                    }
                    for (var i = 0, pointIndex = 0; i < pointsToSample; ) {
                      var point = this._pointArray[pointIndex], b = point.b << networkBiasShift, g = point.g << networkBiasShift, r = point.r << networkBiasShift, a = point.a << networkBiasShift, neuronIndex = this._contest(b, g, r, a);
                      this._alterSingle(alpha, neuronIndex, b, g, r, a);
                      if (rad !== 0)
                        this._alterNeighbour(rad, neuronIndex, b, g, r, a);
                      pointIndex += step;
                      if (pointIndex >= pointsNumber)
                        pointIndex -= pointsNumber;
                      i++;
                      if (delta === 0)
                        delta = 1;
                      if (i % delta === 0) {
                        alpha -= alpha / alphadec | 0;
                        radius -= radius / NeuQuant2._radiusDecrease | 0;
                        rad = radius >> NeuQuant2._radiusBiasShift;
                        if (rad <= 1)
                          rad = 0;
                        for (var j = 0; j < rad; j++)
                          this._radPower[j] = alpha * ((rad * rad - j * j) * NeuQuant2._radBias / (rad * rad)) >>> 0;
                      }
                    }
                  };
                  NeuQuant2.prototype._buildPalette = function() {
                    var palette = new palette_1.Palette();
                    this._network.forEach(function(neuron) {
                      palette.add(neuron.toPoint());
                    });
                    palette.sort();
                    return palette;
                  };
                  NeuQuant2.prototype._alterNeighbour = function(rad, i, b, g, r, al) {
                    var lo = i - rad;
                    if (lo < -1)
                      lo = -1;
                    var hi = i + rad;
                    if (hi > this._networkSize)
                      hi = this._networkSize;
                    var j = i + 1, k = i - 1, m = 1;
                    while (j < hi || k > lo) {
                      var a = this._radPower[m++] / NeuQuant2._alphaRadBias;
                      if (j < hi) {
                        var p = this._network[j++];
                        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
                      }
                      if (k > lo) {
                        var p = this._network[k--];
                        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
                      }
                    }
                  };
                  NeuQuant2.prototype._alterSingle = function(alpha, i, b, g, r, a) {
                    alpha /= NeuQuant2._initAlpha;
                    var n = this._network[i];
                    n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
                  };
                  NeuQuant2.prototype._contest = function(b, g, r, a) {
                    var multiplier = 255 * 4 << networkBiasShift;
                    var bestd = ~(1 << 31), bestbiasd = bestd, bestpos = -1, bestbiaspos = bestpos;
                    for (var i = 0; i < this._networkSize; i++) {
                      var n = this._network[i], dist = this._distance.calculateNormalized(n, { r, g, b, a }) * multiplier | 0;
                      if (dist < bestd) {
                        bestd = dist;
                        bestpos = i;
                      }
                      var biasdist = dist - (this._bias[i] >> NeuQuant2._initialBiasShift - networkBiasShift);
                      if (biasdist < bestbiasd) {
                        bestbiasd = biasdist;
                        bestbiaspos = i;
                      }
                      var betafreq = this._freq[i] >> NeuQuant2._betaShift;
                      this._freq[i] -= betafreq;
                      this._bias[i] += betafreq << NeuQuant2._gammaShift;
                    }
                    this._freq[bestpos] += NeuQuant2._beta;
                    this._bias[bestpos] -= NeuQuant2._betaGamma;
                    return bestbiaspos;
                  };
                  NeuQuant2._prime1 = 499;
                  NeuQuant2._prime2 = 491;
                  NeuQuant2._prime3 = 487;
                  NeuQuant2._prime4 = 503;
                  NeuQuant2._minpicturebytes = NeuQuant2._prime4;
                  NeuQuant2._nCycles = 100;
                  NeuQuant2._initialBiasShift = 16;
                  NeuQuant2._initialBias = 1 << NeuQuant2._initialBiasShift;
                  NeuQuant2._gammaShift = 10;
                  NeuQuant2._betaShift = 10;
                  NeuQuant2._beta = NeuQuant2._initialBias >> NeuQuant2._betaShift;
                  NeuQuant2._betaGamma = NeuQuant2._initialBias << NeuQuant2._gammaShift - NeuQuant2._betaShift;
                  NeuQuant2._radiusBiasShift = 6;
                  NeuQuant2._radiusBias = 1 << NeuQuant2._radiusBiasShift;
                  NeuQuant2._radiusDecrease = 30;
                  NeuQuant2._alphaBiasShift = 10;
                  NeuQuant2._initAlpha = 1 << NeuQuant2._alphaBiasShift;
                  NeuQuant2._radBiasShift = 8;
                  NeuQuant2._radBias = 1 << NeuQuant2._radBiasShift;
                  NeuQuant2._alphaRadBiasShift = NeuQuant2._alphaBiasShift + NeuQuant2._radBiasShift;
                  NeuQuant2._alphaRadBias = 1 << NeuQuant2._alphaRadBiasShift;
                  return NeuQuant2;
                }();
                exports4.NeuQuant = NeuQuant;
              },
              /* 22 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var pointContainer_1 = __webpack_require__(23);
                var rgb2hsl_1 = __webpack_require__(5);
                var hueGroups = 10;
                function hueGroup(hue, segmentsNumber) {
                  var maxHue = 360, seg = maxHue / segmentsNumber, half = seg / 2;
                  for (var i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {
                    if (hue >= mid && hue < mid + seg)
                      return i;
                  }
                  return 0;
                }
                exports4.hueGroup = hueGroup;
                var Palette = function() {
                  function Palette2() {
                    this._pointArray = [];
                    this._i32idx = {};
                    this._pointContainer = new pointContainer_1.PointContainer();
                    this._pointContainer.setHeight(1);
                    this._pointArray = this._pointContainer.getPointArray();
                  }
                  Palette2.prototype.add = function(color) {
                    this._pointArray.push(color);
                    this._pointContainer.setWidth(this._pointArray.length);
                  };
                  Palette2.prototype.has = function(color) {
                    for (var i = this._pointArray.length - 1; i >= 0; i--) {
                      if (color.uint32 === this._pointArray[i].uint32)
                        return true;
                    }
                    return false;
                  };
                  Palette2.prototype.getNearestColor = function(colorDistanceCalculator, color) {
                    return this._pointArray[this.getNearestIndex(colorDistanceCalculator, color) | 0];
                  };
                  Palette2.prototype.getPointContainer = function() {
                    return this._pointContainer;
                  };
                  Palette2.prototype._nearestPointFromCache = function(key) {
                    return typeof this._i32idx[key] === "number" ? this._i32idx[key] : -1;
                  };
                  Palette2.prototype.getNearestIndex = function(colorDistanceCalculator, point) {
                    var idx = this._nearestPointFromCache("" + point.uint32);
                    if (idx >= 0)
                      return idx;
                    var minimalDistance = Number.MAX_VALUE;
                    idx = 0;
                    for (var i = 0, l = this._pointArray.length; i < l; i++) {
                      var p = this._pointArray[i], distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);
                      if (distance < minimalDistance) {
                        minimalDistance = distance;
                        idx = i;
                      }
                    }
                    this._i32idx[point.uint32] = idx;
                    return idx;
                  };
                  Palette2.prototype.sort = function() {
                    this._i32idx = {};
                    this._pointArray.sort(function(a, b) {
                      var hslA = rgb2hsl_1.rgb2hsl(a.r, a.g, a.b), hslB = rgb2hsl_1.rgb2hsl(b.r, b.g, b.b);
                      var hueA = a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups), hueB = b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);
                      var hueDiff = hueB - hueA;
                      if (hueDiff)
                        return -hueDiff;
                      var lA = a.getLuminosity(true), lB = b.getLuminosity(true);
                      if (lB - lA !== 0)
                        return lB - lA;
                      var satDiff = (hslB.s * 100 | 0) - (hslA.s * 100 | 0);
                      if (satDiff)
                        return -satDiff;
                      return 0;
                    });
                  };
                  return Palette2;
                }();
                exports4.Palette = Palette;
              },
              /* 23 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var point_1 = __webpack_require__(24);
                var PointContainer = function() {
                  function PointContainer2() {
                    this._width = 0;
                    this._height = 0;
                    this._pointArray = [];
                  }
                  PointContainer2.prototype.getWidth = function() {
                    return this._width;
                  };
                  PointContainer2.prototype.getHeight = function() {
                    return this._height;
                  };
                  PointContainer2.prototype.setWidth = function(width) {
                    this._width = width;
                  };
                  PointContainer2.prototype.setHeight = function(height) {
                    this._height = height;
                  };
                  PointContainer2.prototype.getPointArray = function() {
                    return this._pointArray;
                  };
                  PointContainer2.prototype.clone = function() {
                    var clone = new PointContainer2();
                    clone._width = this._width;
                    clone._height = this._height;
                    for (var i = 0, l = this._pointArray.length; i < l; i++) {
                      clone._pointArray[i] = point_1.Point.createByUint32(this._pointArray[i].uint32 | 0);
                    }
                    return clone;
                  };
                  PointContainer2.prototype.toUint32Array = function() {
                    var l = this._pointArray.length, uint32Array = new Uint32Array(l);
                    for (var i = 0; i < l; i++) {
                      uint32Array[i] = this._pointArray[i].uint32;
                    }
                    return uint32Array;
                  };
                  PointContainer2.prototype.toUint8Array = function() {
                    return new Uint8Array(this.toUint32Array().buffer);
                  };
                  PointContainer2.fromHTMLImageElement = function(img) {
                    var width = img.naturalWidth, height = img.naturalHeight;
                    var canvas = document.createElement("canvas");
                    canvas.width = width;
                    canvas.height = height;
                    var ctx = canvas.getContext("2d");
                    ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);
                    return PointContainer2.fromHTMLCanvasElement(canvas);
                  };
                  PointContainer2.fromHTMLCanvasElement = function(canvas) {
                    var width = canvas.width, height = canvas.height;
                    var ctx = canvas.getContext("2d"), imgData = ctx.getImageData(0, 0, width, height);
                    return PointContainer2.fromImageData(imgData);
                  };
                  PointContainer2.fromNodeCanvas = function(canvas) {
                    return PointContainer2.fromHTMLCanvasElement(canvas);
                  };
                  PointContainer2.fromImageData = function(imageData) {
                    var width = imageData.width, height = imageData.height;
                    return PointContainer2.fromCanvasPixelArray(imageData.data, width, height);
                  };
                  PointContainer2.fromArray = function(byteArray, width, height) {
                    var uint8array = new Uint8Array(byteArray);
                    return PointContainer2.fromUint8Array(uint8array, width, height);
                  };
                  PointContainer2.fromCanvasPixelArray = function(data, width, height) {
                    return PointContainer2.fromArray(data, width, height);
                  };
                  PointContainer2.fromUint8Array = function(uint8array, width, height) {
                    return PointContainer2.fromUint32Array(new Uint32Array(uint8array.buffer), width, height);
                  };
                  PointContainer2.fromUint32Array = function(uint32array, width, height) {
                    var container = new PointContainer2();
                    container._width = width;
                    container._height = height;
                    for (var i = 0, l = uint32array.length; i < l; i++) {
                      container._pointArray[i] = point_1.Point.createByUint32(uint32array[i] | 0);
                    }
                    return container;
                  };
                  return PointContainer2;
                }();
                exports4.PointContainer = PointContainer;
              },
              /* 24 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var bt709_1 = __webpack_require__(2);
                var Point = function() {
                  function Point2() {
                    this.uint32 = -1 >>> 0;
                    this.r = this.g = this.b = this.a = 0;
                    this.rgba = new Array(4);
                    this.rgba[0] = 0;
                    this.rgba[1] = 0;
                    this.rgba[2] = 0;
                    this.rgba[3] = 0;
                  }
                  Point2.createByQuadruplet = function(quadruplet) {
                    var point = new Point2();
                    point.r = quadruplet[0] | 0;
                    point.g = quadruplet[1] | 0;
                    point.b = quadruplet[2] | 0;
                    point.a = quadruplet[3] | 0;
                    point._loadUINT32();
                    point._loadQuadruplet();
                    return point;
                  };
                  Point2.createByRGBA = function(red, green, blue, alpha) {
                    var point = new Point2();
                    point.r = red | 0;
                    point.g = green | 0;
                    point.b = blue | 0;
                    point.a = alpha | 0;
                    point._loadUINT32();
                    point._loadQuadruplet();
                    return point;
                  };
                  Point2.createByUint32 = function(uint32) {
                    var point = new Point2();
                    point.uint32 = uint32 >>> 0;
                    point._loadRGBA();
                    point._loadQuadruplet();
                    return point;
                  };
                  Point2.prototype.from = function(point) {
                    this.r = point.r;
                    this.g = point.g;
                    this.b = point.b;
                    this.a = point.a;
                    this.uint32 = point.uint32;
                    this.rgba[0] = point.r;
                    this.rgba[1] = point.g;
                    this.rgba[2] = point.b;
                    this.rgba[3] = point.a;
                  };
                  Point2.prototype.getLuminosity = function(useAlphaChannel) {
                    var r = this.r, g = this.g, b = this.b;
                    if (useAlphaChannel) {
                      r = Math.min(255, 255 - this.a + this.a * r / 255);
                      g = Math.min(255, 255 - this.a + this.a * g / 255);
                      b = Math.min(255, 255 - this.a + this.a * b / 255);
                    }
                    return r * bt709_1.Y.RED + g * bt709_1.Y.GREEN + b * bt709_1.Y.BLUE;
                  };
                  Point2.prototype._loadUINT32 = function() {
                    this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
                  };
                  Point2.prototype._loadRGBA = function() {
                    this.r = this.uint32 & 255;
                    this.g = this.uint32 >>> 8 & 255;
                    this.b = this.uint32 >>> 16 & 255;
                    this.a = this.uint32 >>> 24 & 255;
                  };
                  Point2.prototype._loadQuadruplet = function() {
                    this.rgba[0] = this.r;
                    this.rgba[1] = this.g;
                    this.rgba[2] = this.b;
                    this.rgba[3] = this.a;
                  };
                  return Point2;
                }();
                exports4.Point = Point;
              },
              /* 25 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var palette_1 = __webpack_require__(22);
                var point_1 = __webpack_require__(24);
                var networkBiasShift = 3;
                var NeuronFloat = function() {
                  function NeuronFloat2(defaultValue) {
                    this.r = this.g = this.b = this.a = defaultValue;
                  }
                  NeuronFloat2.prototype.toPoint = function() {
                    return point_1.Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
                  };
                  NeuronFloat2.prototype.subtract = function(r, g, b, a) {
                    this.r -= r;
                    this.g -= g;
                    this.b -= b;
                    this.a -= a;
                  };
                  return NeuronFloat2;
                }();
                var NeuQuantFloat = function() {
                  function NeuQuantFloat2(colorDistanceCalculator, colors) {
                    if (colors === void 0) {
                      colors = 256;
                    }
                    this._distance = colorDistanceCalculator;
                    this._pointArray = [];
                    this._sampleFactor = 1;
                    this._networkSize = colors;
                    this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
                  }
                  NeuQuantFloat2.prototype.sample = function(pointBuffer) {
                    this._pointArray = this._pointArray.concat(pointBuffer.getPointArray());
                  };
                  NeuQuantFloat2.prototype.quantize = function() {
                    this._init();
                    this._learn();
                    return this._buildPalette();
                  };
                  NeuQuantFloat2.prototype._init = function() {
                    this._freq = [];
                    this._bias = [];
                    this._radPower = [];
                    this._network = [];
                    for (var i = 0; i < this._networkSize; i++) {
                      this._network[i] = new NeuronFloat((i << networkBiasShift + 8) / this._networkSize);
                      this._freq[i] = NeuQuantFloat2._initialBias / this._networkSize;
                      this._bias[i] = 0;
                    }
                  };
                  NeuQuantFloat2.prototype._learn = function() {
                    var sampleFactor = this._sampleFactor;
                    var pointsNumber = this._pointArray.length;
                    if (pointsNumber < NeuQuantFloat2._minpicturebytes)
                      sampleFactor = 1;
                    var alphadec = 30 + (sampleFactor - 1) / 3, pointsToSample = pointsNumber / sampleFactor;
                    var delta = pointsToSample / NeuQuantFloat2._nCycles | 0, alpha = NeuQuantFloat2._initAlpha, radius = (this._networkSize >> 3) * NeuQuantFloat2._radiusBias;
                    var rad = radius >> NeuQuantFloat2._radiusBiasShift;
                    if (rad <= 1)
                      rad = 0;
                    for (var i = 0; i < rad; i++) {
                      this._radPower[i] = alpha * ((rad * rad - i * i) * NeuQuantFloat2._radBias / (rad * rad));
                    }
                    var step;
                    if (pointsNumber < NeuQuantFloat2._minpicturebytes) {
                      step = 1;
                    } else if (pointsNumber % NeuQuantFloat2._prime1 != 0) {
                      step = NeuQuantFloat2._prime1;
                    } else if (pointsNumber % NeuQuantFloat2._prime2 != 0) {
                      step = NeuQuantFloat2._prime2;
                    } else if (pointsNumber % NeuQuantFloat2._prime3 != 0) {
                      step = NeuQuantFloat2._prime3;
                    } else {
                      step = NeuQuantFloat2._prime4;
                    }
                    for (var i = 0, pointIndex = 0; i < pointsToSample; ) {
                      var point = this._pointArray[pointIndex], b = point.b << networkBiasShift, g = point.g << networkBiasShift, r = point.r << networkBiasShift, a = point.a << networkBiasShift, neuronIndex = this._contest(b, g, r, a);
                      this._alterSingle(alpha, neuronIndex, b, g, r, a);
                      if (rad != 0)
                        this._alterNeighbour(rad, neuronIndex, b, g, r, a);
                      pointIndex += step;
                      if (pointIndex >= pointsNumber)
                        pointIndex -= pointsNumber;
                      i++;
                      if (delta == 0)
                        delta = 1;
                      if (i % delta == 0) {
                        alpha -= alpha / alphadec;
                        radius -= radius / NeuQuantFloat2._radiusDecrease;
                        rad = radius >> NeuQuantFloat2._radiusBiasShift;
                        if (rad <= 1)
                          rad = 0;
                        for (var j = 0; j < rad; j++)
                          this._radPower[j] = alpha * ((rad * rad - j * j) * NeuQuantFloat2._radBias / (rad * rad));
                      }
                    }
                  };
                  NeuQuantFloat2.prototype._buildPalette = function() {
                    var palette = new palette_1.Palette();
                    this._network.forEach(function(neuron) {
                      palette.add(neuron.toPoint());
                    });
                    palette.sort();
                    return palette;
                  };
                  NeuQuantFloat2.prototype._alterNeighbour = function(rad, i, b, g, r, al) {
                    var lo = i - rad;
                    if (lo < -1)
                      lo = -1;
                    var hi = i + rad;
                    if (hi > this._networkSize)
                      hi = this._networkSize;
                    var j = i + 1, k = i - 1, m = 1;
                    while (j < hi || k > lo) {
                      var a = this._radPower[m++] / NeuQuantFloat2._alphaRadBias;
                      if (j < hi) {
                        var p = this._network[j++];
                        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
                      }
                      if (k > lo) {
                        var p = this._network[k--];
                        p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
                      }
                    }
                  };
                  NeuQuantFloat2.prototype._alterSingle = function(alpha, i, b, g, r, a) {
                    alpha /= NeuQuantFloat2._initAlpha;
                    var n = this._network[i];
                    n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
                  };
                  NeuQuantFloat2.prototype._contest = function(b, g, r, al) {
                    var multiplier = 255 * 4 << networkBiasShift;
                    var bestd = ~(1 << 31), bestbiasd = bestd, bestpos = -1, bestbiaspos = bestpos;
                    for (var i = 0; i < this._networkSize; i++) {
                      var n = this._network[i], dist = this._distance.calculateNormalized(n, { r, g, b, a: al }) * multiplier;
                      if (dist < bestd) {
                        bestd = dist;
                        bestpos = i;
                      }
                      var biasdist = dist - (this._bias[i] >> NeuQuantFloat2._initialBiasShift - networkBiasShift);
                      if (biasdist < bestbiasd) {
                        bestbiasd = biasdist;
                        bestbiaspos = i;
                      }
                      var betafreq = this._freq[i] >> NeuQuantFloat2._betaShift;
                      this._freq[i] -= betafreq;
                      this._bias[i] += betafreq << NeuQuantFloat2._gammaShift;
                    }
                    this._freq[bestpos] += NeuQuantFloat2._beta;
                    this._bias[bestpos] -= NeuQuantFloat2._betaGamma;
                    return bestbiaspos;
                  };
                  NeuQuantFloat2._prime1 = 499;
                  NeuQuantFloat2._prime2 = 491;
                  NeuQuantFloat2._prime3 = 487;
                  NeuQuantFloat2._prime4 = 503;
                  NeuQuantFloat2._minpicturebytes = NeuQuantFloat2._prime4;
                  NeuQuantFloat2._nCycles = 100;
                  NeuQuantFloat2._initialBiasShift = 16;
                  NeuQuantFloat2._initialBias = 1 << NeuQuantFloat2._initialBiasShift;
                  NeuQuantFloat2._gammaShift = 10;
                  NeuQuantFloat2._betaShift = 10;
                  NeuQuantFloat2._beta = NeuQuantFloat2._initialBias >> NeuQuantFloat2._betaShift;
                  NeuQuantFloat2._betaGamma = NeuQuantFloat2._initialBias << NeuQuantFloat2._gammaShift - NeuQuantFloat2._betaShift;
                  NeuQuantFloat2._radiusBiasShift = 6;
                  NeuQuantFloat2._radiusBias = 1 << NeuQuantFloat2._radiusBiasShift;
                  NeuQuantFloat2._radiusDecrease = 30;
                  NeuQuantFloat2._alphaBiasShift = 10;
                  NeuQuantFloat2._initAlpha = 1 << NeuQuantFloat2._alphaBiasShift;
                  NeuQuantFloat2._radBiasShift = 8;
                  NeuQuantFloat2._radBias = 1 << NeuQuantFloat2._radBiasShift;
                  NeuQuantFloat2._alphaRadBiasShift = NeuQuantFloat2._alphaBiasShift + NeuQuantFloat2._radBiasShift;
                  NeuQuantFloat2._alphaRadBias = 1 << NeuQuantFloat2._alphaRadBiasShift;
                  return NeuQuantFloat2;
                }();
                exports4.NeuQuantFloat = NeuQuantFloat;
              },
              /* 26 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var palette_1 = __webpack_require__(22);
                var point_1 = __webpack_require__(24);
                var colorHistogram_1 = __webpack_require__(27);
                var arithmetic_1 = __webpack_require__(6);
                var RemovedColor = function() {
                  function RemovedColor2(index, color, distance) {
                    this.index = index;
                    this.color = color;
                    this.distance = distance;
                  }
                  return RemovedColor2;
                }();
                var RGBQuant = function() {
                  function RGBQuant2(colorDistanceCalculator, colors, method) {
                    if (colors === void 0) {
                      colors = 256;
                    }
                    if (method === void 0) {
                      method = 2;
                    }
                    this._distance = colorDistanceCalculator;
                    this._colors = colors;
                    this._histogram = new colorHistogram_1.ColorHistogram(method, colors);
                    this._initialDistance = 0.01;
                    this._distanceIncrement = 5e-3;
                  }
                  RGBQuant2.prototype.sample = function(image) {
                    this._histogram.sample(image);
                  };
                  RGBQuant2.prototype.quantize = function() {
                    var idxi32 = this._histogram.getImportanceSortedColorsIDXI32();
                    if (idxi32.length === 0) {
                      throw new Error("No colors in image");
                    }
                    var palette = this._buildPalette(idxi32);
                    palette.sort();
                    return palette;
                  };
                  RGBQuant2.prototype._buildPalette = function(idxi32) {
                    var palette = new palette_1.Palette(), colorArray = palette.getPointContainer().getPointArray(), usageArray = new Array(idxi32.length);
                    for (var i = 0; i < idxi32.length; i++) {
                      colorArray.push(point_1.Point.createByUint32(idxi32[i]));
                      usageArray[i] = 1;
                    }
                    var len = colorArray.length, memDist = [];
                    var palLen = len, thold = this._initialDistance;
                    while (palLen > this._colors) {
                      memDist.length = 0;
                      for (var i = 0; i < len; i++) {
                        if (usageArray[i] === 0)
                          continue;
                        var pxi = colorArray[i];
                        for (var j = i + 1; j < len; j++) {
                          if (usageArray[j] === 0)
                            continue;
                          var pxj = colorArray[j];
                          var dist = this._distance.calculateNormalized(pxi, pxj);
                          if (dist < thold) {
                            memDist.push(new RemovedColor(j, pxj, dist));
                            usageArray[j] = 0;
                            palLen--;
                          }
                        }
                      }
                      thold += palLen > this._colors * 3 ? this._initialDistance : this._distanceIncrement;
                    }
                    if (palLen < this._colors) {
                      arithmetic_1.stableSort(memDist, function(a, b) {
                        return b.distance - a.distance;
                      });
                      var k = 0;
                      while (palLen < this._colors && k < memDist.length) {
                        var removedColor = memDist[k];
                        usageArray[removedColor.index] = 1;
                        palLen++;
                        k++;
                      }
                    }
                    var colors = colorArray.length;
                    for (var colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {
                      if (usageArray[colorIndex] === 0) {
                        if (colorIndex !== colors - 1) {
                          colorArray[colorIndex] = colorArray[colors - 1];
                        }
                        --colors;
                      }
                    }
                    colorArray.length = colors;
                    return palette;
                  };
                  return RGBQuant2;
                }();
                exports4.RGBQuant = RGBQuant;
              },
              /* 27 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var hueStatistics_1 = __webpack_require__(28);
                var arithmetic_1 = __webpack_require__(6);
                var ColorHistogram = function() {
                  function ColorHistogram2(method, colors) {
                    this._method = method;
                    this._minHueCols = colors << 2;
                    this._initColors = colors << 2;
                    this._hueStats = new hueStatistics_1.HueStatistics(ColorHistogram2._hueGroups, this._minHueCols);
                    this._histogram = /* @__PURE__ */ Object.create(null);
                  }
                  ColorHistogram2.prototype.sample = function(pointBuffer) {
                    switch (this._method) {
                      case 1:
                        this._colorStats1D(pointBuffer);
                        break;
                      case 2:
                        this._colorStats2D(pointBuffer);
                        break;
                    }
                  };
                  ColorHistogram2.prototype.getImportanceSortedColorsIDXI32 = function() {
                    var _this = this;
                    var sorted = arithmetic_1.stableSort(Object.keys(this._histogram), function(a, b) {
                      return _this._histogram[b] - _this._histogram[a];
                    });
                    if (sorted.length === 0) {
                      return [];
                    }
                    var idxi32;
                    switch (this._method) {
                      case 1:
                        var initialColorsLimit = Math.min(sorted.length, this._initColors), last = sorted[initialColorsLimit - 1], freq = this._histogram[last];
                        idxi32 = sorted.slice(0, initialColorsLimit);
                        var pos = initialColorsLimit, len = sorted.length;
                        while (pos < len && this._histogram[sorted[pos]] == freq)
                          idxi32.push(sorted[pos++]);
                        this._hueStats.injectIntoArray(idxi32);
                        break;
                      case 2:
                        idxi32 = sorted;
                        break;
                      default:
                        throw new Error("Incorrect method");
                    }
                    return idxi32.map(function(v) {
                      return +v;
                    });
                  };
                  ColorHistogram2.prototype._colorStats1D = function(pointBuffer) {
                    var histG = this._histogram, pointArray = pointBuffer.getPointArray(), len = pointArray.length;
                    for (var i = 0; i < len; i++) {
                      var col = pointArray[i].uint32;
                      this._hueStats.check(col);
                      if (col in histG)
                        histG[col]++;
                      else
                        histG[col] = 1;
                    }
                  };
                  ColorHistogram2.prototype._colorStats2D = function(pointBuffer) {
                    var _this = this;
                    var width = pointBuffer.getWidth(), height = pointBuffer.getHeight(), pointArray = pointBuffer.getPointArray();
                    var boxW = ColorHistogram2._boxSize[0], boxH = ColorHistogram2._boxSize[1], area = boxW * boxH, boxes = this._makeBoxes(width, height, boxW, boxH), histG = this._histogram;
                    boxes.forEach(function(box) {
                      var effc = Math.round(box.w * box.h / area) * ColorHistogram2._boxPixels;
                      if (effc < 2)
                        effc = 2;
                      var histL = {};
                      _this._iterateBox(box, width, function(i) {
                        var col = pointArray[i].uint32;
                        _this._hueStats.check(col);
                        if (col in histG)
                          histG[col]++;
                        else if (col in histL) {
                          if (++histL[col] >= effc)
                            histG[col] = histL[col];
                        } else
                          histL[col] = 1;
                      });
                    });
                    this._hueStats.injectIntoDictionary(histG);
                  };
                  ColorHistogram2.prototype._iterateBox = function(bbox, wid, fn) {
                    var b = bbox, i0 = b.y * wid + b.x, i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1), incr = wid - b.w + 1;
                    var cnt = 0, i = i0;
                    do {
                      fn.call(this, i);
                      i += ++cnt % b.w == 0 ? incr : 1;
                    } while (i <= i1);
                  };
                  ColorHistogram2.prototype._makeBoxes = function(width, height, stepX, stepY) {
                    var wrem = width % stepX, hrem = height % stepY, xend = width - wrem, yend = height - hrem, boxesArray = [];
                    for (var y = 0; y < height; y += stepY)
                      for (var x = 0; x < width; x += stepX)
                        boxesArray.push({ x, y, w: x == xend ? wrem : stepX, h: y == yend ? hrem : stepY });
                    return boxesArray;
                  };
                  ColorHistogram2._boxSize = [64, 64];
                  ColorHistogram2._boxPixels = 2;
                  ColorHistogram2._hueGroups = 10;
                  return ColorHistogram2;
                }();
                exports4.ColorHistogram = ColorHistogram;
              },
              /* 28 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var rgb2hsl_1 = __webpack_require__(5);
                var palette_1 = __webpack_require__(22);
                var HueGroup = function() {
                  function HueGroup2() {
                    this.num = 0;
                    this.cols = [];
                  }
                  return HueGroup2;
                }();
                var HueStatistics = function() {
                  function HueStatistics2(numGroups, minCols) {
                    this._numGroups = numGroups;
                    this._minCols = minCols;
                    this._stats = [];
                    for (var i = 0; i <= numGroups; i++) {
                      this._stats[i] = new HueGroup();
                    }
                    this._groupsFull = 0;
                  }
                  HueStatistics2.prototype.check = function(i32) {
                    if (this._groupsFull == this._numGroups + 1) {
                      this.check = function() {
                      };
                    }
                    var r = i32 & 255, g = i32 >>> 8 & 255, b = i32 >>> 16 & 255, hg = r == g && g == b ? 0 : 1 + palette_1.hueGroup(rgb2hsl_1.rgb2hsl(r, g, b).h, this._numGroups), gr = this._stats[hg], min = this._minCols;
                    gr.num++;
                    if (gr.num > min)
                      return;
                    if (gr.num == min)
                      this._groupsFull++;
                    if (gr.num <= min)
                      this._stats[hg].cols.push(i32);
                  };
                  HueStatistics2.prototype.injectIntoDictionary = function(histG) {
                    for (var i = 0; i <= this._numGroups; i++) {
                      if (this._stats[i].num <= this._minCols) {
                        this._stats[i].cols.forEach(function(col) {
                          if (!histG[col])
                            histG[col] = 1;
                          else
                            histG[col]++;
                        });
                      }
                    }
                  };
                  HueStatistics2.prototype.injectIntoArray = function(histG) {
                    for (var i = 0; i <= this._numGroups; i++) {
                      if (this._stats[i].num <= this._minCols) {
                        this._stats[i].cols.forEach(function(col) {
                          if (histG.indexOf(col) == -1)
                            histG.push(col);
                        });
                      }
                    }
                  };
                  return HueStatistics2;
                }();
                exports4.HueStatistics = HueStatistics;
              },
              /* 29 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var palette_1 = __webpack_require__(22);
                var point_1 = __webpack_require__(24);
                function createArray1D(dimension1) {
                  var a = [];
                  for (var k = 0; k < dimension1; k++) {
                    a[k] = 0;
                  }
                  return a;
                }
                function createArray4D(dimension1, dimension2, dimension3, dimension4) {
                  var a = new Array(dimension1);
                  for (var i = 0; i < dimension1; i++) {
                    a[i] = new Array(dimension2);
                    for (var j = 0; j < dimension2; j++) {
                      a[i][j] = new Array(dimension3);
                      for (var k = 0; k < dimension3; k++) {
                        a[i][j][k] = new Array(dimension4);
                        for (var l = 0; l < dimension4; l++) {
                          a[i][j][k][l] = 0;
                        }
                      }
                    }
                  }
                  return a;
                }
                function createArray3D(dimension1, dimension2, dimension3) {
                  var a = new Array(dimension1);
                  for (var i = 0; i < dimension1; i++) {
                    a[i] = new Array(dimension2);
                    for (var j = 0; j < dimension2; j++) {
                      a[i][j] = new Array(dimension3);
                      for (var k = 0; k < dimension3; k++) {
                        a[i][j][k] = 0;
                      }
                    }
                  }
                  return a;
                }
                function fillArray3D(a, dimension1, dimension2, dimension3, value) {
                  for (var i = 0; i < dimension1; i++) {
                    a[i] = [];
                    for (var j = 0; j < dimension2; j++) {
                      a[i][j] = [];
                      for (var k = 0; k < dimension3; k++) {
                        a[i][j][k] = value;
                      }
                    }
                  }
                }
                function fillArray1D(a, dimension1, value) {
                  for (var i = 0; i < dimension1; i++) {
                    a[i] = value;
                  }
                }
                var WuColorCube = function() {
                  function WuColorCube2() {
                  }
                  return WuColorCube2;
                }();
                exports4.WuColorCube = WuColorCube;
                var WuQuant = function() {
                  function WuQuant2(colorDistanceCalculator, colors, significantBitsPerChannel) {
                    if (colors === void 0) {
                      colors = 256;
                    }
                    if (significantBitsPerChannel === void 0) {
                      significantBitsPerChannel = 5;
                    }
                    this._distance = colorDistanceCalculator;
                    this._setQuality(significantBitsPerChannel);
                    this._initialize(colors);
                  }
                  WuQuant2.prototype.sample = function(image) {
                    var pointArray = image.getPointArray();
                    for (var i = 0, l = pointArray.length; i < l; i++) {
                      this._addColor(pointArray[i]);
                    }
                    this._pixels = this._pixels.concat(pointArray);
                  };
                  WuQuant2.prototype.quantize = function() {
                    this._preparePalette();
                    var palette = new palette_1.Palette();
                    for (var paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {
                      if (this._sums[paletteIndex] > 0) {
                        var sum = this._sums[paletteIndex], r = this._reds[paletteIndex] / sum, g = this._greens[paletteIndex] / sum, b = this._blues[paletteIndex] / sum, a = this._alphas[paletteIndex] / sum;
                        var color = point_1.Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);
                        palette.add(color);
                      }
                    }
                    palette.sort();
                    return palette;
                  };
                  WuQuant2.prototype._preparePalette = function() {
                    this._calculateMoments();
                    var next = 0, volumeVariance = createArray1D(this._colors);
                    for (var cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {
                      if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {
                        volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0;
                        volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0;
                      } else {
                        volumeVariance[next] = 0;
                        cubeIndex--;
                      }
                      next = 0;
                      var temp = volumeVariance[0];
                      for (var index = 1; index <= cubeIndex; ++index) {
                        if (volumeVariance[index] > temp) {
                          temp = volumeVariance[index];
                          next = index;
                        }
                      }
                      if (temp <= 0) {
                        this._colors = cubeIndex + 1;
                        break;
                      }
                    }
                    var lookupRed = [], lookupGreen = [], lookupBlue = [], lookupAlpha = [];
                    for (var k = 0; k < this._colors; ++k) {
                      var weight = WuQuant2._volume(this._cubes[k], this._weights);
                      if (weight > 0) {
                        lookupRed[k] = WuQuant2._volume(this._cubes[k], this._momentsRed) / weight | 0;
                        lookupGreen[k] = WuQuant2._volume(this._cubes[k], this._momentsGreen) / weight | 0;
                        lookupBlue[k] = WuQuant2._volume(this._cubes[k], this._momentsBlue) / weight | 0;
                        lookupAlpha[k] = WuQuant2._volume(this._cubes[k], this._momentsAlpha) / weight | 0;
                      } else {
                        lookupRed[k] = 0;
                        lookupGreen[k] = 0;
                        lookupBlue[k] = 0;
                        lookupAlpha[k] = 0;
                      }
                    }
                    this._reds = createArray1D(this._colors + 1);
                    this._greens = createArray1D(this._colors + 1);
                    this._blues = createArray1D(this._colors + 1);
                    this._alphas = createArray1D(this._colors + 1);
                    this._sums = createArray1D(this._colors + 1);
                    for (var index = 0, l = this._pixels.length; index < l; index++) {
                      var color = this._pixels[index];
                      var match = -1;
                      var bestMatch = match, bestDistance = Number.MAX_VALUE;
                      for (var lookup = 0; lookup < this._colors; lookup++) {
                        var foundRed = lookupRed[lookup], foundGreen = lookupGreen[lookup], foundBlue = lookupBlue[lookup], foundAlpha = lookupAlpha[lookup];
                        var distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);
                        if (distance < bestDistance) {
                          bestDistance = distance;
                          bestMatch = lookup;
                        }
                      }
                      this._reds[bestMatch] += color.r;
                      this._greens[bestMatch] += color.g;
                      this._blues[bestMatch] += color.b;
                      this._alphas[bestMatch] += color.a;
                      this._sums[bestMatch]++;
                    }
                  };
                  WuQuant2.prototype._addColor = function(color) {
                    var bitsToRemove = 8 - this._significantBitsPerChannel, indexRed = (color.r >> bitsToRemove) + 1, indexGreen = (color.g >> bitsToRemove) + 1, indexBlue = (color.b >> bitsToRemove) + 1, indexAlpha = (color.a >> bitsToRemove) + 1;
                    this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;
                    this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;
                    this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;
                    this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;
                    this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;
                    this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];
                  };
                  WuQuant2.prototype._calculateMoments = function() {
                    var area = [], areaRed = [], areaGreen = [], areaBlue = [], areaAlpha = [], area2 = [];
                    var xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize), xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);
                    for (var alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {
                      fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);
                      fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);
                      fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);
                      fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);
                      fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);
                      fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);
                      for (var redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex) {
                        fillArray1D(area, this._sideSize, 0);
                        fillArray1D(areaRed, this._sideSize, 0);
                        fillArray1D(areaGreen, this._sideSize, 0);
                        fillArray1D(areaBlue, this._sideSize, 0);
                        fillArray1D(areaAlpha, this._sideSize, 0);
                        fillArray1D(area2, this._sideSize, 0);
                        for (var greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {
                          var line = 0, lineRed = 0, lineGreen = 0, lineBlue = 0, lineAlpha = 0, line2 = 0;
                          for (var blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {
                            line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];
                            lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];
                            lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];
                            lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];
                            lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];
                            line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];
                            area[blueIndex] += line;
                            areaRed[blueIndex] += lineRed;
                            areaGreen[blueIndex] += lineGreen;
                            areaBlue[blueIndex] += lineBlue;
                            areaAlpha[blueIndex] += lineAlpha;
                            area2[blueIndex] += line2;
                            xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];
                            xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];
                            xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];
                            xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];
                            xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];
                            xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];
                            this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];
                            this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];
                            this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];
                            this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];
                            this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];
                            this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];
                          }
                        }
                      }
                    }
                  };
                  WuQuant2._volumeFloat = function(cube, moment) {
                    return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                  };
                  WuQuant2._volume = function(cube, moment) {
                    return WuQuant2._volumeFloat(cube, moment) | 0;
                  };
                  WuQuant2._top = function(cube, direction, position, moment) {
                    var result;
                    switch (direction) {
                      case WuQuant2.alpha:
                        result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                        break;
                      case WuQuant2.red:
                        result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);
                        break;
                      case WuQuant2.green:
                        result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);
                        break;
                      case WuQuant2.blue:
                        result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);
                        break;
                      default:
                        throw new Error("impossible");
                    }
                    return result | 0;
                  };
                  WuQuant2._bottom = function(cube, direction, moment) {
                    switch (direction) {
                      case WuQuant2.alpha:
                        return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                      case WuQuant2.red:
                        return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                      case WuQuant2.green:
                        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                      case WuQuant2.blue:
                        return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                      default:
                        return 0;
                    }
                  };
                  WuQuant2.prototype._calculateVariance = function(cube) {
                    var volumeRed = WuQuant2._volume(cube, this._momentsRed), volumeGreen = WuQuant2._volume(cube, this._momentsGreen), volumeBlue = WuQuant2._volume(cube, this._momentsBlue), volumeAlpha = WuQuant2._volume(cube, this._momentsAlpha), volumeMoment = WuQuant2._volumeFloat(cube, this._moments), volumeWeight = WuQuant2._volume(cube, this._weights), distance = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;
                    return volumeMoment - distance / volumeWeight;
                  };
                  WuQuant2.prototype._maximize = function(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {
                    var bottomRed = WuQuant2._bottom(cube, direction, this._momentsRed) | 0, bottomGreen = WuQuant2._bottom(cube, direction, this._momentsGreen) | 0, bottomBlue = WuQuant2._bottom(cube, direction, this._momentsBlue) | 0, bottomAlpha = WuQuant2._bottom(cube, direction, this._momentsAlpha) | 0, bottomWeight = WuQuant2._bottom(cube, direction, this._weights) | 0;
                    var result = 0, cutPosition = -1;
                    for (var position = first; position < last; ++position) {
                      var halfRed = bottomRed + WuQuant2._top(cube, direction, position, this._momentsRed), halfGreen = bottomGreen + WuQuant2._top(cube, direction, position, this._momentsGreen), halfBlue = bottomBlue + WuQuant2._top(cube, direction, position, this._momentsBlue), halfAlpha = bottomAlpha + WuQuant2._top(cube, direction, position, this._momentsAlpha), halfWeight = bottomWeight + WuQuant2._top(cube, direction, position, this._weights);
                      if (halfWeight != 0) {
                        var halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha, temp = halfDistance / halfWeight;
                        halfRed = wholeRed - halfRed;
                        halfGreen = wholeGreen - halfGreen;
                        halfBlue = wholeBlue - halfBlue;
                        halfAlpha = wholeAlpha - halfAlpha;
                        halfWeight = wholeWeight - halfWeight;
                        if (halfWeight != 0) {
                          halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
                          temp += halfDistance / halfWeight;
                          if (temp > result) {
                            result = temp;
                            cutPosition = position;
                          }
                        }
                      }
                    }
                    return { max: result, position: cutPosition };
                  };
                  WuQuant2.prototype._cut = function(first, second) {
                    var direction;
                    var wholeRed = WuQuant2._volume(first, this._momentsRed), wholeGreen = WuQuant2._volume(first, this._momentsGreen), wholeBlue = WuQuant2._volume(first, this._momentsBlue), wholeAlpha = WuQuant2._volume(first, this._momentsAlpha), wholeWeight = WuQuant2._volume(first, this._weights), red = this._maximize(first, WuQuant2.red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), green = this._maximize(first, WuQuant2.green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), blue = this._maximize(first, WuQuant2.blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), alpha = this._maximize(first, WuQuant2.alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
                    if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {
                      direction = WuQuant2.alpha;
                      if (alpha.position < 0)
                        return false;
                    } else {
                      if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {
                        direction = WuQuant2.red;
                      } else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {
                        direction = WuQuant2.green;
                      } else {
                        direction = WuQuant2.blue;
                      }
                    }
                    second.redMaximum = first.redMaximum;
                    second.greenMaximum = first.greenMaximum;
                    second.blueMaximum = first.blueMaximum;
                    second.alphaMaximum = first.alphaMaximum;
                    switch (direction) {
                      case WuQuant2.red:
                        second.redMinimum = first.redMaximum = red.position;
                        second.greenMinimum = first.greenMinimum;
                        second.blueMinimum = first.blueMinimum;
                        second.alphaMinimum = first.alphaMinimum;
                        break;
                      case WuQuant2.green:
                        second.greenMinimum = first.greenMaximum = green.position;
                        second.redMinimum = first.redMinimum;
                        second.blueMinimum = first.blueMinimum;
                        second.alphaMinimum = first.alphaMinimum;
                        break;
                      case WuQuant2.blue:
                        second.blueMinimum = first.blueMaximum = blue.position;
                        second.redMinimum = first.redMinimum;
                        second.greenMinimum = first.greenMinimum;
                        second.alphaMinimum = first.alphaMinimum;
                        break;
                      case WuQuant2.alpha:
                        second.alphaMinimum = first.alphaMaximum = alpha.position;
                        second.blueMinimum = first.blueMinimum;
                        second.redMinimum = first.redMinimum;
                        second.greenMinimum = first.greenMinimum;
                        break;
                    }
                    first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);
                    second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);
                    return true;
                  };
                  WuQuant2.prototype._initialize = function(colors) {
                    this._colors = colors;
                    this._cubes = [];
                    for (var cubeIndex = 0; cubeIndex < colors; cubeIndex++) {
                      this._cubes[cubeIndex] = new WuColorCube();
                    }
                    this._cubes[0].redMinimum = 0;
                    this._cubes[0].greenMinimum = 0;
                    this._cubes[0].blueMinimum = 0;
                    this._cubes[0].alphaMinimum = 0;
                    this._cubes[0].redMaximum = this._maxSideIndex;
                    this._cubes[0].greenMaximum = this._maxSideIndex;
                    this._cubes[0].blueMaximum = this._maxSideIndex;
                    this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;
                    this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
                    this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
                    this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
                    this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
                    this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
                    this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
                    this._table = [];
                    for (var tableIndex = 0; tableIndex < 256; ++tableIndex) {
                      this._table[tableIndex] = tableIndex * tableIndex;
                    }
                    this._pixels = [];
                  };
                  WuQuant2.prototype._setQuality = function(significantBitsPerChannel) {
                    if (significantBitsPerChannel === void 0) {
                      significantBitsPerChannel = 5;
                    }
                    this._significantBitsPerChannel = significantBitsPerChannel;
                    this._maxSideIndex = 1 << this._significantBitsPerChannel;
                    this._alphaMaxSideIndex = this._maxSideIndex;
                    this._sideSize = this._maxSideIndex + 1;
                    this._alphaSideSize = this._alphaMaxSideIndex + 1;
                  };
                  WuQuant2.alpha = 3;
                  WuQuant2.red = 2;
                  WuQuant2.green = 1;
                  WuQuant2.blue = 0;
                  return WuQuant2;
                }();
                exports4.WuQuant = WuQuant;
              },
              /* 30 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var nearestColor_1 = __webpack_require__(31);
                exports4.NearestColor = nearestColor_1.NearestColor;
                var array_1 = __webpack_require__(32);
                exports4.ErrorDiffusionArray = array_1.ErrorDiffusionArray;
                exports4.ErrorDiffusionArrayKernel = array_1.ErrorDiffusionArrayKernel;
                var riemersma_1 = __webpack_require__(33);
                exports4.ErrorDiffusionRiemersma = riemersma_1.ErrorDiffusionRiemersma;
              },
              /* 31 */
              /***/
              function(module4, exports4) {
                "use strict";
                var NearestColor = function() {
                  function NearestColor2(colorDistanceCalculator) {
                    this._distance = colorDistanceCalculator;
                  }
                  NearestColor2.prototype.quantize = function(pointBuffer, palette) {
                    var pointArray = pointBuffer.getPointArray(), width = pointBuffer.getWidth(), height = pointBuffer.getHeight();
                    for (var y = 0; y < height; y++) {
                      for (var x = 0, idx = y * width; x < width; x++, idx++) {
                        var point = pointArray[idx];
                        point.from(palette.getNearestColor(this._distance, point));
                      }
                    }
                    return pointBuffer;
                  };
                  return NearestColor2;
                }();
                exports4.NearestColor = NearestColor;
              },
              /* 32 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var point_1 = __webpack_require__(24);
                var arithmetic_1 = __webpack_require__(6);
                (function(ErrorDiffusionArrayKernel2) {
                  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FloydSteinberg"] = 0] = "FloydSteinberg";
                  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FalseFloydSteinberg"] = 1] = "FalseFloydSteinberg";
                  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Stucki"] = 2] = "Stucki";
                  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Atkinson"] = 3] = "Atkinson";
                  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Jarvis"] = 4] = "Jarvis";
                  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Burkes"] = 5] = "Burkes";
                  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Sierra"] = 6] = "Sierra";
                  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["TwoSierra"] = 7] = "TwoSierra";
                  ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["SierraLite"] = 8] = "SierraLite";
                })(exports4.ErrorDiffusionArrayKernel || (exports4.ErrorDiffusionArrayKernel = {}));
                var ErrorDiffusionArrayKernel = exports4.ErrorDiffusionArrayKernel;
                var ErrorDiffusionArray = function() {
                  function ErrorDiffusionArray2(colorDistanceCalculator, kernel, serpentine, minimumColorDistanceToDither, calculateErrorLikeGIMP) {
                    if (serpentine === void 0) {
                      serpentine = true;
                    }
                    if (minimumColorDistanceToDither === void 0) {
                      minimumColorDistanceToDither = 0;
                    }
                    if (calculateErrorLikeGIMP === void 0) {
                      calculateErrorLikeGIMP = false;
                    }
                    this._setKernel(kernel);
                    this._distance = colorDistanceCalculator;
                    this._minColorDistance = minimumColorDistanceToDither;
                    this._serpentine = serpentine;
                    this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;
                  }
                  ErrorDiffusionArray2.prototype.quantize = function(pointBuffer, palette) {
                    var pointArray = pointBuffer.getPointArray(), originalPoint = new point_1.Point(), width = pointBuffer.getWidth(), height = pointBuffer.getHeight(), errorLines = [];
                    var dir = 1, maxErrorLines = 1;
                    for (var i = 0; i < this._kernel.length; i++) {
                      var kernelErrorLines = this._kernel[i][2] + 1;
                      if (maxErrorLines < kernelErrorLines)
                        maxErrorLines = kernelErrorLines;
                    }
                    for (var i = 0; i < maxErrorLines; i++) {
                      this._fillErrorLine(errorLines[i] = [], width);
                    }
                    for (var y = 0; y < height; y++) {
                      if (this._serpentine)
                        dir = dir * -1;
                      var lni = y * width, xStart = dir == 1 ? 0 : width - 1, xEnd = dir == 1 ? width : -1;
                      this._fillErrorLine(errorLines[0], width);
                      errorLines.push(errorLines.shift());
                      var errorLine = errorLines[0];
                      for (var x = xStart, idx = lni + xStart; x !== xEnd; x += dir, idx += dir) {
                        var point = pointArray[idx], error = errorLine[x];
                        originalPoint.from(point);
                        var correctedPoint = point_1.Point.createByRGBA(arithmetic_1.inRange0to255Rounded(point.r + error[0]), arithmetic_1.inRange0to255Rounded(point.g + error[1]), arithmetic_1.inRange0to255Rounded(point.b + error[2]), arithmetic_1.inRange0to255Rounded(point.a + error[3]));
                        var palettePoint = palette.getNearestColor(this._distance, correctedPoint);
                        point.from(palettePoint);
                        if (this._minColorDistance) {
                          var dist = this._distance.calculateNormalized(point, palettePoint);
                          if (dist < this._minColorDistance)
                            continue;
                        }
                        var er = void 0, eg = void 0, eb = void 0, ea = void 0;
                        if (this._calculateErrorLikeGIMP) {
                          er = correctedPoint.r - palettePoint.r;
                          eg = correctedPoint.g - palettePoint.g;
                          eb = correctedPoint.b - palettePoint.b;
                          ea = correctedPoint.a - palettePoint.a;
                        } else {
                          er = originalPoint.r - palettePoint.r;
                          eg = originalPoint.g - palettePoint.g;
                          eb = originalPoint.b - palettePoint.b;
                          ea = originalPoint.a - palettePoint.a;
                        }
                        var dStart = dir == 1 ? 0 : this._kernel.length - 1, dEnd = dir == 1 ? this._kernel.length : -1;
                        for (var i = dStart; i !== dEnd; i += dir) {
                          var x1 = this._kernel[i][1] * dir, y1 = this._kernel[i][2];
                          if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {
                            var d = this._kernel[i][0], e = errorLines[y1][x1 + x];
                            e[0] = e[0] + er * d;
                            e[1] = e[1] + eg * d;
                            e[2] = e[2] + eb * d;
                            e[3] = e[3] + ea * d;
                          }
                        }
                      }
                    }
                    return pointBuffer;
                  };
                  ErrorDiffusionArray2.prototype._fillErrorLine = function(errorLine, width) {
                    if (errorLine.length > width) {
                      errorLine.length = width;
                    }
                    var l = errorLine.length;
                    for (var i = 0; i < l; i++) {
                      var error = errorLine[i];
                      error[0] = error[1] = error[2] = error[3] = 0;
                    }
                    for (var i = l; i < width; i++) {
                      errorLine[i] = [0, 0, 0, 0];
                    }
                  };
                  ErrorDiffusionArray2.prototype._setKernel = function(kernel) {
                    switch (kernel) {
                      case ErrorDiffusionArrayKernel.FloydSteinberg:
                        this._kernel = [
                          [7 / 16, 1, 0],
                          [3 / 16, -1, 1],
                          [5 / 16, 0, 1],
                          [1 / 16, 1, 1]
                        ];
                        break;
                      case ErrorDiffusionArrayKernel.FalseFloydSteinberg:
                        this._kernel = [
                          [3 / 8, 1, 0],
                          [3 / 8, 0, 1],
                          [2 / 8, 1, 1]
                        ];
                        break;
                      case ErrorDiffusionArrayKernel.Stucki:
                        this._kernel = [
                          [8 / 42, 1, 0],
                          [4 / 42, 2, 0],
                          [2 / 42, -2, 1],
                          [4 / 42, -1, 1],
                          [8 / 42, 0, 1],
                          [4 / 42, 1, 1],
                          [2 / 42, 2, 1],
                          [1 / 42, -2, 2],
                          [2 / 42, -1, 2],
                          [4 / 42, 0, 2],
                          [2 / 42, 1, 2],
                          [1 / 42, 2, 2]
                        ];
                        break;
                      case ErrorDiffusionArrayKernel.Atkinson:
                        this._kernel = [
                          [1 / 8, 1, 0],
                          [1 / 8, 2, 0],
                          [1 / 8, -1, 1],
                          [1 / 8, 0, 1],
                          [1 / 8, 1, 1],
                          [1 / 8, 0, 2]
                        ];
                        break;
                      case ErrorDiffusionArrayKernel.Jarvis:
                        this._kernel = [
                          [7 / 48, 1, 0],
                          [5 / 48, 2, 0],
                          [3 / 48, -2, 1],
                          [5 / 48, -1, 1],
                          [7 / 48, 0, 1],
                          [5 / 48, 1, 1],
                          [3 / 48, 2, 1],
                          [1 / 48, -2, 2],
                          [3 / 48, -1, 2],
                          [5 / 48, 0, 2],
                          [3 / 48, 1, 2],
                          [1 / 48, 2, 2]
                        ];
                        break;
                      case ErrorDiffusionArrayKernel.Burkes:
                        this._kernel = [
                          [8 / 32, 1, 0],
                          [4 / 32, 2, 0],
                          [2 / 32, -2, 1],
                          [4 / 32, -1, 1],
                          [8 / 32, 0, 1],
                          [4 / 32, 1, 1],
                          [2 / 32, 2, 1]
                        ];
                        break;
                      case ErrorDiffusionArrayKernel.Sierra:
                        this._kernel = [
                          [5 / 32, 1, 0],
                          [3 / 32, 2, 0],
                          [2 / 32, -2, 1],
                          [4 / 32, -1, 1],
                          [5 / 32, 0, 1],
                          [4 / 32, 1, 1],
                          [2 / 32, 2, 1],
                          [2 / 32, -1, 2],
                          [3 / 32, 0, 2],
                          [2 / 32, 1, 2]
                        ];
                        break;
                      case ErrorDiffusionArrayKernel.TwoSierra:
                        this._kernel = [
                          [4 / 16, 1, 0],
                          [3 / 16, 2, 0],
                          [1 / 16, -2, 1],
                          [2 / 16, -1, 1],
                          [3 / 16, 0, 1],
                          [2 / 16, 1, 1],
                          [1 / 16, 2, 1]
                        ];
                        break;
                      case ErrorDiffusionArrayKernel.SierraLite:
                        this._kernel = [
                          [2 / 4, 1, 0],
                          [1 / 4, -1, 1],
                          [1 / 4, 0, 1]
                        ];
                        break;
                      default:
                        throw new Error("ErrorDiffusionArray: unknown kernel = " + kernel);
                    }
                  };
                  return ErrorDiffusionArray2;
                }();
                exports4.ErrorDiffusionArray = ErrorDiffusionArray;
              },
              /* 33 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var hilbertCurve_1 = __webpack_require__(34);
                var point_1 = __webpack_require__(24);
                var arithmetic_1 = __webpack_require__(6);
                var ErrorDiffusionRiemersma = function() {
                  function ErrorDiffusionRiemersma2(colorDistanceCalculator, errorQueueSize, errorPropagation) {
                    if (errorQueueSize === void 0) {
                      errorQueueSize = 16;
                    }
                    if (errorPropagation === void 0) {
                      errorPropagation = 1;
                    }
                    this._distance = colorDistanceCalculator;
                    this._errorPropagation = errorPropagation;
                    this._errorQueueSize = errorQueueSize;
                    this._max = this._errorQueueSize;
                    this._createWeights();
                  }
                  ErrorDiffusionRiemersma2.prototype.quantize = function(pointBuffer, palette) {
                    var _this = this;
                    var curve = new hilbertCurve_1.HilbertCurveBase(), pointArray = pointBuffer.getPointArray(), width = pointBuffer.getWidth(), height = pointBuffer.getHeight(), errorQueue = [];
                    var head = 0;
                    for (var i = 0; i < this._errorQueueSize; i++) {
                      errorQueue[i] = { r: 0, g: 0, b: 0, a: 0 };
                    }
                    curve.walk(width, height, function(x, y) {
                      var p = pointArray[x + y * width];
                      var r = p.r, g = p.g, b = p.b, a = p.a;
                      for (var i2 = 0; i2 < _this._errorQueueSize; i2++) {
                        var weight = _this._weights[i2], e = errorQueue[(i2 + head) % _this._errorQueueSize];
                        r += e.r * weight;
                        g += e.g * weight;
                        b += e.b * weight;
                        a += e.a * weight;
                      }
                      var correctedPoint = point_1.Point.createByRGBA(arithmetic_1.inRange0to255Rounded(r), arithmetic_1.inRange0to255Rounded(g), arithmetic_1.inRange0to255Rounded(b), arithmetic_1.inRange0to255Rounded(a));
                      var quantizedPoint = palette.getNearestColor(_this._distance, correctedPoint);
                      head = (head + 1) % _this._errorQueueSize;
                      var tail = (head + _this._errorQueueSize - 1) % _this._errorQueueSize;
                      errorQueue[tail].r = p.r - quantizedPoint.r;
                      errorQueue[tail].g = p.g - quantizedPoint.g;
                      errorQueue[tail].b = p.b - quantizedPoint.b;
                      errorQueue[tail].a = p.a - quantizedPoint.a;
                      p.from(quantizedPoint);
                    });
                    return pointBuffer;
                  };
                  ErrorDiffusionRiemersma2.prototype._createWeights = function() {
                    this._weights = [];
                    var multiplier = Math.exp(Math.log(this._max) / (this._errorQueueSize - 1));
                    for (var i = 0, next = 1; i < this._errorQueueSize; i++) {
                      this._weights[i] = (next + 0.5 | 0) / this._max * this._errorPropagation;
                      next *= multiplier;
                    }
                  };
                  return ErrorDiffusionRiemersma2;
                }();
                exports4.ErrorDiffusionRiemersma = ErrorDiffusionRiemersma;
              },
              /* 34 */
              /***/
              function(module4, exports4) {
                "use strict";
                var Direction;
                (function(Direction2) {
                  Direction2[Direction2["NONE"] = 0] = "NONE";
                  Direction2[Direction2["UP"] = 1] = "UP";
                  Direction2[Direction2["LEFT"] = 2] = "LEFT";
                  Direction2[Direction2["RIGHT"] = 3] = "RIGHT";
                  Direction2[Direction2["DOWN"] = 4] = "DOWN";
                })(Direction || (Direction = {}));
                var HilbertCurveBase = function() {
                  function HilbertCurveBase2() {
                  }
                  HilbertCurveBase2.prototype.walk = function(width, height, visitorCallback) {
                    this._x = 0;
                    this._y = 0;
                    this._d = 0;
                    this._width = width;
                    this._height = height;
                    this._callback = visitorCallback;
                    var maxBound = Math.max(width, height);
                    this._level = Math.log(maxBound) / Math.log(2) + 1 | 0;
                    this._walkHilbert(Direction.UP);
                    this._visit(Direction.NONE);
                  };
                  HilbertCurveBase2.prototype._walkHilbert = function(direction) {
                    if (this._level < 1)
                      return;
                    this._level--;
                    switch (direction) {
                      case Direction.LEFT:
                        this._walkHilbert(Direction.UP);
                        this._visit(Direction.RIGHT);
                        this._walkHilbert(Direction.LEFT);
                        this._visit(Direction.DOWN);
                        this._walkHilbert(Direction.LEFT);
                        this._visit(Direction.LEFT);
                        this._walkHilbert(Direction.DOWN);
                        break;
                      case Direction.RIGHT:
                        this._walkHilbert(Direction.DOWN);
                        this._visit(Direction.LEFT);
                        this._walkHilbert(Direction.RIGHT);
                        this._visit(Direction.UP);
                        this._walkHilbert(Direction.RIGHT);
                        this._visit(Direction.RIGHT);
                        this._walkHilbert(Direction.UP);
                        break;
                      case Direction.UP:
                        this._walkHilbert(Direction.LEFT);
                        this._visit(Direction.DOWN);
                        this._walkHilbert(Direction.UP);
                        this._visit(Direction.RIGHT);
                        this._walkHilbert(Direction.UP);
                        this._visit(Direction.UP);
                        this._walkHilbert(Direction.RIGHT);
                        break;
                      case Direction.DOWN:
                        this._walkHilbert(Direction.RIGHT);
                        this._visit(Direction.UP);
                        this._walkHilbert(Direction.DOWN);
                        this._visit(Direction.LEFT);
                        this._walkHilbert(Direction.DOWN);
                        this._visit(Direction.DOWN);
                        this._walkHilbert(Direction.LEFT);
                        break;
                      default:
                        break;
                    }
                    this._level++;
                  };
                  HilbertCurveBase2.prototype._visit = function(direction) {
                    if (this._x >= 0 && this._x < this._width && this._y >= 0 && this._y < this._height) {
                      this._callback(this._x, this._y, this._d);
                      this._d++;
                    }
                    switch (direction) {
                      case Direction.LEFT:
                        this._x--;
                        break;
                      case Direction.RIGHT:
                        this._x++;
                        break;
                      case Direction.UP:
                        this._y--;
                        break;
                      case Direction.DOWN:
                        this._y++;
                        break;
                    }
                  };
                  return HilbertCurveBase2;
                }();
                exports4.HilbertCurveBase = HilbertCurveBase;
              },
              /* 35 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var ssim_1 = __webpack_require__(36);
                exports4.SSIM = ssim_1.SSIM;
              },
              /* 36 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var bt709_1 = __webpack_require__(2);
                var K1 = 0.01, K2 = 0.03;
                var SSIM = function() {
                  function SSIM2() {
                  }
                  SSIM2.prototype.compare = function(image1, image2) {
                    if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {
                      throw new Error("Images have different sizes!");
                    }
                    var bitsPerComponent = 8, L = (1 << bitsPerComponent) - 1, c1 = Math.pow(K1 * L, 2), c2 = Math.pow(K2 * L, 2);
                    var numWindows = 0, mssim = 0;
                    this._iterate(image1, image2, function(lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) {
                      var sigxy = 0, sigsqx = 0, sigsqy = 0;
                      for (var i = 0; i < lumaValues1.length; i++) {
                        sigsqx += Math.pow(lumaValues1[i] - averageLumaValue1, 2);
                        sigsqy += Math.pow(lumaValues2[i] - averageLumaValue2, 2);
                        sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);
                      }
                      var numPixelsInWin = lumaValues1.length - 1;
                      sigsqx /= numPixelsInWin;
                      sigsqy /= numPixelsInWin;
                      sigxy /= numPixelsInWin;
                      var numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2), denominator = (Math.pow(averageLumaValue1, 2) + Math.pow(averageLumaValue2, 2) + c1) * (sigsqx + sigsqy + c2), ssim = numerator / denominator;
                      mssim += ssim;
                      numWindows++;
                    });
                    return mssim / numWindows;
                  };
                  SSIM2.prototype._iterate = function(image1, image2, callback) {
                    var windowSize = 8, width = image1.getWidth(), height = image1.getHeight();
                    for (var y = 0; y < height; y += windowSize) {
                      for (var x = 0; x < width; x += windowSize) {
                        var windowWidth = Math.min(windowSize, width - x), windowHeight = Math.min(windowSize, height - y);
                        var lumaValues1 = this._calculateLumaValuesForWindow(image1, x, y, windowWidth, windowHeight), lumaValues2 = this._calculateLumaValuesForWindow(image2, x, y, windowWidth, windowHeight), averageLuma1 = this._calculateAverageLuma(lumaValues1), averageLuma2 = this._calculateAverageLuma(lumaValues2);
                        callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);
                      }
                    }
                  };
                  SSIM2.prototype._calculateLumaValuesForWindow = function(image, x, y, width, height) {
                    var pointArray = image.getPointArray(), lumaValues = [];
                    var counter = 0;
                    for (var j = y; j < y + height; j++) {
                      var offset = j * image.getWidth();
                      for (var i = x; i < x + width; i++) {
                        var point = pointArray[offset + i];
                        lumaValues[counter] = point.r * bt709_1.Y.RED + point.g * bt709_1.Y.GREEN + point.b * bt709_1.Y.BLUE;
                        counter++;
                      }
                    }
                    return lumaValues;
                  };
                  SSIM2.prototype._calculateAverageLuma = function(lumaValues) {
                    var sumLuma = 0;
                    for (var i = 0; i < lumaValues.length; i++) {
                      sumLuma += lumaValues[i];
                    }
                    return sumLuma / lumaValues.length;
                  };
                  return SSIM2;
                }();
                exports4.SSIM = SSIM;
              },
              /* 37 */
              /***/
              function(module4, exports4, __webpack_require__) {
                "use strict";
                var arithmetic = __webpack_require__(6);
                exports4.arithmetic = arithmetic;
                var hueStatistics_1 = __webpack_require__(28);
                exports4.HueStatistics = hueStatistics_1.HueStatistics;
                var palette_1 = __webpack_require__(22);
                exports4.Palette = palette_1.Palette;
                var point_1 = __webpack_require__(24);
                exports4.Point = point_1.Point;
                var pointContainer_1 = __webpack_require__(23);
                exports4.PointContainer = pointContainer_1.PointContainer;
              }
              /******/
            ])
          );
        });
        ;
      }, {}], 75: [function(require2, module3, exports3) {
        if (typeof Object.create === "function") {
          module3.exports = function inherits(ctor, superCtor) {
            if (superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
            }
          };
        } else {
          module3.exports = function inherits(ctor, superCtor) {
            if (superCtor) {
              ctor.super_ = superCtor;
              var TempCtor = function() {
              };
              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            }
          };
        }
      }, {}], 76: [function(require2, module3, exports3) {
        module3.exports = function(obj) {
          return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
        };
        function isBuffer(obj) {
          return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
        }
        function isSlowBuffer(obj) {
          return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
        }
      }, {}], 77: [function(require2, module3, exports3) {
        "use strict";
        var fnToStr = Function.prototype.toString;
        var constructorRegex = /^\s*class\b/;
        var isES6ClassFn = function isES6ClassFunction(value) {
          try {
            var fnStr = fnToStr.call(value);
            return constructorRegex.test(fnStr);
          } catch (e) {
            return false;
          }
        };
        var tryFunctionObject = function tryFunctionToStr(value) {
          try {
            if (isES6ClassFn(value)) {
              return false;
            }
            fnToStr.call(value);
            return true;
          } catch (e) {
            return false;
          }
        };
        var toStr = Object.prototype.toString;
        var fnClass = "[object Function]";
        var genClass = "[object GeneratorFunction]";
        var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
        module3.exports = function isCallable(value) {
          if (!value) {
            return false;
          }
          if (typeof value !== "function" && typeof value !== "object") {
            return false;
          }
          if (typeof value === "function" && !value.prototype) {
            return true;
          }
          if (hasToStringTag) {
            return tryFunctionObject(value);
          }
          if (isES6ClassFn(value)) {
            return false;
          }
          var strClass = toStr.call(value);
          return strClass === fnClass || strClass === genClass;
        };
      }, {}], 78: [function(require2, module3, exports3) {
        module3.exports = isFunction;
        var toString = Object.prototype.toString;
        function isFunction(fn) {
          var string = toString.call(fn);
          return string === "[object Function]" || typeof fn === "function" && string !== "[object RegExp]" || typeof window !== "undefined" && // IE8 and below
          (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
        }
        ;
      }, {}], 79: [function(require2, module3, exports3) {
        var toString = {}.toString;
        module3.exports = Array.isArray || function(arr) {
          return toString.call(arr) == "[object Array]";
        };
      }, {}], 80: [function(require2, module3, exports3) {
        var encode = require2("./lib/encoder"), decode = require2("./lib/decoder");
        module3.exports = {
          encode,
          decode
        };
      }, { "./lib/decoder": 81, "./lib/encoder": 82 }], 81: [function(require2, module3, exports3) {
        (function(Buffer) {
          var JpegImage = function jpegImage() {
            "use strict";
            var dctZigZag = new Int32Array([
              0,
              1,
              8,
              16,
              9,
              2,
              3,
              10,
              17,
              24,
              32,
              25,
              18,
              11,
              4,
              5,
              12,
              19,
              26,
              33,
              40,
              48,
              41,
              34,
              27,
              20,
              13,
              6,
              7,
              14,
              21,
              28,
              35,
              42,
              49,
              56,
              57,
              50,
              43,
              36,
              29,
              22,
              15,
              23,
              30,
              37,
              44,
              51,
              58,
              59,
              52,
              45,
              38,
              31,
              39,
              46,
              53,
              60,
              61,
              54,
              47,
              55,
              62,
              63
            ]);
            var dctCos1 = 4017;
            var dctSin1 = 799;
            var dctCos3 = 3406;
            var dctSin3 = 2276;
            var dctCos6 = 1567;
            var dctSin6 = 3784;
            var dctSqrt2 = 5793;
            var dctSqrt1d2 = 2896;
            function constructor() {
            }
            function buildHuffmanTable(codeLengths, values) {
              var k = 0, code = [], i, j, length = 16;
              while (length > 0 && !codeLengths[length - 1])
                length--;
              code.push({ children: [], index: 0 });
              var p = code[0], q;
              for (i = 0; i < length; i++) {
                for (j = 0; j < codeLengths[i]; j++) {
                  p = code.pop();
                  p.children[p.index] = values[k];
                  while (p.index > 0) {
                    if (code.length === 0)
                      throw new Error("Could not recreate Huffman Table");
                    p = code.pop();
                  }
                  p.index++;
                  code.push(p);
                  while (code.length <= i) {
                    code.push(q = { children: [], index: 0 });
                    p.children[p.index] = q.children;
                    p = q;
                  }
                  k++;
                }
                if (i + 1 < length) {
                  code.push(q = { children: [], index: 0 });
                  p.children[p.index] = q.children;
                  p = q;
                }
              }
              return code[0].children;
            }
            function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
              var precision = frame.precision;
              var samplesPerLine = frame.samplesPerLine;
              var scanLines = frame.scanLines;
              var mcusPerLine = frame.mcusPerLine;
              var progressive = frame.progressive;
              var maxH = frame.maxH, maxV = frame.maxV;
              var startOffset = offset, bitsData = 0, bitsCount = 0;
              function readBit() {
                if (bitsCount > 0) {
                  bitsCount--;
                  return bitsData >> bitsCount & 1;
                }
                bitsData = data[offset++];
                if (bitsData == 255) {
                  var nextByte = data[offset++];
                  if (nextByte) {
                    throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
                  }
                }
                bitsCount = 7;
                return bitsData >>> 7;
              }
              function decodeHuffman(tree) {
                var node = tree, bit;
                while ((bit = readBit()) !== null) {
                  node = node[bit];
                  if (typeof node === "number")
                    return node;
                  if (typeof node !== "object")
                    throw new Error("invalid huffman sequence");
                }
                return null;
              }
              function receive(length) {
                var n2 = 0;
                while (length > 0) {
                  var bit = readBit();
                  if (bit === null)
                    return;
                  n2 = n2 << 1 | bit;
                  length--;
                }
                return n2;
              }
              function receiveAndExtend(length) {
                var n2 = receive(length);
                if (n2 >= 1 << length - 1)
                  return n2;
                return n2 + (-1 << length) + 1;
              }
              function decodeBaseline(component2, zz) {
                var t = decodeHuffman(component2.huffmanTableDC);
                var diff = t === 0 ? 0 : receiveAndExtend(t);
                zz[0] = component2.pred += diff;
                var k2 = 1;
                while (k2 < 64) {
                  var rs = decodeHuffman(component2.huffmanTableAC);
                  var s = rs & 15, r = rs >> 4;
                  if (s === 0) {
                    if (r < 15)
                      break;
                    k2 += 16;
                    continue;
                  }
                  k2 += r;
                  var z = dctZigZag[k2];
                  zz[z] = receiveAndExtend(s);
                  k2++;
                }
              }
              function decodeDCFirst(component2, zz) {
                var t = decodeHuffman(component2.huffmanTableDC);
                var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
                zz[0] = component2.pred += diff;
              }
              function decodeDCSuccessive(component2, zz) {
                zz[0] |= readBit() << successive;
              }
              var eobrun = 0;
              function decodeACFirst(component2, zz) {
                if (eobrun > 0) {
                  eobrun--;
                  return;
                }
                var k2 = spectralStart, e = spectralEnd;
                while (k2 <= e) {
                  var rs = decodeHuffman(component2.huffmanTableAC);
                  var s = rs & 15, r = rs >> 4;
                  if (s === 0) {
                    if (r < 15) {
                      eobrun = receive(r) + (1 << r) - 1;
                      break;
                    }
                    k2 += 16;
                    continue;
                  }
                  k2 += r;
                  var z = dctZigZag[k2];
                  zz[z] = receiveAndExtend(s) * (1 << successive);
                  k2++;
                }
              }
              var successiveACState = 0, successiveACNextValue;
              function decodeACSuccessive(component2, zz) {
                var k2 = spectralStart, e = spectralEnd, r = 0;
                while (k2 <= e) {
                  var z = dctZigZag[k2];
                  var direction = zz[z] < 0 ? -1 : 1;
                  switch (successiveACState) {
                    case 0:
                      var rs = decodeHuffman(component2.huffmanTableAC);
                      var s = rs & 15, r = rs >> 4;
                      if (s === 0) {
                        if (r < 15) {
                          eobrun = receive(r) + (1 << r);
                          successiveACState = 4;
                        } else {
                          r = 16;
                          successiveACState = 1;
                        }
                      } else {
                        if (s !== 1)
                          throw new Error("invalid ACn encoding");
                        successiveACNextValue = receiveAndExtend(s);
                        successiveACState = r ? 2 : 3;
                      }
                      continue;
                    case 1:
                    case 2:
                      if (zz[z])
                        zz[z] += (readBit() << successive) * direction;
                      else {
                        r--;
                        if (r === 0)
                          successiveACState = successiveACState == 2 ? 3 : 0;
                      }
                      break;
                    case 3:
                      if (zz[z])
                        zz[z] += (readBit() << successive) * direction;
                      else {
                        zz[z] = successiveACNextValue << successive;
                        successiveACState = 0;
                      }
                      break;
                    case 4:
                      if (zz[z])
                        zz[z] += (readBit() << successive) * direction;
                      break;
                  }
                  k2++;
                }
                if (successiveACState === 4) {
                  eobrun--;
                  if (eobrun === 0)
                    successiveACState = 0;
                }
              }
              function decodeMcu(component2, decode2, mcu2, row, col) {
                var mcuRow = mcu2 / mcusPerLine | 0;
                var mcuCol = mcu2 % mcusPerLine;
                var blockRow = mcuRow * component2.v + row;
                var blockCol = mcuCol * component2.h + col;
                if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
                  return;
                decode2(component2, component2.blocks[blockRow][blockCol]);
              }
              function decodeBlock(component2, decode2, mcu2) {
                var blockRow = mcu2 / component2.blocksPerLine | 0;
                var blockCol = mcu2 % component2.blocksPerLine;
                if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
                  return;
                decode2(component2, component2.blocks[blockRow][blockCol]);
              }
              var componentsLength = components.length;
              var component, i, j, k, n;
              var decodeFn;
              if (progressive) {
                if (spectralStart === 0)
                  decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
                else
                  decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
              } else {
                decodeFn = decodeBaseline;
              }
              var mcu = 0, marker;
              var mcuExpected;
              if (componentsLength == 1) {
                mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
              } else {
                mcuExpected = mcusPerLine * frame.mcusPerColumn;
              }
              if (!resetInterval)
                resetInterval = mcuExpected;
              var h, v;
              while (mcu < mcuExpected) {
                for (i = 0; i < componentsLength; i++)
                  components[i].pred = 0;
                eobrun = 0;
                if (componentsLength == 1) {
                  component = components[0];
                  for (n = 0; n < resetInterval; n++) {
                    decodeBlock(component, decodeFn, mcu);
                    mcu++;
                  }
                } else {
                  for (n = 0; n < resetInterval; n++) {
                    for (i = 0; i < componentsLength; i++) {
                      component = components[i];
                      h = component.h;
                      v = component.v;
                      for (j = 0; j < v; j++) {
                        for (k = 0; k < h; k++) {
                          decodeMcu(component, decodeFn, mcu, j, k);
                        }
                      }
                    }
                    mcu++;
                    if (mcu === mcuExpected)
                      break;
                  }
                }
                if (mcu === mcuExpected) {
                  do {
                    if (data[offset] === 255) {
                      if (data[offset + 1] !== 0) {
                        break;
                      }
                    }
                    offset += 1;
                  } while (offset < data.length - 2);
                }
                bitsCount = 0;
                marker = data[offset] << 8 | data[offset + 1];
                if (marker < 65280) {
                  throw new Error("marker was not found");
                }
                if (marker >= 65488 && marker <= 65495) {
                  offset += 2;
                } else
                  break;
              }
              return offset - startOffset;
            }
            function buildComponentData(frame, component) {
              var lines = [];
              var blocksPerLine = component.blocksPerLine;
              var blocksPerColumn = component.blocksPerColumn;
              var samplesPerLine = blocksPerLine << 3;
              var R = new Int32Array(64), r = new Uint8Array(64);
              function quantizeAndInverse(zz, dataOut, dataIn) {
                var qt = component.quantizationTable;
                var v0, v1, v2, v3, v4, v5, v6, v7, t;
                var p = dataIn;
                var i2;
                for (i2 = 0; i2 < 64; i2++)
                  p[i2] = zz[i2] * qt[i2];
                for (i2 = 0; i2 < 8; ++i2) {
                  var row = 8 * i2;
                  if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
                    t = dctSqrt2 * p[0 + row] + 512 >> 10;
                    p[0 + row] = t;
                    p[1 + row] = t;
                    p[2 + row] = t;
                    p[3 + row] = t;
                    p[4 + row] = t;
                    p[5 + row] = t;
                    p[6 + row] = t;
                    p[7 + row] = t;
                    continue;
                  }
                  v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
                  v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
                  v2 = p[2 + row];
                  v3 = p[6 + row];
                  v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
                  v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
                  v5 = p[3 + row] << 4;
                  v6 = p[5 + row] << 4;
                  t = v0 - v1 + 1 >> 1;
                  v0 = v0 + v1 + 1 >> 1;
                  v1 = t;
                  t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
                  v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
                  v3 = t;
                  t = v4 - v6 + 1 >> 1;
                  v4 = v4 + v6 + 1 >> 1;
                  v6 = t;
                  t = v7 + v5 + 1 >> 1;
                  v5 = v7 - v5 + 1 >> 1;
                  v7 = t;
                  t = v0 - v3 + 1 >> 1;
                  v0 = v0 + v3 + 1 >> 1;
                  v3 = t;
                  t = v1 - v2 + 1 >> 1;
                  v1 = v1 + v2 + 1 >> 1;
                  v2 = t;
                  t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
                  v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
                  v7 = t;
                  t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
                  v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
                  v6 = t;
                  p[0 + row] = v0 + v7;
                  p[7 + row] = v0 - v7;
                  p[1 + row] = v1 + v6;
                  p[6 + row] = v1 - v6;
                  p[2 + row] = v2 + v5;
                  p[5 + row] = v2 - v5;
                  p[3 + row] = v3 + v4;
                  p[4 + row] = v3 - v4;
                }
                for (i2 = 0; i2 < 8; ++i2) {
                  var col = i2;
                  if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
                    t = dctSqrt2 * dataIn[i2 + 0] + 8192 >> 14;
                    p[0 * 8 + col] = t;
                    p[1 * 8 + col] = t;
                    p[2 * 8 + col] = t;
                    p[3 * 8 + col] = t;
                    p[4 * 8 + col] = t;
                    p[5 * 8 + col] = t;
                    p[6 * 8 + col] = t;
                    p[7 * 8 + col] = t;
                    continue;
                  }
                  v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
                  v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
                  v2 = p[2 * 8 + col];
                  v3 = p[6 * 8 + col];
                  v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
                  v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
                  v5 = p[3 * 8 + col];
                  v6 = p[5 * 8 + col];
                  t = v0 - v1 + 1 >> 1;
                  v0 = v0 + v1 + 1 >> 1;
                  v1 = t;
                  t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
                  v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
                  v3 = t;
                  t = v4 - v6 + 1 >> 1;
                  v4 = v4 + v6 + 1 >> 1;
                  v6 = t;
                  t = v7 + v5 + 1 >> 1;
                  v5 = v7 - v5 + 1 >> 1;
                  v7 = t;
                  t = v0 - v3 + 1 >> 1;
                  v0 = v0 + v3 + 1 >> 1;
                  v3 = t;
                  t = v1 - v2 + 1 >> 1;
                  v1 = v1 + v2 + 1 >> 1;
                  v2 = t;
                  t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
                  v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
                  v7 = t;
                  t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
                  v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
                  v6 = t;
                  p[0 * 8 + col] = v0 + v7;
                  p[7 * 8 + col] = v0 - v7;
                  p[1 * 8 + col] = v1 + v6;
                  p[6 * 8 + col] = v1 - v6;
                  p[2 * 8 + col] = v2 + v5;
                  p[5 * 8 + col] = v2 - v5;
                  p[3 * 8 + col] = v3 + v4;
                  p[4 * 8 + col] = v3 - v4;
                }
                for (i2 = 0; i2 < 64; ++i2) {
                  var sample2 = 128 + (p[i2] + 8 >> 4);
                  dataOut[i2] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
                }
              }
              requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
              var i, j;
              for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
                var scanLine = blockRow << 3;
                for (i = 0; i < 8; i++)
                  lines.push(new Uint8Array(samplesPerLine));
                for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
                  quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
                  var offset = 0, sample = blockCol << 3;
                  for (j = 0; j < 8; j++) {
                    var line = lines[scanLine + j];
                    for (i = 0; i < 8; i++)
                      line[sample + i] = r[offset++];
                  }
                }
              }
              return lines;
            }
            function clampTo8bit(a) {
              return a < 0 ? 0 : a > 255 ? 255 : a;
            }
            constructor.prototype = {
              load: function load(path) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", path, true);
                xhr.responseType = "arraybuffer";
                xhr.onload = (function() {
                  var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
                  this.parse(data);
                  if (this.onload)
                    this.onload();
                }).bind(this);
                xhr.send(null);
              },
              parse: function parse(data) {
                var maxResolutionInPixels = this.opts.maxResolutionInMP * 1e3 * 1e3;
                var offset = 0, length = data.length;
                function readUint16() {
                  var value = data[offset] << 8 | data[offset + 1];
                  offset += 2;
                  return value;
                }
                function readDataBlock() {
                  var length2 = readUint16();
                  var array = data.subarray(offset, offset + length2 - 2);
                  offset += array.length;
                  return array;
                }
                function prepareComponents(frame2) {
                  var maxH2 = 0, maxV2 = 0;
                  var component2, componentId2;
                  for (componentId2 in frame2.components) {
                    if (frame2.components.hasOwnProperty(componentId2)) {
                      component2 = frame2.components[componentId2];
                      if (maxH2 < component2.h)
                        maxH2 = component2.h;
                      if (maxV2 < component2.v)
                        maxV2 = component2.v;
                    }
                  }
                  var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH2);
                  var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV2);
                  for (componentId2 in frame2.components) {
                    if (frame2.components.hasOwnProperty(componentId2)) {
                      component2 = frame2.components[componentId2];
                      var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH2);
                      var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV2);
                      var blocksPerLineForMcu = mcusPerLine * component2.h;
                      var blocksPerColumnForMcu = mcusPerColumn * component2.v;
                      var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
                      var blocks = [];
                      requestMemoryAllocation(blocksToAllocate * 256);
                      for (var i2 = 0; i2 < blocksPerColumnForMcu; i2++) {
                        var row = [];
                        for (var j2 = 0; j2 < blocksPerLineForMcu; j2++)
                          row.push(new Int32Array(64));
                        blocks.push(row);
                      }
                      component2.blocksPerLine = blocksPerLine;
                      component2.blocksPerColumn = blocksPerColumn;
                      component2.blocks = blocks;
                    }
                  }
                  frame2.maxH = maxH2;
                  frame2.maxV = maxV2;
                  frame2.mcusPerLine = mcusPerLine;
                  frame2.mcusPerColumn = mcusPerColumn;
                }
                var jfif = null;
                var adobe = null;
                var pixels = null;
                var frame, resetInterval;
                var quantizationTables = [], frames = [];
                var huffmanTablesAC = [], huffmanTablesDC = [];
                var fileMarker = readUint16();
                if (fileMarker != 65496) {
                  throw new Error("SOI not found");
                }
                fileMarker = readUint16();
                while (fileMarker != 65497) {
                  var i, j, l;
                  switch (fileMarker) {
                    case 65280:
                      break;
                    case 65504:
                    case 65505:
                    case 65506:
                    case 65507:
                    case 65508:
                    case 65509:
                    case 65510:
                    case 65511:
                    case 65512:
                    case 65513:
                    case 65514:
                    case 65515:
                    case 65516:
                    case 65517:
                    case 65518:
                    case 65519:
                    case 65534:
                      var appData = readDataBlock();
                      if (fileMarker === 65504) {
                        if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                          jfif = {
                            version: { major: appData[5], minor: appData[6] },
                            densityUnits: appData[7],
                            xDensity: appData[8] << 8 | appData[9],
                            yDensity: appData[10] << 8 | appData[11],
                            thumbWidth: appData[12],
                            thumbHeight: appData[13],
                            thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                          };
                        }
                      }
                      if (fileMarker === 65505) {
                        if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
                          this.exifBuffer = appData.subarray(5, appData.length);
                        }
                      }
                      if (fileMarker === 65518) {
                        if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                          adobe = {
                            version: appData[6],
                            flags0: appData[7] << 8 | appData[8],
                            flags1: appData[9] << 8 | appData[10],
                            transformCode: appData[11]
                          };
                        }
                      }
                      break;
                    case 65499:
                      var quantizationTablesLength = readUint16();
                      var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                      while (offset < quantizationTablesEnd) {
                        var quantizationTableSpec = data[offset++];
                        requestMemoryAllocation(64 * 4);
                        var tableData = new Int32Array(64);
                        if (quantizationTableSpec >> 4 === 0) {
                          for (j = 0; j < 64; j++) {
                            var z = dctZigZag[j];
                            tableData[z] = data[offset++];
                          }
                        } else if (quantizationTableSpec >> 4 === 1) {
                          for (j = 0; j < 64; j++) {
                            var z = dctZigZag[j];
                            tableData[z] = readUint16();
                          }
                        } else
                          throw new Error("DQT: invalid table spec");
                        quantizationTables[quantizationTableSpec & 15] = tableData;
                      }
                      break;
                    case 65472:
                    case 65473:
                    case 65474:
                      readUint16();
                      frame = {};
                      frame.extended = fileMarker === 65473;
                      frame.progressive = fileMarker === 65474;
                      frame.precision = data[offset++];
                      frame.scanLines = readUint16();
                      frame.samplesPerLine = readUint16();
                      frame.components = {};
                      frame.componentsOrder = [];
                      var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
                      if (pixelsInFrame > maxResolutionInPixels) {
                        var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                        throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
                      }
                      var componentsCount = data[offset++], componentId;
                      var maxH = 0, maxV = 0;
                      for (i = 0; i < componentsCount; i++) {
                        componentId = data[offset];
                        var h = data[offset + 1] >> 4;
                        var v = data[offset + 1] & 15;
                        var qId = data[offset + 2];
                        frame.componentsOrder.push(componentId);
                        frame.components[componentId] = {
                          h,
                          v,
                          quantizationIdx: qId
                        };
                        offset += 3;
                      }
                      prepareComponents(frame);
                      frames.push(frame);
                      break;
                    case 65476:
                      var huffmanLength = readUint16();
                      for (i = 2; i < huffmanLength; ) {
                        var huffmanTableSpec = data[offset++];
                        var codeLengths = new Uint8Array(16);
                        var codeLengthSum = 0;
                        for (j = 0; j < 16; j++, offset++) {
                          codeLengthSum += codeLengths[j] = data[offset];
                        }
                        requestMemoryAllocation(16 + codeLengthSum);
                        var huffmanValues = new Uint8Array(codeLengthSum);
                        for (j = 0; j < codeLengthSum; j++, offset++)
                          huffmanValues[j] = data[offset];
                        i += 17 + codeLengthSum;
                        (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                      }
                      break;
                    case 65501:
                      readUint16();
                      resetInterval = readUint16();
                      break;
                    case 65498:
                      var scanLength = readUint16();
                      var selectorsCount = data[offset++];
                      var components = [], component;
                      for (i = 0; i < selectorsCount; i++) {
                        component = frame.components[data[offset++]];
                        var tableSpec = data[offset++];
                        component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                        component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                        components.push(component);
                      }
                      var spectralStart = data[offset++];
                      var spectralEnd = data[offset++];
                      var successiveApproximation = data[offset++];
                      var processed = decodeScan(
                        data,
                        offset,
                        frame,
                        components,
                        resetInterval,
                        spectralStart,
                        spectralEnd,
                        successiveApproximation >> 4,
                        successiveApproximation & 15,
                        this.opts
                      );
                      offset += processed;
                      break;
                    case 65535:
                      if (data[offset] !== 255) {
                        offset--;
                      }
                      break;
                    default:
                      if (data[offset - 3] == 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                        offset -= 3;
                        break;
                      }
                      throw new Error("unknown JPEG marker " + fileMarker.toString(16));
                  }
                  fileMarker = readUint16();
                }
                if (frames.length != 1)
                  throw new Error("only single frame JPEGs supported");
                for (var i = 0; i < frames.length; i++) {
                  var cp = frames[i].components;
                  for (var j in cp) {
                    cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
                    delete cp[j].quantizationIdx;
                  }
                }
                this.width = frame.samplesPerLine;
                this.height = frame.scanLines;
                this.jfif = jfif;
                this.adobe = adobe;
                this.components = [];
                for (var i = 0; i < frame.componentsOrder.length; i++) {
                  var component = frame.components[frame.componentsOrder[i]];
                  this.components.push({
                    lines: buildComponentData(frame, component),
                    scaleX: component.h / frame.maxH,
                    scaleY: component.v / frame.maxV
                  });
                }
              },
              getData: function getData(width, height) {
                var scaleX = this.width / width, scaleY = this.height / height;
                var component1, component2, component3, component4;
                var component1Line, component2Line, component3Line, component4Line;
                var x, y;
                var offset = 0;
                var Y, Cb, Cr, K, C, M, Ye, R, G, B;
                var colorTransform;
                var dataLength = width * height * this.components.length;
                requestMemoryAllocation(dataLength);
                var data = new Uint8Array(dataLength);
                switch (this.components.length) {
                  case 1:
                    component1 = this.components[0];
                    for (y = 0; y < height; y++) {
                      component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                      for (x = 0; x < width; x++) {
                        Y = component1Line[0 | x * component1.scaleX * scaleX];
                        data[offset++] = Y;
                      }
                    }
                    break;
                  case 2:
                    component1 = this.components[0];
                    component2 = this.components[1];
                    for (y = 0; y < height; y++) {
                      component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                      component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                      for (x = 0; x < width; x++) {
                        Y = component1Line[0 | x * component1.scaleX * scaleX];
                        data[offset++] = Y;
                        Y = component2Line[0 | x * component2.scaleX * scaleX];
                        data[offset++] = Y;
                      }
                    }
                    break;
                  case 3:
                    colorTransform = true;
                    if (this.adobe && this.adobe.transformCode)
                      colorTransform = true;
                    else if (typeof this.opts.colorTransform !== "undefined")
                      colorTransform = !!this.opts.colorTransform;
                    component1 = this.components[0];
                    component2 = this.components[1];
                    component3 = this.components[2];
                    for (y = 0; y < height; y++) {
                      component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                      component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                      component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                      for (x = 0; x < width; x++) {
                        if (!colorTransform) {
                          R = component1Line[0 | x * component1.scaleX * scaleX];
                          G = component2Line[0 | x * component2.scaleX * scaleX];
                          B = component3Line[0 | x * component3.scaleX * scaleX];
                        } else {
                          Y = component1Line[0 | x * component1.scaleX * scaleX];
                          Cb = component2Line[0 | x * component2.scaleX * scaleX];
                          Cr = component3Line[0 | x * component3.scaleX * scaleX];
                          R = clampTo8bit(Y + 1.402 * (Cr - 128));
                          G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                          B = clampTo8bit(Y + 1.772 * (Cb - 128));
                        }
                        data[offset++] = R;
                        data[offset++] = G;
                        data[offset++] = B;
                      }
                    }
                    break;
                  case 4:
                    if (!this.adobe)
                      throw new Error("Unsupported color mode (4 components)");
                    colorTransform = false;
                    if (this.adobe && this.adobe.transformCode)
                      colorTransform = true;
                    else if (typeof this.opts.colorTransform !== "undefined")
                      colorTransform = !!this.opts.colorTransform;
                    component1 = this.components[0];
                    component2 = this.components[1];
                    component3 = this.components[2];
                    component4 = this.components[3];
                    for (y = 0; y < height; y++) {
                      component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                      component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                      component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                      component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
                      for (x = 0; x < width; x++) {
                        if (!colorTransform) {
                          C = component1Line[0 | x * component1.scaleX * scaleX];
                          M = component2Line[0 | x * component2.scaleX * scaleX];
                          Ye = component3Line[0 | x * component3.scaleX * scaleX];
                          K = component4Line[0 | x * component4.scaleX * scaleX];
                        } else {
                          Y = component1Line[0 | x * component1.scaleX * scaleX];
                          Cb = component2Line[0 | x * component2.scaleX * scaleX];
                          Cr = component3Line[0 | x * component3.scaleX * scaleX];
                          K = component4Line[0 | x * component4.scaleX * scaleX];
                          C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                          M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                          Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                        }
                        data[offset++] = 255 - C;
                        data[offset++] = 255 - M;
                        data[offset++] = 255 - Ye;
                        data[offset++] = 255 - K;
                      }
                    }
                    break;
                  default:
                    throw new Error("Unsupported color mode");
                }
                return data;
              },
              copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
                var width = imageData.width, height = imageData.height;
                var imageDataArray = imageData.data;
                var data = this.getData(width, height);
                var i = 0, j = 0, x, y;
                var Y, K, C, M, R, G, B;
                switch (this.components.length) {
                  case 1:
                    for (y = 0; y < height; y++) {
                      for (x = 0; x < width; x++) {
                        Y = data[i++];
                        imageDataArray[j++] = Y;
                        imageDataArray[j++] = Y;
                        imageDataArray[j++] = Y;
                        if (formatAsRGBA) {
                          imageDataArray[j++] = 255;
                        }
                      }
                    }
                    break;
                  case 3:
                    for (y = 0; y < height; y++) {
                      for (x = 0; x < width; x++) {
                        R = data[i++];
                        G = data[i++];
                        B = data[i++];
                        imageDataArray[j++] = R;
                        imageDataArray[j++] = G;
                        imageDataArray[j++] = B;
                        if (formatAsRGBA) {
                          imageDataArray[j++] = 255;
                        }
                      }
                    }
                    break;
                  case 4:
                    for (y = 0; y < height; y++) {
                      for (x = 0; x < width; x++) {
                        C = data[i++];
                        M = data[i++];
                        Y = data[i++];
                        K = data[i++];
                        R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                        G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                        B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                        imageDataArray[j++] = R;
                        imageDataArray[j++] = G;
                        imageDataArray[j++] = B;
                        if (formatAsRGBA) {
                          imageDataArray[j++] = 255;
                        }
                      }
                    }
                    break;
                  default:
                    throw new Error("Unsupported color mode");
                }
              }
            };
            var totalBytesAllocated = 0;
            var maxMemoryUsageBytes = 0;
            function requestMemoryAllocation(increaseAmount = 0) {
              var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
              if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
                var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
                throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
              }
              totalBytesAllocated = totalMemoryImpactBytes;
            }
            constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
              totalBytesAllocated = 0;
              maxMemoryUsageBytes = maxMemoryUsageBytes_;
            };
            constructor.getBytesAllocated = function() {
              return totalBytesAllocated;
            };
            constructor.requestMemoryAllocation = requestMemoryAllocation;
            return constructor;
          }();
          if (typeof module3 !== "undefined") {
            module3.exports = decode;
          } else if (typeof window !== "undefined") {
            window["jpeg-js"] = window["jpeg-js"] || {};
            window["jpeg-js"].decode = decode;
          }
          function decode(jpegData, userOpts = {}) {
            var defaultOpts = {
              // "undefined" means "Choose whether to transform colors based on the images color model."
              colorTransform: void 0,
              useTArray: false,
              formatAsRGBA: true,
              tolerantDecoding: true,
              maxResolutionInMP: 100,
              // Don't decode more than 100 megapixels
              maxMemoryUsageInMB: 512
              // Don't decode if memory footprint is more than 512MB
            };
            var opts = { ...defaultOpts, ...userOpts };
            var arr = new Uint8Array(jpegData);
            var decoder = new JpegImage();
            decoder.opts = opts;
            JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
            decoder.parse(arr);
            var channels = opts.formatAsRGBA ? 4 : 3;
            var bytesNeeded = decoder.width * decoder.height * channels;
            try {
              JpegImage.requestMemoryAllocation(bytesNeeded);
              var image = {
                width: decoder.width,
                height: decoder.height,
                exifBuffer: decoder.exifBuffer,
                data: opts.useTArray ? new Uint8Array(bytesNeeded) : new Buffer(bytesNeeded)
              };
            } catch (err) {
              if (err instanceof RangeError) {
                throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
              } else {
                throw err;
              }
            }
            decoder.copyToImageData(image, opts.formatAsRGBA);
            return image;
          }
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 48 }], 82: [function(require2, module3, exports3) {
        (function(Buffer) {
          var btoa = btoa || function(buf) {
            return new Buffer(buf).toString("base64");
          };
          function JPEGEncoder(quality) {
            var self2 = this;
            var fround = Math.round;
            var ffloor = Math.floor;
            var YTable = new Array(64);
            var UVTable = new Array(64);
            var fdtbl_Y = new Array(64);
            var fdtbl_UV = new Array(64);
            var YDC_HT;
            var UVDC_HT;
            var YAC_HT;
            var UVAC_HT;
            var bitcode = new Array(65535);
            var category = new Array(65535);
            var outputfDCTQuant = new Array(64);
            var DU = new Array(64);
            var byteout = [];
            var bytenew = 0;
            var bytepos = 7;
            var YDU = new Array(64);
            var UDU = new Array(64);
            var VDU = new Array(64);
            var clt = new Array(256);
            var RGB_YUV_TABLE = new Array(2048);
            var currentQuality;
            var ZigZag = [
              0,
              1,
              5,
              6,
              14,
              15,
              27,
              28,
              2,
              4,
              7,
              13,
              16,
              26,
              29,
              42,
              3,
              8,
              12,
              17,
              25,
              30,
              41,
              43,
              9,
              11,
              18,
              24,
              31,
              40,
              44,
              53,
              10,
              19,
              23,
              32,
              39,
              45,
              52,
              54,
              20,
              22,
              33,
              38,
              46,
              51,
              55,
              60,
              21,
              34,
              37,
              47,
              50,
              56,
              59,
              61,
              35,
              36,
              48,
              49,
              57,
              58,
              62,
              63
            ];
            var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
            var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
            var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
            var std_ac_luminance_values = [
              1,
              2,
              3,
              0,
              4,
              17,
              5,
              18,
              33,
              49,
              65,
              6,
              19,
              81,
              97,
              7,
              34,
              113,
              20,
              50,
              129,
              145,
              161,
              8,
              35,
              66,
              177,
              193,
              21,
              82,
              209,
              240,
              36,
              51,
              98,
              114,
              130,
              9,
              10,
              22,
              23,
              24,
              25,
              26,
              37,
              38,
              39,
              40,
              41,
              42,
              52,
              53,
              54,
              55,
              56,
              57,
              58,
              67,
              68,
              69,
              70,
              71,
              72,
              73,
              74,
              83,
              84,
              85,
              86,
              87,
              88,
              89,
              90,
              99,
              100,
              101,
              102,
              103,
              104,
              105,
              106,
              115,
              116,
              117,
              118,
              119,
              120,
              121,
              122,
              131,
              132,
              133,
              134,
              135,
              136,
              137,
              138,
              146,
              147,
              148,
              149,
              150,
              151,
              152,
              153,
              154,
              162,
              163,
              164,
              165,
              166,
              167,
              168,
              169,
              170,
              178,
              179,
              180,
              181,
              182,
              183,
              184,
              185,
              186,
              194,
              195,
              196,
              197,
              198,
              199,
              200,
              201,
              202,
              210,
              211,
              212,
              213,
              214,
              215,
              216,
              217,
              218,
              225,
              226,
              227,
              228,
              229,
              230,
              231,
              232,
              233,
              234,
              241,
              242,
              243,
              244,
              245,
              246,
              247,
              248,
              249,
              250
            ];
            var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
            var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
            var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
            var std_ac_chrominance_values = [
              0,
              1,
              2,
              3,
              17,
              4,
              5,
              33,
              49,
              6,
              18,
              65,
              81,
              7,
              97,
              113,
              19,
              34,
              50,
              129,
              8,
              20,
              66,
              145,
              161,
              177,
              193,
              9,
              35,
              51,
              82,
              240,
              21,
              98,
              114,
              209,
              10,
              22,
              36,
              52,
              225,
              37,
              241,
              23,
              24,
              25,
              26,
              38,
              39,
              40,
              41,
              42,
              53,
              54,
              55,
              56,
              57,
              58,
              67,
              68,
              69,
              70,
              71,
              72,
              73,
              74,
              83,
              84,
              85,
              86,
              87,
              88,
              89,
              90,
              99,
              100,
              101,
              102,
              103,
              104,
              105,
              106,
              115,
              116,
              117,
              118,
              119,
              120,
              121,
              122,
              130,
              131,
              132,
              133,
              134,
              135,
              136,
              137,
              138,
              146,
              147,
              148,
              149,
              150,
              151,
              152,
              153,
              154,
              162,
              163,
              164,
              165,
              166,
              167,
              168,
              169,
              170,
              178,
              179,
              180,
              181,
              182,
              183,
              184,
              185,
              186,
              194,
              195,
              196,
              197,
              198,
              199,
              200,
              201,
              202,
              210,
              211,
              212,
              213,
              214,
              215,
              216,
              217,
              218,
              226,
              227,
              228,
              229,
              230,
              231,
              232,
              233,
              234,
              242,
              243,
              244,
              245,
              246,
              247,
              248,
              249,
              250
            ];
            function initQuantTables(sf) {
              var YQT = [
                16,
                11,
                10,
                16,
                24,
                40,
                51,
                61,
                12,
                12,
                14,
                19,
                26,
                58,
                60,
                55,
                14,
                13,
                16,
                24,
                40,
                57,
                69,
                56,
                14,
                17,
                22,
                29,
                51,
                87,
                80,
                62,
                18,
                22,
                37,
                56,
                68,
                109,
                103,
                77,
                24,
                35,
                55,
                64,
                81,
                104,
                113,
                92,
                49,
                64,
                78,
                87,
                103,
                121,
                120,
                101,
                72,
                92,
                95,
                98,
                112,
                100,
                103,
                99
              ];
              for (var i = 0; i < 64; i++) {
                var t = ffloor((YQT[i] * sf + 50) / 100);
                if (t < 1) {
                  t = 1;
                } else if (t > 255) {
                  t = 255;
                }
                YTable[ZigZag[i]] = t;
              }
              var UVQT = [
                17,
                18,
                24,
                47,
                99,
                99,
                99,
                99,
                18,
                21,
                26,
                66,
                99,
                99,
                99,
                99,
                24,
                26,
                56,
                99,
                99,
                99,
                99,
                99,
                47,
                66,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99,
                99
              ];
              for (var j = 0; j < 64; j++) {
                var u = ffloor((UVQT[j] * sf + 50) / 100);
                if (u < 1) {
                  u = 1;
                } else if (u > 255) {
                  u = 255;
                }
                UVTable[ZigZag[j]] = u;
              }
              var aasf = [
                1,
                1.387039845,
                1.306562965,
                1.175875602,
                1,
                0.785694958,
                0.5411961,
                0.275899379
              ];
              var k = 0;
              for (var row = 0; row < 8; row++) {
                for (var col = 0; col < 8; col++) {
                  fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
                  fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
                  k++;
                }
              }
            }
            function computeHuffmanTbl(nrcodes, std_table) {
              var codevalue = 0;
              var pos_in_table = 0;
              var HT = new Array();
              for (var k = 1; k <= 16; k++) {
                for (var j = 1; j <= nrcodes[k]; j++) {
                  HT[std_table[pos_in_table]] = [];
                  HT[std_table[pos_in_table]][0] = codevalue;
                  HT[std_table[pos_in_table]][1] = k;
                  pos_in_table++;
                  codevalue++;
                }
                codevalue *= 2;
              }
              return HT;
            }
            function initHuffmanTbl() {
              YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
              UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
              YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
              UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
            }
            function initCategoryNumber() {
              var nrlower = 1;
              var nrupper = 2;
              for (var cat = 1; cat <= 15; cat++) {
                for (var nr = nrlower; nr < nrupper; nr++) {
                  category[32767 + nr] = cat;
                  bitcode[32767 + nr] = [];
                  bitcode[32767 + nr][1] = cat;
                  bitcode[32767 + nr][0] = nr;
                }
                for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
                  category[32767 + nrneg] = cat;
                  bitcode[32767 + nrneg] = [];
                  bitcode[32767 + nrneg][1] = cat;
                  bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
                }
                nrlower <<= 1;
                nrupper <<= 1;
              }
            }
            function initRGBYUVTable() {
              for (var i = 0; i < 256; i++) {
                RGB_YUV_TABLE[i] = 19595 * i;
                RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;
                RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 32768;
                RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;
                RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;
                RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 8421375;
                RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;
                RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
              }
            }
            function writeBits(bs) {
              var value = bs[0];
              var posval = bs[1] - 1;
              while (posval >= 0) {
                if (value & 1 << posval) {
                  bytenew |= 1 << bytepos;
                }
                posval--;
                bytepos--;
                if (bytepos < 0) {
                  if (bytenew == 255) {
                    writeByte(255);
                    writeByte(0);
                  } else {
                    writeByte(bytenew);
                  }
                  bytepos = 7;
                  bytenew = 0;
                }
              }
            }
            function writeByte(value) {
              byteout.push(value);
            }
            function writeWord(value) {
              writeByte(value >> 8 & 255);
              writeByte(value & 255);
            }
            function fDCTQuant(data, fdtbl) {
              var d0, d1, d2, d3, d4, d5, d6, d7;
              var dataOff = 0;
              var i;
              var I8 = 8;
              var I64 = 64;
              for (i = 0; i < I8; ++i) {
                d0 = data[dataOff];
                d1 = data[dataOff + 1];
                d2 = data[dataOff + 2];
                d3 = data[dataOff + 3];
                d4 = data[dataOff + 4];
                d5 = data[dataOff + 5];
                d6 = data[dataOff + 6];
                d7 = data[dataOff + 7];
                var tmp0 = d0 + d7;
                var tmp7 = d0 - d7;
                var tmp1 = d1 + d6;
                var tmp6 = d1 - d6;
                var tmp2 = d2 + d5;
                var tmp5 = d2 - d5;
                var tmp3 = d3 + d4;
                var tmp4 = d3 - d4;
                var tmp10 = tmp0 + tmp3;
                var tmp13 = tmp0 - tmp3;
                var tmp11 = tmp1 + tmp2;
                var tmp12 = tmp1 - tmp2;
                data[dataOff] = tmp10 + tmp11;
                data[dataOff + 4] = tmp10 - tmp11;
                var z1 = (tmp12 + tmp13) * 0.707106781;
                data[dataOff + 2] = tmp13 + z1;
                data[dataOff + 6] = tmp13 - z1;
                tmp10 = tmp4 + tmp5;
                tmp11 = tmp5 + tmp6;
                tmp12 = tmp6 + tmp7;
                var z5 = (tmp10 - tmp12) * 0.382683433;
                var z2 = 0.5411961 * tmp10 + z5;
                var z4 = 1.306562965 * tmp12 + z5;
                var z3 = tmp11 * 0.707106781;
                var z11 = tmp7 + z3;
                var z13 = tmp7 - z3;
                data[dataOff + 5] = z13 + z2;
                data[dataOff + 3] = z13 - z2;
                data[dataOff + 1] = z11 + z4;
                data[dataOff + 7] = z11 - z4;
                dataOff += 8;
              }
              dataOff = 0;
              for (i = 0; i < I8; ++i) {
                d0 = data[dataOff];
                d1 = data[dataOff + 8];
                d2 = data[dataOff + 16];
                d3 = data[dataOff + 24];
                d4 = data[dataOff + 32];
                d5 = data[dataOff + 40];
                d6 = data[dataOff + 48];
                d7 = data[dataOff + 56];
                var tmp0p2 = d0 + d7;
                var tmp7p2 = d0 - d7;
                var tmp1p2 = d1 + d6;
                var tmp6p2 = d1 - d6;
                var tmp2p2 = d2 + d5;
                var tmp5p2 = d2 - d5;
                var tmp3p2 = d3 + d4;
                var tmp4p2 = d3 - d4;
                var tmp10p2 = tmp0p2 + tmp3p2;
                var tmp13p2 = tmp0p2 - tmp3p2;
                var tmp11p2 = tmp1p2 + tmp2p2;
                var tmp12p2 = tmp1p2 - tmp2p2;
                data[dataOff] = tmp10p2 + tmp11p2;
                data[dataOff + 32] = tmp10p2 - tmp11p2;
                var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
                data[dataOff + 16] = tmp13p2 + z1p2;
                data[dataOff + 48] = tmp13p2 - z1p2;
                tmp10p2 = tmp4p2 + tmp5p2;
                tmp11p2 = tmp5p2 + tmp6p2;
                tmp12p2 = tmp6p2 + tmp7p2;
                var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
                var z2p2 = 0.5411961 * tmp10p2 + z5p2;
                var z4p2 = 1.306562965 * tmp12p2 + z5p2;
                var z3p2 = tmp11p2 * 0.707106781;
                var z11p2 = tmp7p2 + z3p2;
                var z13p2 = tmp7p2 - z3p2;
                data[dataOff + 40] = z13p2 + z2p2;
                data[dataOff + 24] = z13p2 - z2p2;
                data[dataOff + 8] = z11p2 + z4p2;
                data[dataOff + 56] = z11p2 - z4p2;
                dataOff++;
              }
              var fDCTQuant2;
              for (i = 0; i < I64; ++i) {
                fDCTQuant2 = data[i] * fdtbl[i];
                outputfDCTQuant[i] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
              }
              return outputfDCTQuant;
            }
            function writeAPP0() {
              writeWord(65504);
              writeWord(16);
              writeByte(74);
              writeByte(70);
              writeByte(73);
              writeByte(70);
              writeByte(0);
              writeByte(1);
              writeByte(1);
              writeByte(0);
              writeWord(1);
              writeWord(1);
              writeByte(0);
              writeByte(0);
            }
            function writeAPP1(exifBuffer) {
              if (!exifBuffer)
                return;
              writeWord(65505);
              if (exifBuffer[0] === 69 && exifBuffer[1] === 120 && exifBuffer[2] === 105 && exifBuffer[3] === 102) {
                writeWord(exifBuffer.length + 2);
              } else {
                writeWord(exifBuffer.length + 5 + 2);
                writeByte(69);
                writeByte(120);
                writeByte(105);
                writeByte(102);
                writeByte(0);
              }
              for (var i = 0; i < exifBuffer.length; i++) {
                writeByte(exifBuffer[i]);
              }
            }
            function writeSOF0(width, height) {
              writeWord(65472);
              writeWord(17);
              writeByte(8);
              writeWord(height);
              writeWord(width);
              writeByte(3);
              writeByte(1);
              writeByte(17);
              writeByte(0);
              writeByte(2);
              writeByte(17);
              writeByte(1);
              writeByte(3);
              writeByte(17);
              writeByte(1);
            }
            function writeDQT() {
              writeWord(65499);
              writeWord(132);
              writeByte(0);
              for (var i = 0; i < 64; i++) {
                writeByte(YTable[i]);
              }
              writeByte(1);
              for (var j = 0; j < 64; j++) {
                writeByte(UVTable[j]);
              }
            }
            function writeDHT() {
              writeWord(65476);
              writeWord(418);
              writeByte(0);
              for (var i = 0; i < 16; i++) {
                writeByte(std_dc_luminance_nrcodes[i + 1]);
              }
              for (var j = 0; j <= 11; j++) {
                writeByte(std_dc_luminance_values[j]);
              }
              writeByte(16);
              for (var k = 0; k < 16; k++) {
                writeByte(std_ac_luminance_nrcodes[k + 1]);
              }
              for (var l = 0; l <= 161; l++) {
                writeByte(std_ac_luminance_values[l]);
              }
              writeByte(1);
              for (var m = 0; m < 16; m++) {
                writeByte(std_dc_chrominance_nrcodes[m + 1]);
              }
              for (var n = 0; n <= 11; n++) {
                writeByte(std_dc_chrominance_values[n]);
              }
              writeByte(17);
              for (var o = 0; o < 16; o++) {
                writeByte(std_ac_chrominance_nrcodes[o + 1]);
              }
              for (var p = 0; p <= 161; p++) {
                writeByte(std_ac_chrominance_values[p]);
              }
            }
            function writeSOS() {
              writeWord(65498);
              writeWord(12);
              writeByte(3);
              writeByte(1);
              writeByte(0);
              writeByte(2);
              writeByte(17);
              writeByte(3);
              writeByte(17);
              writeByte(0);
              writeByte(63);
              writeByte(0);
            }
            function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
              var EOB = HTAC[0];
              var M16zeroes = HTAC[240];
              var pos;
              var I16 = 16;
              var I63 = 63;
              var I64 = 64;
              var DU_DCT = fDCTQuant(CDU, fdtbl);
              for (var j = 0; j < I64; ++j) {
                DU[ZigZag[j]] = DU_DCT[j];
              }
              var Diff = DU[0] - DC;
              DC = DU[0];
              if (Diff == 0) {
                writeBits(HTDC[0]);
              } else {
                pos = 32767 + Diff;
                writeBits(HTDC[category[pos]]);
                writeBits(bitcode[pos]);
              }
              var end0pos = 63;
              for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
              }
              ;
              if (end0pos == 0) {
                writeBits(EOB);
                return DC;
              }
              var i = 1;
              var lng;
              while (i <= end0pos) {
                var startpos = i;
                for (; DU[i] == 0 && i <= end0pos; ++i) {
                }
                var nrzeroes = i - startpos;
                if (nrzeroes >= I16) {
                  lng = nrzeroes >> 4;
                  for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
                    writeBits(M16zeroes);
                  nrzeroes = nrzeroes & 15;
                }
                pos = 32767 + DU[i];
                writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
                writeBits(bitcode[pos]);
                i++;
              }
              if (end0pos != I63) {
                writeBits(EOB);
              }
              return DC;
            }
            function initCharLookupTable() {
              var sfcc = String.fromCharCode;
              for (var i = 0; i < 256; i++) {
                clt[i] = sfcc(i);
              }
            }
            this.encode = function(image, quality2) {
              var time_start = (/* @__PURE__ */ new Date()).getTime();
              if (quality2)
                setQuality(quality2);
              byteout = new Array();
              bytenew = 0;
              bytepos = 7;
              writeWord(65496);
              writeAPP0();
              writeAPP1(image.exifBuffer);
              writeDQT();
              writeSOF0(image.width, image.height);
              writeDHT();
              writeSOS();
              var DCY = 0;
              var DCU = 0;
              var DCV = 0;
              bytenew = 0;
              bytepos = 7;
              this.encode.displayName = "_encode_";
              var imageData = image.data;
              var width = image.width;
              var height = image.height;
              var quadWidth = width * 4;
              var tripleWidth = width * 3;
              var x, y = 0;
              var r, g, b;
              var start, p, col, row, pos;
              while (y < height) {
                x = 0;
                while (x < quadWidth) {
                  start = quadWidth * y + x;
                  p = start;
                  col = -1;
                  row = 0;
                  for (pos = 0; pos < 64; pos++) {
                    row = pos >> 3;
                    col = (pos & 7) * 4;
                    p = start + row * quadWidth + col;
                    if (y + row >= height) {
                      p -= quadWidth * (y + 1 + row - height);
                    }
                    if (x + col >= quadWidth) {
                      p -= x + col - quadWidth + 4;
                    }
                    r = imageData[p++];
                    g = imageData[p++];
                    b = imageData[p++];
                    YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
                    UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
                    VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
                  }
                  DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
                  DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
                  DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
                  x += 32;
                }
                y += 8;
              }
              if (bytepos >= 0) {
                var fillbits = [];
                fillbits[1] = bytepos + 1;
                fillbits[0] = (1 << bytepos + 1) - 1;
                writeBits(fillbits);
              }
              writeWord(65497);
              if (typeof module3 === "undefined")
                return new Uint8Array(byteout);
              return new Buffer(byteout);
              var jpegDataUri = "data:image/jpeg;base64," + btoa(byteout.join(""));
              byteout = [];
              var duration = (/* @__PURE__ */ new Date()).getTime() - time_start;
              return jpegDataUri;
            };
            function setQuality(quality2) {
              if (quality2 <= 0) {
                quality2 = 1;
              }
              if (quality2 > 100) {
                quality2 = 100;
              }
              if (currentQuality == quality2)
                return;
              var sf = 0;
              if (quality2 < 50) {
                sf = Math.floor(5e3 / quality2);
              } else {
                sf = Math.floor(200 - quality2 * 2);
              }
              initQuantTables(sf);
              currentQuality = quality2;
            }
            function init() {
              var time_start = (/* @__PURE__ */ new Date()).getTime();
              if (!quality)
                quality = 50;
              initCharLookupTable();
              initHuffmanTbl();
              initCategoryNumber();
              initRGBYUVTable();
              setQuality(quality);
              var duration = (/* @__PURE__ */ new Date()).getTime() - time_start;
            }
            init();
          }
          ;
          if (typeof module3 !== "undefined") {
            module3.exports = encode;
          } else if (typeof window !== "undefined") {
            window["jpeg-js"] = window["jpeg-js"] || {};
            window["jpeg-js"].encode = encode;
          }
          function encode(imgData, qu) {
            if (typeof qu === "undefined")
              qu = 50;
            var encoder = new JPEGEncoder(qu);
            var data = encoder.encode(imgData, qu);
            return {
              data,
              width: imgData.width,
              height: imgData.height
            };
          }
          function getImageDataFromImage(idOrElement) {
            var theImg = typeof idOrElement == "string" ? document.getElementById(idOrElement) : idOrElement;
            var cvs = document.createElement("canvas");
            cvs.width = theImg.width;
            cvs.height = theImg.height;
            var ctx = cvs.getContext("2d");
            ctx.drawImage(theImg, 0, 0);
            return ctx.getImageData(0, 0, cvs.width, cvs.height);
          }
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 48 }], 83: [function(require2, module3, exports3) {
        (function(process) {
          var path = require2("path");
          var fs = require2("fs");
          var _0777 = parseInt("0777", 8);
          module3.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
          function mkdirP(p, opts, f, made) {
            if (typeof opts === "function") {
              f = opts;
              opts = {};
            } else if (!opts || typeof opts !== "object") {
              opts = { mode: opts };
            }
            var mode = opts.mode;
            var xfs = opts.fs || fs;
            if (mode === void 0) {
              mode = _0777 & ~process.umask();
            }
            if (!made)
              made = null;
            var cb = f || function() {
            };
            p = path.resolve(p);
            xfs.mkdir(p, mode, function(er) {
              if (!er) {
                made = made || p;
                return cb(null, made);
              }
              switch (er.code) {
                case "ENOENT":
                  mkdirP(path.dirname(p), opts, function(er2, made2) {
                    if (er2)
                      cb(er2, made2);
                    else
                      mkdirP(p, opts, cb, made2);
                  });
                  break;
                default:
                  xfs.stat(p, function(er2, stat) {
                    if (er2 || !stat.isDirectory())
                      cb(er, made);
                    else
                      cb(null, made);
                  });
                  break;
              }
            });
          }
          mkdirP.sync = function sync(p, opts, made) {
            if (!opts || typeof opts !== "object") {
              opts = { mode: opts };
            }
            var mode = opts.mode;
            var xfs = opts.fs || fs;
            if (mode === void 0) {
              mode = _0777 & ~process.umask();
            }
            if (!made)
              made = null;
            p = path.resolve(p);
            try {
              xfs.mkdirSync(p, mode);
              made = made || p;
            } catch (err0) {
              switch (err0.code) {
                case "ENOENT":
                  made = sync(path.dirname(p), opts, made);
                  sync(p, opts, made);
                  break;
                default:
                  var stat;
                  try {
                    stat = xfs.statSync(p);
                  } catch (err1) {
                    throw err0;
                  }
                  if (!stat.isDirectory())
                    throw err0;
                  break;
              }
            }
            return made;
          };
        }).call(this, require2("_process"));
      }, { "_process": 133, "fs": 47, "path": 107 }], 84: [function(require2, module3, exports3) {
        "use strict";
        var getOwnPropertySymbols = Object.getOwnPropertySymbols;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var propIsEnumerable = Object.prototype.propertyIsEnumerable;
        function toObject(val) {
          if (val === null || val === void 0) {
            throw new TypeError("Object.assign cannot be called with null or undefined");
          }
          return Object(val);
        }
        function shouldUseNative() {
          try {
            if (!Object.assign) {
              return false;
            }
            var test1 = new String("abc");
            test1[5] = "de";
            if (Object.getOwnPropertyNames(test1)[0] === "5") {
              return false;
            }
            var test2 = {};
            for (var i = 0; i < 10; i++) {
              test2["_" + String.fromCharCode(i)] = i;
            }
            var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
              return test2[n];
            });
            if (order2.join("") !== "0123456789") {
              return false;
            }
            var test3 = {};
            "abcdefghijklmnopqrst".split("").forEach(function(letter) {
              test3[letter] = letter;
            });
            if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
              return false;
            }
            return true;
          } catch (err) {
            return false;
          }
        }
        module3.exports = shouldUseNative() ? Object.assign : function(target, source) {
          var from;
          var to = toObject(target);
          var symbols;
          for (var s = 1; s < arguments.length; s++) {
            from = Object(arguments[s]);
            for (var key in from) {
              if (hasOwnProperty.call(from, key)) {
                to[key] = from[key];
              }
            }
            if (getOwnPropertySymbols) {
              symbols = getOwnPropertySymbols(from);
              for (var i = 0; i < symbols.length; i++) {
                if (propIsEnumerable.call(from, symbols[i])) {
                  to[symbols[i]] = from[symbols[i]];
                }
              }
            }
          }
          return to;
        };
      }, {}], 85: [function(require2, module3, exports3) {
        arguments[4][64][0].apply(exports3, arguments);
      }, { "dup": 64 }], 86: [function(require2, module3, exports3) {
        "use strict";
        var assign = require2("./lib/utils/common").assign;
        var deflate = require2("./lib/deflate");
        var inflate = require2("./lib/inflate");
        var constants = require2("./lib/zlib/constants");
        var pako = {};
        assign(pako, deflate, inflate, constants);
        module3.exports = pako;
      }, { "./lib/deflate": 87, "./lib/inflate": 88, "./lib/utils/common": 89, "./lib/zlib/constants": 92 }], 87: [function(require2, module3, exports3) {
        "use strict";
        var zlib_deflate = require2("./zlib/deflate");
        var utils = require2("./utils/common");
        var strings = require2("./utils/strings");
        var msg = require2("./zlib/messages");
        var ZStream = require2("./zlib/zstream");
        var toString = Object.prototype.toString;
        var Z_NO_FLUSH = 0;
        var Z_FINISH = 4;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_SYNC_FLUSH = 2;
        var Z_DEFAULT_COMPRESSION = -1;
        var Z_DEFAULT_STRATEGY = 0;
        var Z_DEFLATED = 8;
        function Deflate(options) {
          if (!(this instanceof Deflate))
            return new Deflate(options);
          this.options = utils.assign({
            level: Z_DEFAULT_COMPRESSION,
            method: Z_DEFLATED,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: Z_DEFAULT_STRATEGY,
            to: ""
          }, options || {});
          var opt = this.options;
          if (opt.raw && opt.windowBits > 0) {
            opt.windowBits = -opt.windowBits;
          } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
            opt.windowBits += 16;
          }
          this.err = 0;
          this.msg = "";
          this.ended = false;
          this.chunks = [];
          this.strm = new ZStream();
          this.strm.avail_out = 0;
          var status = zlib_deflate.deflateInit2(
            this.strm,
            opt.level,
            opt.method,
            opt.windowBits,
            opt.memLevel,
            opt.strategy
          );
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
          if (opt.header) {
            zlib_deflate.deflateSetHeader(this.strm, opt.header);
          }
          if (opt.dictionary) {
            var dict;
            if (typeof opt.dictionary === "string") {
              dict = strings.string2buf(opt.dictionary);
            } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
              dict = new Uint8Array(opt.dictionary);
            } else {
              dict = opt.dictionary;
            }
            status = zlib_deflate.deflateSetDictionary(this.strm, dict);
            if (status !== Z_OK) {
              throw new Error(msg[status]);
            }
            this._dict_set = true;
          }
        }
        Deflate.prototype.push = function(data, mode) {
          var strm = this.strm;
          var chunkSize = this.options.chunkSize;
          var status, _mode;
          if (this.ended) {
            return false;
          }
          _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
          if (typeof data === "string") {
            strm.input = strings.string2buf(data);
          } else if (toString.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
          } else {
            strm.input = data;
          }
          strm.next_in = 0;
          strm.avail_in = strm.input.length;
          do {
            if (strm.avail_out === 0) {
              strm.output = new utils.Buf8(chunkSize);
              strm.next_out = 0;
              strm.avail_out = chunkSize;
            }
            status = zlib_deflate.deflate(strm, _mode);
            if (status !== Z_STREAM_END && status !== Z_OK) {
              this.onEnd(status);
              this.ended = true;
              return false;
            }
            if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
              if (this.options.to === "string") {
                this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
              } else {
                this.onData(utils.shrinkBuf(strm.output, strm.next_out));
              }
            }
          } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
          if (_mode === Z_FINISH) {
            status = zlib_deflate.deflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === Z_OK;
          }
          if (_mode === Z_SYNC_FLUSH) {
            this.onEnd(Z_OK);
            strm.avail_out = 0;
            return true;
          }
          return true;
        };
        Deflate.prototype.onData = function(chunk) {
          this.chunks.push(chunk);
        };
        Deflate.prototype.onEnd = function(status) {
          if (status === Z_OK) {
            if (this.options.to === "string") {
              this.result = this.chunks.join("");
            } else {
              this.result = utils.flattenChunks(this.chunks);
            }
          }
          this.chunks = [];
          this.err = status;
          this.msg = this.strm.msg;
        };
        function deflate(input, options) {
          var deflator = new Deflate(options);
          deflator.push(input, true);
          if (deflator.err) {
            throw deflator.msg || msg[deflator.err];
          }
          return deflator.result;
        }
        function deflateRaw(input, options) {
          options = options || {};
          options.raw = true;
          return deflate(input, options);
        }
        function gzip(input, options) {
          options = options || {};
          options.gzip = true;
          return deflate(input, options);
        }
        exports3.Deflate = Deflate;
        exports3.deflate = deflate;
        exports3.deflateRaw = deflateRaw;
        exports3.gzip = gzip;
      }, { "./utils/common": 89, "./utils/strings": 90, "./zlib/deflate": 94, "./zlib/messages": 99, "./zlib/zstream": 101 }], 88: [function(require2, module3, exports3) {
        "use strict";
        var zlib_inflate = require2("./zlib/inflate");
        var utils = require2("./utils/common");
        var strings = require2("./utils/strings");
        var c = require2("./zlib/constants");
        var msg = require2("./zlib/messages");
        var ZStream = require2("./zlib/zstream");
        var GZheader = require2("./zlib/gzheader");
        var toString = Object.prototype.toString;
        function Inflate(options) {
          if (!(this instanceof Inflate))
            return new Inflate(options);
          this.options = utils.assign({
            chunkSize: 16384,
            windowBits: 0,
            to: ""
          }, options || {});
          var opt = this.options;
          if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
            opt.windowBits = -opt.windowBits;
            if (opt.windowBits === 0) {
              opt.windowBits = -15;
            }
          }
          if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
            opt.windowBits += 32;
          }
          if (opt.windowBits > 15 && opt.windowBits < 48) {
            if ((opt.windowBits & 15) === 0) {
              opt.windowBits |= 15;
            }
          }
          this.err = 0;
          this.msg = "";
          this.ended = false;
          this.chunks = [];
          this.strm = new ZStream();
          this.strm.avail_out = 0;
          var status = zlib_inflate.inflateInit2(
            this.strm,
            opt.windowBits
          );
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
          this.header = new GZheader();
          zlib_inflate.inflateGetHeader(this.strm, this.header);
        }
        Inflate.prototype.push = function(data, mode) {
          var strm = this.strm;
          var chunkSize = this.options.chunkSize;
          var dictionary = this.options.dictionary;
          var status, _mode;
          var next_out_utf8, tail, utf8str;
          var dict;
          var allowBufError = false;
          if (this.ended) {
            return false;
          }
          _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
          if (typeof data === "string") {
            strm.input = strings.binstring2buf(data);
          } else if (toString.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
          } else {
            strm.input = data;
          }
          strm.next_in = 0;
          strm.avail_in = strm.input.length;
          do {
            if (strm.avail_out === 0) {
              strm.output = new utils.Buf8(chunkSize);
              strm.next_out = 0;
              strm.avail_out = chunkSize;
            }
            status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
            if (status === c.Z_NEED_DICT && dictionary) {
              if (typeof dictionary === "string") {
                dict = strings.string2buf(dictionary);
              } else if (toString.call(dictionary) === "[object ArrayBuffer]") {
                dict = new Uint8Array(dictionary);
              } else {
                dict = dictionary;
              }
              status = zlib_inflate.inflateSetDictionary(this.strm, dict);
            }
            if (status === c.Z_BUF_ERROR && allowBufError === true) {
              status = c.Z_OK;
              allowBufError = false;
            }
            if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
              this.onEnd(status);
              this.ended = true;
              return false;
            }
            if (strm.next_out) {
              if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
                if (this.options.to === "string") {
                  next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                  tail = strm.next_out - next_out_utf8;
                  utf8str = strings.buf2string(strm.output, next_out_utf8);
                  strm.next_out = tail;
                  strm.avail_out = chunkSize - tail;
                  if (tail) {
                    utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                  }
                  this.onData(utf8str);
                } else {
                  this.onData(utils.shrinkBuf(strm.output, strm.next_out));
                }
              }
            }
            if (strm.avail_in === 0 && strm.avail_out === 0) {
              allowBufError = true;
            }
          } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
          if (status === c.Z_STREAM_END) {
            _mode = c.Z_FINISH;
          }
          if (_mode === c.Z_FINISH) {
            status = zlib_inflate.inflateEnd(this.strm);
            this.onEnd(status);
            this.ended = true;
            return status === c.Z_OK;
          }
          if (_mode === c.Z_SYNC_FLUSH) {
            this.onEnd(c.Z_OK);
            strm.avail_out = 0;
            return true;
          }
          return true;
        };
        Inflate.prototype.onData = function(chunk) {
          this.chunks.push(chunk);
        };
        Inflate.prototype.onEnd = function(status) {
          if (status === c.Z_OK) {
            if (this.options.to === "string") {
              this.result = this.chunks.join("");
            } else {
              this.result = utils.flattenChunks(this.chunks);
            }
          }
          this.chunks = [];
          this.err = status;
          this.msg = this.strm.msg;
        };
        function inflate(input, options) {
          var inflator = new Inflate(options);
          inflator.push(input, true);
          if (inflator.err) {
            throw inflator.msg || msg[inflator.err];
          }
          return inflator.result;
        }
        function inflateRaw(input, options) {
          options = options || {};
          options.raw = true;
          return inflate(input, options);
        }
        exports3.Inflate = Inflate;
        exports3.inflate = inflate;
        exports3.inflateRaw = inflateRaw;
        exports3.ungzip = inflate;
      }, { "./utils/common": 89, "./utils/strings": 90, "./zlib/constants": 92, "./zlib/gzheader": 95, "./zlib/inflate": 97, "./zlib/messages": 99, "./zlib/zstream": 101 }], 89: [function(require2, module3, exports3) {
        arguments[4][36][0].apply(exports3, arguments);
      }, { "dup": 36 }], 90: [function(require2, module3, exports3) {
        "use strict";
        var utils = require2("./common");
        var STR_APPLY_OK = true;
        var STR_APPLY_UIA_OK = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (__) {
          STR_APPLY_OK = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (__) {
          STR_APPLY_UIA_OK = false;
        }
        var _utf8len = new utils.Buf8(256);
        for (var q = 0; q < 256; q++) {
          _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
        }
        _utf8len[254] = _utf8len[254] = 1;
        exports3.string2buf = function(str) {
          var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
          for (m_pos = 0; m_pos < str_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
              c2 = str.charCodeAt(m_pos + 1);
              if ((c2 & 64512) === 56320) {
                c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                m_pos++;
              }
            }
            buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
          }
          buf = new utils.Buf8(buf_len);
          for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
              c2 = str.charCodeAt(m_pos + 1);
              if ((c2 & 64512) === 56320) {
                c = 65536 + (c - 55296 << 10) + (c2 - 56320);
                m_pos++;
              }
            }
            if (c < 128) {
              buf[i++] = c;
            } else if (c < 2048) {
              buf[i++] = 192 | c >>> 6;
              buf[i++] = 128 | c & 63;
            } else if (c < 65536) {
              buf[i++] = 224 | c >>> 12;
              buf[i++] = 128 | c >>> 6 & 63;
              buf[i++] = 128 | c & 63;
            } else {
              buf[i++] = 240 | c >>> 18;
              buf[i++] = 128 | c >>> 12 & 63;
              buf[i++] = 128 | c >>> 6 & 63;
              buf[i++] = 128 | c & 63;
            }
          }
          return buf;
        };
        function buf2binstring(buf, len) {
          if (len < 65537) {
            if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
              return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
            }
          }
          var result = "";
          for (var i = 0; i < len; i++) {
            result += String.fromCharCode(buf[i]);
          }
          return result;
        }
        exports3.buf2binstring = function(buf) {
          return buf2binstring(buf, buf.length);
        };
        exports3.binstring2buf = function(str) {
          var buf = new utils.Buf8(str.length);
          for (var i = 0, len = buf.length; i < len; i++) {
            buf[i] = str.charCodeAt(i);
          }
          return buf;
        };
        exports3.buf2string = function(buf, max) {
          var i, out, c, c_len;
          var len = max || buf.length;
          var utf16buf = new Array(len * 2);
          for (out = 0, i = 0; i < len; ) {
            c = buf[i++];
            if (c < 128) {
              utf16buf[out++] = c;
              continue;
            }
            c_len = _utf8len[c];
            if (c_len > 4) {
              utf16buf[out++] = 65533;
              i += c_len - 1;
              continue;
            }
            c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
            while (c_len > 1 && i < len) {
              c = c << 6 | buf[i++] & 63;
              c_len--;
            }
            if (c_len > 1) {
              utf16buf[out++] = 65533;
              continue;
            }
            if (c < 65536) {
              utf16buf[out++] = c;
            } else {
              c -= 65536;
              utf16buf[out++] = 55296 | c >> 10 & 1023;
              utf16buf[out++] = 56320 | c & 1023;
            }
          }
          return buf2binstring(utf16buf, out);
        };
        exports3.utf8border = function(buf, max) {
          var pos;
          max = max || buf.length;
          if (max > buf.length) {
            max = buf.length;
          }
          pos = max - 1;
          while (pos >= 0 && (buf[pos] & 192) === 128) {
            pos--;
          }
          if (pos < 0) {
            return max;
          }
          if (pos === 0) {
            return max;
          }
          return pos + _utf8len[buf[pos]] > max ? pos : max;
        };
      }, { "./common": 89 }], 91: [function(require2, module3, exports3) {
        arguments[4][37][0].apply(exports3, arguments);
      }, { "dup": 37 }], 92: [function(require2, module3, exports3) {
        arguments[4][38][0].apply(exports3, arguments);
      }, { "dup": 38 }], 93: [function(require2, module3, exports3) {
        arguments[4][39][0].apply(exports3, arguments);
      }, { "dup": 39 }], 94: [function(require2, module3, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var trees = require2("./trees");
        var adler32 = require2("./adler32");
        var crc32 = require2("./crc32");
        var msg = require2("./messages");
        var Z_NO_FLUSH = 0;
        var Z_PARTIAL_FLUSH = 1;
        var Z_FULL_FLUSH = 3;
        var Z_FINISH = 4;
        var Z_BLOCK = 5;
        var Z_OK = 0;
        var Z_STREAM_END = 1;
        var Z_STREAM_ERROR = -2;
        var Z_DATA_ERROR = -3;
        var Z_BUF_ERROR = -5;
        var Z_DEFAULT_COMPRESSION = -1;
        var Z_FILTERED = 1;
        var Z_HUFFMAN_ONLY = 2;
        var Z_RLE = 3;
        var Z_FIXED = 4;
        var Z_DEFAULT_STRATEGY = 0;
        var Z_UNKNOWN = 2;
        var Z_DEFLATED = 8;
        var MAX_MEM_LEVEL = 9;
        var MAX_WBITS = 15;
        var DEF_MEM_LEVEL = 8;
        var LENGTH_CODES = 29;
        var LITERALS = 256;
        var L_CODES = LITERALS + 1 + LENGTH_CODES;
        var D_CODES = 30;
        var BL_CODES = 19;
        var HEAP_SIZE = 2 * L_CODES + 1;
        var MAX_BITS = 15;
        var MIN_MATCH = 3;
        var MAX_MATCH = 258;
        var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
        var PRESET_DICT = 32;
        var INIT_STATE = 42;
        var EXTRA_STATE = 69;
        var NAME_STATE = 73;
        var COMMENT_STATE = 91;
        var HCRC_STATE = 103;
        var BUSY_STATE = 113;
        var FINISH_STATE = 666;
        var BS_NEED_MORE = 1;
        var BS_BLOCK_DONE = 2;
        var BS_FINISH_STARTED = 3;
        var BS_FINISH_DONE = 4;
        var OS_CODE = 3;
        function err(strm, errorCode) {
          strm.msg = msg[errorCode];
          return errorCode;
        }
        function rank(f) {
          return (f << 1) - (f > 4 ? 9 : 0);
        }
        function zero(buf) {
          var len = buf.length;
          while (--len >= 0) {
            buf[len] = 0;
          }
        }
        function flush_pending(strm) {
          var s = strm.state;
          var len = s.pending;
          if (len > strm.avail_out) {
            len = strm.avail_out;
          }
          if (len === 0) {
            return;
          }
          utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
          strm.next_out += len;
          s.pending_out += len;
          strm.total_out += len;
          strm.avail_out -= len;
          s.pending -= len;
          if (s.pending === 0) {
            s.pending_out = 0;
          }
        }
        function flush_block_only(s, last) {
          trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
          s.block_start = s.strstart;
          flush_pending(s.strm);
        }
        function put_byte(s, b) {
          s.pending_buf[s.pending++] = b;
        }
        function putShortMSB(s, b) {
          s.pending_buf[s.pending++] = b >>> 8 & 255;
          s.pending_buf[s.pending++] = b & 255;
        }
        function read_buf(strm, buf, start, size) {
          var len = strm.avail_in;
          if (len > size) {
            len = size;
          }
          if (len === 0) {
            return 0;
          }
          strm.avail_in -= len;
          utils.arraySet(buf, strm.input, strm.next_in, len, start);
          if (strm.state.wrap === 1) {
            strm.adler = adler32(strm.adler, buf, len, start);
          } else if (strm.state.wrap === 2) {
            strm.adler = crc32(strm.adler, buf, len, start);
          }
          strm.next_in += len;
          strm.total_in += len;
          return len;
        }
        function longest_match(s, cur_match) {
          var chain_length = s.max_chain_length;
          var scan = s.strstart;
          var match;
          var len;
          var best_len = s.prev_length;
          var nice_match = s.nice_match;
          var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
          var _win = s.window;
          var wmask = s.w_mask;
          var prev = s.prev;
          var strend = s.strstart + MAX_MATCH;
          var scan_end1 = _win[scan + best_len - 1];
          var scan_end = _win[scan + best_len];
          if (s.prev_length >= s.good_match) {
            chain_length >>= 2;
          }
          if (nice_match > s.lookahead) {
            nice_match = s.lookahead;
          }
          do {
            match = cur_match;
            if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
              continue;
            }
            scan += 2;
            match++;
            do {
            } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
            len = MAX_MATCH - (strend - scan);
            scan = strend - MAX_MATCH;
            if (len > best_len) {
              s.match_start = cur_match;
              best_len = len;
              if (len >= nice_match) {
                break;
              }
              scan_end1 = _win[scan + best_len - 1];
              scan_end = _win[scan + best_len];
            }
          } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
          if (best_len <= s.lookahead) {
            return best_len;
          }
          return s.lookahead;
        }
        function fill_window(s) {
          var _w_size = s.w_size;
          var p, n, m, more, str;
          do {
            more = s.window_size - s.lookahead - s.strstart;
            if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
              utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
              s.match_start -= _w_size;
              s.strstart -= _w_size;
              s.block_start -= _w_size;
              n = s.hash_size;
              p = n;
              do {
                m = s.head[--p];
                s.head[p] = m >= _w_size ? m - _w_size : 0;
              } while (--n);
              n = _w_size;
              p = n;
              do {
                m = s.prev[--p];
                s.prev[p] = m >= _w_size ? m - _w_size : 0;
              } while (--n);
              more += _w_size;
            }
            if (s.strm.avail_in === 0) {
              break;
            }
            n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
            s.lookahead += n;
            if (s.lookahead + s.insert >= MIN_MATCH) {
              str = s.strstart - s.insert;
              s.ins_h = s.window[str];
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
              while (s.insert) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                s.prev[str & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = str;
                str++;
                s.insert--;
                if (s.lookahead + s.insert < MIN_MATCH) {
                  break;
                }
              }
            }
          } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
        }
        function deflate_stored(s, flush) {
          var max_block_size = 65535;
          if (max_block_size > s.pending_buf_size - 5) {
            max_block_size = s.pending_buf_size - 5;
          }
          for (; ; ) {
            if (s.lookahead <= 1) {
              fill_window(s);
              if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            s.strstart += s.lookahead;
            s.lookahead = 0;
            var max_start = s.block_start + max_block_size;
            if (s.strstart === 0 || s.strstart >= max_start) {
              s.lookahead = s.strstart - max_start;
              s.strstart = max_start;
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
            if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = 0;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.strstart > s.block_start) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_NEED_MORE;
        }
        function deflate_fast(s, flush) {
          var hash_head;
          var bflush;
          for (; ; ) {
            if (s.lookahead < MIN_LOOKAHEAD) {
              fill_window(s);
              if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            hash_head = 0;
            if (s.lookahead >= MIN_MATCH) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
            if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
              s.match_length = longest_match(s, hash_head);
            }
            if (s.match_length >= MIN_MATCH) {
              bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
              s.lookahead -= s.match_length;
              if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                s.match_length--;
                do {
                  s.strstart++;
                  s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                  hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                  s.head[s.ins_h] = s.strstart;
                } while (--s.match_length !== 0);
                s.strstart++;
              } else {
                s.strstart += s.match_length;
                s.match_length = 0;
                s.ins_h = s.window[s.strstart];
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
              }
            } else {
              bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
              s.lookahead--;
              s.strstart++;
            }
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function deflate_slow(s, flush) {
          var hash_head;
          var bflush;
          var max_insert;
          for (; ; ) {
            if (s.lookahead < MIN_LOOKAHEAD) {
              fill_window(s);
              if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            hash_head = 0;
            if (s.lookahead >= MIN_MATCH) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
            s.prev_length = s.match_length;
            s.prev_match = s.match_start;
            s.match_length = MIN_MATCH - 1;
            if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
              s.match_length = longest_match(s, hash_head);
              if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
                s.match_length = MIN_MATCH - 1;
              }
            }
            if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
              max_insert = s.strstart + s.lookahead - MIN_MATCH;
              bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
              s.lookahead -= s.prev_length - 1;
              s.prev_length -= 2;
              do {
                if (++s.strstart <= max_insert) {
                  s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                  hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                  s.head[s.ins_h] = s.strstart;
                }
              } while (--s.prev_length !== 0);
              s.match_available = 0;
              s.match_length = MIN_MATCH - 1;
              s.strstart++;
              if (bflush) {
                flush_block_only(s, false);
                if (s.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              }
            } else if (s.match_available) {
              bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
              if (bflush) {
                flush_block_only(s, false);
              }
              s.strstart++;
              s.lookahead--;
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            } else {
              s.match_available = 1;
              s.strstart++;
              s.lookahead--;
            }
          }
          if (s.match_available) {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
            s.match_available = 0;
          }
          s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function deflate_rle(s, flush) {
          var bflush;
          var prev;
          var scan, strend;
          var _win = s.window;
          for (; ; ) {
            if (s.lookahead <= MAX_MATCH) {
              fill_window(s);
              if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              if (s.lookahead === 0) {
                break;
              }
            }
            s.match_length = 0;
            if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
              scan = s.strstart - 1;
              prev = _win[scan];
              if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                strend = s.strstart + MAX_MATCH;
                do {
                } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                s.match_length = MAX_MATCH - (strend - scan);
                if (s.match_length > s.lookahead) {
                  s.match_length = s.lookahead;
                }
              }
            }
            if (s.match_length >= MIN_MATCH) {
              bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
              s.lookahead -= s.match_length;
              s.strstart += s.match_length;
              s.match_length = 0;
            } else {
              bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
              s.lookahead--;
              s.strstart++;
            }
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = 0;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function deflate_huff(s, flush) {
          var bflush;
          for (; ; ) {
            if (s.lookahead === 0) {
              fill_window(s);
              if (s.lookahead === 0) {
                if (flush === Z_NO_FLUSH) {
                  return BS_NEED_MORE;
                }
                break;
              }
            }
            s.match_length = 0;
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s.insert = 0;
          if (flush === Z_FINISH) {
            flush_block_only(s, true);
            if (s.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s.last_lit) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        }
        function Config(good_length, max_lazy, nice_length, max_chain, func) {
          this.good_length = good_length;
          this.max_lazy = max_lazy;
          this.nice_length = nice_length;
          this.max_chain = max_chain;
          this.func = func;
        }
        var configuration_table;
        configuration_table = [
          /*      good lazy nice chain */
          new Config(0, 0, 0, 0, deflate_stored),
          /* 0 store only */
          new Config(4, 4, 8, 4, deflate_fast),
          /* 1 max speed, no lazy matches */
          new Config(4, 5, 16, 8, deflate_fast),
          /* 2 */
          new Config(4, 6, 32, 32, deflate_fast),
          /* 3 */
          new Config(4, 4, 16, 16, deflate_slow),
          /* 4 lazy matches */
          new Config(8, 16, 32, 32, deflate_slow),
          /* 5 */
          new Config(8, 16, 128, 128, deflate_slow),
          /* 6 */
          new Config(8, 32, 128, 256, deflate_slow),
          /* 7 */
          new Config(32, 128, 258, 1024, deflate_slow),
          /* 8 */
          new Config(32, 258, 258, 4096, deflate_slow)
          /* 9 max compression */
        ];
        function lm_init(s) {
          s.window_size = 2 * s.w_size;
          zero(s.head);
          s.max_lazy_match = configuration_table[s.level].max_lazy;
          s.good_match = configuration_table[s.level].good_length;
          s.nice_match = configuration_table[s.level].nice_length;
          s.max_chain_length = configuration_table[s.level].max_chain;
          s.strstart = 0;
          s.block_start = 0;
          s.lookahead = 0;
          s.insert = 0;
          s.match_length = s.prev_length = MIN_MATCH - 1;
          s.match_available = 0;
          s.ins_h = 0;
        }
        function DeflateState() {
          this.strm = null;
          this.status = 0;
          this.pending_buf = null;
          this.pending_buf_size = 0;
          this.pending_out = 0;
          this.pending = 0;
          this.wrap = 0;
          this.gzhead = null;
          this.gzindex = 0;
          this.method = Z_DEFLATED;
          this.last_flush = -1;
          this.w_size = 0;
          this.w_bits = 0;
          this.w_mask = 0;
          this.window = null;
          this.window_size = 0;
          this.prev = null;
          this.head = null;
          this.ins_h = 0;
          this.hash_size = 0;
          this.hash_bits = 0;
          this.hash_mask = 0;
          this.hash_shift = 0;
          this.block_start = 0;
          this.match_length = 0;
          this.prev_match = 0;
          this.match_available = 0;
          this.strstart = 0;
          this.match_start = 0;
          this.lookahead = 0;
          this.prev_length = 0;
          this.max_chain_length = 0;
          this.max_lazy_match = 0;
          this.level = 0;
          this.strategy = 0;
          this.good_match = 0;
          this.nice_match = 0;
          this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
          this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
          this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
          zero(this.dyn_ltree);
          zero(this.dyn_dtree);
          zero(this.bl_tree);
          this.l_desc = null;
          this.d_desc = null;
          this.bl_desc = null;
          this.bl_count = new utils.Buf16(MAX_BITS + 1);
          this.heap = new utils.Buf16(2 * L_CODES + 1);
          zero(this.heap);
          this.heap_len = 0;
          this.heap_max = 0;
          this.depth = new utils.Buf16(2 * L_CODES + 1);
          zero(this.depth);
          this.l_buf = 0;
          this.lit_bufsize = 0;
          this.last_lit = 0;
          this.d_buf = 0;
          this.opt_len = 0;
          this.static_len = 0;
          this.matches = 0;
          this.insert = 0;
          this.bi_buf = 0;
          this.bi_valid = 0;
        }
        function deflateResetKeep(strm) {
          var s;
          if (!strm || !strm.state) {
            return err(strm, Z_STREAM_ERROR);
          }
          strm.total_in = strm.total_out = 0;
          strm.data_type = Z_UNKNOWN;
          s = strm.state;
          s.pending = 0;
          s.pending_out = 0;
          if (s.wrap < 0) {
            s.wrap = -s.wrap;
          }
          s.status = s.wrap ? INIT_STATE : BUSY_STATE;
          strm.adler = s.wrap === 2 ? 0 : 1;
          s.last_flush = Z_NO_FLUSH;
          trees._tr_init(s);
          return Z_OK;
        }
        function deflateReset(strm) {
          var ret = deflateResetKeep(strm);
          if (ret === Z_OK) {
            lm_init(strm.state);
          }
          return ret;
        }
        function deflateSetHeader(strm, head) {
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          if (strm.state.wrap !== 2) {
            return Z_STREAM_ERROR;
          }
          strm.state.gzhead = head;
          return Z_OK;
        }
        function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
          if (!strm) {
            return Z_STREAM_ERROR;
          }
          var wrap = 1;
          if (level === Z_DEFAULT_COMPRESSION) {
            level = 6;
          }
          if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
          } else if (windowBits > 15) {
            wrap = 2;
            windowBits -= 16;
          }
          if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
            return err(strm, Z_STREAM_ERROR);
          }
          if (windowBits === 8) {
            windowBits = 9;
          }
          var s = new DeflateState();
          strm.state = s;
          s.strm = strm;
          s.wrap = wrap;
          s.gzhead = null;
          s.w_bits = windowBits;
          s.w_size = 1 << s.w_bits;
          s.w_mask = s.w_size - 1;
          s.hash_bits = memLevel + 7;
          s.hash_size = 1 << s.hash_bits;
          s.hash_mask = s.hash_size - 1;
          s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
          s.window = new utils.Buf8(s.w_size * 2);
          s.head = new utils.Buf16(s.hash_size);
          s.prev = new utils.Buf16(s.w_size);
          s.lit_bufsize = 1 << memLevel + 6;
          s.pending_buf_size = s.lit_bufsize * 4;
          s.pending_buf = new utils.Buf8(s.pending_buf_size);
          s.d_buf = 1 * s.lit_bufsize;
          s.l_buf = (1 + 2) * s.lit_bufsize;
          s.level = level;
          s.strategy = strategy;
          s.method = method;
          return deflateReset(strm);
        }
        function deflateInit(strm, level) {
          return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
        }
        function deflate(strm, flush) {
          var old_flush, s;
          var beg, val;
          if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
            return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
          }
          s = strm.state;
          if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
            return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
          }
          s.strm = strm;
          old_flush = s.last_flush;
          s.last_flush = flush;
          if (s.status === INIT_STATE) {
            if (s.wrap === 2) {
              strm.adler = 0;
              put_byte(s, 31);
              put_byte(s, 139);
              put_byte(s, 8);
              if (!s.gzhead) {
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, OS_CODE);
                s.status = BUSY_STATE;
              } else {
                put_byte(
                  s,
                  (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
                );
                put_byte(s, s.gzhead.time & 255);
                put_byte(s, s.gzhead.time >> 8 & 255);
                put_byte(s, s.gzhead.time >> 16 & 255);
                put_byte(s, s.gzhead.time >> 24 & 255);
                put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
                put_byte(s, s.gzhead.os & 255);
                if (s.gzhead.extra && s.gzhead.extra.length) {
                  put_byte(s, s.gzhead.extra.length & 255);
                  put_byte(s, s.gzhead.extra.length >> 8 & 255);
                }
                if (s.gzhead.hcrc) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                }
                s.gzindex = 0;
                s.status = EXTRA_STATE;
              }
            } else {
              var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
              var level_flags = -1;
              if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                level_flags = 0;
              } else if (s.level < 6) {
                level_flags = 1;
              } else if (s.level === 6) {
                level_flags = 2;
              } else {
                level_flags = 3;
              }
              header |= level_flags << 6;
              if (s.strstart !== 0) {
                header |= PRESET_DICT;
              }
              header += 31 - header % 31;
              s.status = BUSY_STATE;
              putShortMSB(s, header);
              if (s.strstart !== 0) {
                putShortMSB(s, strm.adler >>> 16);
                putShortMSB(s, strm.adler & 65535);
              }
              strm.adler = 1;
            }
          }
          if (s.status === EXTRA_STATE) {
            if (s.gzhead.extra) {
              beg = s.pending;
              while (s.gzindex < (s.gzhead.extra.length & 65535)) {
                if (s.pending === s.pending_buf_size) {
                  if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s.pending;
                  if (s.pending === s.pending_buf_size) {
                    break;
                  }
                }
                put_byte(s, s.gzhead.extra[s.gzindex] & 255);
                s.gzindex++;
              }
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              if (s.gzindex === s.gzhead.extra.length) {
                s.gzindex = 0;
                s.status = NAME_STATE;
              }
            } else {
              s.status = NAME_STATE;
            }
          }
          if (s.status === NAME_STATE) {
            if (s.gzhead.name) {
              beg = s.pending;
              do {
                if (s.pending === s.pending_buf_size) {
                  if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s.pending;
                  if (s.pending === s.pending_buf_size) {
                    val = 1;
                    break;
                  }
                }
                if (s.gzindex < s.gzhead.name.length) {
                  val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
                } else {
                  val = 0;
                }
                put_byte(s, val);
              } while (val !== 0);
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              if (val === 0) {
                s.gzindex = 0;
                s.status = COMMENT_STATE;
              }
            } else {
              s.status = COMMENT_STATE;
            }
          }
          if (s.status === COMMENT_STATE) {
            if (s.gzhead.comment) {
              beg = s.pending;
              do {
                if (s.pending === s.pending_buf_size) {
                  if (s.gzhead.hcrc && s.pending > beg) {
                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s.pending;
                  if (s.pending === s.pending_buf_size) {
                    val = 1;
                    break;
                  }
                }
                if (s.gzindex < s.gzhead.comment.length) {
                  val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
                } else {
                  val = 0;
                }
                put_byte(s, val);
              } while (val !== 0);
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              if (val === 0) {
                s.status = HCRC_STATE;
              }
            } else {
              s.status = HCRC_STATE;
            }
          }
          if (s.status === HCRC_STATE) {
            if (s.gzhead.hcrc) {
              if (s.pending + 2 > s.pending_buf_size) {
                flush_pending(strm);
              }
              if (s.pending + 2 <= s.pending_buf_size) {
                put_byte(s, strm.adler & 255);
                put_byte(s, strm.adler >> 8 & 255);
                strm.adler = 0;
                s.status = BUSY_STATE;
              }
            } else {
              s.status = BUSY_STATE;
            }
          }
          if (s.pending !== 0) {
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
            return err(strm, Z_BUF_ERROR);
          }
          if (s.status === FINISH_STATE && strm.avail_in !== 0) {
            return err(strm, Z_BUF_ERROR);
          }
          if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
            var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
            if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
              s.status = FINISH_STATE;
            }
            if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
              if (strm.avail_out === 0) {
                s.last_flush = -1;
              }
              return Z_OK;
            }
            if (bstate === BS_BLOCK_DONE) {
              if (flush === Z_PARTIAL_FLUSH) {
                trees._tr_align(s);
              } else if (flush !== Z_BLOCK) {
                trees._tr_stored_block(s, 0, 0, false);
                if (flush === Z_FULL_FLUSH) {
                  zero(s.head);
                  if (s.lookahead === 0) {
                    s.strstart = 0;
                    s.block_start = 0;
                    s.insert = 0;
                  }
                }
              }
              flush_pending(strm);
              if (strm.avail_out === 0) {
                s.last_flush = -1;
                return Z_OK;
              }
            }
          }
          if (flush !== Z_FINISH) {
            return Z_OK;
          }
          if (s.wrap <= 0) {
            return Z_STREAM_END;
          }
          if (s.wrap === 2) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            put_byte(s, strm.adler >> 16 & 255);
            put_byte(s, strm.adler >> 24 & 255);
            put_byte(s, strm.total_in & 255);
            put_byte(s, strm.total_in >> 8 & 255);
            put_byte(s, strm.total_in >> 16 & 255);
            put_byte(s, strm.total_in >> 24 & 255);
          } else {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          flush_pending(strm);
          if (s.wrap > 0) {
            s.wrap = -s.wrap;
          }
          return s.pending !== 0 ? Z_OK : Z_STREAM_END;
        }
        function deflateEnd(strm) {
          var status;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          status = strm.state.status;
          if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
            return err(strm, Z_STREAM_ERROR);
          }
          strm.state = null;
          return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
        }
        function deflateSetDictionary(strm, dictionary) {
          var dictLength = dictionary.length;
          var s;
          var str, n;
          var wrap;
          var avail;
          var next;
          var input;
          var tmpDict;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR;
          }
          s = strm.state;
          wrap = s.wrap;
          if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
            return Z_STREAM_ERROR;
          }
          if (wrap === 1) {
            strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
          }
          s.wrap = 0;
          if (dictLength >= s.w_size) {
            if (wrap === 0) {
              zero(s.head);
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
            tmpDict = new utils.Buf8(s.w_size);
            utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
            dictionary = tmpDict;
            dictLength = s.w_size;
          }
          avail = strm.avail_in;
          next = strm.next_in;
          input = strm.input;
          strm.avail_in = dictLength;
          strm.next_in = 0;
          strm.input = dictionary;
          fill_window(s);
          while (s.lookahead >= MIN_MATCH) {
            str = s.strstart;
            n = s.lookahead - (MIN_MATCH - 1);
            do {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
              s.prev[str & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str;
              str++;
            } while (--n);
            s.strstart = str;
            s.lookahead = MIN_MATCH - 1;
            fill_window(s);
          }
          s.strstart += s.lookahead;
          s.block_start = s.strstart;
          s.insert = s.lookahead;
          s.lookahead = 0;
          s.match_length = s.prev_length = MIN_MATCH - 1;
          s.match_available = 0;
          strm.next_in = next;
          strm.input = input;
          strm.avail_in = avail;
          s.wrap = wrap;
          return Z_OK;
        }
        exports3.deflateInit = deflateInit;
        exports3.deflateInit2 = deflateInit2;
        exports3.deflateReset = deflateReset;
        exports3.deflateResetKeep = deflateResetKeep;
        exports3.deflateSetHeader = deflateSetHeader;
        exports3.deflate = deflate;
        exports3.deflateEnd = deflateEnd;
        exports3.deflateSetDictionary = deflateSetDictionary;
        exports3.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 89, "./adler32": 91, "./crc32": 93, "./messages": 99, "./trees": 100 }], 95: [function(require2, module3, exports3) {
        "use strict";
        function GZheader() {
          this.text = 0;
          this.time = 0;
          this.xflags = 0;
          this.os = 0;
          this.extra = null;
          this.extra_len = 0;
          this.name = "";
          this.comment = "";
          this.hcrc = 0;
          this.done = false;
        }
        module3.exports = GZheader;
      }, {}], 96: [function(require2, module3, exports3) {
        arguments[4][41][0].apply(exports3, arguments);
      }, { "dup": 41 }], 97: [function(require2, module3, exports3) {
        arguments[4][42][0].apply(exports3, arguments);
      }, { "../utils/common": 89, "./adler32": 91, "./crc32": 93, "./inffast": 96, "./inftrees": 98, "dup": 42 }], 98: [function(require2, module3, exports3) {
        arguments[4][43][0].apply(exports3, arguments);
      }, { "../utils/common": 89, "dup": 43 }], 99: [function(require2, module3, exports3) {
        arguments[4][44][0].apply(exports3, arguments);
      }, { "dup": 44 }], 100: [function(require2, module3, exports3) {
        "use strict";
        var utils = require2("../utils/common");
        var Z_FIXED = 4;
        var Z_BINARY = 0;
        var Z_TEXT = 1;
        var Z_UNKNOWN = 2;
        function zero(buf) {
          var len = buf.length;
          while (--len >= 0) {
            buf[len] = 0;
          }
        }
        var STORED_BLOCK = 0;
        var STATIC_TREES = 1;
        var DYN_TREES = 2;
        var MIN_MATCH = 3;
        var MAX_MATCH = 258;
        var LENGTH_CODES = 29;
        var LITERALS = 256;
        var L_CODES = LITERALS + 1 + LENGTH_CODES;
        var D_CODES = 30;
        var BL_CODES = 19;
        var HEAP_SIZE = 2 * L_CODES + 1;
        var MAX_BITS = 15;
        var Buf_size = 16;
        var MAX_BL_BITS = 7;
        var END_BLOCK = 256;
        var REP_3_6 = 16;
        var REPZ_3_10 = 17;
        var REPZ_11_138 = 18;
        var extra_lbits = (
          /* extra bits for each length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
        );
        var extra_dbits = (
          /* extra bits for each distance code */
          [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
        );
        var extra_blbits = (
          /* extra bits for each bit length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
        );
        var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        var DIST_CODE_LEN = 512;
        var static_ltree = new Array((L_CODES + 2) * 2);
        zero(static_ltree);
        var static_dtree = new Array(D_CODES * 2);
        zero(static_dtree);
        var _dist_code = new Array(DIST_CODE_LEN);
        zero(_dist_code);
        var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
        zero(_length_code);
        var base_length = new Array(LENGTH_CODES);
        zero(base_length);
        var base_dist = new Array(D_CODES);
        zero(base_dist);
        function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
          this.static_tree = static_tree;
          this.extra_bits = extra_bits;
          this.extra_base = extra_base;
          this.elems = elems;
          this.max_length = max_length;
          this.has_stree = static_tree && static_tree.length;
        }
        var static_l_desc;
        var static_d_desc;
        var static_bl_desc;
        function TreeDesc(dyn_tree, stat_desc) {
          this.dyn_tree = dyn_tree;
          this.max_code = 0;
          this.stat_desc = stat_desc;
        }
        function d_code(dist) {
          return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
        }
        function put_short(s, w) {
          s.pending_buf[s.pending++] = w & 255;
          s.pending_buf[s.pending++] = w >>> 8 & 255;
        }
        function send_bits(s, value, length) {
          if (s.bi_valid > Buf_size - length) {
            s.bi_buf |= value << s.bi_valid & 65535;
            put_short(s, s.bi_buf);
            s.bi_buf = value >> Buf_size - s.bi_valid;
            s.bi_valid += length - Buf_size;
          } else {
            s.bi_buf |= value << s.bi_valid & 65535;
            s.bi_valid += length;
          }
        }
        function send_code(s, c, tree) {
          send_bits(
            s,
            tree[c * 2],
            tree[c * 2 + 1]
            /*.Len*/
          );
        }
        function bi_reverse(code, len) {
          var res = 0;
          do {
            res |= code & 1;
            code >>>= 1;
            res <<= 1;
          } while (--len > 0);
          return res >>> 1;
        }
        function bi_flush(s) {
          if (s.bi_valid === 16) {
            put_short(s, s.bi_buf);
            s.bi_buf = 0;
            s.bi_valid = 0;
          } else if (s.bi_valid >= 8) {
            s.pending_buf[s.pending++] = s.bi_buf & 255;
            s.bi_buf >>= 8;
            s.bi_valid -= 8;
          }
        }
        function gen_bitlen(s, desc) {
          var tree = desc.dyn_tree;
          var max_code = desc.max_code;
          var stree = desc.stat_desc.static_tree;
          var has_stree = desc.stat_desc.has_stree;
          var extra = desc.stat_desc.extra_bits;
          var base = desc.stat_desc.extra_base;
          var max_length = desc.stat_desc.max_length;
          var h;
          var n, m;
          var bits;
          var xbits;
          var f;
          var overflow = 0;
          for (bits = 0; bits <= MAX_BITS; bits++) {
            s.bl_count[bits] = 0;
          }
          tree[s.heap[s.heap_max] * 2 + 1] = 0;
          for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
            n = s.heap[h];
            bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
            if (bits > max_length) {
              bits = max_length;
              overflow++;
            }
            tree[n * 2 + 1] = bits;
            if (n > max_code) {
              continue;
            }
            s.bl_count[bits]++;
            xbits = 0;
            if (n >= base) {
              xbits = extra[n - base];
            }
            f = tree[n * 2];
            s.opt_len += f * (bits + xbits);
            if (has_stree) {
              s.static_len += f * (stree[n * 2 + 1] + xbits);
            }
          }
          if (overflow === 0) {
            return;
          }
          do {
            bits = max_length - 1;
            while (s.bl_count[bits] === 0) {
              bits--;
            }
            s.bl_count[bits]--;
            s.bl_count[bits + 1] += 2;
            s.bl_count[max_length]--;
            overflow -= 2;
          } while (overflow > 0);
          for (bits = max_length; bits !== 0; bits--) {
            n = s.bl_count[bits];
            while (n !== 0) {
              m = s.heap[--h];
              if (m > max_code) {
                continue;
              }
              if (tree[m * 2 + 1] !== bits) {
                s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                tree[m * 2 + 1] = bits;
              }
              n--;
            }
          }
        }
        function gen_codes(tree, max_code, bl_count) {
          var next_code = new Array(MAX_BITS + 1);
          var code = 0;
          var bits;
          var n;
          for (bits = 1; bits <= MAX_BITS; bits++) {
            next_code[bits] = code = code + bl_count[bits - 1] << 1;
          }
          for (n = 0; n <= max_code; n++) {
            var len = tree[n * 2 + 1];
            if (len === 0) {
              continue;
            }
            tree[n * 2] = bi_reverse(next_code[len]++, len);
          }
        }
        function tr_static_init() {
          var n;
          var bits;
          var length;
          var code;
          var dist;
          var bl_count = new Array(MAX_BITS + 1);
          length = 0;
          for (code = 0; code < LENGTH_CODES - 1; code++) {
            base_length[code] = length;
            for (n = 0; n < 1 << extra_lbits[code]; n++) {
              _length_code[length++] = code;
            }
          }
          _length_code[length - 1] = code;
          dist = 0;
          for (code = 0; code < 16; code++) {
            base_dist[code] = dist;
            for (n = 0; n < 1 << extra_dbits[code]; n++) {
              _dist_code[dist++] = code;
            }
          }
          dist >>= 7;
          for (; code < D_CODES; code++) {
            base_dist[code] = dist << 7;
            for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
              _dist_code[256 + dist++] = code;
            }
          }
          for (bits = 0; bits <= MAX_BITS; bits++) {
            bl_count[bits] = 0;
          }
          n = 0;
          while (n <= 143) {
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
          }
          while (n <= 255) {
            static_ltree[n * 2 + 1] = 9;
            n++;
            bl_count[9]++;
          }
          while (n <= 279) {
            static_ltree[n * 2 + 1] = 7;
            n++;
            bl_count[7]++;
          }
          while (n <= 287) {
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
          }
          gen_codes(static_ltree, L_CODES + 1, bl_count);
          for (n = 0; n < D_CODES; n++) {
            static_dtree[n * 2 + 1] = 5;
            static_dtree[n * 2] = bi_reverse(n, 5);
          }
          static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
          static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
          static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
        }
        function init_block(s) {
          var n;
          for (n = 0; n < L_CODES; n++) {
            s.dyn_ltree[n * 2] = 0;
          }
          for (n = 0; n < D_CODES; n++) {
            s.dyn_dtree[n * 2] = 0;
          }
          for (n = 0; n < BL_CODES; n++) {
            s.bl_tree[n * 2] = 0;
          }
          s.dyn_ltree[END_BLOCK * 2] = 1;
          s.opt_len = s.static_len = 0;
          s.last_lit = s.matches = 0;
        }
        function bi_windup(s) {
          if (s.bi_valid > 8) {
            put_short(s, s.bi_buf);
          } else if (s.bi_valid > 0) {
            s.pending_buf[s.pending++] = s.bi_buf;
          }
          s.bi_buf = 0;
          s.bi_valid = 0;
        }
        function copy_block(s, buf, len, header) {
          bi_windup(s);
          if (header) {
            put_short(s, len);
            put_short(s, ~len);
          }
          utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
          s.pending += len;
        }
        function smaller(tree, n, m, depth) {
          var _n2 = n * 2;
          var _m2 = m * 2;
          return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
        }
        function pqdownheap(s, tree, k) {
          var v = s.heap[k];
          var j = k << 1;
          while (j <= s.heap_len) {
            if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
              j++;
            }
            if (smaller(tree, v, s.heap[j], s.depth)) {
              break;
            }
            s.heap[k] = s.heap[j];
            k = j;
            j <<= 1;
          }
          s.heap[k] = v;
        }
        function compress_block(s, ltree, dtree) {
          var dist;
          var lc;
          var lx = 0;
          var code;
          var extra;
          if (s.last_lit !== 0) {
            do {
              dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
              lc = s.pending_buf[s.l_buf + lx];
              lx++;
              if (dist === 0) {
                send_code(s, lc, ltree);
              } else {
                code = _length_code[lc];
                send_code(s, code + LITERALS + 1, ltree);
                extra = extra_lbits[code];
                if (extra !== 0) {
                  lc -= base_length[code];
                  send_bits(s, lc, extra);
                }
                dist--;
                code = d_code(dist);
                send_code(s, code, dtree);
                extra = extra_dbits[code];
                if (extra !== 0) {
                  dist -= base_dist[code];
                  send_bits(s, dist, extra);
                }
              }
            } while (lx < s.last_lit);
          }
          send_code(s, END_BLOCK, ltree);
        }
        function build_tree(s, desc) {
          var tree = desc.dyn_tree;
          var stree = desc.stat_desc.static_tree;
          var has_stree = desc.stat_desc.has_stree;
          var elems = desc.stat_desc.elems;
          var n, m;
          var max_code = -1;
          var node;
          s.heap_len = 0;
          s.heap_max = HEAP_SIZE;
          for (n = 0; n < elems; n++) {
            if (tree[n * 2] !== 0) {
              s.heap[++s.heap_len] = max_code = n;
              s.depth[n] = 0;
            } else {
              tree[n * 2 + 1] = 0;
            }
          }
          while (s.heap_len < 2) {
            node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
            tree[node * 2] = 1;
            s.depth[node] = 0;
            s.opt_len--;
            if (has_stree) {
              s.static_len -= stree[node * 2 + 1];
            }
          }
          desc.max_code = max_code;
          for (n = s.heap_len >> 1; n >= 1; n--) {
            pqdownheap(s, tree, n);
          }
          node = elems;
          do {
            n = s.heap[
              1
              /*SMALLEST*/
            ];
            s.heap[
              1
              /*SMALLEST*/
            ] = s.heap[s.heap_len--];
            pqdownheap(
              s,
              tree,
              1
              /*SMALLEST*/
            );
            m = s.heap[
              1
              /*SMALLEST*/
            ];
            s.heap[--s.heap_max] = n;
            s.heap[--s.heap_max] = m;
            tree[node * 2] = tree[n * 2] + tree[m * 2];
            s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
            tree[n * 2 + 1] = tree[m * 2 + 1] = node;
            s.heap[
              1
              /*SMALLEST*/
            ] = node++;
            pqdownheap(
              s,
              tree,
              1
              /*SMALLEST*/
            );
          } while (s.heap_len >= 2);
          s.heap[--s.heap_max] = s.heap[
            1
            /*SMALLEST*/
          ];
          gen_bitlen(s, desc);
          gen_codes(tree, max_code, s.bl_count);
        }
        function scan_tree(s, tree, max_code) {
          var n;
          var prevlen = -1;
          var curlen;
          var nextlen = tree[0 * 2 + 1];
          var count = 0;
          var max_count = 7;
          var min_count = 4;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          }
          tree[(max_code + 1) * 2 + 1] = 65535;
          for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
              continue;
            } else if (count < min_count) {
              s.bl_tree[curlen * 2] += count;
            } else if (curlen !== 0) {
              if (curlen !== prevlen) {
                s.bl_tree[curlen * 2]++;
              }
              s.bl_tree[REP_3_6 * 2]++;
            } else if (count <= 10) {
              s.bl_tree[REPZ_3_10 * 2]++;
            } else {
              s.bl_tree[REPZ_11_138 * 2]++;
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            } else if (curlen === nextlen) {
              max_count = 6;
              min_count = 3;
            } else {
              max_count = 7;
              min_count = 4;
            }
          }
        }
        function send_tree(s, tree, max_code) {
          var n;
          var prevlen = -1;
          var curlen;
          var nextlen = tree[0 * 2 + 1];
          var count = 0;
          var max_count = 7;
          var min_count = 4;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          }
          for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
              continue;
            } else if (count < min_count) {
              do {
                send_code(s, curlen, s.bl_tree);
              } while (--count !== 0);
            } else if (curlen !== 0) {
              if (curlen !== prevlen) {
                send_code(s, curlen, s.bl_tree);
                count--;
              }
              send_code(s, REP_3_6, s.bl_tree);
              send_bits(s, count - 3, 2);
            } else if (count <= 10) {
              send_code(s, REPZ_3_10, s.bl_tree);
              send_bits(s, count - 3, 3);
            } else {
              send_code(s, REPZ_11_138, s.bl_tree);
              send_bits(s, count - 11, 7);
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            } else if (curlen === nextlen) {
              max_count = 6;
              min_count = 3;
            } else {
              max_count = 7;
              min_count = 4;
            }
          }
        }
        function build_bl_tree(s) {
          var max_blindex;
          scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
          scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
          build_tree(s, s.bl_desc);
          for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
            if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
              break;
            }
          }
          s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
          return max_blindex;
        }
        function send_all_trees(s, lcodes, dcodes, blcodes) {
          var rank;
          send_bits(s, lcodes - 257, 5);
          send_bits(s, dcodes - 1, 5);
          send_bits(s, blcodes - 4, 4);
          for (rank = 0; rank < blcodes; rank++) {
            send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
          }
          send_tree(s, s.dyn_ltree, lcodes - 1);
          send_tree(s, s.dyn_dtree, dcodes - 1);
        }
        function detect_data_type(s) {
          var black_mask = 4093624447;
          var n;
          for (n = 0; n <= 31; n++, black_mask >>>= 1) {
            if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
              return Z_BINARY;
            }
          }
          if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
            return Z_TEXT;
          }
          for (n = 32; n < LITERALS; n++) {
            if (s.dyn_ltree[n * 2] !== 0) {
              return Z_TEXT;
            }
          }
          return Z_BINARY;
        }
        var static_init_done = false;
        function _tr_init(s) {
          if (!static_init_done) {
            tr_static_init();
            static_init_done = true;
          }
          s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
          s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
          s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
          s.bi_buf = 0;
          s.bi_valid = 0;
          init_block(s);
        }
        function _tr_stored_block(s, buf, stored_len, last) {
          send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
          copy_block(s, buf, stored_len, true);
        }
        function _tr_align(s) {
          send_bits(s, STATIC_TREES << 1, 3);
          send_code(s, END_BLOCK, static_ltree);
          bi_flush(s);
        }
        function _tr_flush_block(s, buf, stored_len, last) {
          var opt_lenb, static_lenb;
          var max_blindex = 0;
          if (s.level > 0) {
            if (s.strm.data_type === Z_UNKNOWN) {
              s.strm.data_type = detect_data_type(s);
            }
            build_tree(s, s.l_desc);
            build_tree(s, s.d_desc);
            max_blindex = build_bl_tree(s);
            opt_lenb = s.opt_len + 3 + 7 >>> 3;
            static_lenb = s.static_len + 3 + 7 >>> 3;
            if (static_lenb <= opt_lenb) {
              opt_lenb = static_lenb;
            }
          } else {
            opt_lenb = static_lenb = stored_len + 5;
          }
          if (stored_len + 4 <= opt_lenb && buf !== -1) {
            _tr_stored_block(s, buf, stored_len, last);
          } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
            send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
            compress_block(s, static_ltree, static_dtree);
          } else {
            send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
            send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
            compress_block(s, s.dyn_ltree, s.dyn_dtree);
          }
          init_block(s);
          if (last) {
            bi_windup(s);
          }
        }
        function _tr_tally(s, dist, lc) {
          s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
          s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
          s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
          s.last_lit++;
          if (dist === 0) {
            s.dyn_ltree[lc * 2]++;
          } else {
            s.matches++;
            dist--;
            s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
            s.dyn_dtree[d_code(dist) * 2]++;
          }
          return s.last_lit === s.lit_bufsize - 1;
        }
        exports3._tr_init = _tr_init;
        exports3._tr_stored_block = _tr_stored_block;
        exports3._tr_flush_block = _tr_flush_block;
        exports3._tr_tally = _tr_tally;
        exports3._tr_align = _tr_align;
      }, { "../utils/common": 89 }], 101: [function(require2, module3, exports3) {
        arguments[4][46][0].apply(exports3, arguments);
      }, { "dup": 46 }], 102: [function(require2, module3, exports3) {
        module3.exports = function parseBMFontAscii(data) {
          if (!data)
            throw new Error("no data provided");
          data = data.toString().trim();
          var output = {
            pages: [],
            chars: [],
            kernings: []
          };
          var lines = data.split(/\r\n?|\n/g);
          if (lines.length === 0)
            throw new Error("no data in BMFont file");
          for (var i = 0; i < lines.length; i++) {
            var lineData = splitLine(lines[i], i);
            if (!lineData)
              continue;
            if (lineData.key === "page") {
              if (typeof lineData.data.id !== "number")
                throw new Error("malformed file at line " + i + " -- needs page id=N");
              if (typeof lineData.data.file !== "string")
                throw new Error("malformed file at line " + i + ' -- needs page file="path"');
              output.pages[lineData.data.id] = lineData.data.file;
            } else if (lineData.key === "chars" || lineData.key === "kernings") {
            } else if (lineData.key === "char") {
              output.chars.push(lineData.data);
            } else if (lineData.key === "kerning") {
              output.kernings.push(lineData.data);
            } else {
              output[lineData.key] = lineData.data;
            }
          }
          return output;
        };
        function splitLine(line, idx) {
          line = line.replace(/\t+/g, " ").trim();
          if (!line)
            return null;
          var space = line.indexOf(" ");
          if (space === -1)
            throw new Error("no named row at line " + idx);
          var key = line.substring(0, space);
          line = line.substring(space + 1);
          line = line.replace(/letter=[\'\"]\S+[\'\"]/gi, "");
          line = line.split("=");
          line = line.map(function(str) {
            return str.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
          });
          var data = [];
          for (var i = 0; i < line.length; i++) {
            var dt = line[i];
            if (i === 0) {
              data.push({
                key: dt[0],
                data: ""
              });
            } else if (i === line.length - 1) {
              data[data.length - 1].data = parseData(dt[0]);
            } else {
              data[data.length - 1].data = parseData(dt[0]);
              data.push({
                key: dt[1],
                data: ""
              });
            }
          }
          var out = {
            key,
            data: {}
          };
          data.forEach(function(v) {
            out.data[v.key] = v.data;
          });
          return out;
        }
        function parseData(data) {
          if (!data || data.length === 0)
            return "";
          if (data.indexOf('"') === 0 || data.indexOf("'") === 0)
            return data.substring(1, data.length - 1);
          if (data.indexOf(",") !== -1)
            return parseIntList(data);
          return parseInt(data, 10);
        }
        function parseIntList(data) {
          return data.split(",").map(function(val) {
            return parseInt(val, 10);
          });
        }
      }, {}], 103: [function(require2, module3, exports3) {
        var HEADER = [66, 77, 70];
        module3.exports = function readBMFontBinary(buf) {
          if (buf.length < 6)
            throw new Error("invalid buffer length for BMFont");
          var header = HEADER.every(function(byte, i2) {
            return buf.readUInt8(i2) === byte;
          });
          if (!header)
            throw new Error("BMFont missing BMF byte header");
          var i = 3;
          var vers = buf.readUInt8(i++);
          if (vers > 3)
            throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
          var target = { kernings: [], chars: [] };
          for (var b = 0; b < 5; b++)
            i += readBlock(target, buf, i);
          return target;
        };
        function readBlock(target, buf, i) {
          if (i > buf.length - 1)
            return 0;
          var blockID = buf.readUInt8(i++);
          var blockSize = buf.readInt32LE(i);
          i += 4;
          switch (blockID) {
            case 1:
              target.info = readInfo(buf, i);
              break;
            case 2:
              target.common = readCommon(buf, i);
              break;
            case 3:
              target.pages = readPages(buf, i, blockSize);
              break;
            case 4:
              target.chars = readChars(buf, i, blockSize);
              break;
            case 5:
              target.kernings = readKernings(buf, i, blockSize);
              break;
          }
          return 5 + blockSize;
        }
        function readInfo(buf, i) {
          var info = {};
          info.size = buf.readInt16LE(i);
          var bitField = buf.readUInt8(i + 2);
          info.smooth = bitField >> 7 & 1;
          info.unicode = bitField >> 6 & 1;
          info.italic = bitField >> 5 & 1;
          info.bold = bitField >> 4 & 1;
          if (bitField >> 3 & 1)
            info.fixedHeight = 1;
          info.charset = buf.readUInt8(i + 3) || "";
          info.stretchH = buf.readUInt16LE(i + 4);
          info.aa = buf.readUInt8(i + 6);
          info.padding = [
            buf.readInt8(i + 7),
            buf.readInt8(i + 8),
            buf.readInt8(i + 9),
            buf.readInt8(i + 10)
          ];
          info.spacing = [
            buf.readInt8(i + 11),
            buf.readInt8(i + 12)
          ];
          info.outline = buf.readUInt8(i + 13);
          info.face = readStringNT(buf, i + 14);
          return info;
        }
        function readCommon(buf, i) {
          var common = {};
          common.lineHeight = buf.readUInt16LE(i);
          common.base = buf.readUInt16LE(i + 2);
          common.scaleW = buf.readUInt16LE(i + 4);
          common.scaleH = buf.readUInt16LE(i + 6);
          common.pages = buf.readUInt16LE(i + 8);
          var bitField = buf.readUInt8(i + 10);
          common.packed = 0;
          common.alphaChnl = buf.readUInt8(i + 11);
          common.redChnl = buf.readUInt8(i + 12);
          common.greenChnl = buf.readUInt8(i + 13);
          common.blueChnl = buf.readUInt8(i + 14);
          return common;
        }
        function readPages(buf, i, size) {
          var pages = [];
          var text = readNameNT(buf, i);
          var len = text.length + 1;
          var count = size / len;
          for (var c = 0; c < count; c++) {
            pages[c] = buf.slice(i, i + text.length).toString("utf8");
            i += len;
          }
          return pages;
        }
        function readChars(buf, i, blockSize) {
          var chars = [];
          var count = blockSize / 20;
          for (var c = 0; c < count; c++) {
            var char = {};
            var off = c * 20;
            char.id = buf.readUInt32LE(i + 0 + off);
            char.x = buf.readUInt16LE(i + 4 + off);
            char.y = buf.readUInt16LE(i + 6 + off);
            char.width = buf.readUInt16LE(i + 8 + off);
            char.height = buf.readUInt16LE(i + 10 + off);
            char.xoffset = buf.readInt16LE(i + 12 + off);
            char.yoffset = buf.readInt16LE(i + 14 + off);
            char.xadvance = buf.readInt16LE(i + 16 + off);
            char.page = buf.readUInt8(i + 18 + off);
            char.chnl = buf.readUInt8(i + 19 + off);
            chars[c] = char;
          }
          return chars;
        }
        function readKernings(buf, i, blockSize) {
          var kernings = [];
          var count = blockSize / 10;
          for (var c = 0; c < count; c++) {
            var kern = {};
            var off = c * 10;
            kern.first = buf.readUInt32LE(i + 0 + off);
            kern.second = buf.readUInt32LE(i + 4 + off);
            kern.amount = buf.readInt16LE(i + 8 + off);
            kernings[c] = kern;
          }
          return kernings;
        }
        function readNameNT(buf, offset) {
          var pos = offset;
          for (; pos < buf.length; pos++) {
            if (buf[pos] === 0)
              break;
          }
          return buf.slice(offset, pos);
        }
        function readStringNT(buf, offset) {
          return readNameNT(buf, offset).toString("utf8");
        }
      }, {}], 104: [function(require2, module3, exports3) {
        var parseAttributes = require2("./parse-attribs");
        var parseFromString = require2("xml-parse-from-string");
        var NAME_MAP = {
          scaleh: "scaleH",
          scalew: "scaleW",
          stretchh: "stretchH",
          lineheight: "lineHeight",
          alphachnl: "alphaChnl",
          redchnl: "redChnl",
          greenchnl: "greenChnl",
          bluechnl: "blueChnl"
        };
        module3.exports = function parse(data) {
          data = data.toString();
          var xmlRoot = parseFromString(data);
          var output = {
            pages: [],
            chars: [],
            kernings: []
          };
          ["info", "common"].forEach(function(key) {
            var element = xmlRoot.getElementsByTagName(key)[0];
            if (element)
              output[key] = parseAttributes(getAttribs(element));
          });
          var pageRoot = xmlRoot.getElementsByTagName("pages")[0];
          if (!pageRoot)
            throw new Error("malformed file -- no <pages> element");
          var pages = pageRoot.getElementsByTagName("page");
          for (var i = 0; i < pages.length; i++) {
            var p = pages[i];
            var id = parseInt(p.getAttribute("id"), 10);
            var file = p.getAttribute("file");
            if (isNaN(id))
              throw new Error('malformed file -- page "id" attribute is NaN');
            if (!file)
              throw new Error('malformed file -- needs page "file" attribute');
            output.pages[parseInt(id, 10)] = file;
          }
          ;
          ["chars", "kernings"].forEach(function(key) {
            var element = xmlRoot.getElementsByTagName(key)[0];
            if (!element)
              return;
            var childTag = key.substring(0, key.length - 1);
            var children = element.getElementsByTagName(childTag);
            for (var i2 = 0; i2 < children.length; i2++) {
              var child = children[i2];
              output[key].push(parseAttributes(getAttribs(child)));
            }
          });
          return output;
        };
        function getAttribs(element) {
          var attribs = getAttribList(element);
          return attribs.reduce(function(dict, attrib) {
            var key = mapName(attrib.nodeName);
            dict[key] = attrib.nodeValue;
            return dict;
          }, {});
        }
        function getAttribList(element) {
          var attribs = [];
          for (var i = 0; i < element.attributes.length; i++)
            attribs.push(element.attributes[i]);
          return attribs;
        }
        function mapName(nodeName) {
          return NAME_MAP[nodeName.toLowerCase()] || nodeName;
        }
      }, { "./parse-attribs": 105, "xml-parse-from-string": 188 }], 105: [function(require2, module3, exports3) {
        var GLYPH_DESIGNER_ERROR = "chasrset";
        module3.exports = function parseAttributes(obj) {
          if (GLYPH_DESIGNER_ERROR in obj) {
            obj["charset"] = obj[GLYPH_DESIGNER_ERROR];
            delete obj[GLYPH_DESIGNER_ERROR];
          }
          for (var k in obj) {
            if (k === "face" || k === "charset")
              continue;
            else if (k === "padding" || k === "spacing")
              obj[k] = parseIntList(obj[k]);
            else
              obj[k] = parseInt(obj[k], 10);
          }
          return obj;
        };
        function parseIntList(data) {
          return data.split(",").map(function(val) {
            return parseInt(val, 10);
          });
        }
      }, {}], 106: [function(require2, module3, exports3) {
        var trim = require2("trim"), forEach = require2("for-each"), isArray = function(arg) {
          return Object.prototype.toString.call(arg) === "[object Array]";
        };
        module3.exports = function(headers) {
          if (!headers)
            return {};
          var result = {};
          forEach(
            trim(headers).split("\n"),
            function(row) {
              var index = row.indexOf(":"), key = trim(row.slice(0, index)).toLowerCase(), value = trim(row.slice(index + 1));
              if (typeof result[key] === "undefined") {
                result[key] = value;
              } else if (isArray(result[key])) {
                result[key].push(value);
              } else {
                result[key] = [result[key], value];
              }
            }
          );
          return result;
        };
      }, { "for-each": 63, "trim": 179 }], 107: [function(require2, module3, exports3) {
        (function(process) {
          function normalizeArray(parts, allowAboveRoot) {
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === ".") {
                parts.splice(i, 1);
              } else if (last === "..") {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }
            if (allowAboveRoot) {
              for (; up--; up) {
                parts.unshift("..");
              }
            }
            return parts;
          }
          exports3.resolve = function() {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
              var path = i >= 0 ? arguments[i] : process.cwd();
              if (typeof path !== "string") {
                throw new TypeError("Arguments to path.resolve must be strings");
              } else if (!path) {
                continue;
              }
              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = path.charAt(0) === "/";
            }
            resolvedPath = normalizeArray(filter(resolvedPath.split("/"), function(p) {
              return !!p;
            }), !resolvedAbsolute).join("/");
            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          };
          exports3.normalize = function(path) {
            var isAbsolute = exports3.isAbsolute(path), trailingSlash = substr(path, -1) === "/";
            path = normalizeArray(filter(path.split("/"), function(p) {
              return !!p;
            }), !isAbsolute).join("/");
            if (!path && !isAbsolute) {
              path = ".";
            }
            if (path && trailingSlash) {
              path += "/";
            }
            return (isAbsolute ? "/" : "") + path;
          };
          exports3.isAbsolute = function(path) {
            return path.charAt(0) === "/";
          };
          exports3.join = function() {
            var paths = Array.prototype.slice.call(arguments, 0);
            return exports3.normalize(filter(paths, function(p, index) {
              if (typeof p !== "string") {
                throw new TypeError("Arguments to path.join must be strings");
              }
              return p;
            }).join("/"));
          };
          exports3.relative = function(from, to) {
            from = exports3.resolve(from).substr(1);
            to = exports3.resolve(to).substr(1);
            function trim(arr) {
              var start = 0;
              for (; start < arr.length; start++) {
                if (arr[start] !== "")
                  break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "")
                  break;
              }
              if (start > end)
                return [];
              return arr.slice(start, end - start + 1);
            }
            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i = 0; i < length; i++) {
              if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
              }
            }
            var outputParts = [];
            for (var i = samePartsLength; i < fromParts.length; i++) {
              outputParts.push("..");
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/");
          };
          exports3.sep = "/";
          exports3.delimiter = ":";
          exports3.dirname = function(path) {
            if (typeof path !== "string")
              path = path + "";
            if (path.length === 0)
              return ".";
            var code = path.charCodeAt(0);
            var hasRoot = code === 47;
            var end = -1;
            var matchedSlash = true;
            for (var i = path.length - 1; i >= 1; --i) {
              code = path.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  end = i;
                  break;
                }
              } else {
                matchedSlash = false;
              }
            }
            if (end === -1)
              return hasRoot ? "/" : ".";
            if (hasRoot && end === 1) {
              return "/";
            }
            return path.slice(0, end);
          };
          function basename(path) {
            if (typeof path !== "string")
              path = path + "";
            var start = 0;
            var end = -1;
            var matchedSlash = true;
            var i;
            for (i = path.length - 1; i >= 0; --i) {
              if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                  start = i + 1;
                  break;
                }
              } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
            }
            if (end === -1)
              return "";
            return path.slice(start, end);
          }
          exports3.basename = function(path, ext) {
            var f = basename(path);
            if (ext && f.substr(-1 * ext.length) === ext) {
              f = f.substr(0, f.length - ext.length);
            }
            return f;
          };
          exports3.extname = function(path) {
            if (typeof path !== "string")
              path = path + "";
            var startDot = -1;
            var startPart = 0;
            var end = -1;
            var matchedSlash = true;
            var preDotState = 0;
            for (var i = path.length - 1; i >= 0; --i) {
              var code = path.charCodeAt(i);
              if (code === 47) {
                if (!matchedSlash) {
                  startPart = i + 1;
                  break;
                }
                continue;
              }
              if (end === -1) {
                matchedSlash = false;
                end = i + 1;
              }
              if (code === 46) {
                if (startDot === -1)
                  startDot = i;
                else if (preDotState !== 1)
                  preDotState = 1;
              } else if (startDot !== -1) {
                preDotState = -1;
              }
            }
            if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
            preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
            preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
              return "";
            }
            return path.slice(startDot, end);
          };
          function filter(xs, f) {
            if (xs.filter)
              return xs.filter(f);
            var res = [];
            for (var i = 0; i < xs.length; i++) {
              if (f(xs[i], i, xs))
                res.push(xs[i]);
            }
            return res;
          }
          var substr = "ab".substr(-1) === "b" ? function(str, start, len) {
            return str.substr(start, len);
          } : function(str, start, len) {
            if (start < 0)
              start = str.length + start;
            return str.substr(start, len);
          };
        }).call(this, require2("_process"));
      }, { "_process": 133 }], 108: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          var http = require2("http");
          var https = require2("https");
          var url = require2("url");
          var qs = require2("querystring");
          var zlib = require2("zlib");
          var util = require2("util");
          var phin = function phin2(opts, cb) {
            if (typeof opts !== "string") {
              if (!opts.hasOwnProperty("url")) {
                throw new Error("Missing url option from options for request method.");
              }
            }
            var addr = (typeof opts === "undefined" ? "undefined" : _typeof(opts)) === "object" ? url.parse(opts.url) : url.parse(opts);
            var options = { "hostname": addr.hostname, "port": addr.port || (addr.protocol.toLowerCase() === "http:" ? 80 : 443), "path": addr.path, "method": "GET", "headers": {}, "auth": addr.auth || null, "parse": "none", "stream": false };
            if ((typeof opts === "undefined" ? "undefined" : _typeof(opts)) === "object") {
              options = Object.assign(options, opts);
            }
            options.port = Number(options.port);
            if (options.hasOwnProperty("timeout"))
              delete options.timeout;
            if (options.compressed === true) {
              options.headers["accept-encoding"] = "gzip, deflate";
            }
            if (opts.hasOwnProperty("form")) {
              if (_typeof(opts.form) !== "object") {
                throw new Error("phin 'form' option must be of type Object if present.");
              }
              var formDataString = qs.stringify(opts.form);
              options.headers["Content-Type"] = "application/x-www-form-urlencoded";
              options.headers["Content-Length"] = Buffer.byteLength(formDataString);
              opts.data = formDataString;
            }
            var req = void 0;
            var resHandler = function resHandler2(res) {
              var stream = res;
              if (options.compressed === true) {
                if (res.headers["content-encoding"] === "gzip") {
                  stream = res.pipe(zlib.createGunzip());
                } else if (res.headers["content-encoding"] === "deflate") {
                  stream = res.pipe(zlib.createInflate());
                }
              }
              if (options.stream === true) {
                res.stream = stream;
                cb(null, res);
              } else {
                res.body = new Buffer([]);
                stream.on("data", function(chunk) {
                  res.body = Buffer.concat([res.body, chunk]);
                });
                stream.on("end", function() {
                  if (cb) {
                    if (options.parse === "json") {
                      try {
                        res.body = JSON.parse(res.body.toString());
                      } catch (err) {
                        cb("Invalid JSON received.", res);
                        return;
                      }
                    }
                    cb(null, res);
                  }
                });
              }
            };
            switch (addr.protocol.toLowerCase()) {
              case "http:":
                req = http.request(options, resHandler);
                break;
              case "https:":
                req = https.request(options, resHandler);
                break;
              default:
                if (cb) {
                  cb(new Error("Invalid / unknown URL protocol. Expected HTTP or HTTPS."), null);
                }
                return;
            }
            if (typeof opts.timeout === "number") {
              req.setTimeout(opts.timeout, function() {
                req.abort();
                cb(new Error("Timeout has been reached."), null);
                cb = null;
              });
            }
            req.on("error", function(err) {
              if (cb) {
                cb(err, null);
              }
            });
            if (opts.hasOwnProperty("data")) {
              var postData = opts.data;
              if (!(opts.data instanceof Buffer) && _typeof(opts.data) === "object") {
                var contentType = options.headers["content-type"] || options.headers["Content-Type"];
                if (contentType === "application/x-www-form-urlencoded") {
                  postData = qs.stringify(opts.data);
                } else {
                  try {
                    postData = JSON.stringify(opts.data);
                  } catch (err) {
                    cb(new Error("Couldn't stringify object. (Likely due to a circular reference.)"), null);
                  }
                }
              }
              req.write(postData);
            }
            req.end();
          };
          phin.promisified = function(opts, http2) {
            return new Promise(function(resolve, reject) {
              phin(opts, function(err, res) {
                if (err) {
                  reject(err);
                } else {
                  resolve(res);
                }
              }, http2);
            });
          };
          if (util.promisify) {
            phin[util.promisify.custom] = phin.promisified;
          }
          module3.exports = phin;
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 48, "http": 156, "https": 72, "querystring": 137, "url": 180, "util": 186, "zlib": 35 }], 109: [function(require2, module3, exports3) {
        "use strict";
        module3.exports = pixelmatch;
        function pixelmatch(img1, img2, output, width, height, options) {
          if (!options)
            options = {};
          var threshold = options.threshold === void 0 ? 0.1 : options.threshold;
          var maxDelta = 35215 * threshold * threshold, diff = 0;
          for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
              var pos = (y * width + x) * 4;
              var delta = colorDelta(img1, img2, pos, pos);
              if (delta > maxDelta) {
                if (!options.includeAA && (antialiased(img1, x, y, width, height, img2) || antialiased(img2, x, y, width, height, img1))) {
                  if (output)
                    drawPixel(output, pos, 255, 255, 0);
                } else {
                  if (output)
                    drawPixel(output, pos, 255, 0, 0);
                  diff++;
                }
              } else if (output) {
                var val = blend(grayPixel(img1, pos), 0.1);
                drawPixel(output, pos, val, val, val);
              }
            }
          }
          return diff;
        }
        function antialiased(img, x1, y1, width, height, img2) {
          var x0 = Math.max(x1 - 1, 0), y0 = Math.max(y1 - 1, 0), x2 = Math.min(x1 + 1, width - 1), y2 = Math.min(y1 + 1, height - 1), pos = (y1 * width + x1) * 4, zeroes = 0, positives = 0, negatives = 0, min = 0, max = 0, minX, minY, maxX, maxY;
          for (var x = x0; x <= x2; x++) {
            for (var y = y0; y <= y2; y++) {
              if (x === x1 && y === y1)
                continue;
              var delta = colorDelta(img, img, pos, (y * width + x) * 4, true);
              if (delta === 0)
                zeroes++;
              else if (delta < 0)
                negatives++;
              else if (delta > 0)
                positives++;
              if (zeroes > 2)
                return false;
              if (!img2)
                continue;
              if (delta < min) {
                min = delta;
                minX = x;
                minY = y;
              }
              if (delta > max) {
                max = delta;
                maxX = x;
                maxY = y;
              }
            }
          }
          if (!img2)
            return true;
          if (negatives === 0 || positives === 0)
            return false;
          return !antialiased(img, minX, minY, width, height) && !antialiased(img2, minX, minY, width, height) || !antialiased(img, maxX, maxY, width, height) && !antialiased(img2, maxX, maxY, width, height);
        }
        function colorDelta(img1, img2, k, m, yOnly) {
          var a1 = img1[k + 3] / 255, a2 = img2[m + 3] / 255, r1 = blend(img1[k + 0], a1), g1 = blend(img1[k + 1], a1), b1 = blend(img1[k + 2], a1), r2 = blend(img2[m + 0], a2), g2 = blend(img2[m + 1], a2), b2 = blend(img2[m + 2], a2), y = rgb2y(r1, g1, b1) - rgb2y(r2, g2, b2);
          if (yOnly)
            return y;
          var i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2), q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);
          return 0.5053 * y * y + 0.299 * i * i + 0.1957 * q * q;
        }
        function rgb2y(r, g, b) {
          return r * 0.29889531 + g * 0.58662247 + b * 0.11448223;
        }
        function rgb2i(r, g, b) {
          return r * 0.59597799 - g * 0.2741761 - b * 0.32180189;
        }
        function rgb2q(r, g, b) {
          return r * 0.21147017 - g * 0.52261711 + b * 0.31114694;
        }
        function blend(c, a) {
          return 255 + (c - 255) * a;
        }
        function drawPixel(output, pos, r, g, b) {
          output[pos + 0] = r;
          output[pos + 1] = g;
          output[pos + 2] = b;
          output[pos + 3] = 255;
        }
        function grayPixel(img, i) {
          var a = img[i + 3] / 255, r = blend(img[i + 0], a), g = blend(img[i + 1], a), b = blend(img[i + 2], a);
          return rgb2y(r, g, b);
        }
      }, {}], 110: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var interlaceUtils = require2("./interlace");
          var pixelBppMap = {
            1: {
              // L
              0: 0,
              1: 0,
              2: 0,
              3: 255
            },
            2: {
              // LA
              0: 0,
              1: 0,
              2: 0,
              3: 1
            },
            3: {
              // RGB
              0: 0,
              1: 1,
              2: 2,
              3: 255
            },
            4: {
              // RGBA
              0: 0,
              1: 1,
              2: 2,
              3: 3
            }
          };
          function bitRetriever(data, depth) {
            var leftOver = [];
            var i = 0;
            function split() {
              if (i === data.length) {
                throw new Error("Ran out of data");
              }
              var byte = data[i];
              i++;
              var byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
              switch (depth) {
                default:
                  throw new Error("unrecognised depth");
                case 16:
                  byte2 = data[i];
                  i++;
                  leftOver.push((byte << 8) + byte2);
                  break;
                case 4:
                  byte2 = byte & 15;
                  byte1 = byte >> 4;
                  leftOver.push(byte1, byte2);
                  break;
                case 2:
                  byte4 = byte & 3;
                  byte3 = byte >> 2 & 3;
                  byte2 = byte >> 4 & 3;
                  byte1 = byte >> 6 & 3;
                  leftOver.push(byte1, byte2, byte3, byte4);
                  break;
                case 1:
                  byte8 = byte & 1;
                  byte7 = byte >> 1 & 1;
                  byte6 = byte >> 2 & 1;
                  byte5 = byte >> 3 & 1;
                  byte4 = byte >> 4 & 1;
                  byte3 = byte >> 5 & 1;
                  byte2 = byte >> 6 & 1;
                  byte1 = byte >> 7 & 1;
                  leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
                  break;
              }
            }
            return {
              get: function(count) {
                while (leftOver.length < count) {
                  split();
                }
                var returner = leftOver.slice(0, count);
                leftOver = leftOver.slice(count);
                return returner;
              },
              resetAfterLine: function() {
                leftOver.length = 0;
              },
              end: function() {
                if (i !== data.length) {
                  throw new Error("extra data found");
                }
              }
            };
          }
          function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
            var imageWidth = image.width;
            var imageHeight = image.height;
            var imagePass = image.index;
            for (var y = 0; y < imageHeight; y++) {
              for (var x = 0; x < imageWidth; x++) {
                var pxPos = getPxPos(x, y, imagePass);
                for (var i = 0; i < 4; i++) {
                  var idx = pixelBppMap[bpp][i];
                  if (idx === 255) {
                    pxData[pxPos + i] = 255;
                  } else {
                    var dataPos = idx + rawPos;
                    if (dataPos === data.length) {
                      throw new Error("Ran out of data");
                    }
                    pxData[pxPos + i] = data[dataPos];
                  }
                }
                rawPos += bpp;
              }
            }
            return rawPos;
          }
          function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
            var imageWidth = image.width;
            var imageHeight = image.height;
            var imagePass = image.index;
            for (var y = 0; y < imageHeight; y++) {
              for (var x = 0; x < imageWidth; x++) {
                var pixelData = bits.get(bpp);
                var pxPos = getPxPos(x, y, imagePass);
                for (var i = 0; i < 4; i++) {
                  var idx = pixelBppMap[bpp][i];
                  pxData[pxPos + i] = idx !== 255 ? pixelData[idx] : maxBit;
                }
              }
              bits.resetAfterLine();
            }
          }
          exports3.dataToBitMap = function(data, bitmapInfo) {
            var width = bitmapInfo.width;
            var height = bitmapInfo.height;
            var depth = bitmapInfo.depth;
            var bpp = bitmapInfo.bpp;
            var interlace = bitmapInfo.interlace;
            if (depth !== 8) {
              var bits = bitRetriever(data, depth);
            }
            var pxData;
            if (depth <= 8) {
              pxData = new Buffer(width * height * 4);
            } else {
              pxData = new Uint16Array(width * height * 4);
            }
            var maxBit = Math.pow(2, depth) - 1;
            var rawPos = 0;
            var images;
            var getPxPos;
            if (interlace) {
              images = interlaceUtils.getImagePasses(width, height);
              getPxPos = interlaceUtils.getInterlaceIterator(width, height);
            } else {
              var nonInterlacedPxPos = 0;
              getPxPos = function() {
                var returner = nonInterlacedPxPos;
                nonInterlacedPxPos += 4;
                return returner;
              };
              images = [{ width, height }];
            }
            for (var imageIndex = 0; imageIndex < images.length; imageIndex++) {
              if (depth === 8) {
                rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
              } else {
                mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
              }
            }
            if (depth === 8) {
              if (rawPos !== data.length) {
                throw new Error("extra data found");
              }
            } else {
              bits.end();
            }
            return pxData;
          };
        }).call(this, require2("buffer").Buffer);
      }, { "./interlace": 120, "buffer": 48 }], 111: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var constants = require2("./constants");
          module3.exports = function(dataIn, width, height, options) {
            var outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;
            if (options.colorType === options.inputColorType) {
              var bigEndian = function() {
                var buffer = new ArrayBuffer(2);
                new DataView(buffer).setInt16(
                  0,
                  256,
                  true
                  /* littleEndian */
                );
                return new Int16Array(buffer)[0] !== 256;
              }();
              if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
                return dataIn;
              }
            }
            var data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
            var maxValue = 255;
            var inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];
            if (inBpp == 4 && !options.inputHasAlpha)
              inBpp = 3;
            var outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];
            if (options.bitDepth === 16) {
              maxValue = 65535;
              outBpp *= 2;
            }
            var outData = new Buffer(width * height * outBpp);
            var inIndex = 0;
            var outIndex = 0;
            var bgColor = options.bgColor || {};
            if (bgColor.red === void 0) {
              bgColor.red = maxValue;
            }
            if (bgColor.green === void 0) {
              bgColor.green = maxValue;
            }
            if (bgColor.blue === void 0) {
              bgColor.blue = maxValue;
            }
            function getRGBA(data2, inIndex2) {
              var red, green, blue, alpha = maxValue;
              switch (options.inputColorType) {
                case constants.COLORTYPE_COLOR_ALPHA:
                  alpha = data2[inIndex2 + 3];
                  red = data2[inIndex2];
                  green = data2[inIndex2 + 1];
                  blue = data2[inIndex2 + 2];
                  break;
                case constants.COLORTYPE_COLOR:
                  red = data2[inIndex2];
                  green = data2[inIndex2 + 1];
                  blue = data2[inIndex2 + 2];
                  break;
                case constants.COLORTYPE_ALPHA:
                  alpha = data2[inIndex2 + 1];
                  red = data2[inIndex2];
                  green = red;
                  blue = red;
                  break;
                case constants.COLORTYPE_GRAYSCALE:
                  red = data2[inIndex2];
                  green = red;
                  blue = red;
                  break;
                default:
                  throw new Error("input color type:" + options.inputColorType + " is not supported at present");
              }
              if (options.inputHasAlpha) {
                if (!outHasAlpha) {
                  alpha /= maxValue;
                  red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
                  green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
                  blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
                }
              }
              return { red, green, blue, alpha };
            }
            for (var y = 0; y < height; y++) {
              for (var x = 0; x < width; x++) {
                var rgba = getRGBA(data, inIndex);
                switch (options.colorType) {
                  case constants.COLORTYPE_COLOR_ALPHA:
                  case constants.COLORTYPE_COLOR:
                    if (options.bitDepth === 8) {
                      outData[outIndex] = rgba.red;
                      outData[outIndex + 1] = rgba.green;
                      outData[outIndex + 2] = rgba.blue;
                      if (outHasAlpha) {
                        outData[outIndex + 3] = rgba.alpha;
                      }
                    } else {
                      outData.writeUInt16BE(rgba.red, outIndex);
                      outData.writeUInt16BE(rgba.green, outIndex + 2);
                      outData.writeUInt16BE(rgba.blue, outIndex + 4);
                      if (outHasAlpha) {
                        outData.writeUInt16BE(rgba.alpha, outIndex + 6);
                      }
                    }
                    break;
                  case constants.COLORTYPE_ALPHA:
                  case constants.COLORTYPE_GRAYSCALE:
                    var grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
                    if (options.bitDepth === 8) {
                      outData[outIndex] = grayscale;
                      if (outHasAlpha) {
                        outData[outIndex + 1] = rgba.alpha;
                      }
                    } else {
                      outData.writeUInt16BE(grayscale, outIndex);
                      if (outHasAlpha) {
                        outData.writeUInt16BE(rgba.alpha, outIndex + 2);
                      }
                    }
                    break;
                }
                inIndex += inBpp;
                outIndex += outBpp;
              }
            }
            return outData;
          };
        }).call(this, require2("buffer").Buffer);
      }, { "./constants": 113, "buffer": 48 }], 112: [function(require2, module3, exports3) {
        (function(process, Buffer) {
          "use strict";
          var util = require2("util");
          var Stream = require2("stream");
          var ChunkStream = module3.exports = function() {
            Stream.call(this);
            this._buffers = [];
            this._buffered = 0;
            this._reads = [];
            this._paused = false;
            this._encoding = "utf8";
            this.writable = true;
          };
          util.inherits(ChunkStream, Stream);
          ChunkStream.prototype.read = function(length, callback) {
            this._reads.push({
              length: Math.abs(length),
              // if length < 0 then at most this length
              allowLess: length < 0,
              func: callback
            });
            process.nextTick((function() {
              this._process();
              if (this._paused && this._reads.length > 0) {
                this._paused = false;
                this.emit("drain");
              }
            }).bind(this));
          };
          ChunkStream.prototype.write = function(data, encoding) {
            if (!this.writable) {
              this.emit("error", new Error("Stream not writable"));
              return false;
            }
            var dataBuffer;
            if (Buffer.isBuffer(data)) {
              dataBuffer = data;
            } else {
              dataBuffer = new Buffer(data, encoding || this._encoding);
            }
            this._buffers.push(dataBuffer);
            this._buffered += dataBuffer.length;
            this._process();
            if (this._reads && this._reads.length === 0) {
              this._paused = true;
            }
            return this.writable && !this._paused;
          };
          ChunkStream.prototype.end = function(data, encoding) {
            if (data) {
              this.write(data, encoding);
            }
            this.writable = false;
            if (!this._buffers) {
              return;
            }
            if (this._buffers.length === 0) {
              this._end();
            } else {
              this._buffers.push(null);
              this._process();
            }
          };
          ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
          ChunkStream.prototype._end = function() {
            if (this._reads.length > 0) {
              this.emit(
                "error",
                new Error("There are some read requests waiting on finished stream")
              );
            }
            this.destroy();
          };
          ChunkStream.prototype.destroy = function() {
            if (!this._buffers) {
              return;
            }
            this.writable = false;
            this._reads = null;
            this._buffers = null;
            this.emit("close");
          };
          ChunkStream.prototype._processReadAllowingLess = function(read) {
            this._reads.shift();
            var smallerBuf = this._buffers[0];
            if (smallerBuf.length > read.length) {
              this._buffered -= read.length;
              this._buffers[0] = smallerBuf.slice(read.length);
              read.func.call(this, smallerBuf.slice(0, read.length));
            } else {
              this._buffered -= smallerBuf.length;
              this._buffers.shift();
              read.func.call(this, smallerBuf);
            }
          };
          ChunkStream.prototype._processRead = function(read) {
            this._reads.shift();
            var pos = 0;
            var count = 0;
            var data = new Buffer(read.length);
            while (pos < read.length) {
              var buf = this._buffers[count++];
              var len = Math.min(buf.length, read.length - pos);
              buf.copy(data, pos, 0, len);
              pos += len;
              if (len !== buf.length) {
                this._buffers[--count] = buf.slice(len);
              }
            }
            if (count > 0) {
              this._buffers.splice(0, count);
            }
            this._buffered -= read.length;
            read.func.call(this, data);
          };
          ChunkStream.prototype._process = function() {
            try {
              while (this._buffered > 0 && this._reads && this._reads.length > 0) {
                var read = this._reads[0];
                if (read.allowLess) {
                  this._processReadAllowingLess(read);
                } else if (this._buffered >= read.length) {
                  this._processRead(read);
                } else {
                  break;
                }
              }
              if (this._buffers && this._buffers.length > 0 && this._buffers[0] === null) {
                this._end();
              }
            } catch (ex) {
              this.emit("error", ex);
            }
          };
        }).call(this, require2("_process"), require2("buffer").Buffer);
      }, { "_process": 133, "buffer": 48, "stream": 155, "util": 186 }], 113: [function(require2, module3, exports3) {
        "use strict";
        module3.exports = {
          PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
          TYPE_IHDR: 1229472850,
          TYPE_IEND: 1229278788,
          TYPE_IDAT: 1229209940,
          TYPE_PLTE: 1347179589,
          TYPE_tRNS: 1951551059,
          // eslint-disable-line camelcase
          TYPE_gAMA: 1732332865,
          // eslint-disable-line camelcase
          // color-type bits
          COLORTYPE_GRAYSCALE: 0,
          COLORTYPE_PALETTE: 1,
          COLORTYPE_COLOR: 2,
          COLORTYPE_ALPHA: 4,
          // e.g. grayscale and alpha
          // color-type combinations
          COLORTYPE_PALETTE_COLOR: 3,
          COLORTYPE_COLOR_ALPHA: 6,
          COLORTYPE_TO_BPP_MAP: {
            0: 1,
            2: 3,
            3: 1,
            4: 2,
            6: 4
          },
          GAMMA_DIVISION: 1e5
        };
      }, {}], 114: [function(require2, module3, exports3) {
        "use strict";
        var crcTable = [];
        (function() {
          for (var i = 0; i < 256; i++) {
            var currentCrc = i;
            for (var j = 0; j < 8; j++) {
              if (currentCrc & 1) {
                currentCrc = 3988292384 ^ currentCrc >>> 1;
              } else {
                currentCrc = currentCrc >>> 1;
              }
            }
            crcTable[i] = currentCrc;
          }
        })();
        var CrcCalculator = module3.exports = function() {
          this._crc = -1;
        };
        CrcCalculator.prototype.write = function(data) {
          for (var i = 0; i < data.length; i++) {
            this._crc = crcTable[(this._crc ^ data[i]) & 255] ^ this._crc >>> 8;
          }
          return true;
        };
        CrcCalculator.prototype.crc32 = function() {
          return this._crc ^ -1;
        };
        CrcCalculator.crc32 = function(buf) {
          var crc = -1;
          for (var i = 0; i < buf.length; i++) {
            crc = crcTable[(crc ^ buf[i]) & 255] ^ crc >>> 8;
          }
          return crc ^ -1;
        };
      }, {}], 115: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var paethPredictor = require2("./paeth-predictor");
          function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
            for (var x = 0; x < byteWidth; x++) {
              rawData[rawPos + x] = pxData[pxPos + x];
            }
          }
          function filterSumNone(pxData, pxPos, byteWidth) {
            var sum = 0;
            var length = pxPos + byteWidth;
            for (var i = pxPos; i < length; i++) {
              sum += Math.abs(pxData[i]);
            }
            return sum;
          }
          function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
            for (var x = 0; x < byteWidth; x++) {
              var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
              var val = pxData[pxPos + x] - left;
              rawData[rawPos + x] = val;
            }
          }
          function filterSumSub(pxData, pxPos, byteWidth, bpp) {
            var sum = 0;
            for (var x = 0; x < byteWidth; x++) {
              var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
              var val = pxData[pxPos + x] - left;
              sum += Math.abs(val);
            }
            return sum;
          }
          function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
            for (var x = 0; x < byteWidth; x++) {
              var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
              var val = pxData[pxPos + x] - up;
              rawData[rawPos + x] = val;
            }
          }
          function filterSumUp(pxData, pxPos, byteWidth) {
            var sum = 0;
            var length = pxPos + byteWidth;
            for (var x = pxPos; x < length; x++) {
              var up = pxPos > 0 ? pxData[x - byteWidth] : 0;
              var val = pxData[x] - up;
              sum += Math.abs(val);
            }
            return sum;
          }
          function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
            for (var x = 0; x < byteWidth; x++) {
              var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
              var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
              var val = pxData[pxPos + x] - (left + up >> 1);
              rawData[rawPos + x] = val;
            }
          }
          function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
            var sum = 0;
            for (var x = 0; x < byteWidth; x++) {
              var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
              var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
              var val = pxData[pxPos + x] - (left + up >> 1);
              sum += Math.abs(val);
            }
            return sum;
          }
          function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
            for (var x = 0; x < byteWidth; x++) {
              var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
              var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
              var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
              var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
              rawData[rawPos + x] = val;
            }
          }
          function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
            var sum = 0;
            for (var x = 0; x < byteWidth; x++) {
              var left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
              var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
              var upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
              var val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
              sum += Math.abs(val);
            }
            return sum;
          }
          var filters = {
            0: filterNone,
            1: filterSub,
            2: filterUp,
            3: filterAvg,
            4: filterPaeth
          };
          var filterSums = {
            0: filterSumNone,
            1: filterSumSub,
            2: filterSumUp,
            3: filterSumAvg,
            4: filterSumPaeth
          };
          module3.exports = function(pxData, width, height, options, bpp) {
            var filterTypes;
            if (!("filterType" in options) || options.filterType === -1) {
              filterTypes = [0, 1, 2, 3, 4];
            } else if (typeof options.filterType === "number") {
              filterTypes = [options.filterType];
            } else {
              throw new Error("unrecognised filter types");
            }
            if (options.bitDepth === 16)
              bpp *= 2;
            var byteWidth = width * bpp;
            var rawPos = 0;
            var pxPos = 0;
            var rawData = new Buffer((byteWidth + 1) * height);
            var sel = filterTypes[0];
            for (var y = 0; y < height; y++) {
              if (filterTypes.length > 1) {
                var min = Infinity;
                for (var i = 0; i < filterTypes.length; i++) {
                  var sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
                  if (sum < min) {
                    sel = filterTypes[i];
                    min = sum;
                  }
                }
              }
              rawData[rawPos] = sel;
              rawPos++;
              filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
              rawPos += byteWidth;
              pxPos += byteWidth;
            }
            return rawData;
          };
        }).call(this, require2("buffer").Buffer);
      }, { "./paeth-predictor": 124, "buffer": 48 }], 116: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var util = require2("util");
          var ChunkStream = require2("./chunkstream");
          var Filter = require2("./filter-parse");
          var FilterAsync = module3.exports = function(bitmapInfo) {
            ChunkStream.call(this);
            var buffers = [];
            var that = this;
            this._filter = new Filter(bitmapInfo, {
              read: this.read.bind(this),
              write: function(buffer) {
                buffers.push(buffer);
              },
              complete: function() {
                that.emit("complete", Buffer.concat(buffers));
              }
            });
            this._filter.start();
          };
          util.inherits(FilterAsync, ChunkStream);
        }).call(this, require2("buffer").Buffer);
      }, { "./chunkstream": 112, "./filter-parse": 118, "buffer": 48, "util": 186 }], 117: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var SyncReader = require2("./sync-reader");
          var Filter = require2("./filter-parse");
          exports3.process = function(inBuffer, bitmapInfo) {
            var outBuffers = [];
            var reader = new SyncReader(inBuffer);
            var filter = new Filter(bitmapInfo, {
              read: reader.read.bind(reader),
              write: function(bufferPart) {
                outBuffers.push(bufferPart);
              },
              complete: function() {
              }
            });
            filter.start();
            reader.process();
            return Buffer.concat(outBuffers);
          };
        }).call(this, require2("buffer").Buffer);
      }, { "./filter-parse": 118, "./sync-reader": 131, "buffer": 48 }], 118: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var interlaceUtils = require2("./interlace");
          var paethPredictor = require2("./paeth-predictor");
          function getByteWidth(width, bpp, depth) {
            var byteWidth = width * bpp;
            if (depth !== 8) {
              byteWidth = Math.ceil(byteWidth / (8 / depth));
            }
            return byteWidth;
          }
          var Filter = module3.exports = function(bitmapInfo, dependencies) {
            var width = bitmapInfo.width;
            var height = bitmapInfo.height;
            var interlace = bitmapInfo.interlace;
            var bpp = bitmapInfo.bpp;
            var depth = bitmapInfo.depth;
            this.read = dependencies.read;
            this.write = dependencies.write;
            this.complete = dependencies.complete;
            this._imageIndex = 0;
            this._images = [];
            if (interlace) {
              var passes = interlaceUtils.getImagePasses(width, height);
              for (var i = 0; i < passes.length; i++) {
                this._images.push({
                  byteWidth: getByteWidth(passes[i].width, bpp, depth),
                  height: passes[i].height,
                  lineIndex: 0
                });
              }
            } else {
              this._images.push({
                byteWidth: getByteWidth(width, bpp, depth),
                height,
                lineIndex: 0
              });
            }
            if (depth === 8) {
              this._xComparison = bpp;
            } else if (depth === 16) {
              this._xComparison = bpp * 2;
            } else {
              this._xComparison = 1;
            }
          };
          Filter.prototype.start = function() {
            this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
          };
          Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
            var xComparison = this._xComparison;
            var xBiggerThan = xComparison - 1;
            for (var x = 0; x < byteWidth; x++) {
              var rawByte = rawData[1 + x];
              var f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
              unfilteredLine[x] = rawByte + f1Left;
            }
          };
          Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
            var lastLine = this._lastLine;
            for (var x = 0; x < byteWidth; x++) {
              var rawByte = rawData[1 + x];
              var f2Up = lastLine ? lastLine[x] : 0;
              unfilteredLine[x] = rawByte + f2Up;
            }
          };
          Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
            var xComparison = this._xComparison;
            var xBiggerThan = xComparison - 1;
            var lastLine = this._lastLine;
            for (var x = 0; x < byteWidth; x++) {
              var rawByte = rawData[1 + x];
              var f3Up = lastLine ? lastLine[x] : 0;
              var f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
              var f3Add = Math.floor((f3Left + f3Up) / 2);
              unfilteredLine[x] = rawByte + f3Add;
            }
          };
          Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
            var xComparison = this._xComparison;
            var xBiggerThan = xComparison - 1;
            var lastLine = this._lastLine;
            for (var x = 0; x < byteWidth; x++) {
              var rawByte = rawData[1 + x];
              var f4Up = lastLine ? lastLine[x] : 0;
              var f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
              var f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
              var f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
              unfilteredLine[x] = rawByte + f4Add;
            }
          };
          Filter.prototype._reverseFilterLine = function(rawData) {
            var filter = rawData[0];
            var unfilteredLine;
            var currentImage = this._images[this._imageIndex];
            var byteWidth = currentImage.byteWidth;
            if (filter === 0) {
              unfilteredLine = rawData.slice(1, byteWidth + 1);
            } else {
              unfilteredLine = new Buffer(byteWidth);
              switch (filter) {
                case 1:
                  this._unFilterType1(rawData, unfilteredLine, byteWidth);
                  break;
                case 2:
                  this._unFilterType2(rawData, unfilteredLine, byteWidth);
                  break;
                case 3:
                  this._unFilterType3(rawData, unfilteredLine, byteWidth);
                  break;
                case 4:
                  this._unFilterType4(rawData, unfilteredLine, byteWidth);
                  break;
                default:
                  throw new Error("Unrecognised filter type - " + filter);
              }
            }
            this.write(unfilteredLine);
            currentImage.lineIndex++;
            if (currentImage.lineIndex >= currentImage.height) {
              this._lastLine = null;
              this._imageIndex++;
              currentImage = this._images[this._imageIndex];
            } else {
              this._lastLine = unfilteredLine;
            }
            if (currentImage) {
              this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
            } else {
              this._lastLine = null;
              this.complete();
            }
          };
        }).call(this, require2("buffer").Buffer);
      }, { "./interlace": 120, "./paeth-predictor": 124, "buffer": 48 }], 119: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          function dePalette(indata, outdata, width, height, palette) {
            var pxPos = 0;
            for (var y = 0; y < height; y++) {
              for (var x = 0; x < width; x++) {
                var color = palette[indata[pxPos]];
                if (!color) {
                  throw new Error("index " + indata[pxPos] + " not in palette");
                }
                for (var i = 0; i < 4; i++) {
                  outdata[pxPos + i] = color[i];
                }
                pxPos += 4;
              }
            }
          }
          function replaceTransparentColor(indata, outdata, width, height, transColor) {
            var pxPos = 0;
            for (var y = 0; y < height; y++) {
              for (var x = 0; x < width; x++) {
                var makeTrans = false;
                if (transColor.length === 1) {
                  if (transColor[0] === indata[pxPos]) {
                    makeTrans = true;
                  }
                } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
                  makeTrans = true;
                }
                if (makeTrans) {
                  for (var i = 0; i < 4; i++) {
                    outdata[pxPos + i] = 0;
                  }
                }
                pxPos += 4;
              }
            }
          }
          function scaleDepth(indata, outdata, width, height, depth) {
            var maxOutSample = 255;
            var maxInSample = Math.pow(2, depth) - 1;
            var pxPos = 0;
            for (var y = 0; y < height; y++) {
              for (var x = 0; x < width; x++) {
                for (var i = 0; i < 4; i++) {
                  outdata[pxPos + i] = Math.floor(indata[pxPos + i] * maxOutSample / maxInSample + 0.5);
                }
                pxPos += 4;
              }
            }
          }
          module3.exports = function(indata, imageData) {
            var depth = imageData.depth;
            var width = imageData.width;
            var height = imageData.height;
            var colorType = imageData.colorType;
            var transColor = imageData.transColor;
            var palette = imageData.palette;
            var outdata = indata;
            if (colorType === 3) {
              dePalette(indata, outdata, width, height, palette);
            } else {
              if (transColor) {
                replaceTransparentColor(indata, outdata, width, height, transColor);
              }
              if (depth !== 8) {
                if (depth === 16) {
                  outdata = new Buffer(width * height * 4);
                }
                scaleDepth(indata, outdata, width, height, depth);
              }
            }
            return outdata;
          };
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 48 }], 120: [function(require2, module3, exports3) {
        "use strict";
        var imagePasses = [
          {
            // pass 1 - 1px
            x: [0],
            y: [0]
          },
          {
            // pass 2 - 1px
            x: [4],
            y: [0]
          },
          {
            // pass 3 - 2px
            x: [0, 4],
            y: [4]
          },
          {
            // pass 4 - 4px
            x: [2, 6],
            y: [0, 4]
          },
          {
            // pass 5 - 8px
            x: [0, 2, 4, 6],
            y: [2, 6]
          },
          {
            // pass 6 - 16px
            x: [1, 3, 5, 7],
            y: [0, 2, 4, 6]
          },
          {
            // pass 7 - 32px
            x: [0, 1, 2, 3, 4, 5, 6, 7],
            y: [1, 3, 5, 7]
          }
        ];
        exports3.getImagePasses = function(width, height) {
          var images = [];
          var xLeftOver = width % 8;
          var yLeftOver = height % 8;
          var xRepeats = (width - xLeftOver) / 8;
          var yRepeats = (height - yLeftOver) / 8;
          for (var i = 0; i < imagePasses.length; i++) {
            var pass = imagePasses[i];
            var passWidth = xRepeats * pass.x.length;
            var passHeight = yRepeats * pass.y.length;
            for (var j = 0; j < pass.x.length; j++) {
              if (pass.x[j] < xLeftOver) {
                passWidth++;
              } else {
                break;
              }
            }
            for (j = 0; j < pass.y.length; j++) {
              if (pass.y[j] < yLeftOver) {
                passHeight++;
              } else {
                break;
              }
            }
            if (passWidth > 0 && passHeight > 0) {
              images.push({ width: passWidth, height: passHeight, index: i });
            }
          }
          return images;
        };
        exports3.getInterlaceIterator = function(width) {
          return function(x, y, pass) {
            var outerXLeftOver = x % imagePasses[pass].x.length;
            var outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
            var outerYLeftOver = y % imagePasses[pass].y.length;
            var outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
            return outerX * 4 + outerY * width * 4;
          };
        };
      }, {}], 121: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var util = require2("util");
          var Stream = require2("stream");
          var constants = require2("./constants");
          var Packer = require2("./packer");
          var PackerAsync = module3.exports = function(opt) {
            Stream.call(this);
            var options = opt || {};
            this._packer = new Packer(options);
            this._deflate = this._packer.createDeflate();
            this.readable = true;
          };
          util.inherits(PackerAsync, Stream);
          PackerAsync.prototype.pack = function(data, width, height, gamma) {
            this.emit("data", new Buffer(constants.PNG_SIGNATURE));
            this.emit("data", this._packer.packIHDR(width, height));
            if (gamma) {
              this.emit("data", this._packer.packGAMA(gamma));
            }
            var filteredData = this._packer.filterData(data, width, height);
            this._deflate.on("error", this.emit.bind(this, "error"));
            this._deflate.on("data", (function(compressedData) {
              this.emit("data", this._packer.packIDAT(compressedData));
            }).bind(this));
            this._deflate.on("end", (function() {
              this.emit("data", this._packer.packIEND());
              this.emit("end");
            }).bind(this));
            this._deflate.end(filteredData);
          };
        }).call(this, require2("buffer").Buffer);
      }, { "./constants": 113, "./packer": 123, "buffer": 48, "stream": 155, "util": 186 }], 122: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var hasSyncZlib = true;
          var zlib = require2("zlib");
          if (!zlib.deflateSync) {
            hasSyncZlib = false;
          }
          var constants = require2("./constants");
          var Packer = require2("./packer");
          module3.exports = function(metaData, opt) {
            if (!hasSyncZlib) {
              throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
            }
            var options = opt || {};
            var packer = new Packer(options);
            var chunks = [];
            chunks.push(new Buffer(constants.PNG_SIGNATURE));
            chunks.push(packer.packIHDR(metaData.width, metaData.height));
            if (metaData.gamma) {
              chunks.push(packer.packGAMA(metaData.gamma));
            }
            var filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);
            var compressedData = zlib.deflateSync(filteredData, packer.getDeflateOptions());
            filteredData = null;
            if (!compressedData || !compressedData.length) {
              throw new Error("bad png - invalid compressed data response");
            }
            chunks.push(packer.packIDAT(compressedData));
            chunks.push(packer.packIEND());
            return Buffer.concat(chunks);
          };
        }).call(this, require2("buffer").Buffer);
      }, { "./constants": 113, "./packer": 123, "buffer": 48, "zlib": 35 }], 123: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var constants = require2("./constants");
          var CrcStream = require2("./crc");
          var bitPacker = require2("./bitpacker");
          var filter = require2("./filter-pack");
          var zlib = require2("zlib");
          var Packer = module3.exports = function(options) {
            this._options = options;
            options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
            options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
            options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
            options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
            options.deflateFactory = options.deflateFactory || zlib.createDeflate;
            options.bitDepth = options.bitDepth || 8;
            options.colorType = typeof options.colorType === "number" ? options.colorType : constants.COLORTYPE_COLOR_ALPHA;
            options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants.COLORTYPE_COLOR_ALPHA;
            if ([
              constants.COLORTYPE_GRAYSCALE,
              constants.COLORTYPE_COLOR,
              constants.COLORTYPE_COLOR_ALPHA,
              constants.COLORTYPE_ALPHA
            ].indexOf(options.colorType) === -1) {
              throw new Error("option color type:" + options.colorType + " is not supported at present");
            }
            if ([
              constants.COLORTYPE_GRAYSCALE,
              constants.COLORTYPE_COLOR,
              constants.COLORTYPE_COLOR_ALPHA,
              constants.COLORTYPE_ALPHA
            ].indexOf(options.inputColorType) === -1) {
              throw new Error("option input color type:" + options.inputColorType + " is not supported at present");
            }
            if (options.bitDepth !== 8 && options.bitDepth !== 16) {
              throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
            }
          };
          Packer.prototype.getDeflateOptions = function() {
            return {
              chunkSize: this._options.deflateChunkSize,
              level: this._options.deflateLevel,
              strategy: this._options.deflateStrategy
            };
          };
          Packer.prototype.createDeflate = function() {
            return this._options.deflateFactory(this.getDeflateOptions());
          };
          Packer.prototype.filterData = function(data, width, height) {
            var packedData = bitPacker(data, width, height, this._options);
            var bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
            var filteredData = filter(packedData, width, height, this._options, bpp);
            return filteredData;
          };
          Packer.prototype._packChunk = function(type, data) {
            var len = data ? data.length : 0;
            var buf = new Buffer(len + 12);
            buf.writeUInt32BE(len, 0);
            buf.writeUInt32BE(type, 4);
            if (data) {
              data.copy(buf, 8);
            }
            buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
            return buf;
          };
          Packer.prototype.packGAMA = function(gamma) {
            var buf = new Buffer(4);
            buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
            return this._packChunk(constants.TYPE_gAMA, buf);
          };
          Packer.prototype.packIHDR = function(width, height) {
            var buf = new Buffer(13);
            buf.writeUInt32BE(width, 0);
            buf.writeUInt32BE(height, 4);
            buf[8] = this._options.bitDepth;
            buf[9] = this._options.colorType;
            buf[10] = 0;
            buf[11] = 0;
            buf[12] = 0;
            return this._packChunk(constants.TYPE_IHDR, buf);
          };
          Packer.prototype.packIDAT = function(data) {
            return this._packChunk(constants.TYPE_IDAT, data);
          };
          Packer.prototype.packIEND = function() {
            return this._packChunk(constants.TYPE_IEND, null);
          };
        }).call(this, require2("buffer").Buffer);
      }, { "./bitpacker": 111, "./constants": 113, "./crc": 114, "./filter-pack": 115, "buffer": 48, "zlib": 35 }], 124: [function(require2, module3, exports3) {
        "use strict";
        module3.exports = function paethPredictor(left, above, upLeft) {
          var paeth = left + above - upLeft;
          var pLeft = Math.abs(paeth - left);
          var pAbove = Math.abs(paeth - above);
          var pUpLeft = Math.abs(paeth - upLeft);
          if (pLeft <= pAbove && pLeft <= pUpLeft) {
            return left;
          }
          if (pAbove <= pUpLeft) {
            return above;
          }
          return upLeft;
        };
      }, {}], 125: [function(require2, module3, exports3) {
        "use strict";
        var util = require2("util");
        var zlib = require2("zlib");
        var ChunkStream = require2("./chunkstream");
        var FilterAsync = require2("./filter-parse-async");
        var Parser = require2("./parser");
        var bitmapper = require2("./bitmapper");
        var formatNormaliser = require2("./format-normaliser");
        var ParserAsync = module3.exports = function(options) {
          ChunkStream.call(this);
          this._parser = new Parser(options, {
            read: this.read.bind(this),
            error: this._handleError.bind(this),
            metadata: this._handleMetaData.bind(this),
            gamma: this.emit.bind(this, "gamma"),
            palette: this._handlePalette.bind(this),
            transColor: this._handleTransColor.bind(this),
            finished: this._finished.bind(this),
            inflateData: this._inflateData.bind(this)
          });
          this._options = options;
          this.writable = true;
          this._parser.start();
        };
        util.inherits(ParserAsync, ChunkStream);
        ParserAsync.prototype._handleError = function(err) {
          this.emit("error", err);
          this.writable = false;
          this.destroy();
          if (this._inflate && this._inflate.destroy) {
            this._inflate.destroy();
          }
          if (this._filter) {
            this._filter.destroy();
            this._filter.on("error", function() {
            });
          }
          this.errord = true;
        };
        ParserAsync.prototype._inflateData = function(data) {
          if (!this._inflate) {
            if (this._bitmapInfo.interlace) {
              this._inflate = zlib.createInflate();
              this._inflate.on("error", this.emit.bind(this, "error"));
              this._filter.on("complete", this._complete.bind(this));
              this._inflate.pipe(this._filter);
            } else {
              var rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
              var imageSize = rowSize * this._bitmapInfo.height;
              var chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);
              this._inflate = zlib.createInflate({ chunkSize });
              var leftToInflate = imageSize;
              var emitError = this.emit.bind(this, "error");
              this._inflate.on("error", function(err) {
                if (!leftToInflate) {
                  return;
                }
                emitError(err);
              });
              this._filter.on("complete", this._complete.bind(this));
              var filterWrite = this._filter.write.bind(this._filter);
              this._inflate.on("data", function(chunk) {
                if (!leftToInflate) {
                  return;
                }
                if (chunk.length > leftToInflate) {
                  chunk = chunk.slice(0, leftToInflate);
                }
                leftToInflate -= chunk.length;
                filterWrite(chunk);
              });
              this._inflate.on("end", this._filter.end.bind(this._filter));
            }
          }
          this._inflate.write(data);
        };
        ParserAsync.prototype._handleMetaData = function(metaData) {
          this.emit("metadata", metaData);
          this._bitmapInfo = Object.create(metaData);
          this._filter = new FilterAsync(this._bitmapInfo);
        };
        ParserAsync.prototype._handleTransColor = function(transColor) {
          this._bitmapInfo.transColor = transColor;
        };
        ParserAsync.prototype._handlePalette = function(palette) {
          this._bitmapInfo.palette = palette;
        };
        ParserAsync.prototype._finished = function() {
          if (this.errord) {
            return;
          }
          if (!this._inflate) {
            this.emit("error", "No Inflate block");
          } else {
            this._inflate.end();
          }
          this.destroySoon();
        };
        ParserAsync.prototype._complete = function(filteredData) {
          if (this.errord) {
            return;
          }
          try {
            var bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
            var normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
            bitmapData = null;
          } catch (ex) {
            this._handleError(ex);
            return;
          }
          this.emit("parsed", normalisedBitmapData);
        };
      }, { "./bitmapper": 110, "./chunkstream": 112, "./filter-parse-async": 116, "./format-normaliser": 119, "./parser": 127, "util": 186, "zlib": 35 }], 126: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var hasSyncZlib = true;
          var zlib = require2("zlib");
          var inflateSync = require2("./sync-inflate");
          if (!zlib.deflateSync) {
            hasSyncZlib = false;
          }
          var SyncReader = require2("./sync-reader");
          var FilterSync = require2("./filter-parse-sync");
          var Parser = require2("./parser");
          var bitmapper = require2("./bitmapper");
          var formatNormaliser = require2("./format-normaliser");
          module3.exports = function(buffer, options) {
            if (!hasSyncZlib) {
              throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
            }
            var err;
            function handleError(_err_) {
              err = _err_;
            }
            var metaData;
            function handleMetaData(_metaData_) {
              metaData = _metaData_;
            }
            function handleTransColor(transColor) {
              metaData.transColor = transColor;
            }
            function handlePalette(palette) {
              metaData.palette = palette;
            }
            var gamma;
            function handleGamma(_gamma_) {
              gamma = _gamma_;
            }
            var inflateDataList = [];
            function handleInflateData(inflatedData2) {
              inflateDataList.push(inflatedData2);
            }
            var reader = new SyncReader(buffer);
            var parser = new Parser(options, {
              read: reader.read.bind(reader),
              error: handleError,
              metadata: handleMetaData,
              gamma: handleGamma,
              palette: handlePalette,
              transColor: handleTransColor,
              inflateData: handleInflateData
            });
            parser.start();
            reader.process();
            if (err) {
              throw err;
            }
            var inflateData = Buffer.concat(inflateDataList);
            inflateDataList.length = 0;
            var inflatedData;
            if (metaData.interlace) {
              inflatedData = zlib.inflateSync(inflateData);
            } else {
              var rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
              var imageSize = rowSize * metaData.height;
              inflatedData = inflateSync(inflateData, { chunkSize: imageSize, maxLength: imageSize });
            }
            inflateData = null;
            if (!inflatedData || !inflatedData.length) {
              throw new Error("bad png - invalid inflate data response");
            }
            var unfilteredData = FilterSync.process(inflatedData, metaData);
            inflateData = null;
            var bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
            unfilteredData = null;
            var normalisedBitmapData = formatNormaliser(bitmapData, metaData);
            metaData.data = normalisedBitmapData;
            metaData.gamma = gamma || 0;
            return metaData;
          };
        }).call(this, require2("buffer").Buffer);
      }, { "./bitmapper": 110, "./filter-parse-sync": 117, "./format-normaliser": 119, "./parser": 127, "./sync-inflate": 130, "./sync-reader": 131, "buffer": 48, "zlib": 35 }], 127: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var constants = require2("./constants");
          var CrcCalculator = require2("./crc");
          var Parser = module3.exports = function(options, dependencies) {
            this._options = options;
            options.checkCRC = options.checkCRC !== false;
            this._hasIHDR = false;
            this._hasIEND = false;
            this._palette = [];
            this._colorType = 0;
            this._chunks = {};
            this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
            this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
            this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
            this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
            this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
            this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);
            this.read = dependencies.read;
            this.error = dependencies.error;
            this.metadata = dependencies.metadata;
            this.gamma = dependencies.gamma;
            this.transColor = dependencies.transColor;
            this.palette = dependencies.palette;
            this.parsed = dependencies.parsed;
            this.inflateData = dependencies.inflateData;
            this.finished = dependencies.finished;
          };
          Parser.prototype.start = function() {
            this.read(
              constants.PNG_SIGNATURE.length,
              this._parseSignature.bind(this)
            );
          };
          Parser.prototype._parseSignature = function(data) {
            var signature = constants.PNG_SIGNATURE;
            for (var i = 0; i < signature.length; i++) {
              if (data[i] !== signature[i]) {
                this.error(new Error("Invalid file signature"));
                return;
              }
            }
            this.read(8, this._parseChunkBegin.bind(this));
          };
          Parser.prototype._parseChunkBegin = function(data) {
            var length = data.readUInt32BE(0);
            var type = data.readUInt32BE(4);
            var name = "";
            for (var i = 4; i < 8; i++) {
              name += String.fromCharCode(data[i]);
            }
            var ancillary = Boolean(data[4] & 32);
            if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
              this.error(new Error("Expected IHDR on beggining"));
              return;
            }
            this._crc = new CrcCalculator();
            this._crc.write(new Buffer(name));
            if (this._chunks[type]) {
              return this._chunks[type](length);
            }
            if (!ancillary) {
              this.error(new Error("Unsupported critical chunk type " + name));
              return;
            }
            this.read(length + 4, this._skipChunk.bind(this));
          };
          Parser.prototype._skipChunk = function() {
            this.read(8, this._parseChunkBegin.bind(this));
          };
          Parser.prototype._handleChunkEnd = function() {
            this.read(4, this._parseChunkEnd.bind(this));
          };
          Parser.prototype._parseChunkEnd = function(data) {
            var fileCrc = data.readInt32BE(0);
            var calcCrc = this._crc.crc32();
            if (this._options.checkCRC && calcCrc !== fileCrc) {
              this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
              return;
            }
            if (!this._hasIEND) {
              this.read(8, this._parseChunkBegin.bind(this));
            }
          };
          Parser.prototype._handleIHDR = function(length) {
            this.read(length, this._parseIHDR.bind(this));
          };
          Parser.prototype._parseIHDR = function(data) {
            this._crc.write(data);
            var width = data.readUInt32BE(0);
            var height = data.readUInt32BE(4);
            var depth = data[8];
            var colorType = data[9];
            var compr = data[10];
            var filter = data[11];
            var interlace = data[12];
            if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
              this.error(new Error("Unsupported bit depth " + depth));
              return;
            }
            if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
              this.error(new Error("Unsupported color type"));
              return;
            }
            if (compr !== 0) {
              this.error(new Error("Unsupported compression method"));
              return;
            }
            if (filter !== 0) {
              this.error(new Error("Unsupported filter method"));
              return;
            }
            if (interlace !== 0 && interlace !== 1) {
              this.error(new Error("Unsupported interlace method"));
              return;
            }
            this._colorType = colorType;
            var bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];
            this._hasIHDR = true;
            this.metadata({
              width,
              height,
              depth,
              interlace: Boolean(interlace),
              palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
              color: Boolean(colorType & constants.COLORTYPE_COLOR),
              alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
              bpp,
              colorType
            });
            this._handleChunkEnd();
          };
          Parser.prototype._handlePLTE = function(length) {
            this.read(length, this._parsePLTE.bind(this));
          };
          Parser.prototype._parsePLTE = function(data) {
            this._crc.write(data);
            var entries = Math.floor(data.length / 3);
            for (var i = 0; i < entries; i++) {
              this._palette.push([
                data[i * 3],
                data[i * 3 + 1],
                data[i * 3 + 2],
                255
              ]);
            }
            this.palette(this._palette);
            this._handleChunkEnd();
          };
          Parser.prototype._handleTRNS = function(length) {
            this.read(length, this._parseTRNS.bind(this));
          };
          Parser.prototype._parseTRNS = function(data) {
            this._crc.write(data);
            if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
              if (this._palette.length === 0) {
                this.error(new Error("Transparency chunk must be after palette"));
                return;
              }
              if (data.length > this._palette.length) {
                this.error(new Error("More transparent colors than palette size"));
                return;
              }
              for (var i = 0; i < data.length; i++) {
                this._palette[i][3] = data[i];
              }
              this.palette(this._palette);
            }
            if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
              this.transColor([data.readUInt16BE(0)]);
            }
            if (this._colorType === constants.COLORTYPE_COLOR) {
              this.transColor([data.readUInt16BE(0), data.readUInt16BE(2), data.readUInt16BE(4)]);
            }
            this._handleChunkEnd();
          };
          Parser.prototype._handleGAMA = function(length) {
            this.read(length, this._parseGAMA.bind(this));
          };
          Parser.prototype._parseGAMA = function(data) {
            this._crc.write(data);
            this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);
            this._handleChunkEnd();
          };
          Parser.prototype._handleIDAT = function(length) {
            this.read(-length, this._parseIDAT.bind(this, length));
          };
          Parser.prototype._parseIDAT = function(length, data) {
            this._crc.write(data);
            if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
              throw new Error("Expected palette not found");
            }
            this.inflateData(data);
            var leftOverLength = length - data.length;
            if (leftOverLength > 0) {
              this._handleIDAT(leftOverLength);
            } else {
              this._handleChunkEnd();
            }
          };
          Parser.prototype._handleIEND = function(length) {
            this.read(length, this._parseIEND.bind(this));
          };
          Parser.prototype._parseIEND = function(data) {
            this._crc.write(data);
            this._hasIEND = true;
            this._handleChunkEnd();
            if (this.finished) {
              this.finished();
            }
          };
        }).call(this, require2("buffer").Buffer);
      }, { "./constants": 113, "./crc": 114, "buffer": 48 }], 128: [function(require2, module3, exports3) {
        "use strict";
        var parse = require2("./parser-sync");
        var pack = require2("./packer-sync");
        exports3.read = function(buffer, options) {
          return parse(buffer, options || {});
        };
        exports3.write = function(png, options) {
          return pack(png, options);
        };
      }, { "./packer-sync": 122, "./parser-sync": 126 }], 129: [function(require2, module3, exports3) {
        (function(process, Buffer) {
          "use strict";
          var util = require2("util");
          var Stream = require2("stream");
          var Parser = require2("./parser-async");
          var Packer = require2("./packer-async");
          var PNGSync = require2("./png-sync");
          var PNG = exports3.PNG = function(options) {
            Stream.call(this);
            options = options || {};
            this.width = options.width | 0;
            this.height = options.height | 0;
            this.data = this.width > 0 && this.height > 0 ? new Buffer(4 * this.width * this.height) : null;
            if (options.fill && this.data) {
              this.data.fill(0);
            }
            this.gamma = 0;
            this.readable = this.writable = true;
            this._parser = new Parser(options);
            this._parser.on("error", this.emit.bind(this, "error"));
            this._parser.on("close", this._handleClose.bind(this));
            this._parser.on("metadata", this._metadata.bind(this));
            this._parser.on("gamma", this._gamma.bind(this));
            this._parser.on("parsed", (function(data) {
              this.data = data;
              this.emit("parsed", data);
            }).bind(this));
            this._packer = new Packer(options);
            this._packer.on("data", this.emit.bind(this, "data"));
            this._packer.on("end", this.emit.bind(this, "end"));
            this._parser.on("close", this._handleClose.bind(this));
            this._packer.on("error", this.emit.bind(this, "error"));
          };
          util.inherits(PNG, Stream);
          PNG.sync = PNGSync;
          PNG.prototype.pack = function() {
            if (!this.data || !this.data.length) {
              this.emit("error", "No data provided");
              return this;
            }
            process.nextTick((function() {
              this._packer.pack(this.data, this.width, this.height, this.gamma);
            }).bind(this));
            return this;
          };
          PNG.prototype.parse = function(data, callback) {
            if (callback) {
              var onParsed, onError;
              onParsed = (function(parsedData) {
                this.removeListener("error", onError);
                this.data = parsedData;
                callback(null, this);
              }).bind(this);
              onError = (function(err) {
                this.removeListener("parsed", onParsed);
                callback(err, null);
              }).bind(this);
              this.once("parsed", onParsed);
              this.once("error", onError);
            }
            this.end(data);
            return this;
          };
          PNG.prototype.write = function(data) {
            this._parser.write(data);
            return true;
          };
          PNG.prototype.end = function(data) {
            this._parser.end(data);
          };
          PNG.prototype._metadata = function(metadata) {
            this.width = metadata.width;
            this.height = metadata.height;
            this.emit("metadata", metadata);
          };
          PNG.prototype._gamma = function(gamma) {
            this.gamma = gamma;
          };
          PNG.prototype._handleClose = function() {
            if (!this._parser.writable && !this._packer.readable) {
              this.emit("close");
            }
          };
          PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
            srcX |= 0;
            srcY |= 0;
            width |= 0;
            height |= 0;
            deltaX |= 0;
            deltaY |= 0;
            if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
              throw new Error("bitblt reading outside image");
            }
            if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
              throw new Error("bitblt writing outside image");
            }
            for (var y = 0; y < height; y++) {
              src.data.copy(
                dst.data,
                (deltaY + y) * dst.width + deltaX << 2,
                (srcY + y) * src.width + srcX << 2,
                (srcY + y) * src.width + srcX + width << 2
              );
            }
          };
          PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
            PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
            return this;
          };
          PNG.adjustGamma = function(src) {
            if (src.gamma) {
              for (var y = 0; y < src.height; y++) {
                for (var x = 0; x < src.width; x++) {
                  var idx = src.width * y + x << 2;
                  for (var i = 0; i < 3; i++) {
                    var sample = src.data[idx + i] / 255;
                    sample = Math.pow(sample, 1 / 2.2 / src.gamma);
                    src.data[idx + i] = Math.round(sample * 255);
                  }
                }
              }
              src.gamma = 0;
            }
          };
          PNG.prototype.adjustGamma = function() {
            PNG.adjustGamma(this);
          };
        }).call(this, require2("_process"), require2("buffer").Buffer);
      }, { "./packer-async": 121, "./parser-async": 125, "./png-sync": 128, "_process": 133, "buffer": 48, "stream": 155, "util": 186 }], 130: [function(require2, module3, exports3) {
        (function(process, Buffer) {
          "use strict";
          var assert = require2("assert").ok;
          var zlib = require2("zlib");
          var util = require2("util");
          var kMaxLength = require2("buffer").kMaxLength;
          function Inflate(opts) {
            if (!(this instanceof Inflate)) {
              return new Inflate(opts);
            }
            if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {
              opts.chunkSize = zlib.Z_MIN_CHUNK;
            }
            zlib.Inflate.call(this, opts);
            this._offset = this._offset === void 0 ? this._outOffset : this._offset;
            this._buffer = this._buffer || this._outBuffer;
            if (opts && opts.maxLength != null) {
              this._maxLength = opts.maxLength;
            }
          }
          function createInflate(opts) {
            return new Inflate(opts);
          }
          function _close(engine, callback) {
            if (callback) {
              process.nextTick(callback);
            }
            if (!engine._handle) {
              return;
            }
            engine._handle.close();
            engine._handle = null;
          }
          Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
            if (typeof asyncCb === "function") {
              return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
            }
            var self2 = this;
            var availInBefore = chunk && chunk.length;
            var availOutBefore = this._chunkSize - this._offset;
            var leftToInflate = this._maxLength;
            var inOff = 0;
            var buffers = [];
            var nread = 0;
            var error;
            this.on("error", function(err) {
              error = err;
            });
            function handleChunk(availInAfter, availOutAfter) {
              if (self2._hadError) {
                return;
              }
              var have = availOutBefore - availOutAfter;
              assert(have >= 0, "have should not go down");
              if (have > 0) {
                var out = self2._buffer.slice(self2._offset, self2._offset + have);
                self2._offset += have;
                if (out.length > leftToInflate) {
                  out = out.slice(0, leftToInflate);
                }
                buffers.push(out);
                nread += out.length;
                leftToInflate -= out.length;
                if (leftToInflate === 0) {
                  return false;
                }
              }
              if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
                availOutBefore = self2._chunkSize;
                self2._offset = 0;
                self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
              }
              if (availOutAfter === 0) {
                inOff += availInBefore - availInAfter;
                availInBefore = availInAfter;
                return true;
              }
              return false;
            }
            assert(this._handle, "zlib binding closed");
            do {
              var res = this._handle.writeSync(
                flushFlag,
                chunk,
                // in
                inOff,
                // in_off
                availInBefore,
                // in_len
                this._buffer,
                // out
                this._offset,
                //out_off
                availOutBefore
              );
              res = res || this._writeState;
            } while (!this._hadError && handleChunk(res[0], res[1]));
            if (this._hadError) {
              throw error;
            }
            if (nread >= kMaxLength) {
              _close(this);
              throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
            }
            var buf = Buffer.concat(buffers, nread);
            _close(this);
            return buf;
          };
          util.inherits(Inflate, zlib.Inflate);
          function zlibBufferSync(engine, buffer) {
            if (typeof buffer === "string") {
              buffer = Buffer.from(buffer);
            }
            if (!(buffer instanceof Buffer)) {
              throw new TypeError("Not a string or buffer");
            }
            var flushFlag = engine._finishFlushFlag;
            if (flushFlag == null) {
              flushFlag = zlib.Z_FINISH;
            }
            return engine._processChunk(buffer, flushFlag);
          }
          function inflateSync(buffer, opts) {
            return zlibBufferSync(new Inflate(opts), buffer);
          }
          module3.exports = exports3 = inflateSync;
          exports3.Inflate = Inflate;
          exports3.createInflate = createInflate;
          exports3.inflateSync = inflateSync;
        }).call(this, require2("_process"), require2("buffer").Buffer);
      }, { "_process": 133, "assert": 25, "buffer": 48, "util": 186, "zlib": 35 }], 131: [function(require2, module3, exports3) {
        "use strict";
        var SyncReader = module3.exports = function(buffer) {
          this._buffer = buffer;
          this._reads = [];
        };
        SyncReader.prototype.read = function(length, callback) {
          this._reads.push({
            length: Math.abs(length),
            // if length < 0 then at most this length
            allowLess: length < 0,
            func: callback
          });
        };
        SyncReader.prototype.process = function() {
          while (this._reads.length > 0 && this._buffer.length) {
            var read = this._reads[0];
            if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
              this._reads.shift();
              var buf = this._buffer;
              this._buffer = buf.slice(read.length);
              read.func.call(this, buf.slice(0, read.length));
            } else {
              break;
            }
          }
          if (this._reads.length > 0) {
            return new Error("There are some read requests waitng on finished stream");
          }
          if (this._buffer.length > 0) {
            return new Error("unrecognised content at end of stream");
          }
        };
      }, {}], 132: [function(require2, module3, exports3) {
        (function(process) {
          "use strict";
          if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
            module3.exports = { nextTick };
          } else {
            module3.exports = process;
          }
          function nextTick(fn, arg1, arg2, arg3) {
            if (typeof fn !== "function") {
              throw new TypeError('"callback" argument must be a function');
            }
            var len = arguments.length;
            var args, i;
            switch (len) {
              case 0:
              case 1:
                return process.nextTick(fn);
              case 2:
                return process.nextTick(function afterTickOne() {
                  fn.call(null, arg1);
                });
              case 3:
                return process.nextTick(function afterTickTwo() {
                  fn.call(null, arg1, arg2);
                });
              case 4:
                return process.nextTick(function afterTickThree() {
                  fn.call(null, arg1, arg2, arg3);
                });
              default:
                args = new Array(len - 1);
                i = 0;
                while (i < args.length) {
                  args[i++] = arguments[i];
                }
                return process.nextTick(function afterTick() {
                  fn.apply(null, args);
                });
            }
          }
        }).call(this, require2("_process"));
      }, { "_process": 133 }], 133: [function(require2, module3, exports3) {
        var process = module3.exports = {};
        var cachedSetTimeout;
        var cachedClearTimeout;
        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            return setTimeout(fun, 0);
          }
          if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e2) {
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            return clearTimeout(marker);
          }
          if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              return cachedClearTimeout.call(null, marker);
            } catch (e2) {
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;
        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }
        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;
          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }
        process.nextTick = function(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = "";
        process.versions = {};
        function noop() {
        }
        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;
        process.listeners = function(name) {
          return [];
        };
        process.binding = function(name) {
          throw new Error("process.binding is not supported");
        };
        process.cwd = function() {
          return "/";
        };
        process.chdir = function(dir) {
          throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
          return 0;
        };
      }, {}], 134: [function(require2, module3, exports3) {
        (function(global2) {
          ;
          (function(root) {
            var freeExports = typeof exports3 == "object" && exports3 && !exports3.nodeType && exports3;
            var freeModule = typeof module3 == "object" && module3 && !module3.nodeType && module3;
            var freeGlobal = typeof global2 == "object" && global2;
            if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
              root = freeGlobal;
            }
            var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
              "overflow": "Overflow: input needs wider integers to process",
              "not-basic": "Illegal input >= 0x80 (not a basic code point)",
              "invalid-input": "Invalid input"
            }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
            function error(type) {
              throw new RangeError(errors[type]);
            }
            function map(array, fn) {
              var length = array.length;
              var result = [];
              while (length--) {
                result[length] = fn(array[length]);
              }
              return result;
            }
            function mapDomain(string, fn) {
              var parts = string.split("@");
              var result = "";
              if (parts.length > 1) {
                result = parts[0] + "@";
                string = parts[1];
              }
              string = string.replace(regexSeparators, ".");
              var labels = string.split(".");
              var encoded = map(labels, fn).join(".");
              return result + encoded;
            }
            function ucs2decode(string) {
              var output = [], counter = 0, length = string.length, value, extra;
              while (counter < length) {
                value = string.charCodeAt(counter++);
                if (value >= 55296 && value <= 56319 && counter < length) {
                  extra = string.charCodeAt(counter++);
                  if ((extra & 64512) == 56320) {
                    output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                  } else {
                    output.push(value);
                    counter--;
                  }
                } else {
                  output.push(value);
                }
              }
              return output;
            }
            function ucs2encode(array) {
              return map(array, function(value) {
                var output = "";
                if (value > 65535) {
                  value -= 65536;
                  output += stringFromCharCode(value >>> 10 & 1023 | 55296);
                  value = 56320 | value & 1023;
                }
                output += stringFromCharCode(value);
                return output;
              }).join("");
            }
            function basicToDigit(codePoint) {
              if (codePoint - 48 < 10) {
                return codePoint - 22;
              }
              if (codePoint - 65 < 26) {
                return codePoint - 65;
              }
              if (codePoint - 97 < 26) {
                return codePoint - 97;
              }
              return base;
            }
            function digitToBasic(digit, flag) {
              return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
            }
            function adapt(delta, numPoints, firstTime) {
              var k = 0;
              delta = firstTime ? floor(delta / damp) : delta >> 1;
              delta += floor(delta / numPoints);
              for (; delta > baseMinusTMin * tMax >> 1; k += base) {
                delta = floor(delta / baseMinusTMin);
              }
              return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
            }
            function decode(input) {
              var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
              basic = input.lastIndexOf(delimiter);
              if (basic < 0) {
                basic = 0;
              }
              for (j = 0; j < basic; ++j) {
                if (input.charCodeAt(j) >= 128) {
                  error("not-basic");
                }
                output.push(input.charCodeAt(j));
              }
              for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
                for (oldi = i, w = 1, k = base; ; k += base) {
                  if (index >= inputLength) {
                    error("invalid-input");
                  }
                  digit = basicToDigit(input.charCodeAt(index++));
                  if (digit >= base || digit > floor((maxInt - i) / w)) {
                    error("overflow");
                  }
                  i += digit * w;
                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (digit < t) {
                    break;
                  }
                  baseMinusT = base - t;
                  if (w > floor(maxInt / baseMinusT)) {
                    error("overflow");
                  }
                  w *= baseMinusT;
                }
                out = output.length + 1;
                bias = adapt(i - oldi, out, oldi == 0);
                if (floor(i / out) > maxInt - n) {
                  error("overflow");
                }
                n += floor(i / out);
                i %= out;
                output.splice(i++, 0, n);
              }
              return ucs2encode(output);
            }
            function encode(input) {
              var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
              input = ucs2decode(input);
              inputLength = input.length;
              n = initialN;
              delta = 0;
              bias = initialBias;
              for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < 128) {
                  output.push(stringFromCharCode(currentValue));
                }
              }
              handledCPCount = basicLength = output.length;
              if (basicLength) {
                output.push(delimiter);
              }
              while (handledCPCount < inputLength) {
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                  }
                }
                handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                  error("overflow");
                }
                delta += (m - n) * handledCPCountPlusOne;
                n = m;
                for (j = 0; j < inputLength; ++j) {
                  currentValue = input[j];
                  if (currentValue < n && ++delta > maxInt) {
                    error("overflow");
                  }
                  if (currentValue == n) {
                    for (q = delta, k = base; ; k += base) {
                      t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                      if (q < t) {
                        break;
                      }
                      qMinusT = q - t;
                      baseMinusT = base - t;
                      output.push(
                        stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                      );
                      q = floor(qMinusT / baseMinusT);
                    }
                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                  }
                }
                ++delta;
                ++n;
              }
              return output.join("");
            }
            function toUnicode(input) {
              return mapDomain(input, function(string) {
                return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
              });
            }
            function toASCII(input) {
              return mapDomain(input, function(string) {
                return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
              });
            }
            punycode = {
              /**
               * A string representing the current Punycode.js version number.
               * @memberOf punycode
               * @type String
               */
              "version": "1.4.1",
              /**
               * An object of methods to convert from JavaScript's internal character
               * representation (UCS-2) to Unicode code points, and back.
               * @see <https://mathiasbynens.be/notes/javascript-encoding>
               * @memberOf punycode
               * @type Object
               */
              "ucs2": {
                "decode": ucs2decode,
                "encode": ucs2encode
              },
              "decode": decode,
              "encode": encode,
              "toASCII": toASCII,
              "toUnicode": toUnicode
            };
            if (typeof define2 == "function" && typeof define2.amd == "object" && define2.amd) {
              define2("punycode", function() {
                return punycode;
              });
            } else if (freeExports && freeModule) {
              if (module3.exports == freeExports) {
                freeModule.exports = punycode;
              } else {
                for (key in punycode) {
                  punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                }
              }
            } else {
              root.punycode = punycode;
            }
          })(this);
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 135: [function(require2, module3, exports3) {
        "use strict";
        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        module3.exports = function(qs, sep, eq, options) {
          sep = sep || "&";
          eq = eq || "=";
          var obj = {};
          if (typeof qs !== "string" || qs.length === 0) {
            return obj;
          }
          var regexp = /\+/g;
          qs = qs.split(sep);
          var maxKeys = 1e3;
          if (options && typeof options.maxKeys === "number") {
            maxKeys = options.maxKeys;
          }
          var len = qs.length;
          if (maxKeys > 0 && len > maxKeys) {
            len = maxKeys;
          }
          for (var i = 0; i < len; ++i) {
            var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
            if (idx >= 0) {
              kstr = x.substr(0, idx);
              vstr = x.substr(idx + 1);
            } else {
              kstr = x;
              vstr = "";
            }
            k = decodeURIComponent(kstr);
            v = decodeURIComponent(vstr);
            if (!hasOwnProperty(obj, k)) {
              obj[k] = v;
            } else if (isArray(obj[k])) {
              obj[k].push(v);
            } else {
              obj[k] = [obj[k], v];
            }
          }
          return obj;
        };
        var isArray = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === "[object Array]";
        };
      }, {}], 136: [function(require2, module3, exports3) {
        "use strict";
        var stringifyPrimitive = function(v) {
          switch (typeof v) {
            case "string":
              return v;
            case "boolean":
              return v ? "true" : "false";
            case "number":
              return isFinite(v) ? v : "";
            default:
              return "";
          }
        };
        module3.exports = function(obj, sep, eq, name) {
          sep = sep || "&";
          eq = eq || "=";
          if (obj === null) {
            obj = void 0;
          }
          if (typeof obj === "object") {
            return map(objectKeys(obj), function(k) {
              var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
              if (isArray(obj[k])) {
                return map(obj[k], function(v) {
                  return ks + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep);
              } else {
                return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
              }
            }).join(sep);
          }
          if (!name)
            return "";
          return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
        };
        var isArray = Array.isArray || function(xs) {
          return Object.prototype.toString.call(xs) === "[object Array]";
        };
        function map(xs, f) {
          if (xs.map)
            return xs.map(f);
          var res = [];
          for (var i = 0; i < xs.length; i++) {
            res.push(f(xs[i], i));
          }
          return res;
        }
        var objectKeys = Object.keys || function(obj) {
          var res = [];
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              res.push(key);
          }
          return res;
        };
      }, {}], 137: [function(require2, module3, exports3) {
        "use strict";
        exports3.decode = exports3.parse = require2("./decode");
        exports3.encode = exports3.stringify = require2("./encode");
      }, { "./decode": 135, "./encode": 136 }], 138: [function(require2, module3, exports3) {
        module3.exports = require2("./lib/_stream_duplex.js");
      }, { "./lib/_stream_duplex.js": 139 }], 139: [function(require2, module3, exports3) {
        "use strict";
        var pna = require2("process-nextick-args");
        var objectKeys = Object.keys || function(obj) {
          var keys2 = [];
          for (var key in obj) {
            keys2.push(key);
          }
          return keys2;
        };
        module3.exports = Duplex;
        var util = require2("core-util-is");
        util.inherits = require2("inherits");
        var Readable = require2("./_stream_readable");
        var Writable = require2("./_stream_writable");
        util.inherits(Duplex, Readable);
        {
          var keys = objectKeys(Writable.prototype);
          for (var v = 0; v < keys.length; v++) {
            var method = keys[v];
            if (!Duplex.prototype[method])
              Duplex.prototype[method] = Writable.prototype[method];
          }
        }
        function Duplex(options) {
          if (!(this instanceof Duplex))
            return new Duplex(options);
          Readable.call(this, options);
          Writable.call(this, options);
          if (options && options.readable === false)
            this.readable = false;
          if (options && options.writable === false)
            this.writable = false;
          this.allowHalfOpen = true;
          if (options && options.allowHalfOpen === false)
            this.allowHalfOpen = false;
          this.once("end", onend);
        }
        Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
          // making it explicit this property is not enumerable
          // because otherwise some prototype manipulation in
          // userland will fail
          enumerable: false,
          get: function() {
            return this._writableState.highWaterMark;
          }
        });
        function onend() {
          if (this.allowHalfOpen || this._writableState.ended)
            return;
          pna.nextTick(onEndNT, this);
        }
        function onEndNT(self2) {
          self2.end();
        }
        Object.defineProperty(Duplex.prototype, "destroyed", {
          get: function() {
            if (this._readableState === void 0 || this._writableState === void 0) {
              return false;
            }
            return this._readableState.destroyed && this._writableState.destroyed;
          },
          set: function(value) {
            if (this._readableState === void 0 || this._writableState === void 0) {
              return;
            }
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        });
        Duplex.prototype._destroy = function(err, cb) {
          this.push(null);
          this.end();
          pna.nextTick(cb, err);
        };
      }, { "./_stream_readable": 141, "./_stream_writable": 143, "core-util-is": 51, "inherits": 75, "process-nextick-args": 132 }], 140: [function(require2, module3, exports3) {
        "use strict";
        module3.exports = PassThrough;
        var Transform = require2("./_stream_transform");
        var util = require2("core-util-is");
        util.inherits = require2("inherits");
        util.inherits(PassThrough, Transform);
        function PassThrough(options) {
          if (!(this instanceof PassThrough))
            return new PassThrough(options);
          Transform.call(this, options);
        }
        PassThrough.prototype._transform = function(chunk, encoding, cb) {
          cb(null, chunk);
        };
      }, { "./_stream_transform": 142, "core-util-is": 51, "inherits": 75 }], 141: [function(require2, module3, exports3) {
        (function(process, global2) {
          "use strict";
          var pna = require2("process-nextick-args");
          module3.exports = Readable;
          var isArray = require2("isarray");
          var Duplex;
          Readable.ReadableState = ReadableState;
          var EE = require2("events").EventEmitter;
          var EElistenerCount = function(emitter, type) {
            return emitter.listeners(type).length;
          };
          var Stream = require2("./internal/streams/stream");
          var Buffer = require2("safe-buffer").Buffer;
          var OurUint8Array = global2.Uint8Array || function() {
          };
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          var util = require2("core-util-is");
          util.inherits = require2("inherits");
          var debugUtil = require2("util");
          var debug = void 0;
          if (debugUtil && debugUtil.debuglog) {
            debug = debugUtil.debuglog("stream");
          } else {
            debug = function() {
            };
          }
          var BufferList = require2("./internal/streams/BufferList");
          var destroyImpl = require2("./internal/streams/destroy");
          var StringDecoder;
          util.inherits(Readable, Stream);
          var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
          function prependListener(emitter, event, fn) {
            if (typeof emitter.prependListener === "function")
              return emitter.prependListener(event, fn);
            if (!emitter._events || !emitter._events[event])
              emitter.on(event, fn);
            else if (isArray(emitter._events[event]))
              emitter._events[event].unshift(fn);
            else
              emitter._events[event] = [fn, emitter._events[event]];
          }
          function ReadableState(options, stream) {
            Duplex = Duplex || require2("./_stream_duplex");
            options = options || {};
            var isDuplex = stream instanceof Duplex;
            this.objectMode = !!options.objectMode;
            if (isDuplex)
              this.objectMode = this.objectMode || !!options.readableObjectMode;
            var hwm = options.highWaterMark;
            var readableHwm = options.readableHighWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
            if (hwm || hwm === 0)
              this.highWaterMark = hwm;
            else if (isDuplex && (readableHwm || readableHwm === 0))
              this.highWaterMark = readableHwm;
            else
              this.highWaterMark = defaultHwm;
            this.highWaterMark = Math.floor(this.highWaterMark);
            this.buffer = new BufferList();
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = null;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false;
            this.sync = true;
            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;
            this.resumeScheduled = false;
            this.destroyed = false;
            this.defaultEncoding = options.defaultEncoding || "utf8";
            this.awaitDrain = 0;
            this.readingMore = false;
            this.decoder = null;
            this.encoding = null;
            if (options.encoding) {
              if (!StringDecoder)
                StringDecoder = require2("string_decoder/").StringDecoder;
              this.decoder = new StringDecoder(options.encoding);
              this.encoding = options.encoding;
            }
          }
          function Readable(options) {
            Duplex = Duplex || require2("./_stream_duplex");
            if (!(this instanceof Readable))
              return new Readable(options);
            this._readableState = new ReadableState(options, this);
            this.readable = true;
            if (options) {
              if (typeof options.read === "function")
                this._read = options.read;
              if (typeof options.destroy === "function")
                this._destroy = options.destroy;
            }
            Stream.call(this);
          }
          Object.defineProperty(Readable.prototype, "destroyed", {
            get: function() {
              if (this._readableState === void 0) {
                return false;
              }
              return this._readableState.destroyed;
            },
            set: function(value) {
              if (!this._readableState) {
                return;
              }
              this._readableState.destroyed = value;
            }
          });
          Readable.prototype.destroy = destroyImpl.destroy;
          Readable.prototype._undestroy = destroyImpl.undestroy;
          Readable.prototype._destroy = function(err, cb) {
            this.push(null);
            cb(err);
          };
          Readable.prototype.push = function(chunk, encoding) {
            var state = this._readableState;
            var skipChunkCheck;
            if (!state.objectMode) {
              if (typeof chunk === "string") {
                encoding = encoding || state.defaultEncoding;
                if (encoding !== state.encoding) {
                  chunk = Buffer.from(chunk, encoding);
                  encoding = "";
                }
                skipChunkCheck = true;
              }
            } else {
              skipChunkCheck = true;
            }
            return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
          };
          Readable.prototype.unshift = function(chunk) {
            return readableAddChunk(this, chunk, null, true, false);
          };
          function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
            var state = stream._readableState;
            if (chunk === null) {
              state.reading = false;
              onEofChunk(stream, state);
            } else {
              var er;
              if (!skipChunkCheck)
                er = chunkInvalid(state, chunk);
              if (er) {
                stream.emit("error", er);
              } else if (state.objectMode || chunk && chunk.length > 0) {
                if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                  chunk = _uint8ArrayToBuffer(chunk);
                }
                if (addToFront) {
                  if (state.endEmitted)
                    stream.emit("error", new Error("stream.unshift() after end event"));
                  else
                    addChunk(stream, state, chunk, true);
                } else if (state.ended) {
                  stream.emit("error", new Error("stream.push() after EOF"));
                } else {
                  state.reading = false;
                  if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0)
                      addChunk(stream, state, chunk, false);
                    else
                      maybeReadMore(stream, state);
                  } else {
                    addChunk(stream, state, chunk, false);
                  }
                }
              } else if (!addToFront) {
                state.reading = false;
              }
            }
            return needMoreData(state);
          }
          function addChunk(stream, state, chunk, addToFront) {
            if (state.flowing && state.length === 0 && !state.sync) {
              stream.emit("data", chunk);
              stream.read(0);
            } else {
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront)
                state.buffer.unshift(chunk);
              else
                state.buffer.push(chunk);
              if (state.needReadable)
                emitReadable(stream);
            }
            maybeReadMore(stream, state);
          }
          function chunkInvalid(state, chunk) {
            var er;
            if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
              er = new TypeError("Invalid non-string/buffer chunk");
            }
            return er;
          }
          function needMoreData(state) {
            return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
          }
          Readable.prototype.isPaused = function() {
            return this._readableState.flowing === false;
          };
          Readable.prototype.setEncoding = function(enc) {
            if (!StringDecoder)
              StringDecoder = require2("string_decoder/").StringDecoder;
            this._readableState.decoder = new StringDecoder(enc);
            this._readableState.encoding = enc;
            return this;
          };
          var MAX_HWM = 8388608;
          function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) {
              n = MAX_HWM;
            } else {
              n--;
              n |= n >>> 1;
              n |= n >>> 2;
              n |= n >>> 4;
              n |= n >>> 8;
              n |= n >>> 16;
              n++;
            }
            return n;
          }
          function howMuchToRead(n, state) {
            if (n <= 0 || state.length === 0 && state.ended)
              return 0;
            if (state.objectMode)
              return 1;
            if (n !== n) {
              if (state.flowing && state.length)
                return state.buffer.head.data.length;
              else
                return state.length;
            }
            if (n > state.highWaterMark)
              state.highWaterMark = computeNewHighWaterMark(n);
            if (n <= state.length)
              return n;
            if (!state.ended) {
              state.needReadable = true;
              return 0;
            }
            return state.length;
          }
          Readable.prototype.read = function(n) {
            debug("read", n);
            n = parseInt(n, 10);
            var state = this._readableState;
            var nOrig = n;
            if (n !== 0)
              state.emittedReadable = false;
            if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
              debug("read: emitReadable", state.length, state.ended);
              if (state.length === 0 && state.ended)
                endReadable(this);
              else
                emitReadable(this);
              return null;
            }
            n = howMuchToRead(n, state);
            if (n === 0 && state.ended) {
              if (state.length === 0)
                endReadable(this);
              return null;
            }
            var doRead = state.needReadable;
            debug("need readable", doRead);
            if (state.length === 0 || state.length - n < state.highWaterMark) {
              doRead = true;
              debug("length less than watermark", doRead);
            }
            if (state.ended || state.reading) {
              doRead = false;
              debug("reading or ended", doRead);
            } else if (doRead) {
              debug("do read");
              state.reading = true;
              state.sync = true;
              if (state.length === 0)
                state.needReadable = true;
              this._read(state.highWaterMark);
              state.sync = false;
              if (!state.reading)
                n = howMuchToRead(nOrig, state);
            }
            var ret;
            if (n > 0)
              ret = fromList(n, state);
            else
              ret = null;
            if (ret === null) {
              state.needReadable = true;
              n = 0;
            } else {
              state.length -= n;
            }
            if (state.length === 0) {
              if (!state.ended)
                state.needReadable = true;
              if (nOrig !== n && state.ended)
                endReadable(this);
            }
            if (ret !== null)
              this.emit("data", ret);
            return ret;
          };
          function onEofChunk(stream, state) {
            if (state.ended)
              return;
            if (state.decoder) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length) {
                state.buffer.push(chunk);
                state.length += state.objectMode ? 1 : chunk.length;
              }
            }
            state.ended = true;
            emitReadable(stream);
          }
          function emitReadable(stream) {
            var state = stream._readableState;
            state.needReadable = false;
            if (!state.emittedReadable) {
              debug("emitReadable", state.flowing);
              state.emittedReadable = true;
              if (state.sync)
                pna.nextTick(emitReadable_, stream);
              else
                emitReadable_(stream);
            }
          }
          function emitReadable_(stream) {
            debug("emit readable");
            stream.emit("readable");
            flow(stream);
          }
          function maybeReadMore(stream, state) {
            if (!state.readingMore) {
              state.readingMore = true;
              pna.nextTick(maybeReadMore_, stream, state);
            }
          }
          function maybeReadMore_(stream, state) {
            var len = state.length;
            while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
              debug("maybeReadMore read 0");
              stream.read(0);
              if (len === state.length)
                break;
              else
                len = state.length;
            }
            state.readingMore = false;
          }
          Readable.prototype._read = function(n) {
            this.emit("error", new Error("_read() is not implemented"));
          };
          Readable.prototype.pipe = function(dest, pipeOpts) {
            var src = this;
            var state = this._readableState;
            switch (state.pipesCount) {
              case 0:
                state.pipes = dest;
                break;
              case 1:
                state.pipes = [state.pipes, dest];
                break;
              default:
                state.pipes.push(dest);
                break;
            }
            state.pipesCount += 1;
            debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
            var endFn = doEnd ? onend : unpipe;
            if (state.endEmitted)
              pna.nextTick(endFn);
            else
              src.once("end", endFn);
            dest.on("unpipe", onunpipe);
            function onunpipe(readable, unpipeInfo) {
              debug("onunpipe");
              if (readable === src) {
                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                  unpipeInfo.hasUnpiped = true;
                  cleanup();
                }
              }
            }
            function onend() {
              debug("onend");
              dest.end();
            }
            var ondrain = pipeOnDrain(src);
            dest.on("drain", ondrain);
            var cleanedUp = false;
            function cleanup() {
              debug("cleanup");
              dest.removeListener("close", onclose);
              dest.removeListener("finish", onfinish);
              dest.removeListener("drain", ondrain);
              dest.removeListener("error", onerror);
              dest.removeListener("unpipe", onunpipe);
              src.removeListener("end", onend);
              src.removeListener("end", unpipe);
              src.removeListener("data", ondata);
              cleanedUp = true;
              if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                ondrain();
            }
            var increasedAwaitDrain = false;
            src.on("data", ondata);
            function ondata(chunk) {
              debug("ondata");
              increasedAwaitDrain = false;
              var ret = dest.write(chunk);
              if (false === ret && !increasedAwaitDrain) {
                if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                  debug("false write response, pause", src._readableState.awaitDrain);
                  src._readableState.awaitDrain++;
                  increasedAwaitDrain = true;
                }
                src.pause();
              }
            }
            function onerror(er) {
              debug("onerror", er);
              unpipe();
              dest.removeListener("error", onerror);
              if (EElistenerCount(dest, "error") === 0)
                dest.emit("error", er);
            }
            prependListener(dest, "error", onerror);
            function onclose() {
              dest.removeListener("finish", onfinish);
              unpipe();
            }
            dest.once("close", onclose);
            function onfinish() {
              debug("onfinish");
              dest.removeListener("close", onclose);
              unpipe();
            }
            dest.once("finish", onfinish);
            function unpipe() {
              debug("unpipe");
              src.unpipe(dest);
            }
            dest.emit("pipe", src);
            if (!state.flowing) {
              debug("pipe resume");
              src.resume();
            }
            return dest;
          };
          function pipeOnDrain(src) {
            return function() {
              var state = src._readableState;
              debug("pipeOnDrain", state.awaitDrain);
              if (state.awaitDrain)
                state.awaitDrain--;
              if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                state.flowing = true;
                flow(src);
              }
            };
          }
          Readable.prototype.unpipe = function(dest) {
            var state = this._readableState;
            var unpipeInfo = { hasUnpiped: false };
            if (state.pipesCount === 0)
              return this;
            if (state.pipesCount === 1) {
              if (dest && dest !== state.pipes)
                return this;
              if (!dest)
                dest = state.pipes;
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              if (dest)
                dest.emit("unpipe", this, unpipeInfo);
              return this;
            }
            if (!dest) {
              var dests = state.pipes;
              var len = state.pipesCount;
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              for (var i = 0; i < len; i++) {
                dests[i].emit("unpipe", this, unpipeInfo);
              }
              return this;
            }
            var index = indexOf(state.pipes, dest);
            if (index === -1)
              return this;
            state.pipes.splice(index, 1);
            state.pipesCount -= 1;
            if (state.pipesCount === 1)
              state.pipes = state.pipes[0];
            dest.emit("unpipe", this, unpipeInfo);
            return this;
          };
          Readable.prototype.on = function(ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);
            if (ev === "data") {
              if (this._readableState.flowing !== false)
                this.resume();
            } else if (ev === "readable") {
              var state = this._readableState;
              if (!state.endEmitted && !state.readableListening) {
                state.readableListening = state.needReadable = true;
                state.emittedReadable = false;
                if (!state.reading) {
                  pna.nextTick(nReadingNextTick, this);
                } else if (state.length) {
                  emitReadable(this);
                }
              }
            }
            return res;
          };
          Readable.prototype.addListener = Readable.prototype.on;
          function nReadingNextTick(self2) {
            debug("readable nexttick read 0");
            self2.read(0);
          }
          Readable.prototype.resume = function() {
            var state = this._readableState;
            if (!state.flowing) {
              debug("resume");
              state.flowing = true;
              resume(this, state);
            }
            return this;
          };
          function resume(stream, state) {
            if (!state.resumeScheduled) {
              state.resumeScheduled = true;
              pna.nextTick(resume_, stream, state);
            }
          }
          function resume_(stream, state) {
            if (!state.reading) {
              debug("resume read 0");
              stream.read(0);
            }
            state.resumeScheduled = false;
            state.awaitDrain = 0;
            stream.emit("resume");
            flow(stream);
            if (state.flowing && !state.reading)
              stream.read(0);
          }
          Readable.prototype.pause = function() {
            debug("call pause flowing=%j", this._readableState.flowing);
            if (false !== this._readableState.flowing) {
              debug("pause");
              this._readableState.flowing = false;
              this.emit("pause");
            }
            return this;
          };
          function flow(stream) {
            var state = stream._readableState;
            debug("flow", state.flowing);
            while (state.flowing && stream.read() !== null) {
            }
          }
          Readable.prototype.wrap = function(stream) {
            var _this = this;
            var state = this._readableState;
            var paused = false;
            stream.on("end", function() {
              debug("wrapped end");
              if (state.decoder && !state.ended) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length)
                  _this.push(chunk);
              }
              _this.push(null);
            });
            stream.on("data", function(chunk) {
              debug("wrapped data");
              if (state.decoder)
                chunk = state.decoder.write(chunk);
              if (state.objectMode && (chunk === null || chunk === void 0))
                return;
              else if (!state.objectMode && (!chunk || !chunk.length))
                return;
              var ret = _this.push(chunk);
              if (!ret) {
                paused = true;
                stream.pause();
              }
            });
            for (var i in stream) {
              if (this[i] === void 0 && typeof stream[i] === "function") {
                this[i] = function(method) {
                  return function() {
                    return stream[method].apply(stream, arguments);
                  };
                }(i);
              }
            }
            for (var n = 0; n < kProxyEvents.length; n++) {
              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
            }
            this._read = function(n2) {
              debug("wrapped _read", n2);
              if (paused) {
                paused = false;
                stream.resume();
              }
            };
            return this;
          };
          Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function() {
              return this._readableState.highWaterMark;
            }
          });
          Readable._fromList = fromList;
          function fromList(n, state) {
            if (state.length === 0)
              return null;
            var ret;
            if (state.objectMode)
              ret = state.buffer.shift();
            else if (!n || n >= state.length) {
              if (state.decoder)
                ret = state.buffer.join("");
              else if (state.buffer.length === 1)
                ret = state.buffer.head.data;
              else
                ret = state.buffer.concat(state.length);
              state.buffer.clear();
            } else {
              ret = fromListPartial(n, state.buffer, state.decoder);
            }
            return ret;
          }
          function fromListPartial(n, list, hasStrings) {
            var ret;
            if (n < list.head.data.length) {
              ret = list.head.data.slice(0, n);
              list.head.data = list.head.data.slice(n);
            } else if (n === list.head.data.length) {
              ret = list.shift();
            } else {
              ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
            }
            return ret;
          }
          function copyFromBufferString(n, list) {
            var p = list.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    list.head = p.next;
                  else
                    list.head = list.tail = null;
                } else {
                  list.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            list.length -= c;
            return ret;
          }
          function copyFromBuffer(n, list) {
            var ret = Buffer.allocUnsafe(n);
            var p = list.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    list.head = p.next;
                  else
                    list.head = list.tail = null;
                } else {
                  list.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            list.length -= c;
            return ret;
          }
          function endReadable(stream) {
            var state = stream._readableState;
            if (state.length > 0)
              throw new Error('"endReadable()" called on non-empty stream');
            if (!state.endEmitted) {
              state.ended = true;
              pna.nextTick(endReadableNT, state, stream);
            }
          }
          function endReadableNT(state, stream) {
            if (!state.endEmitted && state.length === 0) {
              state.endEmitted = true;
              stream.readable = false;
              stream.emit("end");
            }
          }
          function indexOf(xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
              if (xs[i] === x)
                return i;
            }
            return -1;
          }
        }).call(this, require2("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "./_stream_duplex": 139, "./internal/streams/BufferList": 144, "./internal/streams/destroy": 145, "./internal/streams/stream": 146, "_process": 133, "core-util-is": 51, "events": 52, "inherits": 75, "isarray": 79, "process-nextick-args": 132, "safe-buffer": 147, "string_decoder/": 148, "util": 33 }], 142: [function(require2, module3, exports3) {
        "use strict";
        module3.exports = Transform;
        var Duplex = require2("./_stream_duplex");
        var util = require2("core-util-is");
        util.inherits = require2("inherits");
        util.inherits(Transform, Duplex);
        function afterTransform(er, data) {
          var ts = this._transformState;
          ts.transforming = false;
          var cb = ts.writecb;
          if (!cb) {
            return this.emit("error", new Error("write callback called multiple times"));
          }
          ts.writechunk = null;
          ts.writecb = null;
          if (data != null)
            this.push(data);
          cb(er);
          var rs = this._readableState;
          rs.reading = false;
          if (rs.needReadable || rs.length < rs.highWaterMark) {
            this._read(rs.highWaterMark);
          }
        }
        function Transform(options) {
          if (!(this instanceof Transform))
            return new Transform(options);
          Duplex.call(this, options);
          this._transformState = {
            afterTransform: afterTransform.bind(this),
            needTransform: false,
            transforming: false,
            writecb: null,
            writechunk: null,
            writeencoding: null
          };
          this._readableState.needReadable = true;
          this._readableState.sync = false;
          if (options) {
            if (typeof options.transform === "function")
              this._transform = options.transform;
            if (typeof options.flush === "function")
              this._flush = options.flush;
          }
          this.on("prefinish", prefinish);
        }
        function prefinish() {
          var _this = this;
          if (typeof this._flush === "function") {
            this._flush(function(er, data) {
              done(_this, er, data);
            });
          } else {
            done(this, null, null);
          }
        }
        Transform.prototype.push = function(chunk, encoding) {
          this._transformState.needTransform = false;
          return Duplex.prototype.push.call(this, chunk, encoding);
        };
        Transform.prototype._transform = function(chunk, encoding, cb) {
          throw new Error("_transform() is not implemented");
        };
        Transform.prototype._write = function(chunk, encoding, cb) {
          var ts = this._transformState;
          ts.writecb = cb;
          ts.writechunk = chunk;
          ts.writeencoding = encoding;
          if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
              this._read(rs.highWaterMark);
          }
        };
        Transform.prototype._read = function(n) {
          var ts = this._transformState;
          if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
          } else {
            ts.needTransform = true;
          }
        };
        Transform.prototype._destroy = function(err, cb) {
          var _this2 = this;
          Duplex.prototype._destroy.call(this, err, function(err2) {
            cb(err2);
            _this2.emit("close");
          });
        };
        function done(stream, er, data) {
          if (er)
            return stream.emit("error", er);
          if (data != null)
            stream.push(data);
          if (stream._writableState.length)
            throw new Error("Calling transform done when ws.length != 0");
          if (stream._transformState.transforming)
            throw new Error("Calling transform done when still transforming");
          return stream.push(null);
        }
      }, { "./_stream_duplex": 139, "core-util-is": 51, "inherits": 75 }], 143: [function(require2, module3, exports3) {
        (function(process, global2, setImmediate) {
          "use strict";
          var pna = require2("process-nextick-args");
          module3.exports = Writable;
          function WriteReq(chunk, encoding, cb) {
            this.chunk = chunk;
            this.encoding = encoding;
            this.callback = cb;
            this.next = null;
          }
          function CorkedRequest(state) {
            var _this = this;
            this.next = null;
            this.entry = null;
            this.finish = function() {
              onCorkedFinish(_this, state);
            };
          }
          var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
          var Duplex;
          Writable.WritableState = WritableState;
          var util = require2("core-util-is");
          util.inherits = require2("inherits");
          var internalUtil = {
            deprecate: require2("util-deprecate")
          };
          var Stream = require2("./internal/streams/stream");
          var Buffer = require2("safe-buffer").Buffer;
          var OurUint8Array = global2.Uint8Array || function() {
          };
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          var destroyImpl = require2("./internal/streams/destroy");
          util.inherits(Writable, Stream);
          function nop() {
          }
          function WritableState(options, stream) {
            Duplex = Duplex || require2("./_stream_duplex");
            options = options || {};
            var isDuplex = stream instanceof Duplex;
            this.objectMode = !!options.objectMode;
            if (isDuplex)
              this.objectMode = this.objectMode || !!options.writableObjectMode;
            var hwm = options.highWaterMark;
            var writableHwm = options.writableHighWaterMark;
            var defaultHwm = this.objectMode ? 16 : 16 * 1024;
            if (hwm || hwm === 0)
              this.highWaterMark = hwm;
            else if (isDuplex && (writableHwm || writableHwm === 0))
              this.highWaterMark = writableHwm;
            else
              this.highWaterMark = defaultHwm;
            this.highWaterMark = Math.floor(this.highWaterMark);
            this.finalCalled = false;
            this.needDrain = false;
            this.ending = false;
            this.ended = false;
            this.finished = false;
            this.destroyed = false;
            var noDecode = options.decodeStrings === false;
            this.decodeStrings = !noDecode;
            this.defaultEncoding = options.defaultEncoding || "utf8";
            this.length = 0;
            this.writing = false;
            this.corked = 0;
            this.sync = true;
            this.bufferProcessing = false;
            this.onwrite = function(er) {
              onwrite(stream, er);
            };
            this.writecb = null;
            this.writelen = 0;
            this.bufferedRequest = null;
            this.lastBufferedRequest = null;
            this.pendingcb = 0;
            this.prefinished = false;
            this.errorEmitted = false;
            this.bufferedRequestCount = 0;
            this.corkedRequestsFree = new CorkedRequest(this);
          }
          WritableState.prototype.getBuffer = function getBuffer() {
            var current = this.bufferedRequest;
            var out = [];
            while (current) {
              out.push(current);
              current = current.next;
            }
            return out;
          };
          (function() {
            try {
              Object.defineProperty(WritableState.prototype, "buffer", {
                get: internalUtil.deprecate(function() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
              });
            } catch (_) {
            }
          })();
          var realHasInstance;
          if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
            realHasInstance = Function.prototype[Symbol.hasInstance];
            Object.defineProperty(Writable, Symbol.hasInstance, {
              value: function(object) {
                if (realHasInstance.call(this, object))
                  return true;
                if (this !== Writable)
                  return false;
                return object && object._writableState instanceof WritableState;
              }
            });
          } else {
            realHasInstance = function(object) {
              return object instanceof this;
            };
          }
          function Writable(options) {
            Duplex = Duplex || require2("./_stream_duplex");
            if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
              return new Writable(options);
            }
            this._writableState = new WritableState(options, this);
            this.writable = true;
            if (options) {
              if (typeof options.write === "function")
                this._write = options.write;
              if (typeof options.writev === "function")
                this._writev = options.writev;
              if (typeof options.destroy === "function")
                this._destroy = options.destroy;
              if (typeof options.final === "function")
                this._final = options.final;
            }
            Stream.call(this);
          }
          Writable.prototype.pipe = function() {
            this.emit("error", new Error("Cannot pipe, not readable"));
          };
          function writeAfterEnd(stream, cb) {
            var er = new Error("write after end");
            stream.emit("error", er);
            pna.nextTick(cb, er);
          }
          function validChunk(stream, state, chunk, cb) {
            var valid = true;
            var er = false;
            if (chunk === null) {
              er = new TypeError("May not write null values to stream");
            } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
              er = new TypeError("Invalid non-string/buffer chunk");
            }
            if (er) {
              stream.emit("error", er);
              pna.nextTick(cb, er);
              valid = false;
            }
            return valid;
          }
          Writable.prototype.write = function(chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;
            var isBuf = !state.objectMode && _isUint8Array(chunk);
            if (isBuf && !Buffer.isBuffer(chunk)) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (typeof encoding === "function") {
              cb = encoding;
              encoding = null;
            }
            if (isBuf)
              encoding = "buffer";
            else if (!encoding)
              encoding = state.defaultEncoding;
            if (typeof cb !== "function")
              cb = nop;
            if (state.ended)
              writeAfterEnd(this, cb);
            else if (isBuf || validChunk(this, state, chunk, cb)) {
              state.pendingcb++;
              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
            }
            return ret;
          };
          Writable.prototype.cork = function() {
            var state = this._writableState;
            state.corked++;
          };
          Writable.prototype.uncork = function() {
            var state = this._writableState;
            if (state.corked) {
              state.corked--;
              if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
                clearBuffer(this, state);
            }
          };
          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
            if (typeof encoding === "string")
              encoding = encoding.toLowerCase();
            if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
              throw new TypeError("Unknown encoding: " + encoding);
            this._writableState.defaultEncoding = encoding;
            return this;
          };
          function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
              chunk = Buffer.from(chunk, encoding);
            }
            return chunk;
          }
          Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function() {
              return this._writableState.highWaterMark;
            }
          });
          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
            if (!isBuf) {
              var newChunk = decodeChunk(state, chunk, encoding);
              if (chunk !== newChunk) {
                isBuf = true;
                encoding = "buffer";
                chunk = newChunk;
              }
            }
            var len = state.objectMode ? 1 : chunk.length;
            state.length += len;
            var ret = state.length < state.highWaterMark;
            if (!ret)
              state.needDrain = true;
            if (state.writing || state.corked) {
              var last = state.lastBufferedRequest;
              state.lastBufferedRequest = {
                chunk,
                encoding,
                isBuf,
                callback: cb,
                next: null
              };
              if (last) {
                last.next = state.lastBufferedRequest;
              } else {
                state.bufferedRequest = state.lastBufferedRequest;
              }
              state.bufferedRequestCount += 1;
            } else {
              doWrite(stream, state, false, len, chunk, encoding, cb);
            }
            return ret;
          }
          function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            if (writev)
              stream._writev(chunk, state.onwrite);
            else
              stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
          }
          function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb;
            if (sync) {
              pna.nextTick(cb, er);
              pna.nextTick(finishMaybe, stream, state);
              stream._writableState.errorEmitted = true;
              stream.emit("error", er);
            } else {
              cb(er);
              stream._writableState.errorEmitted = true;
              stream.emit("error", er);
              finishMaybe(stream, state);
            }
          }
          function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
          }
          function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;
            onwriteStateUpdate(state);
            if (er)
              onwriteError(stream, state, sync, er, cb);
            else {
              var finished = needFinish(state);
              if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                clearBuffer(stream, state);
              }
              if (sync) {
                asyncWrite(afterWrite, stream, state, finished, cb);
              } else {
                afterWrite(stream, state, finished, cb);
              }
            }
          }
          function afterWrite(stream, state, finished, cb) {
            if (!finished)
              onwriteDrain(stream, state);
            state.pendingcb--;
            cb();
            finishMaybe(stream, state);
          }
          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false;
              stream.emit("drain");
            }
          }
          function clearBuffer(stream, state) {
            state.bufferProcessing = true;
            var entry = state.bufferedRequest;
            if (stream._writev && entry && entry.next) {
              var l = state.bufferedRequestCount;
              var buffer = new Array(l);
              var holder = state.corkedRequestsFree;
              holder.entry = entry;
              var count = 0;
              var allBuffers = true;
              while (entry) {
                buffer[count] = entry;
                if (!entry.isBuf)
                  allBuffers = false;
                entry = entry.next;
                count += 1;
              }
              buffer.allBuffers = allBuffers;
              doWrite(stream, state, true, state.length, buffer, "", holder.finish);
              state.pendingcb++;
              state.lastBufferedRequest = null;
              if (holder.next) {
                state.corkedRequestsFree = holder.next;
                holder.next = null;
              } else {
                state.corkedRequestsFree = new CorkedRequest(state);
              }
              state.bufferedRequestCount = 0;
            } else {
              while (entry) {
                var chunk = entry.chunk;
                var encoding = entry.encoding;
                var cb = entry.callback;
                var len = state.objectMode ? 1 : chunk.length;
                doWrite(stream, state, false, len, chunk, encoding, cb);
                entry = entry.next;
                state.bufferedRequestCount--;
                if (state.writing) {
                  break;
                }
              }
              if (entry === null)
                state.lastBufferedRequest = null;
            }
            state.bufferedRequest = entry;
            state.bufferProcessing = false;
          }
          Writable.prototype._write = function(chunk, encoding, cb) {
            cb(new Error("_write() is not implemented"));
          };
          Writable.prototype._writev = null;
          Writable.prototype.end = function(chunk, encoding, cb) {
            var state = this._writableState;
            if (typeof chunk === "function") {
              cb = chunk;
              chunk = null;
              encoding = null;
            } else if (typeof encoding === "function") {
              cb = encoding;
              encoding = null;
            }
            if (chunk !== null && chunk !== void 0)
              this.write(chunk, encoding);
            if (state.corked) {
              state.corked = 1;
              this.uncork();
            }
            if (!state.ending && !state.finished)
              endWritable(this, state, cb);
          };
          function needFinish(state) {
            return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
          }
          function callFinal(stream, state) {
            stream._final(function(err) {
              state.pendingcb--;
              if (err) {
                stream.emit("error", err);
              }
              state.prefinished = true;
              stream.emit("prefinish");
              finishMaybe(stream, state);
            });
          }
          function prefinish(stream, state) {
            if (!state.prefinished && !state.finalCalled) {
              if (typeof stream._final === "function") {
                state.pendingcb++;
                state.finalCalled = true;
                pna.nextTick(callFinal, stream, state);
              } else {
                state.prefinished = true;
                stream.emit("prefinish");
              }
            }
          }
          function finishMaybe(stream, state) {
            var need = needFinish(state);
            if (need) {
              prefinish(stream, state);
              if (state.pendingcb === 0) {
                state.finished = true;
                stream.emit("finish");
              }
            }
            return need;
          }
          function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);
            if (cb) {
              if (state.finished)
                pna.nextTick(cb);
              else
                stream.once("finish", cb);
            }
            state.ended = true;
            stream.writable = false;
          }
          function onCorkedFinish(corkReq, state, err) {
            var entry = corkReq.entry;
            corkReq.entry = null;
            while (entry) {
              var cb = entry.callback;
              state.pendingcb--;
              cb(err);
              entry = entry.next;
            }
            if (state.corkedRequestsFree) {
              state.corkedRequestsFree.next = corkReq;
            } else {
              state.corkedRequestsFree = corkReq;
            }
          }
          Object.defineProperty(Writable.prototype, "destroyed", {
            get: function() {
              if (this._writableState === void 0) {
                return false;
              }
              return this._writableState.destroyed;
            },
            set: function(value) {
              if (!this._writableState) {
                return;
              }
              this._writableState.destroyed = value;
            }
          });
          Writable.prototype.destroy = destroyImpl.destroy;
          Writable.prototype._undestroy = destroyImpl.undestroy;
          Writable.prototype._destroy = function(err, cb) {
            this.end();
            cb(err);
          };
        }).call(this, require2("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("timers").setImmediate);
      }, { "./_stream_duplex": 139, "./internal/streams/destroy": 145, "./internal/streams/stream": 146, "_process": 133, "core-util-is": 51, "inherits": 75, "process-nextick-args": 132, "safe-buffer": 147, "timers": 176, "util-deprecate": 183 }], 144: [function(require2, module3, exports3) {
        "use strict";
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        var Buffer = require2("safe-buffer").Buffer;
        var util = require2("util");
        function copyBuffer(src, target, offset) {
          src.copy(target, offset);
        }
        module3.exports = function() {
          function BufferList() {
            _classCallCheck(this, BufferList);
            this.head = null;
            this.tail = null;
            this.length = 0;
          }
          BufferList.prototype.push = function push(v) {
            var entry = { data: v, next: null };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          };
          BufferList.prototype.unshift = function unshift(v) {
            var entry = { data: v, next: this.head };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          };
          BufferList.prototype.shift = function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          };
          BufferList.prototype.clear = function clear() {
            this.head = this.tail = null;
            this.length = 0;
          };
          BufferList.prototype.join = function join(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          };
          BufferList.prototype.concat = function concat(n) {
            if (this.length === 0)
              return Buffer.alloc(0);
            if (this.length === 1)
              return this.head.data;
            var ret = Buffer.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          };
          return BufferList;
        }();
        if (util && util.inspect && util.inspect.custom) {
          module3.exports.prototype[util.inspect.custom] = function() {
            var obj = util.inspect({ length: this.length });
            return this.constructor.name + " " + obj;
          };
        }
      }, { "safe-buffer": 147, "util": 33 }], 145: [function(require2, module3, exports3) {
        "use strict";
        var pna = require2("process-nextick-args");
        function destroy(err, cb) {
          var _this = this;
          var readableDestroyed = this._readableState && this._readableState.destroyed;
          var writableDestroyed = this._writableState && this._writableState.destroyed;
          if (readableDestroyed || writableDestroyed) {
            if (cb) {
              cb(err);
            } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
              pna.nextTick(emitErrorNT, this, err);
            }
            return this;
          }
          if (this._readableState) {
            this._readableState.destroyed = true;
          }
          if (this._writableState) {
            this._writableState.destroyed = true;
          }
          this._destroy(err || null, function(err2) {
            if (!cb && err2) {
              pna.nextTick(emitErrorNT, _this, err2);
              if (_this._writableState) {
                _this._writableState.errorEmitted = true;
              }
            } else if (cb) {
              cb(err2);
            }
          });
          return this;
        }
        function undestroy() {
          if (this._readableState) {
            this._readableState.destroyed = false;
            this._readableState.reading = false;
            this._readableState.ended = false;
            this._readableState.endEmitted = false;
          }
          if (this._writableState) {
            this._writableState.destroyed = false;
            this._writableState.ended = false;
            this._writableState.ending = false;
            this._writableState.finished = false;
            this._writableState.errorEmitted = false;
          }
        }
        function emitErrorNT(self2, err) {
          self2.emit("error", err);
        }
        module3.exports = {
          destroy,
          undestroy
        };
      }, { "process-nextick-args": 132 }], 146: [function(require2, module3, exports3) {
        module3.exports = require2("events").EventEmitter;
      }, { "events": 52 }], 147: [function(require2, module3, exports3) {
        var buffer = require2("buffer");
        var Buffer = buffer.Buffer;
        function copyProps(src, dst) {
          for (var key in src) {
            dst[key] = src[key];
          }
        }
        if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
          module3.exports = buffer;
        } else {
          copyProps(buffer, exports3);
          exports3.Buffer = SafeBuffer;
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer(arg, encodingOrOffset, length);
        }
        copyProps(Buffer, SafeBuffer);
        SafeBuffer.from = function(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number");
          }
          return Buffer(arg, encodingOrOffset, length);
        };
        SafeBuffer.alloc = function(size, fill, encoding) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          var buf = Buffer(size);
          if (fill !== void 0) {
            if (typeof encoding === "string") {
              buf.fill(fill, encoding);
            } else {
              buf.fill(fill);
            }
          } else {
            buf.fill(0);
          }
          return buf;
        };
        SafeBuffer.allocUnsafe = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return Buffer(size);
        };
        SafeBuffer.allocUnsafeSlow = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return buffer.SlowBuffer(size);
        };
      }, { "buffer": 48 }], 148: [function(require2, module3, exports3) {
        "use strict";
        var Buffer = require2("safe-buffer").Buffer;
        var isEncoding = Buffer.isEncoding || function(encoding) {
          encoding = "" + encoding;
          switch (encoding && encoding.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return true;
            default:
              return false;
          }
        };
        function _normalizeEncoding(enc) {
          if (!enc)
            return "utf8";
          var retried;
          while (true) {
            switch (enc) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return enc;
              default:
                if (retried)
                  return;
                enc = ("" + enc).toLowerCase();
                retried = true;
            }
          }
        }
        ;
        function normalizeEncoding(enc) {
          var nenc = _normalizeEncoding(enc);
          if (typeof nenc !== "string" && (Buffer.isEncoding === isEncoding || !isEncoding(enc)))
            throw new Error("Unknown encoding: " + enc);
          return nenc || enc;
        }
        exports3.StringDecoder = StringDecoder;
        function StringDecoder(encoding) {
          this.encoding = normalizeEncoding(encoding);
          var nb;
          switch (this.encoding) {
            case "utf16le":
              this.text = utf16Text;
              this.end = utf16End;
              nb = 4;
              break;
            case "utf8":
              this.fillLast = utf8FillLast;
              nb = 4;
              break;
            case "base64":
              this.text = base64Text;
              this.end = base64End;
              nb = 3;
              break;
            default:
              this.write = simpleWrite;
              this.end = simpleEnd;
              return;
          }
          this.lastNeed = 0;
          this.lastTotal = 0;
          this.lastChar = Buffer.allocUnsafe(nb);
        }
        StringDecoder.prototype.write = function(buf) {
          if (buf.length === 0)
            return "";
          var r;
          var i;
          if (this.lastNeed) {
            r = this.fillLast(buf);
            if (r === void 0)
              return "";
            i = this.lastNeed;
            this.lastNeed = 0;
          } else {
            i = 0;
          }
          if (i < buf.length)
            return r ? r + this.text(buf, i) : this.text(buf, i);
          return r || "";
        };
        StringDecoder.prototype.end = utf8End;
        StringDecoder.prototype.text = utf8Text;
        StringDecoder.prototype.fillLast = function(buf) {
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
          this.lastNeed -= buf.length;
        };
        function utf8CheckByte(byte) {
          if (byte <= 127)
            return 0;
          else if (byte >> 5 === 6)
            return 2;
          else if (byte >> 4 === 14)
            return 3;
          else if (byte >> 3 === 30)
            return 4;
          return byte >> 6 === 2 ? -1 : -2;
        }
        function utf8CheckIncomplete(self2, buf, i) {
          var j = buf.length - 1;
          if (j < i)
            return 0;
          var nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0)
              self2.lastNeed = nb - 1;
            return nb;
          }
          if (--j < i || nb === -2)
            return 0;
          nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0)
              self2.lastNeed = nb - 2;
            return nb;
          }
          if (--j < i || nb === -2)
            return 0;
          nb = utf8CheckByte(buf[j]);
          if (nb >= 0) {
            if (nb > 0) {
              if (nb === 2)
                nb = 0;
              else
                self2.lastNeed = nb - 3;
            }
            return nb;
          }
          return 0;
        }
        function utf8CheckExtraBytes(self2, buf, p) {
          if ((buf[0] & 192) !== 128) {
            self2.lastNeed = 0;
            return "";
          }
          if (self2.lastNeed > 1 && buf.length > 1) {
            if ((buf[1] & 192) !== 128) {
              self2.lastNeed = 1;
              return "";
            }
            if (self2.lastNeed > 2 && buf.length > 2) {
              if ((buf[2] & 192) !== 128) {
                self2.lastNeed = 2;
                return "";
              }
            }
          }
        }
        function utf8FillLast(buf) {
          var p = this.lastTotal - this.lastNeed;
          var r = utf8CheckExtraBytes(this, buf, p);
          if (r !== void 0)
            return r;
          if (this.lastNeed <= buf.length) {
            buf.copy(this.lastChar, p, 0, this.lastNeed);
            return this.lastChar.toString(this.encoding, 0, this.lastTotal);
          }
          buf.copy(this.lastChar, p, 0, buf.length);
          this.lastNeed -= buf.length;
        }
        function utf8Text(buf, i) {
          var total = utf8CheckIncomplete(this, buf, i);
          if (!this.lastNeed)
            return buf.toString("utf8", i);
          this.lastTotal = total;
          var end = buf.length - (total - this.lastNeed);
          buf.copy(this.lastChar, 0, end);
          return buf.toString("utf8", i, end);
        }
        function utf8End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed)
            return r + "";
          return r;
        }
        function utf16Text(buf, i) {
          if ((buf.length - i) % 2 === 0) {
            var r = buf.toString("utf16le", i);
            if (r) {
              var c = r.charCodeAt(r.length - 1);
              if (c >= 55296 && c <= 56319) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
              }
            }
            return r;
          }
          this.lastNeed = 1;
          this.lastTotal = 2;
          this.lastChar[0] = buf[buf.length - 1];
          return buf.toString("utf16le", i, buf.length - 1);
        }
        function utf16End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed) {
            var end = this.lastTotal - this.lastNeed;
            return r + this.lastChar.toString("utf16le", 0, end);
          }
          return r;
        }
        function base64Text(buf, i) {
          var n = (buf.length - i) % 3;
          if (n === 0)
            return buf.toString("base64", i);
          this.lastNeed = 3 - n;
          this.lastTotal = 3;
          if (n === 1) {
            this.lastChar[0] = buf[buf.length - 1];
          } else {
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
          }
          return buf.toString("base64", i, buf.length - n);
        }
        function base64End(buf) {
          var r = buf && buf.length ? this.write(buf) : "";
          if (this.lastNeed)
            return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
          return r;
        }
        function simpleWrite(buf) {
          return buf.toString(this.encoding);
        }
        function simpleEnd(buf) {
          return buf && buf.length ? this.write(buf) : "";
        }
      }, { "safe-buffer": 147 }], 149: [function(require2, module3, exports3) {
        module3.exports = require2("./readable").PassThrough;
      }, { "./readable": 150 }], 150: [function(require2, module3, exports3) {
        exports3 = module3.exports = require2("./lib/_stream_readable.js");
        exports3.Stream = exports3;
        exports3.Readable = exports3;
        exports3.Writable = require2("./lib/_stream_writable.js");
        exports3.Duplex = require2("./lib/_stream_duplex.js");
        exports3.Transform = require2("./lib/_stream_transform.js");
        exports3.PassThrough = require2("./lib/_stream_passthrough.js");
      }, { "./lib/_stream_duplex.js": 139, "./lib/_stream_passthrough.js": 140, "./lib/_stream_readable.js": 141, "./lib/_stream_transform.js": 142, "./lib/_stream_writable.js": 143 }], 151: [function(require2, module3, exports3) {
        module3.exports = require2("./readable").Transform;
      }, { "./readable": 150 }], 152: [function(require2, module3, exports3) {
        module3.exports = require2("./lib/_stream_writable.js");
      }, { "./lib/_stream_writable.js": 143 }], 153: [function(require2, module3, exports3) {
        var runtime = function(exports4) {
          "use strict";
          var Op = Object.prototype;
          var hasOwn = Op.hasOwnProperty;
          var undefined2;
          var $Symbol = typeof Symbol === "function" ? Symbol : {};
          var iteratorSymbol = $Symbol.iterator || "@@iterator";
          var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
          var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
          function wrap(innerFn, outerFn, self2, tryLocsList) {
            var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
            var generator = Object.create(protoGenerator.prototype);
            var context = new Context(tryLocsList || []);
            generator._invoke = makeInvokeMethod(innerFn, self2, context);
            return generator;
          }
          exports4.wrap = wrap;
          function tryCatch(fn, obj, arg) {
            try {
              return { type: "normal", arg: fn.call(obj, arg) };
            } catch (err) {
              return { type: "throw", arg: err };
            }
          }
          var GenStateSuspendedStart = "suspendedStart";
          var GenStateSuspendedYield = "suspendedYield";
          var GenStateExecuting = "executing";
          var GenStateCompleted = "completed";
          var ContinueSentinel = {};
          function Generator() {
          }
          function GeneratorFunction() {
          }
          function GeneratorFunctionPrototype() {
          }
          var IteratorPrototype = {};
          IteratorPrototype[iteratorSymbol] = function() {
            return this;
          };
          var getProto = Object.getPrototypeOf;
          var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
          if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
            IteratorPrototype = NativeIteratorPrototype;
          }
          var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
          GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
          GeneratorFunctionPrototype.constructor = GeneratorFunction;
          GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
          function defineIteratorMethods(prototype) {
            ["next", "throw", "return"].forEach(function(method) {
              prototype[method] = function(arg) {
                return this._invoke(method, arg);
              };
            });
          }
          exports4.isGeneratorFunction = function(genFun) {
            var ctor = typeof genFun === "function" && genFun.constructor;
            return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
            // do is to check its .name property.
            (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
          };
          exports4.mark = function(genFun) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
            } else {
              genFun.__proto__ = GeneratorFunctionPrototype;
              if (!(toStringTagSymbol in genFun)) {
                genFun[toStringTagSymbol] = "GeneratorFunction";
              }
            }
            genFun.prototype = Object.create(Gp);
            return genFun;
          };
          exports4.awrap = function(arg) {
            return { __await: arg };
          };
          function AsyncIterator(generator) {
            function invoke(method, arg, resolve, reject) {
              var record = tryCatch(generator[method], generator, arg);
              if (record.type === "throw") {
                reject(record.arg);
              } else {
                var result = record.arg;
                var value = result.value;
                if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
                  return Promise.resolve(value.__await).then(function(value2) {
                    invoke("next", value2, resolve, reject);
                  }, function(err) {
                    invoke("throw", err, resolve, reject);
                  });
                }
                return Promise.resolve(value).then(function(unwrapped) {
                  result.value = unwrapped;
                  resolve(result);
                }, function(error) {
                  return invoke("throw", error, resolve, reject);
                });
              }
            }
            var previousPromise;
            function enqueue(method, arg) {
              function callInvokeWithMethodAndArg() {
                return new Promise(function(resolve, reject) {
                  invoke(method, arg, resolve, reject);
                });
              }
              return previousPromise = // If enqueue has been called before, then we want to wait until
              // all previous Promises have been resolved before calling invoke,
              // so that results are always delivered in the correct order. If
              // enqueue has not been called before, then it is important to
              // call invoke immediately, without waiting on a callback to fire,
              // so that the async generator function has the opportunity to do
              // any necessary setup in a predictable way. This predictability
              // is why the Promise constructor synchronously invokes its
              // executor callback, and why async functions synchronously
              // execute code before the first await. Since we implement simple
              // async functions in terms of async generators, it is especially
              // important to get this right, even though it requires care.
              previousPromise ? previousPromise.then(
                callInvokeWithMethodAndArg,
                // Avoid propagating failures to Promises returned by later
                // invocations of the iterator.
                callInvokeWithMethodAndArg
              ) : callInvokeWithMethodAndArg();
            }
            this._invoke = enqueue;
          }
          defineIteratorMethods(AsyncIterator.prototype);
          AsyncIterator.prototype[asyncIteratorSymbol] = function() {
            return this;
          };
          exports4.AsyncIterator = AsyncIterator;
          exports4.async = function(innerFn, outerFn, self2, tryLocsList) {
            var iter = new AsyncIterator(
              wrap(innerFn, outerFn, self2, tryLocsList)
            );
            return exports4.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
              return result.done ? result.value : iter.next();
            });
          };
          function makeInvokeMethod(innerFn, self2, context) {
            var state = GenStateSuspendedStart;
            return function invoke(method, arg) {
              if (state === GenStateExecuting) {
                throw new Error("Generator is already running");
              }
              if (state === GenStateCompleted) {
                if (method === "throw") {
                  throw arg;
                }
                return doneResult();
              }
              context.method = method;
              context.arg = arg;
              while (true) {
                var delegate = context.delegate;
                if (delegate) {
                  var delegateResult = maybeInvokeDelegate(delegate, context);
                  if (delegateResult) {
                    if (delegateResult === ContinueSentinel)
                      continue;
                    return delegateResult;
                  }
                }
                if (context.method === "next") {
                  context.sent = context._sent = context.arg;
                } else if (context.method === "throw") {
                  if (state === GenStateSuspendedStart) {
                    state = GenStateCompleted;
                    throw context.arg;
                  }
                  context.dispatchException(context.arg);
                } else if (context.method === "return") {
                  context.abrupt("return", context.arg);
                }
                state = GenStateExecuting;
                var record = tryCatch(innerFn, self2, context);
                if (record.type === "normal") {
                  state = context.done ? GenStateCompleted : GenStateSuspendedYield;
                  if (record.arg === ContinueSentinel) {
                    continue;
                  }
                  return {
                    value: record.arg,
                    done: context.done
                  };
                } else if (record.type === "throw") {
                  state = GenStateCompleted;
                  context.method = "throw";
                  context.arg = record.arg;
                }
              }
            };
          }
          function maybeInvokeDelegate(delegate, context) {
            var method = delegate.iterator[context.method];
            if (method === undefined2) {
              context.delegate = null;
              if (context.method === "throw") {
                if (delegate.iterator["return"]) {
                  context.method = "return";
                  context.arg = undefined2;
                  maybeInvokeDelegate(delegate, context);
                  if (context.method === "throw") {
                    return ContinueSentinel;
                  }
                }
                context.method = "throw";
                context.arg = new TypeError(
                  "The iterator does not provide a 'throw' method"
                );
              }
              return ContinueSentinel;
            }
            var record = tryCatch(method, delegate.iterator, context.arg);
            if (record.type === "throw") {
              context.method = "throw";
              context.arg = record.arg;
              context.delegate = null;
              return ContinueSentinel;
            }
            var info = record.arg;
            if (!info) {
              context.method = "throw";
              context.arg = new TypeError("iterator result is not an object");
              context.delegate = null;
              return ContinueSentinel;
            }
            if (info.done) {
              context[delegate.resultName] = info.value;
              context.next = delegate.nextLoc;
              if (context.method !== "return") {
                context.method = "next";
                context.arg = undefined2;
              }
            } else {
              return info;
            }
            context.delegate = null;
            return ContinueSentinel;
          }
          defineIteratorMethods(Gp);
          Gp[toStringTagSymbol] = "Generator";
          Gp[iteratorSymbol] = function() {
            return this;
          };
          Gp.toString = function() {
            return "[object Generator]";
          };
          function pushTryEntry(locs) {
            var entry = { tryLoc: locs[0] };
            if (1 in locs) {
              entry.catchLoc = locs[1];
            }
            if (2 in locs) {
              entry.finallyLoc = locs[2];
              entry.afterLoc = locs[3];
            }
            this.tryEntries.push(entry);
          }
          function resetTryEntry(entry) {
            var record = entry.completion || {};
            record.type = "normal";
            delete record.arg;
            entry.completion = record;
          }
          function Context(tryLocsList) {
            this.tryEntries = [{ tryLoc: "root" }];
            tryLocsList.forEach(pushTryEntry, this);
            this.reset(true);
          }
          exports4.keys = function(object) {
            var keys = [];
            for (var key in object) {
              keys.push(key);
            }
            keys.reverse();
            return function next() {
              while (keys.length) {
                var key2 = keys.pop();
                if (key2 in object) {
                  next.value = key2;
                  next.done = false;
                  return next;
                }
              }
              next.done = true;
              return next;
            };
          };
          function values(iterable) {
            if (iterable) {
              var iteratorMethod = iterable[iteratorSymbol];
              if (iteratorMethod) {
                return iteratorMethod.call(iterable);
              }
              if (typeof iterable.next === "function") {
                return iterable;
              }
              if (!isNaN(iterable.length)) {
                var i = -1, next = function next2() {
                  while (++i < iterable.length) {
                    if (hasOwn.call(iterable, i)) {
                      next2.value = iterable[i];
                      next2.done = false;
                      return next2;
                    }
                  }
                  next2.value = undefined2;
                  next2.done = true;
                  return next2;
                };
                return next.next = next;
              }
            }
            return { next: doneResult };
          }
          exports4.values = values;
          function doneResult() {
            return { value: undefined2, done: true };
          }
          Context.prototype = {
            constructor: Context,
            reset: function(skipTempReset) {
              this.prev = 0;
              this.next = 0;
              this.sent = this._sent = undefined2;
              this.done = false;
              this.delegate = null;
              this.method = "next";
              this.arg = undefined2;
              this.tryEntries.forEach(resetTryEntry);
              if (!skipTempReset) {
                for (var name in this) {
                  if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                    this[name] = undefined2;
                  }
                }
              }
            },
            stop: function() {
              this.done = true;
              var rootEntry = this.tryEntries[0];
              var rootRecord = rootEntry.completion;
              if (rootRecord.type === "throw") {
                throw rootRecord.arg;
              }
              return this.rval;
            },
            dispatchException: function(exception) {
              if (this.done) {
                throw exception;
              }
              var context = this;
              function handle(loc, caught) {
                record.type = "throw";
                record.arg = exception;
                context.next = loc;
                if (caught) {
                  context.method = "next";
                  context.arg = undefined2;
                }
                return !!caught;
              }
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                var record = entry.completion;
                if (entry.tryLoc === "root") {
                  return handle("end");
                }
                if (entry.tryLoc <= this.prev) {
                  var hasCatch = hasOwn.call(entry, "catchLoc");
                  var hasFinally = hasOwn.call(entry, "finallyLoc");
                  if (hasCatch && hasFinally) {
                    if (this.prev < entry.catchLoc) {
                      return handle(entry.catchLoc, true);
                    } else if (this.prev < entry.finallyLoc) {
                      return handle(entry.finallyLoc);
                    }
                  } else if (hasCatch) {
                    if (this.prev < entry.catchLoc) {
                      return handle(entry.catchLoc, true);
                    }
                  } else if (hasFinally) {
                    if (this.prev < entry.finallyLoc) {
                      return handle(entry.finallyLoc);
                    }
                  } else {
                    throw new Error("try statement without catch or finally");
                  }
                }
              }
            },
            abrupt: function(type, arg) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                  var finallyEntry = entry;
                  break;
                }
              }
              if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
                finallyEntry = null;
              }
              var record = finallyEntry ? finallyEntry.completion : {};
              record.type = type;
              record.arg = arg;
              if (finallyEntry) {
                this.method = "next";
                this.next = finallyEntry.finallyLoc;
                return ContinueSentinel;
              }
              return this.complete(record);
            },
            complete: function(record, afterLoc) {
              if (record.type === "throw") {
                throw record.arg;
              }
              if (record.type === "break" || record.type === "continue") {
                this.next = record.arg;
              } else if (record.type === "return") {
                this.rval = this.arg = record.arg;
                this.method = "return";
                this.next = "end";
              } else if (record.type === "normal" && afterLoc) {
                this.next = afterLoc;
              }
              return ContinueSentinel;
            },
            finish: function(finallyLoc) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.finallyLoc === finallyLoc) {
                  this.complete(entry.completion, entry.afterLoc);
                  resetTryEntry(entry);
                  return ContinueSentinel;
                }
              }
            },
            "catch": function(tryLoc) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.tryLoc === tryLoc) {
                  var record = entry.completion;
                  if (record.type === "throw") {
                    var thrown = record.arg;
                    resetTryEntry(entry);
                  }
                  return thrown;
                }
              }
              throw new Error("illegal catch attempt");
            },
            delegateYield: function(iterable, resultName, nextLoc) {
              this.delegate = {
                iterator: values(iterable),
                resultName,
                nextLoc
              };
              if (this.method === "next") {
                this.arg = undefined2;
              }
              return ContinueSentinel;
            }
          };
          return exports4;
        }(
          // If this script is executing as a CommonJS module, use module.exports
          // as the regeneratorRuntime namespace. Otherwise create a new empty
          // object. Either way, the resulting object will be used to initialize
          // the regeneratorRuntime variable at the top of this file.
          typeof module3 === "object" ? module3.exports : {}
        );
        try {
          regeneratorRuntime = runtime;
        } catch (accidentalStrictMode) {
          Function("r", "regeneratorRuntime = r")(runtime);
        }
      }, {}], 154: [function(require2, module3, exports3) {
        var buffer = require2("buffer");
        var Buffer = buffer.Buffer;
        function copyProps(src, dst) {
          for (var key in src) {
            dst[key] = src[key];
          }
        }
        if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
          module3.exports = buffer;
        } else {
          copyProps(buffer, exports3);
          exports3.Buffer = SafeBuffer;
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
          return Buffer(arg, encodingOrOffset, length);
        }
        SafeBuffer.prototype = Object.create(Buffer.prototype);
        copyProps(Buffer, SafeBuffer);
        SafeBuffer.from = function(arg, encodingOrOffset, length) {
          if (typeof arg === "number") {
            throw new TypeError("Argument must not be a number");
          }
          return Buffer(arg, encodingOrOffset, length);
        };
        SafeBuffer.alloc = function(size, fill, encoding) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          var buf = Buffer(size);
          if (fill !== void 0) {
            if (typeof encoding === "string") {
              buf.fill(fill, encoding);
            } else {
              buf.fill(fill);
            }
          } else {
            buf.fill(0);
          }
          return buf;
        };
        SafeBuffer.allocUnsafe = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return Buffer(size);
        };
        SafeBuffer.allocUnsafeSlow = function(size) {
          if (typeof size !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return buffer.SlowBuffer(size);
        };
      }, { "buffer": 48 }], 155: [function(require2, module3, exports3) {
        module3.exports = Stream;
        var EE = require2("events").EventEmitter;
        var inherits = require2("inherits");
        inherits(Stream, EE);
        Stream.Readable = require2("readable-stream/readable.js");
        Stream.Writable = require2("readable-stream/writable.js");
        Stream.Duplex = require2("readable-stream/duplex.js");
        Stream.Transform = require2("readable-stream/transform.js");
        Stream.PassThrough = require2("readable-stream/passthrough.js");
        Stream.Stream = Stream;
        function Stream() {
          EE.call(this);
        }
        Stream.prototype.pipe = function(dest, options) {
          var source = this;
          function ondata(chunk) {
            if (dest.writable) {
              if (false === dest.write(chunk) && source.pause) {
                source.pause();
              }
            }
          }
          source.on("data", ondata);
          function ondrain() {
            if (source.readable && source.resume) {
              source.resume();
            }
          }
          dest.on("drain", ondrain);
          if (!dest._isStdio && (!options || options.end !== false)) {
            source.on("end", onend);
            source.on("close", onclose);
          }
          var didOnEnd = false;
          function onend() {
            if (didOnEnd)
              return;
            didOnEnd = true;
            dest.end();
          }
          function onclose() {
            if (didOnEnd)
              return;
            didOnEnd = true;
            if (typeof dest.destroy === "function")
              dest.destroy();
          }
          function onerror(er) {
            cleanup();
            if (EE.listenerCount(this, "error") === 0) {
              throw er;
            }
          }
          source.on("error", onerror);
          dest.on("error", onerror);
          function cleanup() {
            source.removeListener("data", ondata);
            dest.removeListener("drain", ondrain);
            source.removeListener("end", onend);
            source.removeListener("close", onclose);
            source.removeListener("error", onerror);
            dest.removeListener("error", onerror);
            source.removeListener("end", cleanup);
            source.removeListener("close", cleanup);
            dest.removeListener("close", cleanup);
          }
          source.on("end", cleanup);
          source.on("close", cleanup);
          dest.on("close", cleanup);
          dest.emit("pipe", source);
          return dest;
        };
      }, { "events": 52, "inherits": 75, "readable-stream/duplex.js": 138, "readable-stream/passthrough.js": 149, "readable-stream/readable.js": 150, "readable-stream/transform.js": 151, "readable-stream/writable.js": 152 }], 156: [function(require2, module3, exports3) {
        (function(global2) {
          var ClientRequest = require2("./lib/request");
          var response = require2("./lib/response");
          var extend = require2("xtend");
          var statusCodes = require2("builtin-status-codes");
          var url = require2("url");
          var http = exports3;
          http.request = function(opts, cb) {
            if (typeof opts === "string")
              opts = url.parse(opts);
            else
              opts = extend(opts);
            var defaultProtocol = global2.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
            var protocol = opts.protocol || defaultProtocol;
            var host = opts.hostname || opts.host;
            var port = opts.port;
            var path = opts.path || "/";
            if (host && host.indexOf(":") !== -1)
              host = "[" + host + "]";
            opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path;
            opts.method = (opts.method || "GET").toUpperCase();
            opts.headers = opts.headers || {};
            var req = new ClientRequest(opts);
            if (cb)
              req.on("response", cb);
            return req;
          };
          http.get = function get(opts, cb) {
            var req = http.request(opts, cb);
            req.end();
            return req;
          };
          http.ClientRequest = ClientRequest;
          http.IncomingMessage = response.IncomingMessage;
          http.Agent = function() {
          };
          http.Agent.defaultMaxSockets = 4;
          http.globalAgent = new http.Agent();
          http.STATUS_CODES = statusCodes;
          http.METHODS = [
            "CHECKOUT",
            "CONNECT",
            "COPY",
            "DELETE",
            "GET",
            "HEAD",
            "LOCK",
            "M-SEARCH",
            "MERGE",
            "MKACTIVITY",
            "MKCOL",
            "MOVE",
            "NOTIFY",
            "OPTIONS",
            "PATCH",
            "POST",
            "PROPFIND",
            "PROPPATCH",
            "PURGE",
            "PUT",
            "REPORT",
            "SEARCH",
            "SUBSCRIBE",
            "TRACE",
            "UNLOCK",
            "UNSUBSCRIBE"
          ];
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "./lib/request": 158, "./lib/response": 159, "builtin-status-codes": 50, "url": 180, "xtend": 189 }], 157: [function(require2, module3, exports3) {
        (function(global2) {
          exports3.fetch = isFunction(global2.fetch) && isFunction(global2.ReadableStream);
          exports3.writableStream = isFunction(global2.WritableStream);
          exports3.abortController = isFunction(global2.AbortController);
          var xhr;
          function getXHR() {
            if (xhr !== void 0)
              return xhr;
            if (global2.XMLHttpRequest) {
              xhr = new global2.XMLHttpRequest();
              try {
                xhr.open("GET", global2.XDomainRequest ? "/" : "https://example.com");
              } catch (e) {
                xhr = null;
              }
            } else {
              xhr = null;
            }
            return xhr;
          }
          function checkTypeSupport(type) {
            var xhr2 = getXHR();
            if (!xhr2)
              return false;
            try {
              xhr2.responseType = type;
              return xhr2.responseType === type;
            } catch (e) {
            }
            return false;
          }
          exports3.arraybuffer = exports3.fetch || checkTypeSupport("arraybuffer");
          exports3.msstream = !exports3.fetch && checkTypeSupport("ms-stream");
          exports3.mozchunkedarraybuffer = !exports3.fetch && checkTypeSupport("moz-chunked-arraybuffer");
          exports3.overrideMimeType = exports3.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);
          function isFunction(value) {
            return typeof value === "function";
          }
          xhr = null;
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 158: [function(require2, module3, exports3) {
        (function(process, global2, Buffer) {
          var capability = require2("./capability");
          var inherits = require2("inherits");
          var response = require2("./response");
          var stream = require2("readable-stream");
          var IncomingMessage = response.IncomingMessage;
          var rStates = response.readyStates;
          function decideMode(preferBinary, useFetch) {
            if (capability.fetch && useFetch) {
              return "fetch";
            } else if (capability.mozchunkedarraybuffer) {
              return "moz-chunked-arraybuffer";
            } else if (capability.msstream) {
              return "ms-stream";
            } else if (capability.arraybuffer && preferBinary) {
              return "arraybuffer";
            } else {
              return "text";
            }
          }
          var ClientRequest = module3.exports = function(opts) {
            var self2 = this;
            stream.Writable.call(self2);
            self2._opts = opts;
            self2._body = [];
            self2._headers = {};
            if (opts.auth)
              self2.setHeader("Authorization", "Basic " + Buffer.from(opts.auth).toString("base64"));
            Object.keys(opts.headers).forEach(function(name) {
              self2.setHeader(name, opts.headers[name]);
            });
            var preferBinary;
            var useFetch = true;
            if (opts.mode === "disable-fetch" || "requestTimeout" in opts && !capability.abortController) {
              useFetch = false;
              preferBinary = true;
            } else if (opts.mode === "prefer-streaming") {
              preferBinary = false;
            } else if (opts.mode === "allow-wrong-content-type") {
              preferBinary = !capability.overrideMimeType;
            } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
              preferBinary = true;
            } else {
              throw new Error("Invalid value for opts.mode");
            }
            self2._mode = decideMode(preferBinary, useFetch);
            self2._fetchTimer = null;
            self2.on("finish", function() {
              self2._onFinish();
            });
          };
          inherits(ClientRequest, stream.Writable);
          ClientRequest.prototype.setHeader = function(name, value) {
            var self2 = this;
            var lowerName = name.toLowerCase();
            if (unsafeHeaders.indexOf(lowerName) !== -1)
              return;
            self2._headers[lowerName] = {
              name,
              value
            };
          };
          ClientRequest.prototype.getHeader = function(name) {
            var header = this._headers[name.toLowerCase()];
            if (header)
              return header.value;
            return null;
          };
          ClientRequest.prototype.removeHeader = function(name) {
            var self2 = this;
            delete self2._headers[name.toLowerCase()];
          };
          ClientRequest.prototype._onFinish = function() {
            var self2 = this;
            if (self2._destroyed)
              return;
            var opts = self2._opts;
            var headersObj = self2._headers;
            var body = null;
            if (opts.method !== "GET" && opts.method !== "HEAD") {
              body = new Blob(self2._body, {
                type: (headersObj["content-type"] || {}).value || ""
              });
            }
            var headersList = [];
            Object.keys(headersObj).forEach(function(keyName) {
              var name = headersObj[keyName].name;
              var value = headersObj[keyName].value;
              if (Array.isArray(value)) {
                value.forEach(function(v) {
                  headersList.push([name, v]);
                });
              } else {
                headersList.push([name, value]);
              }
            });
            if (self2._mode === "fetch") {
              var signal = null;
              var fetchTimer = null;
              if (capability.abortController) {
                var controller = new AbortController();
                signal = controller.signal;
                self2._fetchAbortController = controller;
                if ("requestTimeout" in opts && opts.requestTimeout !== 0) {
                  self2._fetchTimer = global2.setTimeout(function() {
                    self2.emit("requestTimeout");
                    if (self2._fetchAbortController)
                      self2._fetchAbortController.abort();
                  }, opts.requestTimeout);
                }
              }
              global2.fetch(self2._opts.url, {
                method: self2._opts.method,
                headers: headersList,
                body: body || void 0,
                mode: "cors",
                credentials: opts.withCredentials ? "include" : "same-origin",
                signal
              }).then(function(response2) {
                self2._fetchResponse = response2;
                self2._connect();
              }, function(reason) {
                global2.clearTimeout(self2._fetchTimer);
                if (!self2._destroyed)
                  self2.emit("error", reason);
              });
            } else {
              var xhr = self2._xhr = new global2.XMLHttpRequest();
              try {
                xhr.open(self2._opts.method, self2._opts.url, true);
              } catch (err) {
                process.nextTick(function() {
                  self2.emit("error", err);
                });
                return;
              }
              if ("responseType" in xhr)
                xhr.responseType = self2._mode;
              if ("withCredentials" in xhr)
                xhr.withCredentials = !!opts.withCredentials;
              if (self2._mode === "text" && "overrideMimeType" in xhr)
                xhr.overrideMimeType("text/plain; charset=x-user-defined");
              if ("requestTimeout" in opts) {
                xhr.timeout = opts.requestTimeout;
                xhr.ontimeout = function() {
                  self2.emit("requestTimeout");
                };
              }
              headersList.forEach(function(header) {
                xhr.setRequestHeader(header[0], header[1]);
              });
              self2._response = null;
              xhr.onreadystatechange = function() {
                switch (xhr.readyState) {
                  case rStates.LOADING:
                  case rStates.DONE:
                    self2._onXHRProgress();
                    break;
                }
              };
              if (self2._mode === "moz-chunked-arraybuffer") {
                xhr.onprogress = function() {
                  self2._onXHRProgress();
                };
              }
              xhr.onerror = function() {
                if (self2._destroyed)
                  return;
                self2.emit("error", new Error("XHR error"));
              };
              try {
                xhr.send(body);
              } catch (err) {
                process.nextTick(function() {
                  self2.emit("error", err);
                });
                return;
              }
            }
          };
          function statusValid(xhr) {
            try {
              var status = xhr.status;
              return status !== null && status !== 0;
            } catch (e) {
              return false;
            }
          }
          ClientRequest.prototype._onXHRProgress = function() {
            var self2 = this;
            if (!statusValid(self2._xhr) || self2._destroyed)
              return;
            if (!self2._response)
              self2._connect();
            self2._response._onXHRProgress();
          };
          ClientRequest.prototype._connect = function() {
            var self2 = this;
            if (self2._destroyed)
              return;
            self2._response = new IncomingMessage(self2._xhr, self2._fetchResponse, self2._mode, self2._fetchTimer);
            self2._response.on("error", function(err) {
              self2.emit("error", err);
            });
            self2.emit("response", self2._response);
          };
          ClientRequest.prototype._write = function(chunk, encoding, cb) {
            var self2 = this;
            self2._body.push(chunk);
            cb();
          };
          ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function() {
            var self2 = this;
            self2._destroyed = true;
            global2.clearTimeout(self2._fetchTimer);
            if (self2._response)
              self2._response._destroyed = true;
            if (self2._xhr)
              self2._xhr.abort();
            else if (self2._fetchAbortController)
              self2._fetchAbortController.abort();
          };
          ClientRequest.prototype.end = function(data, encoding, cb) {
            var self2 = this;
            if (typeof data === "function") {
              cb = data;
              data = void 0;
            }
            stream.Writable.prototype.end.call(self2, data, encoding, cb);
          };
          ClientRequest.prototype.flushHeaders = function() {
          };
          ClientRequest.prototype.setTimeout = function() {
          };
          ClientRequest.prototype.setNoDelay = function() {
          };
          ClientRequest.prototype.setSocketKeepAlive = function() {
          };
          var unsafeHeaders = [
            "accept-charset",
            "accept-encoding",
            "access-control-request-headers",
            "access-control-request-method",
            "connection",
            "content-length",
            "cookie",
            "cookie2",
            "date",
            "dnt",
            "expect",
            "host",
            "keep-alive",
            "origin",
            "referer",
            "te",
            "trailer",
            "transfer-encoding",
            "upgrade",
            "via"
          ];
        }).call(this, require2("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("buffer").Buffer);
      }, { "./capability": 157, "./response": 159, "_process": 133, "buffer": 48, "inherits": 75, "readable-stream": 174 }], 159: [function(require2, module3, exports3) {
        (function(process, global2, Buffer) {
          var capability = require2("./capability");
          var inherits = require2("inherits");
          var stream = require2("readable-stream");
          var rStates = exports3.readyStates = {
            UNSENT: 0,
            OPENED: 1,
            HEADERS_RECEIVED: 2,
            LOADING: 3,
            DONE: 4
          };
          var IncomingMessage = exports3.IncomingMessage = function(xhr, response, mode, fetchTimer) {
            var self2 = this;
            stream.Readable.call(self2);
            self2._mode = mode;
            self2.headers = {};
            self2.rawHeaders = [];
            self2.trailers = {};
            self2.rawTrailers = [];
            self2.on("end", function() {
              process.nextTick(function() {
                self2.emit("close");
              });
            });
            if (mode === "fetch") {
              let read2 = function() {
                reader.read().then(function(result) {
                  if (self2._destroyed)
                    return;
                  if (result.done) {
                    global2.clearTimeout(fetchTimer);
                    self2.push(null);
                    return;
                  }
                  self2.push(Buffer.from(result.value));
                  read2();
                }).catch(function(err) {
                  global2.clearTimeout(fetchTimer);
                  if (!self2._destroyed)
                    self2.emit("error", err);
                });
              };
              var read = read2;
              self2._fetchResponse = response;
              self2.url = response.url;
              self2.statusCode = response.status;
              self2.statusMessage = response.statusText;
              response.headers.forEach(function(header, key) {
                self2.headers[key.toLowerCase()] = header;
                self2.rawHeaders.push(key, header);
              });
              if (capability.writableStream) {
                var writable = new WritableStream({
                  write: function(chunk) {
                    return new Promise(function(resolve, reject) {
                      if (self2._destroyed) {
                        reject();
                      } else if (self2.push(Buffer.from(chunk))) {
                        resolve();
                      } else {
                        self2._resumeFetch = resolve;
                      }
                    });
                  },
                  close: function() {
                    global2.clearTimeout(fetchTimer);
                    if (!self2._destroyed)
                      self2.push(null);
                  },
                  abort: function(err) {
                    if (!self2._destroyed)
                      self2.emit("error", err);
                  }
                });
                try {
                  response.body.pipeTo(writable).catch(function(err) {
                    global2.clearTimeout(fetchTimer);
                    if (!self2._destroyed)
                      self2.emit("error", err);
                  });
                  return;
                } catch (e) {
                }
              }
              var reader = response.body.getReader();
              read2();
            } else {
              self2._xhr = xhr;
              self2._pos = 0;
              self2.url = xhr.responseURL;
              self2.statusCode = xhr.status;
              self2.statusMessage = xhr.statusText;
              var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
              headers.forEach(function(header) {
                var matches = header.match(/^([^:]+):\s*(.*)/);
                if (matches) {
                  var key = matches[1].toLowerCase();
                  if (key === "set-cookie") {
                    if (self2.headers[key] === void 0) {
                      self2.headers[key] = [];
                    }
                    self2.headers[key].push(matches[2]);
                  } else if (self2.headers[key] !== void 0) {
                    self2.headers[key] += ", " + matches[2];
                  } else {
                    self2.headers[key] = matches[2];
                  }
                  self2.rawHeaders.push(matches[1], matches[2]);
                }
              });
              self2._charset = "x-user-defined";
              if (!capability.overrideMimeType) {
                var mimeType = self2.rawHeaders["mime-type"];
                if (mimeType) {
                  var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
                  if (charsetMatch) {
                    self2._charset = charsetMatch[1].toLowerCase();
                  }
                }
                if (!self2._charset)
                  self2._charset = "utf-8";
              }
            }
          };
          inherits(IncomingMessage, stream.Readable);
          IncomingMessage.prototype._read = function() {
            var self2 = this;
            var resolve = self2._resumeFetch;
            if (resolve) {
              self2._resumeFetch = null;
              resolve();
            }
          };
          IncomingMessage.prototype._onXHRProgress = function() {
            var self2 = this;
            var xhr = self2._xhr;
            var response = null;
            switch (self2._mode) {
              case "text":
                response = xhr.responseText;
                if (response.length > self2._pos) {
                  var newData = response.substr(self2._pos);
                  if (self2._charset === "x-user-defined") {
                    var buffer = Buffer.alloc(newData.length);
                    for (var i = 0; i < newData.length; i++)
                      buffer[i] = newData.charCodeAt(i) & 255;
                    self2.push(buffer);
                  } else {
                    self2.push(newData, self2._charset);
                  }
                  self2._pos = response.length;
                }
                break;
              case "arraybuffer":
                if (xhr.readyState !== rStates.DONE || !xhr.response)
                  break;
                response = xhr.response;
                self2.push(Buffer.from(new Uint8Array(response)));
                break;
              case "moz-chunked-arraybuffer":
                response = xhr.response;
                if (xhr.readyState !== rStates.LOADING || !response)
                  break;
                self2.push(Buffer.from(new Uint8Array(response)));
                break;
              case "ms-stream":
                response = xhr.response;
                if (xhr.readyState !== rStates.LOADING)
                  break;
                var reader = new global2.MSStreamReader();
                reader.onprogress = function() {
                  if (reader.result.byteLength > self2._pos) {
                    self2.push(Buffer.from(new Uint8Array(reader.result.slice(self2._pos))));
                    self2._pos = reader.result.byteLength;
                  }
                };
                reader.onload = function() {
                  self2.push(null);
                };
                reader.readAsArrayBuffer(response);
                break;
            }
            if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
              self2.push(null);
            }
          };
        }).call(this, require2("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("buffer").Buffer);
      }, { "./capability": 157, "_process": 133, "buffer": 48, "inherits": 75, "readable-stream": 174 }], 160: [function(require2, module3, exports3) {
        "use strict";
        function _inheritsLoose(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var codes = {};
        function createErrorType(code, message, Base) {
          if (!Base) {
            Base = Error;
          }
          function getMessage(arg1, arg2, arg3) {
            if (typeof message === "string") {
              return message;
            } else {
              return message(arg1, arg2, arg3);
            }
          }
          var NodeError = function(_Base) {
            _inheritsLoose(NodeError2, _Base);
            function NodeError2(arg1, arg2, arg3) {
              return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
            }
            return NodeError2;
          }(Base);
          NodeError.prototype.name = Base.name;
          NodeError.prototype.code = code;
          codes[code] = NodeError;
        }
        function oneOf(expected, thing) {
          if (Array.isArray(expected)) {
            var len = expected.length;
            expected = expected.map(function(i) {
              return String(i);
            });
            if (len > 2) {
              return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
            } else if (len === 2) {
              return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
            } else {
              return "of ".concat(thing, " ").concat(expected[0]);
            }
          } else {
            return "of ".concat(thing, " ").concat(String(expected));
          }
        }
        function startsWith(str, search, pos) {
          return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
        }
        function endsWith(str, search, this_len) {
          if (this_len === void 0 || this_len > str.length) {
            this_len = str.length;
          }
          return str.substring(this_len - search.length, this_len) === search;
        }
        function includes(str, search, start) {
          if (typeof start !== "number") {
            start = 0;
          }
          if (start + search.length > str.length) {
            return false;
          } else {
            return str.indexOf(search, start) !== -1;
          }
        }
        createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
          return 'The value "' + value + '" is invalid for option "' + name + '"';
        }, TypeError);
        createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
          var determiner;
          if (typeof expected === "string" && startsWith(expected, "not ")) {
            determiner = "must not be";
            expected = expected.replace(/^not /, "");
          } else {
            determiner = "must be";
          }
          var msg;
          if (endsWith(name, " argument")) {
            msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
          } else {
            var type = includes(name, ".") ? "property" : "argument";
            msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
          }
          msg += ". Received type ".concat(typeof actual);
          return msg;
        }, TypeError);
        createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
        createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
          return "The " + name + " method is not implemented";
        });
        createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
        createErrorType("ERR_STREAM_DESTROYED", function(name) {
          return "Cannot call " + name + " after a stream was destroyed";
        });
        createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
        createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
        createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
        createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
        createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
          return "Unknown encoding: " + arg;
        }, TypeError);
        createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
        module3.exports.codes = codes;
      }, {}], 161: [function(require2, module3, exports3) {
        (function(process) {
          "use strict";
          var experimentalWarnings = /* @__PURE__ */ new Set();
          function emitExperimentalWarning(feature) {
            if (experimentalWarnings.has(feature))
              return;
            var msg = feature + " is an experimental feature. This feature could change at any time";
            experimentalWarnings.add(feature);
            process.emitWarning(msg, "ExperimentalWarning");
          }
          function noop() {
          }
          module3.exports.emitExperimentalWarning = process.emitWarning ? emitExperimentalWarning : noop;
        }).call(this, require2("_process"));
      }, { "_process": 133 }], 162: [function(require2, module3, exports3) {
        (function(process) {
          "use strict";
          var objectKeys = Object.keys || function(obj) {
            var keys2 = [];
            for (var key in obj) {
              keys2.push(key);
            }
            return keys2;
          };
          module3.exports = Duplex;
          var Readable = require2("./_stream_readable");
          var Writable = require2("./_stream_writable");
          require2("inherits")(Duplex, Readable);
          {
            var keys = objectKeys(Writable.prototype);
            for (var v = 0; v < keys.length; v++) {
              var method = keys[v];
              if (!Duplex.prototype[method])
                Duplex.prototype[method] = Writable.prototype[method];
            }
          }
          function Duplex(options) {
            if (!(this instanceof Duplex))
              return new Duplex(options);
            Readable.call(this, options);
            Writable.call(this, options);
            this.allowHalfOpen = true;
            if (options) {
              if (options.readable === false)
                this.readable = false;
              if (options.writable === false)
                this.writable = false;
              if (options.allowHalfOpen === false) {
                this.allowHalfOpen = false;
                this.once("end", onend);
              }
            }
          }
          Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState.highWaterMark;
            }
          });
          Object.defineProperty(Duplex.prototype, "writableBuffer", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState && this._writableState.getBuffer();
            }
          });
          Object.defineProperty(Duplex.prototype, "writableLength", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState.length;
            }
          });
          function onend() {
            if (this._writableState.ended)
              return;
            process.nextTick(onEndNT, this);
          }
          function onEndNT(self2) {
            self2.end();
          }
          Object.defineProperty(Duplex.prototype, "destroyed", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              if (this._readableState === void 0 || this._writableState === void 0) {
                return false;
              }
              return this._readableState.destroyed && this._writableState.destroyed;
            },
            set: function set(value) {
              if (this._readableState === void 0 || this._writableState === void 0) {
                return;
              }
              this._readableState.destroyed = value;
              this._writableState.destroyed = value;
            }
          });
        }).call(this, require2("_process"));
      }, { "./_stream_readable": 164, "./_stream_writable": 166, "_process": 133, "inherits": 75 }], 163: [function(require2, module3, exports3) {
        "use strict";
        module3.exports = PassThrough;
        var Transform = require2("./_stream_transform");
        require2("inherits")(PassThrough, Transform);
        function PassThrough(options) {
          if (!(this instanceof PassThrough))
            return new PassThrough(options);
          Transform.call(this, options);
        }
        PassThrough.prototype._transform = function(chunk, encoding, cb) {
          cb(null, chunk);
        };
      }, { "./_stream_transform": 165, "inherits": 75 }], 164: [function(require2, module3, exports3) {
        (function(process, global2) {
          "use strict";
          module3.exports = Readable;
          var Duplex;
          Readable.ReadableState = ReadableState;
          var EE = require2("events").EventEmitter;
          var EElistenerCount = function EElistenerCount2(emitter, type) {
            return emitter.listeners(type).length;
          };
          var Stream = require2("./internal/streams/stream");
          var Buffer = require2("buffer").Buffer;
          var OurUint8Array = global2.Uint8Array || function() {
          };
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          var debugUtil = require2("util");
          var debug;
          if (debugUtil && debugUtil.debuglog) {
            debug = debugUtil.debuglog("stream");
          } else {
            debug = function debug2() {
            };
          }
          var BufferList = require2("./internal/streams/buffer_list");
          var destroyImpl = require2("./internal/streams/destroy");
          var _require = require2("./internal/streams/state"), getHighWaterMark = _require.getHighWaterMark;
          var _require$codes = require2("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
          var _require2 = require2("../experimentalWarning"), emitExperimentalWarning = _require2.emitExperimentalWarning;
          var StringDecoder;
          var createReadableStreamAsyncIterator;
          require2("inherits")(Readable, Stream);
          var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
          function prependListener(emitter, event, fn) {
            if (typeof emitter.prependListener === "function")
              return emitter.prependListener(event, fn);
            if (!emitter._events || !emitter._events[event])
              emitter.on(event, fn);
            else if (Array.isArray(emitter._events[event]))
              emitter._events[event].unshift(fn);
            else
              emitter._events[event] = [fn, emitter._events[event]];
          }
          function ReadableState(options, stream, isDuplex) {
            Duplex = Duplex || require2("./_stream_duplex");
            options = options || {};
            if (typeof isDuplex !== "boolean")
              isDuplex = stream instanceof Duplex;
            this.objectMode = !!options.objectMode;
            if (isDuplex)
              this.objectMode = this.objectMode || !!options.readableObjectMode;
            this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
            this.buffer = new BufferList();
            this.length = 0;
            this.pipes = null;
            this.pipesCount = 0;
            this.flowing = null;
            this.ended = false;
            this.endEmitted = false;
            this.reading = false;
            this.sync = true;
            this.needReadable = false;
            this.emittedReadable = false;
            this.readableListening = false;
            this.resumeScheduled = false;
            this.paused = true;
            this.emitClose = options.emitClose !== false;
            this.destroyed = false;
            this.defaultEncoding = options.defaultEncoding || "utf8";
            this.awaitDrain = 0;
            this.readingMore = false;
            this.decoder = null;
            this.encoding = null;
            if (options.encoding) {
              if (!StringDecoder)
                StringDecoder = require2("string_decoder/").StringDecoder;
              this.decoder = new StringDecoder(options.encoding);
              this.encoding = options.encoding;
            }
          }
          function Readable(options) {
            Duplex = Duplex || require2("./_stream_duplex");
            if (!(this instanceof Readable))
              return new Readable(options);
            var isDuplex = this instanceof Duplex;
            this._readableState = new ReadableState(options, this, isDuplex);
            this.readable = true;
            if (options) {
              if (typeof options.read === "function")
                this._read = options.read;
              if (typeof options.destroy === "function")
                this._destroy = options.destroy;
            }
            Stream.call(this);
          }
          Object.defineProperty(Readable.prototype, "destroyed", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              if (this._readableState === void 0) {
                return false;
              }
              return this._readableState.destroyed;
            },
            set: function set(value) {
              if (!this._readableState) {
                return;
              }
              this._readableState.destroyed = value;
            }
          });
          Readable.prototype.destroy = destroyImpl.destroy;
          Readable.prototype._undestroy = destroyImpl.undestroy;
          Readable.prototype._destroy = function(err, cb) {
            cb(err);
          };
          Readable.prototype.push = function(chunk, encoding) {
            var state = this._readableState;
            var skipChunkCheck;
            if (!state.objectMode) {
              if (typeof chunk === "string") {
                encoding = encoding || state.defaultEncoding;
                if (encoding !== state.encoding) {
                  chunk = Buffer.from(chunk, encoding);
                  encoding = "";
                }
                skipChunkCheck = true;
              }
            } else {
              skipChunkCheck = true;
            }
            return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
          };
          Readable.prototype.unshift = function(chunk) {
            return readableAddChunk(this, chunk, null, true, false);
          };
          function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
            debug("readableAddChunk", chunk);
            var state = stream._readableState;
            if (chunk === null) {
              state.reading = false;
              onEofChunk(stream, state);
            } else {
              var er;
              if (!skipChunkCheck)
                er = chunkInvalid(state, chunk);
              if (er) {
                stream.emit("error", er);
              } else if (state.objectMode || chunk && chunk.length > 0) {
                if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                  chunk = _uint8ArrayToBuffer(chunk);
                }
                if (addToFront) {
                  if (state.endEmitted)
                    stream.emit("error", new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                  else
                    addChunk(stream, state, chunk, true);
                } else if (state.ended) {
                  stream.emit("error", new ERR_STREAM_PUSH_AFTER_EOF());
                } else if (state.destroyed) {
                  return false;
                } else {
                  state.reading = false;
                  if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0)
                      addChunk(stream, state, chunk, false);
                    else
                      maybeReadMore(stream, state);
                  } else {
                    addChunk(stream, state, chunk, false);
                  }
                }
              } else if (!addToFront) {
                state.reading = false;
                maybeReadMore(stream, state);
              }
            }
            return !state.ended && (state.length < state.highWaterMark || state.length === 0);
          }
          function addChunk(stream, state, chunk, addToFront) {
            if (state.flowing && state.length === 0 && !state.sync) {
              state.awaitDrain = 0;
              stream.emit("data", chunk);
            } else {
              state.length += state.objectMode ? 1 : chunk.length;
              if (addToFront)
                state.buffer.unshift(chunk);
              else
                state.buffer.push(chunk);
              if (state.needReadable)
                emitReadable(stream);
            }
            maybeReadMore(stream, state);
          }
          function chunkInvalid(state, chunk) {
            var er;
            if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
              er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
            }
            return er;
          }
          Readable.prototype.isPaused = function() {
            return this._readableState.flowing === false;
          };
          Readable.prototype.setEncoding = function(enc) {
            if (!StringDecoder)
              StringDecoder = require2("string_decoder/").StringDecoder;
            this._readableState.decoder = new StringDecoder(enc);
            this._readableState.encoding = this._readableState.decoder.encoding;
            return this;
          };
          var MAX_HWM = 8388608;
          function computeNewHighWaterMark(n) {
            if (n >= MAX_HWM) {
              n = MAX_HWM;
            } else {
              n--;
              n |= n >>> 1;
              n |= n >>> 2;
              n |= n >>> 4;
              n |= n >>> 8;
              n |= n >>> 16;
              n++;
            }
            return n;
          }
          function howMuchToRead(n, state) {
            if (n <= 0 || state.length === 0 && state.ended)
              return 0;
            if (state.objectMode)
              return 1;
            if (n !== n) {
              if (state.flowing && state.length)
                return state.buffer.head.data.length;
              else
                return state.length;
            }
            if (n > state.highWaterMark)
              state.highWaterMark = computeNewHighWaterMark(n);
            if (n <= state.length)
              return n;
            if (!state.ended) {
              state.needReadable = true;
              return 0;
            }
            return state.length;
          }
          Readable.prototype.read = function(n) {
            debug("read", n);
            n = parseInt(n, 10);
            var state = this._readableState;
            var nOrig = n;
            if (n !== 0)
              state.emittedReadable = false;
            if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
              debug("read: emitReadable", state.length, state.ended);
              if (state.length === 0 && state.ended)
                endReadable(this);
              else
                emitReadable(this);
              return null;
            }
            n = howMuchToRead(n, state);
            if (n === 0 && state.ended) {
              if (state.length === 0)
                endReadable(this);
              return null;
            }
            var doRead = state.needReadable;
            debug("need readable", doRead);
            if (state.length === 0 || state.length - n < state.highWaterMark) {
              doRead = true;
              debug("length less than watermark", doRead);
            }
            if (state.ended || state.reading) {
              doRead = false;
              debug("reading or ended", doRead);
            } else if (doRead) {
              debug("do read");
              state.reading = true;
              state.sync = true;
              if (state.length === 0)
                state.needReadable = true;
              this._read(state.highWaterMark);
              state.sync = false;
              if (!state.reading)
                n = howMuchToRead(nOrig, state);
            }
            var ret;
            if (n > 0)
              ret = fromList(n, state);
            else
              ret = null;
            if (ret === null) {
              state.needReadable = true;
              n = 0;
            } else {
              state.length -= n;
              state.awaitDrain = 0;
            }
            if (state.length === 0) {
              if (!state.ended)
                state.needReadable = true;
              if (nOrig !== n && state.ended)
                endReadable(this);
            }
            if (ret !== null)
              this.emit("data", ret);
            return ret;
          };
          function onEofChunk(stream, state) {
            if (state.ended)
              return;
            if (state.decoder) {
              var chunk = state.decoder.end();
              if (chunk && chunk.length) {
                state.buffer.push(chunk);
                state.length += state.objectMode ? 1 : chunk.length;
              }
            }
            state.ended = true;
            if (state.sync) {
              emitReadable(stream);
            } else {
              state.needReadable = false;
              if (!state.emittedReadable) {
                state.emittedReadable = true;
                emitReadable_(stream);
              }
            }
          }
          function emitReadable(stream) {
            var state = stream._readableState;
            state.needReadable = false;
            if (!state.emittedReadable) {
              debug("emitReadable", state.flowing);
              state.emittedReadable = true;
              process.nextTick(emitReadable_, stream);
            }
          }
          function emitReadable_(stream) {
            var state = stream._readableState;
            debug("emitReadable_", state.destroyed, state.length, state.ended);
            if (!state.destroyed && (state.length || state.ended)) {
              stream.emit("readable");
            }
            state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
            flow(stream);
          }
          function maybeReadMore(stream, state) {
            if (!state.readingMore) {
              state.readingMore = true;
              process.nextTick(maybeReadMore_, stream, state);
            }
          }
          function maybeReadMore_(stream, state) {
            while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
              var len = state.length;
              debug("maybeReadMore read 0");
              stream.read(0);
              if (len === state.length)
                break;
            }
            state.readingMore = false;
          }
          Readable.prototype._read = function(n) {
            this.emit("error", new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
          };
          Readable.prototype.pipe = function(dest, pipeOpts) {
            var src = this;
            var state = this._readableState;
            switch (state.pipesCount) {
              case 0:
                state.pipes = dest;
                break;
              case 1:
                state.pipes = [state.pipes, dest];
                break;
              default:
                state.pipes.push(dest);
                break;
            }
            state.pipesCount += 1;
            debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
            var endFn = doEnd ? onend : unpipe;
            if (state.endEmitted)
              process.nextTick(endFn);
            else
              src.once("end", endFn);
            dest.on("unpipe", onunpipe);
            function onunpipe(readable, unpipeInfo) {
              debug("onunpipe");
              if (readable === src) {
                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                  unpipeInfo.hasUnpiped = true;
                  cleanup();
                }
              }
            }
            function onend() {
              debug("onend");
              dest.end();
            }
            var ondrain = pipeOnDrain(src);
            dest.on("drain", ondrain);
            var cleanedUp = false;
            function cleanup() {
              debug("cleanup");
              dest.removeListener("close", onclose);
              dest.removeListener("finish", onfinish);
              dest.removeListener("drain", ondrain);
              dest.removeListener("error", onerror);
              dest.removeListener("unpipe", onunpipe);
              src.removeListener("end", onend);
              src.removeListener("end", unpipe);
              src.removeListener("data", ondata);
              cleanedUp = true;
              if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                ondrain();
            }
            src.on("data", ondata);
            function ondata(chunk) {
              debug("ondata");
              var ret = dest.write(chunk);
              debug("dest.write", ret);
              if (ret === false) {
                if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                  debug("false write response, pause", state.awaitDrain);
                  state.awaitDrain++;
                }
                src.pause();
              }
            }
            function onerror(er) {
              debug("onerror", er);
              unpipe();
              dest.removeListener("error", onerror);
              if (EElistenerCount(dest, "error") === 0)
                dest.emit("error", er);
            }
            prependListener(dest, "error", onerror);
            function onclose() {
              dest.removeListener("finish", onfinish);
              unpipe();
            }
            dest.once("close", onclose);
            function onfinish() {
              debug("onfinish");
              dest.removeListener("close", onclose);
              unpipe();
            }
            dest.once("finish", onfinish);
            function unpipe() {
              debug("unpipe");
              src.unpipe(dest);
            }
            dest.emit("pipe", src);
            if (!state.flowing) {
              debug("pipe resume");
              src.resume();
            }
            return dest;
          };
          function pipeOnDrain(src) {
            return function pipeOnDrainFunctionResult() {
              var state = src._readableState;
              debug("pipeOnDrain", state.awaitDrain);
              if (state.awaitDrain)
                state.awaitDrain--;
              if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                state.flowing = true;
                flow(src);
              }
            };
          }
          Readable.prototype.unpipe = function(dest) {
            var state = this._readableState;
            var unpipeInfo = {
              hasUnpiped: false
            };
            if (state.pipesCount === 0)
              return this;
            if (state.pipesCount === 1) {
              if (dest && dest !== state.pipes)
                return this;
              if (!dest)
                dest = state.pipes;
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              if (dest)
                dest.emit("unpipe", this, unpipeInfo);
              return this;
            }
            if (!dest) {
              var dests = state.pipes;
              var len = state.pipesCount;
              state.pipes = null;
              state.pipesCount = 0;
              state.flowing = false;
              for (var i = 0; i < len; i++) {
                dests[i].emit("unpipe", this, {
                  hasUnpiped: false
                });
              }
              return this;
            }
            var index = indexOf(state.pipes, dest);
            if (index === -1)
              return this;
            state.pipes.splice(index, 1);
            state.pipesCount -= 1;
            if (state.pipesCount === 1)
              state.pipes = state.pipes[0];
            dest.emit("unpipe", this, unpipeInfo);
            return this;
          };
          Readable.prototype.on = function(ev, fn) {
            var res = Stream.prototype.on.call(this, ev, fn);
            var state = this._readableState;
            if (ev === "data") {
              state.readableListening = this.listenerCount("readable") > 0;
              if (state.flowing !== false)
                this.resume();
            } else if (ev === "readable") {
              if (!state.endEmitted && !state.readableListening) {
                state.readableListening = state.needReadable = true;
                state.flowing = false;
                state.emittedReadable = false;
                debug("on readable", state.length, state.reading);
                if (state.length) {
                  emitReadable(this);
                } else if (!state.reading) {
                  process.nextTick(nReadingNextTick, this);
                }
              }
            }
            return res;
          };
          Readable.prototype.addListener = Readable.prototype.on;
          Readable.prototype.removeListener = function(ev, fn) {
            var res = Stream.prototype.removeListener.call(this, ev, fn);
            if (ev === "readable") {
              process.nextTick(updateReadableListening, this);
            }
            return res;
          };
          Readable.prototype.removeAllListeners = function(ev) {
            var res = Stream.prototype.removeAllListeners.apply(this, arguments);
            if (ev === "readable" || ev === void 0) {
              process.nextTick(updateReadableListening, this);
            }
            return res;
          };
          function updateReadableListening(self2) {
            var state = self2._readableState;
            state.readableListening = self2.listenerCount("readable") > 0;
            if (state.resumeScheduled && !state.paused) {
              state.flowing = true;
            } else if (self2.listenerCount("data") > 0) {
              self2.resume();
            }
          }
          function nReadingNextTick(self2) {
            debug("readable nexttick read 0");
            self2.read(0);
          }
          Readable.prototype.resume = function() {
            var state = this._readableState;
            if (!state.flowing) {
              debug("resume");
              state.flowing = !state.readableListening;
              resume(this, state);
            }
            state.paused = false;
            return this;
          };
          function resume(stream, state) {
            if (!state.resumeScheduled) {
              state.resumeScheduled = true;
              process.nextTick(resume_, stream, state);
            }
          }
          function resume_(stream, state) {
            debug("resume", state.reading);
            if (!state.reading) {
              stream.read(0);
            }
            state.resumeScheduled = false;
            stream.emit("resume");
            flow(stream);
            if (state.flowing && !state.reading)
              stream.read(0);
          }
          Readable.prototype.pause = function() {
            debug("call pause flowing=%j", this._readableState.flowing);
            if (this._readableState.flowing !== false) {
              debug("pause");
              this._readableState.flowing = false;
              this.emit("pause");
            }
            this._readableState.paused = true;
            return this;
          };
          function flow(stream) {
            var state = stream._readableState;
            debug("flow", state.flowing);
            while (state.flowing && stream.read() !== null) {
              ;
            }
          }
          Readable.prototype.wrap = function(stream) {
            var _this = this;
            var state = this._readableState;
            var paused = false;
            stream.on("end", function() {
              debug("wrapped end");
              if (state.decoder && !state.ended) {
                var chunk = state.decoder.end();
                if (chunk && chunk.length)
                  _this.push(chunk);
              }
              _this.push(null);
            });
            stream.on("data", function(chunk) {
              debug("wrapped data");
              if (state.decoder)
                chunk = state.decoder.write(chunk);
              if (state.objectMode && (chunk === null || chunk === void 0))
                return;
              else if (!state.objectMode && (!chunk || !chunk.length))
                return;
              var ret = _this.push(chunk);
              if (!ret) {
                paused = true;
                stream.pause();
              }
            });
            for (var i in stream) {
              if (this[i] === void 0 && typeof stream[i] === "function") {
                this[i] = function methodWrap(method) {
                  return function methodWrapReturnFunction() {
                    return stream[method].apply(stream, arguments);
                  };
                }(i);
              }
            }
            for (var n = 0; n < kProxyEvents.length; n++) {
              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
            }
            this._read = function(n2) {
              debug("wrapped _read", n2);
              if (paused) {
                paused = false;
                stream.resume();
              }
            };
            return this;
          };
          if (typeof Symbol === "function") {
            Readable.prototype[Symbol.asyncIterator] = function() {
              emitExperimentalWarning("Readable[Symbol.asyncIterator]");
              if (createReadableStreamAsyncIterator === void 0) {
                createReadableStreamAsyncIterator = require2("./internal/streams/async_iterator");
              }
              return createReadableStreamAsyncIterator(this);
            };
          }
          Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._readableState.highWaterMark;
            }
          });
          Object.defineProperty(Readable.prototype, "readableBuffer", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._readableState && this._readableState.buffer;
            }
          });
          Object.defineProperty(Readable.prototype, "readableFlowing", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._readableState.flowing;
            },
            set: function set(state) {
              if (this._readableState) {
                this._readableState.flowing = state;
              }
            }
          });
          Readable._fromList = fromList;
          Object.defineProperty(Readable.prototype, "readableLength", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._readableState.length;
            }
          });
          function fromList(n, state) {
            if (state.length === 0)
              return null;
            var ret;
            if (state.objectMode)
              ret = state.buffer.shift();
            else if (!n || n >= state.length) {
              if (state.decoder)
                ret = state.buffer.join("");
              else if (state.buffer.length === 1)
                ret = state.buffer.first();
              else
                ret = state.buffer.concat(state.length);
              state.buffer.clear();
            } else {
              ret = state.buffer.consume(n, state.decoder);
            }
            return ret;
          }
          function endReadable(stream) {
            var state = stream._readableState;
            debug("endReadable", state.endEmitted);
            if (!state.endEmitted) {
              state.ended = true;
              process.nextTick(endReadableNT, state, stream);
            }
          }
          function endReadableNT(state, stream) {
            debug("endReadableNT", state.endEmitted, state.length);
            if (!state.endEmitted && state.length === 0) {
              state.endEmitted = true;
              stream.readable = false;
              stream.emit("end");
            }
          }
          function indexOf(xs, x) {
            for (var i = 0, l = xs.length; i < l; i++) {
              if (xs[i] === x)
                return i;
            }
            return -1;
          }
        }).call(this, require2("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "../errors": 160, "../experimentalWarning": 161, "./_stream_duplex": 162, "./internal/streams/async_iterator": 167, "./internal/streams/buffer_list": 168, "./internal/streams/destroy": 169, "./internal/streams/state": 172, "./internal/streams/stream": 173, "_process": 133, "buffer": 48, "events": 52, "inherits": 75, "string_decoder/": 175, "util": 33 }], 165: [function(require2, module3, exports3) {
        "use strict";
        module3.exports = Transform;
        var _require$codes = require2("../errors").codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
        var Duplex = require2("./_stream_duplex");
        require2("inherits")(Transform, Duplex);
        function afterTransform(er, data) {
          var ts = this._transformState;
          ts.transforming = false;
          var cb = ts.writecb;
          if (cb === null) {
            return this.emit("error", new ERR_MULTIPLE_CALLBACK());
          }
          ts.writechunk = null;
          ts.writecb = null;
          if (data != null)
            this.push(data);
          cb(er);
          var rs = this._readableState;
          rs.reading = false;
          if (rs.needReadable || rs.length < rs.highWaterMark) {
            this._read(rs.highWaterMark);
          }
        }
        function Transform(options) {
          if (!(this instanceof Transform))
            return new Transform(options);
          Duplex.call(this, options);
          this._transformState = {
            afterTransform: afterTransform.bind(this),
            needTransform: false,
            transforming: false,
            writecb: null,
            writechunk: null,
            writeencoding: null
          };
          this._readableState.needReadable = true;
          this._readableState.sync = false;
          if (options) {
            if (typeof options.transform === "function")
              this._transform = options.transform;
            if (typeof options.flush === "function")
              this._flush = options.flush;
          }
          this.on("prefinish", prefinish);
        }
        function prefinish() {
          var _this = this;
          if (typeof this._flush === "function" && !this._readableState.destroyed) {
            this._flush(function(er, data) {
              done(_this, er, data);
            });
          } else {
            done(this, null, null);
          }
        }
        Transform.prototype.push = function(chunk, encoding) {
          this._transformState.needTransform = false;
          return Duplex.prototype.push.call(this, chunk, encoding);
        };
        Transform.prototype._transform = function(chunk, encoding, cb) {
          cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
        };
        Transform.prototype._write = function(chunk, encoding, cb) {
          var ts = this._transformState;
          ts.writecb = cb;
          ts.writechunk = chunk;
          ts.writeencoding = encoding;
          if (!ts.transforming) {
            var rs = this._readableState;
            if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
              this._read(rs.highWaterMark);
          }
        };
        Transform.prototype._read = function(n) {
          var ts = this._transformState;
          if (ts.writechunk !== null && !ts.transforming) {
            ts.transforming = true;
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
          } else {
            ts.needTransform = true;
          }
        };
        Transform.prototype._destroy = function(err, cb) {
          Duplex.prototype._destroy.call(this, err, function(err2) {
            cb(err2);
          });
        };
        function done(stream, er, data) {
          if (er)
            return stream.emit("error", er);
          if (data != null)
            stream.push(data);
          if (stream._writableState.length)
            throw new ERR_TRANSFORM_WITH_LENGTH_0();
          if (stream._transformState.transforming)
            throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
          return stream.push(null);
        }
      }, { "../errors": 160, "./_stream_duplex": 162, "inherits": 75 }], 166: [function(require2, module3, exports3) {
        (function(process, global2) {
          "use strict";
          module3.exports = Writable;
          function WriteReq(chunk, encoding, cb) {
            this.chunk = chunk;
            this.encoding = encoding;
            this.callback = cb;
            this.next = null;
          }
          function CorkedRequest(state) {
            var _this = this;
            this.next = null;
            this.entry = null;
            this.finish = function() {
              onCorkedFinish(_this, state);
            };
          }
          var Duplex;
          Writable.WritableState = WritableState;
          var internalUtil = {
            deprecate: require2("util-deprecate")
          };
          var Stream = require2("./internal/streams/stream");
          var Buffer = require2("buffer").Buffer;
          var OurUint8Array = global2.Uint8Array || function() {
          };
          function _uint8ArrayToBuffer(chunk) {
            return Buffer.from(chunk);
          }
          function _isUint8Array(obj) {
            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
          }
          var destroyImpl = require2("./internal/streams/destroy");
          var _require = require2("./internal/streams/state"), getHighWaterMark = _require.getHighWaterMark;
          var _require$codes = require2("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
          require2("inherits")(Writable, Stream);
          function nop() {
          }
          function WritableState(options, stream, isDuplex) {
            Duplex = Duplex || require2("./_stream_duplex");
            options = options || {};
            if (typeof isDuplex !== "boolean")
              isDuplex = stream instanceof Duplex;
            this.objectMode = !!options.objectMode;
            if (isDuplex)
              this.objectMode = this.objectMode || !!options.writableObjectMode;
            this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
            this.finalCalled = false;
            this.needDrain = false;
            this.ending = false;
            this.ended = false;
            this.finished = false;
            this.destroyed = false;
            var noDecode = options.decodeStrings === false;
            this.decodeStrings = !noDecode;
            this.defaultEncoding = options.defaultEncoding || "utf8";
            this.length = 0;
            this.writing = false;
            this.corked = 0;
            this.sync = true;
            this.bufferProcessing = false;
            this.onwrite = function(er) {
              onwrite(stream, er);
            };
            this.writecb = null;
            this.writelen = 0;
            this.bufferedRequest = null;
            this.lastBufferedRequest = null;
            this.pendingcb = 0;
            this.prefinished = false;
            this.errorEmitted = false;
            this.emitClose = options.emitClose !== false;
            this.bufferedRequestCount = 0;
            this.corkedRequestsFree = new CorkedRequest(this);
          }
          WritableState.prototype.getBuffer = function getBuffer() {
            var current = this.bufferedRequest;
            var out = [];
            while (current) {
              out.push(current);
              current = current.next;
            }
            return out;
          };
          (function() {
            try {
              Object.defineProperty(WritableState.prototype, "buffer", {
                get: internalUtil.deprecate(function writableStateBufferGetter() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
              });
            } catch (_) {
            }
          })();
          var realHasInstance;
          if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
            realHasInstance = Function.prototype[Symbol.hasInstance];
            Object.defineProperty(Writable, Symbol.hasInstance, {
              value: function value(object) {
                if (realHasInstance.call(this, object))
                  return true;
                if (this !== Writable)
                  return false;
                return object && object._writableState instanceof WritableState;
              }
            });
          } else {
            realHasInstance = function realHasInstance2(object) {
              return object instanceof this;
            };
          }
          function Writable(options) {
            Duplex = Duplex || require2("./_stream_duplex");
            var isDuplex = this instanceof Duplex;
            if (!isDuplex && !realHasInstance.call(Writable, this))
              return new Writable(options);
            this._writableState = new WritableState(options, this, isDuplex);
            this.writable = true;
            if (options) {
              if (typeof options.write === "function")
                this._write = options.write;
              if (typeof options.writev === "function")
                this._writev = options.writev;
              if (typeof options.destroy === "function")
                this._destroy = options.destroy;
              if (typeof options.final === "function")
                this._final = options.final;
            }
            Stream.call(this);
          }
          Writable.prototype.pipe = function() {
            this.emit("error", new ERR_STREAM_CANNOT_PIPE());
          };
          function writeAfterEnd(stream, cb) {
            var er = new ERR_STREAM_WRITE_AFTER_END();
            stream.emit("error", er);
            process.nextTick(cb, er);
          }
          function validChunk(stream, state, chunk, cb) {
            var er;
            if (chunk === null) {
              er = new ERR_STREAM_NULL_VALUES();
            } else if (typeof chunk !== "string" && !state.objectMode) {
              er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
            }
            if (er) {
              stream.emit("error", er);
              process.nextTick(cb, er);
              return false;
            }
            return true;
          }
          Writable.prototype.write = function(chunk, encoding, cb) {
            var state = this._writableState;
            var ret = false;
            var isBuf = !state.objectMode && _isUint8Array(chunk);
            if (isBuf && !Buffer.isBuffer(chunk)) {
              chunk = _uint8ArrayToBuffer(chunk);
            }
            if (typeof encoding === "function") {
              cb = encoding;
              encoding = null;
            }
            if (isBuf)
              encoding = "buffer";
            else if (!encoding)
              encoding = state.defaultEncoding;
            if (typeof cb !== "function")
              cb = nop;
            if (state.ending)
              writeAfterEnd(this, cb);
            else if (isBuf || validChunk(this, state, chunk, cb)) {
              state.pendingcb++;
              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
            }
            return ret;
          };
          Writable.prototype.cork = function() {
            this._writableState.corked++;
          };
          Writable.prototype.uncork = function() {
            var state = this._writableState;
            if (state.corked) {
              state.corked--;
              if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
                clearBuffer(this, state);
            }
          };
          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
            if (typeof encoding === "string")
              encoding = encoding.toLowerCase();
            if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
              throw new ERR_UNKNOWN_ENCODING(encoding);
            this._writableState.defaultEncoding = encoding;
            return this;
          };
          Object.defineProperty(Writable.prototype, "writableBuffer", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState && this._writableState.getBuffer();
            }
          });
          function decodeChunk(state, chunk, encoding) {
            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
              chunk = Buffer.from(chunk, encoding);
            }
            return chunk;
          }
          Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState.highWaterMark;
            }
          });
          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
            if (!isBuf) {
              var newChunk = decodeChunk(state, chunk, encoding);
              if (chunk !== newChunk) {
                isBuf = true;
                encoding = "buffer";
                chunk = newChunk;
              }
            }
            var len = state.objectMode ? 1 : chunk.length;
            state.length += len;
            var ret = state.length < state.highWaterMark;
            if (!ret)
              state.needDrain = true;
            if (state.writing || state.corked) {
              var last = state.lastBufferedRequest;
              state.lastBufferedRequest = {
                chunk,
                encoding,
                isBuf,
                callback: cb,
                next: null
              };
              if (last) {
                last.next = state.lastBufferedRequest;
              } else {
                state.bufferedRequest = state.lastBufferedRequest;
              }
              state.bufferedRequestCount += 1;
            } else {
              doWrite(stream, state, false, len, chunk, encoding, cb);
            }
            return ret;
          }
          function doWrite(stream, state, writev, len, chunk, encoding, cb) {
            state.writelen = len;
            state.writecb = cb;
            state.writing = true;
            state.sync = true;
            if (state.destroyed)
              state.onwrite(new ERR_STREAM_DESTROYED("write"));
            else if (writev)
              stream._writev(chunk, state.onwrite);
            else
              stream._write(chunk, encoding, state.onwrite);
            state.sync = false;
          }
          function onwriteError(stream, state, sync, er, cb) {
            --state.pendingcb;
            if (sync) {
              process.nextTick(cb, er);
              process.nextTick(finishMaybe, stream, state);
              stream._writableState.errorEmitted = true;
              stream.emit("error", er);
            } else {
              cb(er);
              stream._writableState.errorEmitted = true;
              stream.emit("error", er);
              finishMaybe(stream, state);
            }
          }
          function onwriteStateUpdate(state) {
            state.writing = false;
            state.writecb = null;
            state.length -= state.writelen;
            state.writelen = 0;
          }
          function onwrite(stream, er) {
            var state = stream._writableState;
            var sync = state.sync;
            var cb = state.writecb;
            if (typeof cb !== "function")
              throw new ERR_MULTIPLE_CALLBACK();
            onwriteStateUpdate(state);
            if (er)
              onwriteError(stream, state, sync, er, cb);
            else {
              var finished = needFinish(state) || stream.destroyed;
              if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                clearBuffer(stream, state);
              }
              if (sync) {
                process.nextTick(afterWrite, stream, state, finished, cb);
              } else {
                afterWrite(stream, state, finished, cb);
              }
            }
          }
          function afterWrite(stream, state, finished, cb) {
            if (!finished)
              onwriteDrain(stream, state);
            state.pendingcb--;
            cb();
            finishMaybe(stream, state);
          }
          function onwriteDrain(stream, state) {
            if (state.length === 0 && state.needDrain) {
              state.needDrain = false;
              stream.emit("drain");
            }
          }
          function clearBuffer(stream, state) {
            state.bufferProcessing = true;
            var entry = state.bufferedRequest;
            if (stream._writev && entry && entry.next) {
              var l = state.bufferedRequestCount;
              var buffer = new Array(l);
              var holder = state.corkedRequestsFree;
              holder.entry = entry;
              var count = 0;
              var allBuffers = true;
              while (entry) {
                buffer[count] = entry;
                if (!entry.isBuf)
                  allBuffers = false;
                entry = entry.next;
                count += 1;
              }
              buffer.allBuffers = allBuffers;
              doWrite(stream, state, true, state.length, buffer, "", holder.finish);
              state.pendingcb++;
              state.lastBufferedRequest = null;
              if (holder.next) {
                state.corkedRequestsFree = holder.next;
                holder.next = null;
              } else {
                state.corkedRequestsFree = new CorkedRequest(state);
              }
              state.bufferedRequestCount = 0;
            } else {
              while (entry) {
                var chunk = entry.chunk;
                var encoding = entry.encoding;
                var cb = entry.callback;
                var len = state.objectMode ? 1 : chunk.length;
                doWrite(stream, state, false, len, chunk, encoding, cb);
                entry = entry.next;
                state.bufferedRequestCount--;
                if (state.writing) {
                  break;
                }
              }
              if (entry === null)
                state.lastBufferedRequest = null;
            }
            state.bufferedRequest = entry;
            state.bufferProcessing = false;
          }
          Writable.prototype._write = function(chunk, encoding, cb) {
            cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
          };
          Writable.prototype._writev = null;
          Writable.prototype.end = function(chunk, encoding, cb) {
            var state = this._writableState;
            if (typeof chunk === "function") {
              cb = chunk;
              chunk = null;
              encoding = null;
            } else if (typeof encoding === "function") {
              cb = encoding;
              encoding = null;
            }
            if (chunk !== null && chunk !== void 0)
              this.write(chunk, encoding);
            if (state.corked) {
              state.corked = 1;
              this.uncork();
            }
            if (!state.ending)
              endWritable(this, state, cb);
            return this;
          };
          Object.defineProperty(Writable.prototype, "writableLength", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              return this._writableState.length;
            }
          });
          function needFinish(state) {
            return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
          }
          function callFinal(stream, state) {
            stream._final(function(err) {
              state.pendingcb--;
              if (err) {
                stream.emit("error", err);
              }
              state.prefinished = true;
              stream.emit("prefinish");
              finishMaybe(stream, state);
            });
          }
          function prefinish(stream, state) {
            if (!state.prefinished && !state.finalCalled) {
              if (typeof stream._final === "function" && !state.destroyed) {
                state.pendingcb++;
                state.finalCalled = true;
                process.nextTick(callFinal, stream, state);
              } else {
                state.prefinished = true;
                stream.emit("prefinish");
              }
            }
          }
          function finishMaybe(stream, state) {
            var need = needFinish(state);
            if (need) {
              prefinish(stream, state);
              if (state.pendingcb === 0) {
                state.finished = true;
                stream.emit("finish");
              }
            }
            return need;
          }
          function endWritable(stream, state, cb) {
            state.ending = true;
            finishMaybe(stream, state);
            if (cb) {
              if (state.finished)
                process.nextTick(cb);
              else
                stream.once("finish", cb);
            }
            state.ended = true;
            stream.writable = false;
          }
          function onCorkedFinish(corkReq, state, err) {
            var entry = corkReq.entry;
            corkReq.entry = null;
            while (entry) {
              var cb = entry.callback;
              state.pendingcb--;
              cb(err);
              entry = entry.next;
            }
            state.corkedRequestsFree.next = corkReq;
          }
          Object.defineProperty(Writable.prototype, "destroyed", {
            // making it explicit this property is not enumerable
            // because otherwise some prototype manipulation in
            // userland will fail
            enumerable: false,
            get: function get() {
              if (this._writableState === void 0) {
                return false;
              }
              return this._writableState.destroyed;
            },
            set: function set(value) {
              if (!this._writableState) {
                return;
              }
              this._writableState.destroyed = value;
            }
          });
          Writable.prototype.destroy = destroyImpl.destroy;
          Writable.prototype._undestroy = destroyImpl.undestroy;
          Writable.prototype._destroy = function(err, cb) {
            cb(err);
          };
        }).call(this, require2("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, { "../errors": 160, "./_stream_duplex": 162, "./internal/streams/destroy": 169, "./internal/streams/state": 172, "./internal/streams/stream": 173, "_process": 133, "buffer": 48, "inherits": 75, "util-deprecate": 183 }], 167: [function(require2, module3, exports3) {
        (function(process) {
          "use strict";
          var _Object$setPrototypeO;
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          var finished = require2("./end-of-stream");
          var kLastResolve = Symbol("lastResolve");
          var kLastReject = Symbol("lastReject");
          var kError = Symbol("error");
          var kEnded = Symbol("ended");
          var kLastPromise = Symbol("lastPromise");
          var kHandlePromise = Symbol("handlePromise");
          var kStream = Symbol("stream");
          function createIterResult(value, done) {
            return {
              value,
              done
            };
          }
          function readAndResolve(iter) {
            var resolve = iter[kLastResolve];
            if (resolve !== null) {
              var data = iter[kStream].read();
              if (data !== null) {
                iter[kLastPromise] = null;
                iter[kLastResolve] = null;
                iter[kLastReject] = null;
                resolve(createIterResult(data, false));
              }
            }
          }
          function onReadable(iter) {
            process.nextTick(readAndResolve, iter);
          }
          function wrapForNext(lastPromise, iter) {
            return function(resolve, reject) {
              lastPromise.then(function() {
                if (iter[kEnded]) {
                  resolve(createIterResult(void 0, true));
                  return;
                }
                iter[kHandlePromise](resolve, reject);
              }, reject);
            };
          }
          var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
          });
          var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
            get stream() {
              return this[kStream];
            },
            next: function next() {
              var _this = this;
              var error = this[kError];
              if (error !== null) {
                return Promise.reject(error);
              }
              if (this[kEnded]) {
                return Promise.resolve(createIterResult(void 0, true));
              }
              if (this[kStream].destroyed) {
                return new Promise(function(resolve, reject) {
                  process.nextTick(function() {
                    if (_this[kError]) {
                      reject(_this[kError]);
                    } else {
                      resolve(createIterResult(void 0, true));
                    }
                  });
                });
              }
              var lastPromise = this[kLastPromise];
              var promise;
              if (lastPromise) {
                promise = new Promise(wrapForNext(lastPromise, this));
              } else {
                var data = this[kStream].read();
                if (data !== null) {
                  return Promise.resolve(createIterResult(data, false));
                }
                promise = new Promise(this[kHandlePromise]);
              }
              this[kLastPromise] = promise;
              return promise;
            }
          }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
            return this;
          }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
            var _this2 = this;
            return new Promise(function(resolve, reject) {
              _this2[kStream].destroy(null, function(err) {
                if (err) {
                  reject(err);
                  return;
                }
                resolve(createIterResult(void 0, true));
              });
            });
          }), _Object$setPrototypeO), AsyncIteratorPrototype);
          var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
            var _Object$create;
            var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
              value: stream,
              writable: true
            }), _defineProperty(_Object$create, kLastResolve, {
              value: null,
              writable: true
            }), _defineProperty(_Object$create, kLastReject, {
              value: null,
              writable: true
            }), _defineProperty(_Object$create, kError, {
              value: null,
              writable: true
            }), _defineProperty(_Object$create, kEnded, {
              value: stream._readableState.endEmitted,
              writable: true
            }), _defineProperty(_Object$create, kHandlePromise, {
              value: function value(resolve, reject) {
                var data = iterator[kStream].read();
                if (data) {
                  iterator[kLastPromise] = null;
                  iterator[kLastResolve] = null;
                  iterator[kLastReject] = null;
                  resolve(createIterResult(data, false));
                } else {
                  iterator[kLastResolve] = resolve;
                  iterator[kLastReject] = reject;
                }
              },
              writable: true
            }), _Object$create));
            iterator[kLastPromise] = null;
            finished(stream, function(err) {
              if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var reject = iterator[kLastReject];
                if (reject !== null) {
                  iterator[kLastPromise] = null;
                  iterator[kLastResolve] = null;
                  iterator[kLastReject] = null;
                  reject(err);
                }
                iterator[kError] = err;
                return;
              }
              var resolve = iterator[kLastResolve];
              if (resolve !== null) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(void 0, true));
              }
              iterator[kEnded] = true;
            });
            stream.on("readable", onReadable.bind(null, iterator));
            return iterator;
          };
          module3.exports = createReadableStreamAsyncIterator;
        }).call(this, require2("_process"));
      }, { "./end-of-stream": 170, "_process": 133 }], 168: [function(require2, module3, exports3) {
        "use strict";
        function _objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            var ownKeys = Object.keys(source);
            if (typeof Object.getOwnPropertySymbols === "function") {
              ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
              }));
            }
            ownKeys.forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          }
          return target;
        }
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        var _require = require2("buffer"), Buffer = _require.Buffer;
        var _require2 = require2("util"), inspect = _require2.inspect;
        var custom = inspect && inspect.custom || "inspect";
        function copyBuffer(src, target, offset) {
          Buffer.prototype.copy.call(src, target, offset);
        }
        module3.exports = function() {
          function BufferList() {
            this.head = null;
            this.tail = null;
            this.length = 0;
          }
          var _proto = BufferList.prototype;
          _proto.push = function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0)
              this.tail.next = entry;
            else
              this.head = entry;
            this.tail = entry;
            ++this.length;
          };
          _proto.unshift = function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0)
              this.tail = entry;
            this.head = entry;
            ++this.length;
          };
          _proto.shift = function shift() {
            if (this.length === 0)
              return;
            var ret = this.head.data;
            if (this.length === 1)
              this.head = this.tail = null;
            else
              this.head = this.head.next;
            --this.length;
            return ret;
          };
          _proto.clear = function clear() {
            this.head = this.tail = null;
            this.length = 0;
          };
          _proto.join = function join(s) {
            if (this.length === 0)
              return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) {
              ret += s + p.data;
            }
            return ret;
          };
          _proto.concat = function concat(n) {
            if (this.length === 0)
              return Buffer.alloc(0);
            var ret = Buffer.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          };
          _proto.consume = function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          };
          _proto.first = function first() {
            return this.head.data;
          };
          _proto._getString = function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length)
                ret += str;
              else
                ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          };
          _proto._getBuffer = function _getBuffer(n) {
            var ret = Buffer.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next)
                    this.head = p.next;
                  else
                    this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          };
          _proto[custom] = function(_, options) {
            return inspect(this, _objectSpread({}, options, {
              // Only inspect one level.
              depth: 0,
              // It should not recurse.
              customInspect: false
            }));
          };
          return BufferList;
        }();
      }, { "buffer": 48, "util": 33 }], 169: [function(require2, module3, exports3) {
        (function(process) {
          "use strict";
          function destroy(err, cb) {
            var _this = this;
            var readableDestroyed = this._readableState && this._readableState.destroyed;
            var writableDestroyed = this._writableState && this._writableState.destroyed;
            if (readableDestroyed || writableDestroyed) {
              if (cb) {
                cb(err);
              } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
                process.nextTick(emitErrorNT, this, err);
              }
              return this;
            }
            if (this._readableState) {
              this._readableState.destroyed = true;
            }
            if (this._writableState) {
              this._writableState.destroyed = true;
            }
            this._destroy(err || null, function(err2) {
              if (!cb && err2) {
                process.nextTick(emitErrorAndCloseNT, _this, err2);
                if (_this._writableState) {
                  _this._writableState.errorEmitted = true;
                }
              } else if (cb) {
                process.nextTick(emitCloseNT, _this);
                cb(err2);
              } else {
                process.nextTick(emitCloseNT, _this);
              }
            });
            return this;
          }
          function emitErrorAndCloseNT(self2, err) {
            emitErrorNT(self2, err);
            emitCloseNT(self2);
          }
          function emitCloseNT(self2) {
            if (self2._writableState && !self2._writableState.emitClose)
              return;
            if (self2._readableState && !self2._readableState.emitClose)
              return;
            self2.emit("close");
          }
          function undestroy() {
            if (this._readableState) {
              this._readableState.destroyed = false;
              this._readableState.reading = false;
              this._readableState.ended = false;
              this._readableState.endEmitted = false;
            }
            if (this._writableState) {
              this._writableState.destroyed = false;
              this._writableState.ended = false;
              this._writableState.ending = false;
              this._writableState.finalCalled = false;
              this._writableState.prefinished = false;
              this._writableState.finished = false;
              this._writableState.errorEmitted = false;
            }
          }
          function emitErrorNT(self2, err) {
            self2.emit("error", err);
          }
          module3.exports = {
            destroy,
            undestroy
          };
        }).call(this, require2("_process"));
      }, { "_process": 133 }], 170: [function(require2, module3, exports3) {
        "use strict";
        var ERR_STREAM_PREMATURE_CLOSE = require2("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
        function once(callback) {
          var called = false;
          return function() {
            if (called)
              return;
            called = true;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            callback.apply(this, args);
          };
        }
        function noop() {
        }
        function isRequest(stream) {
          return stream.setHeader && typeof stream.abort === "function";
        }
        function eos(stream, opts, callback) {
          if (typeof opts === "function")
            return eos(stream, null, opts);
          if (!opts)
            opts = {};
          callback = once(callback || noop);
          var readable = opts.readable || opts.readable !== false && stream.readable;
          var writable = opts.writable || opts.writable !== false && stream.writable;
          var onlegacyfinish = function onlegacyfinish2() {
            if (!stream.writable)
              onfinish();
          };
          var writableEnded = stream._writableState && stream._writableState.finished;
          var onfinish = function onfinish2() {
            writable = false;
            writableEnded = true;
            if (!readable)
              callback.call(stream);
          };
          var readableEnded = stream._readableState && stream._readableState.endEmitted;
          var onend = function onend2() {
            readable = false;
            readableEnded = true;
            if (!writable)
              callback.call(stream);
          };
          var onerror = function onerror2(err) {
            callback.call(stream, err);
          };
          var onclose = function onclose2() {
            var err;
            if (readable && !readableEnded) {
              if (!stream._readableState || !stream._readableState.ended)
                err = new ERR_STREAM_PREMATURE_CLOSE();
              return callback.call(stream, err);
            }
            if (writable && !writableEnded) {
              if (!stream._writableState || !stream._writableState.ended)
                err = new ERR_STREAM_PREMATURE_CLOSE();
              return callback.call(stream, err);
            }
          };
          var onrequest = function onrequest2() {
            stream.req.on("finish", onfinish);
          };
          if (isRequest(stream)) {
            stream.on("complete", onfinish);
            stream.on("abort", onclose);
            if (stream.req)
              onrequest();
            else
              stream.on("request", onrequest);
          } else if (writable && !stream._writableState) {
            stream.on("end", onlegacyfinish);
            stream.on("close", onlegacyfinish);
          }
          stream.on("end", onend);
          stream.on("finish", onfinish);
          if (opts.error !== false)
            stream.on("error", onerror);
          stream.on("close", onclose);
          return function() {
            stream.removeListener("complete", onfinish);
            stream.removeListener("abort", onclose);
            stream.removeListener("request", onrequest);
            if (stream.req)
              stream.req.removeListener("finish", onfinish);
            stream.removeListener("end", onlegacyfinish);
            stream.removeListener("close", onlegacyfinish);
            stream.removeListener("finish", onfinish);
            stream.removeListener("end", onend);
            stream.removeListener("error", onerror);
            stream.removeListener("close", onclose);
          };
        }
        module3.exports = eos;
      }, { "../../../errors": 160 }], 171: [function(require2, module3, exports3) {
        "use strict";
        var eos;
        function once(callback) {
          var called = false;
          return function() {
            if (called)
              return;
            called = true;
            callback.apply(void 0, arguments);
          };
        }
        var _require$codes = require2("../../../errors").codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
        function noop(err) {
          if (err)
            throw err;
        }
        function isRequest(stream) {
          return stream.setHeader && typeof stream.abort === "function";
        }
        function destroyer(stream, reading, writing, callback) {
          callback = once(callback);
          var closed = false;
          stream.on("close", function() {
            closed = true;
          });
          if (eos === void 0)
            eos = require2("./end-of-stream");
          eos(stream, {
            readable: reading,
            writable: writing
          }, function(err) {
            if (err)
              return callback(err);
            closed = true;
            callback();
          });
          var destroyed = false;
          return function(err) {
            if (closed)
              return;
            if (destroyed)
              return;
            destroyed = true;
            if (isRequest(stream))
              return stream.abort();
            if (typeof stream.destroy === "function")
              return stream.destroy();
            callback(err || new ERR_STREAM_DESTROYED("pipe"));
          };
        }
        function call(fn) {
          fn();
        }
        function pipe(from, to) {
          return from.pipe(to);
        }
        function popCallback(streams) {
          if (!streams.length)
            return noop;
          if (typeof streams[streams.length - 1] !== "function")
            return noop;
          return streams.pop();
        }
        function pipeline() {
          for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
            streams[_key] = arguments[_key];
          }
          var callback = popCallback(streams);
          if (Array.isArray(streams[0]))
            streams = streams[0];
          if (streams.length < 2) {
            throw new ERR_MISSING_ARGS("streams");
          }
          var error;
          var destroys = streams.map(function(stream, i) {
            var reading = i < streams.length - 1;
            var writing = i > 0;
            return destroyer(stream, reading, writing, function(err) {
              if (!error)
                error = err;
              if (err)
                destroys.forEach(call);
              if (reading)
                return;
              destroys.forEach(call);
              callback(error);
            });
          });
          return streams.reduce(pipe);
        }
        module3.exports = pipeline;
      }, { "../../../errors": 160, "./end-of-stream": 170 }], 172: [function(require2, module3, exports3) {
        "use strict";
        var ERR_INVALID_OPT_VALUE = require2("../../../errors").codes.ERR_INVALID_OPT_VALUE;
        function highWaterMarkFrom(options, isDuplex, duplexKey) {
          return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
        }
        function getHighWaterMark(state, options, duplexKey, isDuplex) {
          var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
          if (hwm != null) {
            if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
              var name = isDuplex ? duplexKey : "highWaterMark";
              throw new ERR_INVALID_OPT_VALUE(name, hwm);
            }
            return Math.floor(hwm);
          }
          return state.objectMode ? 16 : 16 * 1024;
        }
        module3.exports = {
          getHighWaterMark
        };
      }, { "../../../errors": 160 }], 173: [function(require2, module3, exports3) {
        arguments[4][146][0].apply(exports3, arguments);
      }, { "dup": 146, "events": 52 }], 174: [function(require2, module3, exports3) {
        exports3 = module3.exports = require2("./lib/_stream_readable.js");
        exports3.Stream = exports3;
        exports3.Readable = exports3;
        exports3.Writable = require2("./lib/_stream_writable.js");
        exports3.Duplex = require2("./lib/_stream_duplex.js");
        exports3.Transform = require2("./lib/_stream_transform.js");
        exports3.PassThrough = require2("./lib/_stream_passthrough.js");
        exports3.finished = require2("./lib/internal/streams/end-of-stream.js");
        exports3.pipeline = require2("./lib/internal/streams/pipeline.js");
      }, { "./lib/_stream_duplex.js": 162, "./lib/_stream_passthrough.js": 163, "./lib/_stream_readable.js": 164, "./lib/_stream_transform.js": 165, "./lib/_stream_writable.js": 166, "./lib/internal/streams/end-of-stream.js": 170, "./lib/internal/streams/pipeline.js": 171 }], 175: [function(require2, module3, exports3) {
        arguments[4][148][0].apply(exports3, arguments);
      }, { "dup": 148, "safe-buffer": 154 }], 176: [function(require2, module3, exports3) {
        (function(setImmediate, clearImmediate) {
          var nextTick = require2("process/browser.js").nextTick;
          var apply = Function.prototype.apply;
          var slice = Array.prototype.slice;
          var immediateIds = {};
          var nextImmediateId = 0;
          exports3.setTimeout = function() {
            return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
          };
          exports3.setInterval = function() {
            return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
          };
          exports3.clearTimeout = exports3.clearInterval = function(timeout) {
            timeout.close();
          };
          function Timeout(id, clearFn) {
            this._id = id;
            this._clearFn = clearFn;
          }
          Timeout.prototype.unref = Timeout.prototype.ref = function() {
          };
          Timeout.prototype.close = function() {
            this._clearFn.call(window, this._id);
          };
          exports3.enroll = function(item, msecs) {
            clearTimeout(item._idleTimeoutId);
            item._idleTimeout = msecs;
          };
          exports3.unenroll = function(item) {
            clearTimeout(item._idleTimeoutId);
            item._idleTimeout = -1;
          };
          exports3._unrefActive = exports3.active = function(item) {
            clearTimeout(item._idleTimeoutId);
            var msecs = item._idleTimeout;
            if (msecs >= 0) {
              item._idleTimeoutId = setTimeout(function onTimeout() {
                if (item._onTimeout)
                  item._onTimeout();
              }, msecs);
            }
          };
          exports3.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
            var id = nextImmediateId++;
            var args = arguments.length < 2 ? false : slice.call(arguments, 1);
            immediateIds[id] = true;
            nextTick(function onNextTick() {
              if (immediateIds[id]) {
                if (args) {
                  fn.apply(null, args);
                } else {
                  fn.call(null);
                }
                exports3.clearImmediate(id);
              }
            });
            return id;
          };
          exports3.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
            delete immediateIds[id];
          };
        }).call(this, require2("timers").setImmediate, require2("timers").clearImmediate);
      }, { "process/browser.js": 133, "timers": 176 }], 177: [function(require2, module3, exports3) {
        (function(process) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
            return typeof obj;
          } : function(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
          exports3.clone = clone;
          exports3.addLast = addLast;
          exports3.addFirst = addFirst;
          exports3.removeLast = removeLast;
          exports3.removeFirst = removeFirst;
          exports3.insert = insert;
          exports3.removeAt = removeAt;
          exports3.replaceAt = replaceAt;
          exports3.getIn = getIn;
          exports3.set = set;
          exports3.setIn = setIn;
          exports3.update = update;
          exports3.updateIn = updateIn;
          exports3.merge = merge;
          exports3.mergeDeep = mergeDeep;
          exports3.mergeIn = mergeIn;
          exports3.omit = omit;
          exports3.addDefaults = addDefaults;
          var INVALID_ARGS = "INVALID_ARGS";
          function throwStr(msg) {
            throw new Error(msg);
          }
          function getKeysAndSymbols(obj) {
            var keys = Object.keys(obj);
            if (Object.getOwnPropertySymbols) {
              return keys.concat(Object.getOwnPropertySymbols(obj));
            }
            return keys;
          }
          var hasOwnProperty = {}.hasOwnProperty;
          function clone(obj) {
            if (Array.isArray(obj))
              return obj.slice();
            var keys = getKeysAndSymbols(obj);
            var out = {};
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              out[key] = obj[key];
            }
            return out;
          }
          function doMerge(fAddDefaults, fDeep, first) {
            var out = first;
            !(out != null) && throwStr(process.env.NODE_ENV !== "production" ? "At least one object should be provided to merge()" : INVALID_ARGS);
            var fChanged = false;
            for (var _len = arguments.length, rest = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
              rest[_key - 3] = arguments[_key];
            }
            for (var idx = 0; idx < rest.length; idx++) {
              var obj = rest[idx];
              if (obj == null)
                continue;
              var keys = getKeysAndSymbols(obj);
              if (!keys.length)
                continue;
              for (var j = 0; j <= keys.length; j++) {
                var key = keys[j];
                if (fAddDefaults && out[key] !== void 0)
                  continue;
                var nextVal = obj[key];
                if (fDeep && isObject(out[key]) && isObject(nextVal)) {
                  nextVal = doMerge(fAddDefaults, fDeep, out[key], nextVal);
                }
                if (nextVal === void 0 || nextVal === out[key])
                  continue;
                if (!fChanged) {
                  fChanged = true;
                  out = clone(out);
                }
                out[key] = nextVal;
              }
            }
            return out;
          }
          function isObject(o) {
            var type = typeof o === "undefined" ? "undefined" : _typeof(o);
            return o != null && type === "object";
          }
          function addLast(array, val) {
            if (Array.isArray(val))
              return array.concat(val);
            return array.concat([val]);
          }
          function addFirst(array, val) {
            if (Array.isArray(val))
              return val.concat(array);
            return [val].concat(array);
          }
          function removeLast(array) {
            if (!array.length)
              return array;
            return array.slice(0, array.length - 1);
          }
          function removeFirst(array) {
            if (!array.length)
              return array;
            return array.slice(1);
          }
          function insert(array, idx, val) {
            return array.slice(0, idx).concat(Array.isArray(val) ? val : [val]).concat(array.slice(idx));
          }
          function removeAt(array, idx) {
            if (idx >= array.length || idx < 0)
              return array;
            return array.slice(0, idx).concat(array.slice(idx + 1));
          }
          function replaceAt(array, idx, newItem) {
            if (array[idx] === newItem)
              return array;
            var len = array.length;
            var result = Array(len);
            for (var i = 0; i < len; i++) {
              result[i] = array[i];
            }
            result[idx] = newItem;
            return result;
          }
          function getIn(obj, path) {
            !Array.isArray(path) && throwStr(process.env.NODE_ENV !== "production" ? "A path array should be provided when calling getIn()" : INVALID_ARGS);
            if (obj == null)
              return void 0;
            var ptr = obj;
            for (var i = 0; i < path.length; i++) {
              var key = path[i];
              ptr = ptr != null ? ptr[key] : void 0;
              if (ptr === void 0)
                return ptr;
            }
            return ptr;
          }
          function set(obj, key, val) {
            var fallback = typeof key === "number" ? [] : {};
            var finalObj = obj == null ? fallback : obj;
            if (finalObj[key] === val)
              return finalObj;
            var obj2 = clone(finalObj);
            obj2[key] = val;
            return obj2;
          }
          function doSetIn(obj, path, val, idx) {
            var newValue = void 0;
            var key = path[idx];
            if (idx === path.length - 1) {
              newValue = val;
            } else {
              var nestedObj = isObject(obj) && isObject(obj[key]) ? obj[key] : typeof path[idx + 1] === "number" ? [] : {};
              newValue = doSetIn(nestedObj, path, val, idx + 1);
            }
            return set(obj, key, newValue);
          }
          function setIn(obj, path, val) {
            if (!path.length)
              return val;
            return doSetIn(obj, path, val, 0);
          }
          function update(obj, key, fnUpdate) {
            var prevVal = obj == null ? void 0 : obj[key];
            var nextVal = fnUpdate(prevVal);
            return set(obj, key, nextVal);
          }
          function updateIn(obj, path, fnUpdate) {
            var prevVal = getIn(obj, path);
            var nextVal = fnUpdate(prevVal);
            return setIn(obj, path, nextVal);
          }
          function merge(a, b, c, d, e, f) {
            for (var _len2 = arguments.length, rest = Array(_len2 > 6 ? _len2 - 6 : 0), _key2 = 6; _key2 < _len2; _key2++) {
              rest[_key2 - 6] = arguments[_key2];
            }
            return rest.length ? doMerge.call.apply(doMerge, [null, false, false, a, b, c, d, e, f].concat(rest)) : doMerge(false, false, a, b, c, d, e, f);
          }
          function mergeDeep(a, b, c, d, e, f) {
            for (var _len3 = arguments.length, rest = Array(_len3 > 6 ? _len3 - 6 : 0), _key3 = 6; _key3 < _len3; _key3++) {
              rest[_key3 - 6] = arguments[_key3];
            }
            return rest.length ? doMerge.call.apply(doMerge, [null, false, true, a, b, c, d, e, f].concat(rest)) : doMerge(false, true, a, b, c, d, e, f);
          }
          function mergeIn(a, path, b, c, d, e, f) {
            var prevVal = getIn(a, path);
            if (prevVal == null)
              prevVal = {};
            var nextVal = void 0;
            for (var _len4 = arguments.length, rest = Array(_len4 > 7 ? _len4 - 7 : 0), _key4 = 7; _key4 < _len4; _key4++) {
              rest[_key4 - 7] = arguments[_key4];
            }
            if (rest.length) {
              nextVal = doMerge.call.apply(doMerge, [null, false, false, prevVal, b, c, d, e, f].concat(rest));
            } else {
              nextVal = doMerge(false, false, prevVal, b, c, d, e, f);
            }
            return setIn(a, path, nextVal);
          }
          function omit(obj, attrs) {
            var omitList = Array.isArray(attrs) ? attrs : [attrs];
            var fDoSomething = false;
            for (var i = 0; i < omitList.length; i++) {
              if (hasOwnProperty.call(obj, omitList[i])) {
                fDoSomething = true;
                break;
              }
            }
            if (!fDoSomething)
              return obj;
            var out = {};
            var keys = getKeysAndSymbols(obj);
            for (var _i = 0; _i < keys.length; _i++) {
              var key = keys[_i];
              if (omitList.indexOf(key) >= 0)
                continue;
              out[key] = obj[key];
            }
            return out;
          }
          function addDefaults(a, b, c, d, e, f) {
            for (var _len5 = arguments.length, rest = Array(_len5 > 6 ? _len5 - 6 : 0), _key5 = 6; _key5 < _len5; _key5++) {
              rest[_key5 - 6] = arguments[_key5];
            }
            return rest.length ? doMerge.call.apply(doMerge, [null, true, false, a, b, c, d, e, f].concat(rest)) : doMerge(true, false, a, b, c, d, e, f);
          }
          var timm = {
            clone,
            addLast,
            addFirst,
            removeLast,
            removeFirst,
            insert,
            removeAt,
            replaceAt,
            getIn,
            // eslint-disable-next-line object-shorthand
            set,
            // so that flow doesn't complain
            setIn,
            update,
            updateIn,
            merge,
            mergeDeep,
            mergeIn,
            omit,
            addDefaults
          };
          exports3.default = timm;
        }).call(this, require2("_process"));
      }, { "_process": 133 }], 178: [function(require2, module3, exports3) {
        (function(Math2) {
          var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math2.round, mathMin = Math2.min, mathMax = Math2.max, mathRandom = Math2.random;
          function tinycolor(color, opts) {
            color = color ? color : "";
            opts = opts || {};
            if (color instanceof tinycolor) {
              return color;
            }
            if (!(this instanceof tinycolor)) {
              return new tinycolor(color, opts);
            }
            var rgb = inputToRGB(color);
            this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
            this._gradientType = opts.gradientType;
            if (this._r < 1) {
              this._r = mathRound(this._r);
            }
            if (this._g < 1) {
              this._g = mathRound(this._g);
            }
            if (this._b < 1) {
              this._b = mathRound(this._b);
            }
            this._ok = rgb.ok;
            this._tc_id = tinyCounter++;
          }
          tinycolor.prototype = {
            isDark: function() {
              return this.getBrightness() < 128;
            },
            isLight: function() {
              return !this.isDark();
            },
            isValid: function() {
              return this._ok;
            },
            getOriginalInput: function() {
              return this._originalInput;
            },
            getFormat: function() {
              return this._format;
            },
            getAlpha: function() {
              return this._a;
            },
            getBrightness: function() {
              var rgb = this.toRgb();
              return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
            },
            getLuminance: function() {
              var rgb = this.toRgb();
              var RsRGB, GsRGB, BsRGB, R, G, B;
              RsRGB = rgb.r / 255;
              GsRGB = rgb.g / 255;
              BsRGB = rgb.b / 255;
              if (RsRGB <= 0.03928) {
                R = RsRGB / 12.92;
              } else {
                R = Math2.pow((RsRGB + 0.055) / 1.055, 2.4);
              }
              if (GsRGB <= 0.03928) {
                G = GsRGB / 12.92;
              } else {
                G = Math2.pow((GsRGB + 0.055) / 1.055, 2.4);
              }
              if (BsRGB <= 0.03928) {
                B = BsRGB / 12.92;
              } else {
                B = Math2.pow((BsRGB + 0.055) / 1.055, 2.4);
              }
              return 0.2126 * R + 0.7152 * G + 0.0722 * B;
            },
            setAlpha: function(value) {
              this._a = boundAlpha(value);
              this._roundA = mathRound(100 * this._a) / 100;
              return this;
            },
            toHsv: function() {
              var hsv = rgbToHsv(this._r, this._g, this._b);
              return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
            },
            toHsvString: function() {
              var hsv = rgbToHsv(this._r, this._g, this._b);
              var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
              return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
            },
            toHsl: function() {
              var hsl = rgbToHsl(this._r, this._g, this._b);
              return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
            },
            toHslString: function() {
              var hsl = rgbToHsl(this._r, this._g, this._b);
              var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
              return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
            },
            toHex: function(allow3Char) {
              return rgbToHex(this._r, this._g, this._b, allow3Char);
            },
            toHexString: function(allow3Char) {
              return "#" + this.toHex(allow3Char);
            },
            toHex8: function(allow4Char) {
              return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
            },
            toHex8String: function(allow4Char) {
              return "#" + this.toHex8(allow4Char);
            },
            toRgb: function() {
              return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
            },
            toRgbString: function() {
              return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
            },
            toPercentageRgb: function() {
              return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
            },
            toPercentageRgbString: function() {
              return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
            },
            toName: function() {
              if (this._a === 0) {
                return "transparent";
              }
              if (this._a < 1) {
                return false;
              }
              return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
            },
            toFilter: function(secondColor) {
              var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
              var secondHex8String = hex8String;
              var gradientType = this._gradientType ? "GradientType = 1, " : "";
              if (secondColor) {
                var s = tinycolor(secondColor);
                secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
              }
              return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
            },
            toString: function(format) {
              var formatSet = !!format;
              format = format || this._format;
              var formattedString = false;
              var hasAlpha = this._a < 1 && this._a >= 0;
              var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
              if (needsAlphaFormat) {
                if (format === "name" && this._a === 0) {
                  return this.toName();
                }
                return this.toRgbString();
              }
              if (format === "rgb") {
                formattedString = this.toRgbString();
              }
              if (format === "prgb") {
                formattedString = this.toPercentageRgbString();
              }
              if (format === "hex" || format === "hex6") {
                formattedString = this.toHexString();
              }
              if (format === "hex3") {
                formattedString = this.toHexString(true);
              }
              if (format === "hex4") {
                formattedString = this.toHex8String(true);
              }
              if (format === "hex8") {
                formattedString = this.toHex8String();
              }
              if (format === "name") {
                formattedString = this.toName();
              }
              if (format === "hsl") {
                formattedString = this.toHslString();
              }
              if (format === "hsv") {
                formattedString = this.toHsvString();
              }
              return formattedString || this.toHexString();
            },
            clone: function() {
              return tinycolor(this.toString());
            },
            _applyModification: function(fn, args) {
              var color = fn.apply(null, [this].concat([].slice.call(args)));
              this._r = color._r;
              this._g = color._g;
              this._b = color._b;
              this.setAlpha(color._a);
              return this;
            },
            lighten: function() {
              return this._applyModification(lighten, arguments);
            },
            brighten: function() {
              return this._applyModification(brighten, arguments);
            },
            darken: function() {
              return this._applyModification(darken, arguments);
            },
            desaturate: function() {
              return this._applyModification(desaturate, arguments);
            },
            saturate: function() {
              return this._applyModification(saturate, arguments);
            },
            greyscale: function() {
              return this._applyModification(greyscale, arguments);
            },
            spin: function() {
              return this._applyModification(spin, arguments);
            },
            _applyCombination: function(fn, args) {
              return fn.apply(null, [this].concat([].slice.call(args)));
            },
            analogous: function() {
              return this._applyCombination(analogous, arguments);
            },
            complement: function() {
              return this._applyCombination(complement, arguments);
            },
            monochromatic: function() {
              return this._applyCombination(monochromatic, arguments);
            },
            splitcomplement: function() {
              return this._applyCombination(splitcomplement, arguments);
            },
            triad: function() {
              return this._applyCombination(triad, arguments);
            },
            tetrad: function() {
              return this._applyCombination(tetrad, arguments);
            }
          };
          tinycolor.fromRatio = function(color, opts) {
            if (typeof color == "object") {
              var newColor = {};
              for (var i in color) {
                if (color.hasOwnProperty(i)) {
                  if (i === "a") {
                    newColor[i] = color[i];
                  } else {
                    newColor[i] = convertToPercentage(color[i]);
                  }
                }
              }
              color = newColor;
            }
            return tinycolor(color, opts);
          };
          function inputToRGB(color) {
            var rgb = { r: 0, g: 0, b: 0 };
            var a = 1;
            var s = null;
            var v = null;
            var l = null;
            var ok = false;
            var format = false;
            if (typeof color == "string") {
              color = stringInputToObject(color);
            }
            if (typeof color == "object") {
              if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
                rgb = rgbToRgb(color.r, color.g, color.b);
                ok = true;
                format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
              } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
                s = convertToPercentage(color.s);
                v = convertToPercentage(color.v);
                rgb = hsvToRgb(color.h, s, v);
                ok = true;
                format = "hsv";
              } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
                s = convertToPercentage(color.s);
                l = convertToPercentage(color.l);
                rgb = hslToRgb(color.h, s, l);
                ok = true;
                format = "hsl";
              }
              if (color.hasOwnProperty("a")) {
                a = color.a;
              }
            }
            a = boundAlpha(a);
            return {
              ok,
              format: color.format || format,
              r: mathMin(255, mathMax(rgb.r, 0)),
              g: mathMin(255, mathMax(rgb.g, 0)),
              b: mathMin(255, mathMax(rgb.b, 0)),
              a
            };
          }
          function rgbToRgb(r, g, b) {
            return {
              r: bound01(r, 255) * 255,
              g: bound01(g, 255) * 255,
              b: bound01(b, 255) * 255
            };
          }
          function rgbToHsl(r, g, b) {
            r = bound01(r, 255);
            g = bound01(g, 255);
            b = bound01(b, 255);
            var max = mathMax(r, g, b), min = mathMin(r, g, b);
            var h, s, l = (max + min) / 2;
            if (max == min) {
              h = s = 0;
            } else {
              var d = max - min;
              s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
              switch (max) {
                case r:
                  h = (g - b) / d + (g < b ? 6 : 0);
                  break;
                case g:
                  h = (b - r) / d + 2;
                  break;
                case b:
                  h = (r - g) / d + 4;
                  break;
              }
              h /= 6;
            }
            return { h, s, l };
          }
          function hslToRgb(h, s, l) {
            var r, g, b;
            h = bound01(h, 360);
            s = bound01(s, 100);
            l = bound01(l, 100);
            function hue2rgb(p2, q2, t) {
              if (t < 0)
                t += 1;
              if (t > 1)
                t -= 1;
              if (t < 1 / 6)
                return p2 + (q2 - p2) * 6 * t;
              if (t < 1 / 2)
                return q2;
              if (t < 2 / 3)
                return p2 + (q2 - p2) * (2 / 3 - t) * 6;
              return p2;
            }
            if (s === 0) {
              r = g = b = l;
            } else {
              var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
              var p = 2 * l - q;
              r = hue2rgb(p, q, h + 1 / 3);
              g = hue2rgb(p, q, h);
              b = hue2rgb(p, q, h - 1 / 3);
            }
            return { r: r * 255, g: g * 255, b: b * 255 };
          }
          function rgbToHsv(r, g, b) {
            r = bound01(r, 255);
            g = bound01(g, 255);
            b = bound01(b, 255);
            var max = mathMax(r, g, b), min = mathMin(r, g, b);
            var h, s, v = max;
            var d = max - min;
            s = max === 0 ? 0 : d / max;
            if (max == min) {
              h = 0;
            } else {
              switch (max) {
                case r:
                  h = (g - b) / d + (g < b ? 6 : 0);
                  break;
                case g:
                  h = (b - r) / d + 2;
                  break;
                case b:
                  h = (r - g) / d + 4;
                  break;
              }
              h /= 6;
            }
            return { h, s, v };
          }
          function hsvToRgb(h, s, v) {
            h = bound01(h, 360) * 6;
            s = bound01(s, 100);
            v = bound01(v, 100);
            var i = Math2.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b = [p, p, t, v, v, q][mod];
            return { r: r * 255, g: g * 255, b: b * 255 };
          }
          function rgbToHex(r, g, b, allow3Char) {
            var hex = [
              pad2(mathRound(r).toString(16)),
              pad2(mathRound(g).toString(16)),
              pad2(mathRound(b).toString(16))
            ];
            if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
              return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
            }
            return hex.join("");
          }
          function rgbaToHex(r, g, b, a, allow4Char) {
            var hex = [
              pad2(mathRound(r).toString(16)),
              pad2(mathRound(g).toString(16)),
              pad2(mathRound(b).toString(16)),
              pad2(convertDecimalToHex(a))
            ];
            if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
              return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
            }
            return hex.join("");
          }
          function rgbaToArgbHex(r, g, b, a) {
            var hex = [
              pad2(convertDecimalToHex(a)),
              pad2(mathRound(r).toString(16)),
              pad2(mathRound(g).toString(16)),
              pad2(mathRound(b).toString(16))
            ];
            return hex.join("");
          }
          tinycolor.equals = function(color1, color2) {
            if (!color1 || !color2) {
              return false;
            }
            return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
          };
          tinycolor.random = function() {
            return tinycolor.fromRatio({
              r: mathRandom(),
              g: mathRandom(),
              b: mathRandom()
            });
          };
          function desaturate(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            hsl.s -= amount / 100;
            hsl.s = clamp01(hsl.s);
            return tinycolor(hsl);
          }
          function saturate(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            hsl.s += amount / 100;
            hsl.s = clamp01(hsl.s);
            return tinycolor(hsl);
          }
          function greyscale(color) {
            return tinycolor(color).desaturate(100);
          }
          function lighten(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            hsl.l += amount / 100;
            hsl.l = clamp01(hsl.l);
            return tinycolor(hsl);
          }
          function brighten(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var rgb = tinycolor(color).toRgb();
            rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
            rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
            rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
            return tinycolor(rgb);
          }
          function darken(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            hsl.l -= amount / 100;
            hsl.l = clamp01(hsl.l);
            return tinycolor(hsl);
          }
          function spin(color, amount) {
            var hsl = tinycolor(color).toHsl();
            var hue = (hsl.h + amount) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return tinycolor(hsl);
          }
          function complement(color) {
            var hsl = tinycolor(color).toHsl();
            hsl.h = (hsl.h + 180) % 360;
            return tinycolor(hsl);
          }
          function triad(color) {
            var hsl = tinycolor(color).toHsl();
            var h = hsl.h;
            return [
              tinycolor(color),
              tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
              tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
            ];
          }
          function tetrad(color) {
            var hsl = tinycolor(color).toHsl();
            var h = hsl.h;
            return [
              tinycolor(color),
              tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
              tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
              tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
            ];
          }
          function splitcomplement(color) {
            var hsl = tinycolor(color).toHsl();
            var h = hsl.h;
            return [
              tinycolor(color),
              tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
              tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
            ];
          }
          function analogous(color, results, slices) {
            results = results || 6;
            slices = slices || 30;
            var hsl = tinycolor(color).toHsl();
            var part = 360 / slices;
            var ret = [tinycolor(color)];
            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
              hsl.h = (hsl.h + part) % 360;
              ret.push(tinycolor(hsl));
            }
            return ret;
          }
          function monochromatic(color, results) {
            results = results || 6;
            var hsv = tinycolor(color).toHsv();
            var h = hsv.h, s = hsv.s, v = hsv.v;
            var ret = [];
            var modification = 1 / results;
            while (results--) {
              ret.push(tinycolor({ h, s, v }));
              v = (v + modification) % 1;
            }
            return ret;
          }
          tinycolor.mix = function(color1, color2, amount) {
            amount = amount === 0 ? 0 : amount || 50;
            var rgb1 = tinycolor(color1).toRgb();
            var rgb2 = tinycolor(color2).toRgb();
            var p = amount / 100;
            var rgba = {
              r: (rgb2.r - rgb1.r) * p + rgb1.r,
              g: (rgb2.g - rgb1.g) * p + rgb1.g,
              b: (rgb2.b - rgb1.b) * p + rgb1.b,
              a: (rgb2.a - rgb1.a) * p + rgb1.a
            };
            return tinycolor(rgba);
          };
          tinycolor.readability = function(color1, color2) {
            var c1 = tinycolor(color1);
            var c2 = tinycolor(color2);
            return (Math2.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math2.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
          };
          tinycolor.isReadable = function(color1, color2, wcag2) {
            var readability = tinycolor.readability(color1, color2);
            var wcag2Parms, out;
            out = false;
            wcag2Parms = validateWCAG2Parms(wcag2);
            switch (wcag2Parms.level + wcag2Parms.size) {
              case "AAsmall":
              case "AAAlarge":
                out = readability >= 4.5;
                break;
              case "AAlarge":
                out = readability >= 3;
                break;
              case "AAAsmall":
                out = readability >= 7;
                break;
            }
            return out;
          };
          tinycolor.mostReadable = function(baseColor, colorList, args) {
            var bestColor = null;
            var bestScore = 0;
            var readability;
            var includeFallbackColors, level, size;
            args = args || {};
            includeFallbackColors = args.includeFallbackColors;
            level = args.level;
            size = args.size;
            for (var i = 0; i < colorList.length; i++) {
              readability = tinycolor.readability(baseColor, colorList[i]);
              if (readability > bestScore) {
                bestScore = readability;
                bestColor = tinycolor(colorList[i]);
              }
            }
            if (tinycolor.isReadable(baseColor, bestColor, { "level": level, "size": size }) || !includeFallbackColors) {
              return bestColor;
            } else {
              args.includeFallbackColors = false;
              return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
            }
          };
          var names = tinycolor.names = {
            aliceblue: "f0f8ff",
            antiquewhite: "faebd7",
            aqua: "0ff",
            aquamarine: "7fffd4",
            azure: "f0ffff",
            beige: "f5f5dc",
            bisque: "ffe4c4",
            black: "000",
            blanchedalmond: "ffebcd",
            blue: "00f",
            blueviolet: "8a2be2",
            brown: "a52a2a",
            burlywood: "deb887",
            burntsienna: "ea7e5d",
            cadetblue: "5f9ea0",
            chartreuse: "7fff00",
            chocolate: "d2691e",
            coral: "ff7f50",
            cornflowerblue: "6495ed",
            cornsilk: "fff8dc",
            crimson: "dc143c",
            cyan: "0ff",
            darkblue: "00008b",
            darkcyan: "008b8b",
            darkgoldenrod: "b8860b",
            darkgray: "a9a9a9",
            darkgreen: "006400",
            darkgrey: "a9a9a9",
            darkkhaki: "bdb76b",
            darkmagenta: "8b008b",
            darkolivegreen: "556b2f",
            darkorange: "ff8c00",
            darkorchid: "9932cc",
            darkred: "8b0000",
            darksalmon: "e9967a",
            darkseagreen: "8fbc8f",
            darkslateblue: "483d8b",
            darkslategray: "2f4f4f",
            darkslategrey: "2f4f4f",
            darkturquoise: "00ced1",
            darkviolet: "9400d3",
            deeppink: "ff1493",
            deepskyblue: "00bfff",
            dimgray: "696969",
            dimgrey: "696969",
            dodgerblue: "1e90ff",
            firebrick: "b22222",
            floralwhite: "fffaf0",
            forestgreen: "228b22",
            fuchsia: "f0f",
            gainsboro: "dcdcdc",
            ghostwhite: "f8f8ff",
            gold: "ffd700",
            goldenrod: "daa520",
            gray: "808080",
            green: "008000",
            greenyellow: "adff2f",
            grey: "808080",
            honeydew: "f0fff0",
            hotpink: "ff69b4",
            indianred: "cd5c5c",
            indigo: "4b0082",
            ivory: "fffff0",
            khaki: "f0e68c",
            lavender: "e6e6fa",
            lavenderblush: "fff0f5",
            lawngreen: "7cfc00",
            lemonchiffon: "fffacd",
            lightblue: "add8e6",
            lightcoral: "f08080",
            lightcyan: "e0ffff",
            lightgoldenrodyellow: "fafad2",
            lightgray: "d3d3d3",
            lightgreen: "90ee90",
            lightgrey: "d3d3d3",
            lightpink: "ffb6c1",
            lightsalmon: "ffa07a",
            lightseagreen: "20b2aa",
            lightskyblue: "87cefa",
            lightslategray: "789",
            lightslategrey: "789",
            lightsteelblue: "b0c4de",
            lightyellow: "ffffe0",
            lime: "0f0",
            limegreen: "32cd32",
            linen: "faf0e6",
            magenta: "f0f",
            maroon: "800000",
            mediumaquamarine: "66cdaa",
            mediumblue: "0000cd",
            mediumorchid: "ba55d3",
            mediumpurple: "9370db",
            mediumseagreen: "3cb371",
            mediumslateblue: "7b68ee",
            mediumspringgreen: "00fa9a",
            mediumturquoise: "48d1cc",
            mediumvioletred: "c71585",
            midnightblue: "191970",
            mintcream: "f5fffa",
            mistyrose: "ffe4e1",
            moccasin: "ffe4b5",
            navajowhite: "ffdead",
            navy: "000080",
            oldlace: "fdf5e6",
            olive: "808000",
            olivedrab: "6b8e23",
            orange: "ffa500",
            orangered: "ff4500",
            orchid: "da70d6",
            palegoldenrod: "eee8aa",
            palegreen: "98fb98",
            paleturquoise: "afeeee",
            palevioletred: "db7093",
            papayawhip: "ffefd5",
            peachpuff: "ffdab9",
            peru: "cd853f",
            pink: "ffc0cb",
            plum: "dda0dd",
            powderblue: "b0e0e6",
            purple: "800080",
            rebeccapurple: "663399",
            red: "f00",
            rosybrown: "bc8f8f",
            royalblue: "4169e1",
            saddlebrown: "8b4513",
            salmon: "fa8072",
            sandybrown: "f4a460",
            seagreen: "2e8b57",
            seashell: "fff5ee",
            sienna: "a0522d",
            silver: "c0c0c0",
            skyblue: "87ceeb",
            slateblue: "6a5acd",
            slategray: "708090",
            slategrey: "708090",
            snow: "fffafa",
            springgreen: "00ff7f",
            steelblue: "4682b4",
            tan: "d2b48c",
            teal: "008080",
            thistle: "d8bfd8",
            tomato: "ff6347",
            turquoise: "40e0d0",
            violet: "ee82ee",
            wheat: "f5deb3",
            white: "fff",
            whitesmoke: "f5f5f5",
            yellow: "ff0",
            yellowgreen: "9acd32"
          };
          var hexNames = tinycolor.hexNames = flip(names);
          function flip(o) {
            var flipped = {};
            for (var i in o) {
              if (o.hasOwnProperty(i)) {
                flipped[o[i]] = i;
              }
            }
            return flipped;
          }
          function boundAlpha(a) {
            a = parseFloat(a);
            if (isNaN(a) || a < 0 || a > 1) {
              a = 1;
            }
            return a;
          }
          function bound01(n, max) {
            if (isOnePointZero(n)) {
              n = "100%";
            }
            var processPercent = isPercentage(n);
            n = mathMin(max, mathMax(0, parseFloat(n)));
            if (processPercent) {
              n = parseInt(n * max, 10) / 100;
            }
            if (Math2.abs(n - max) < 1e-6) {
              return 1;
            }
            return n % max / parseFloat(max);
          }
          function clamp01(val) {
            return mathMin(1, mathMax(0, val));
          }
          function parseIntFromHex(val) {
            return parseInt(val, 16);
          }
          function isOnePointZero(n) {
            return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
          }
          function isPercentage(n) {
            return typeof n === "string" && n.indexOf("%") != -1;
          }
          function pad2(c) {
            return c.length == 1 ? "0" + c : "" + c;
          }
          function convertToPercentage(n) {
            if (n <= 1) {
              n = n * 100 + "%";
            }
            return n;
          }
          function convertDecimalToHex(d) {
            return Math2.round(parseFloat(d) * 255).toString(16);
          }
          function convertHexToDecimal(h) {
            return parseIntFromHex(h) / 255;
          }
          var matchers = function() {
            var CSS_INTEGER = "[-\\+]?\\d+%?";
            var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
            var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
            var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
            var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
            return {
              CSS_UNIT: new RegExp(CSS_UNIT),
              rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
              rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
              hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
              hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
              hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
              hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
              hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
              hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
              hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
              hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
            };
          }();
          function isValidCSSUnit(color) {
            return !!matchers.CSS_UNIT.exec(color);
          }
          function stringInputToObject(color) {
            color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
            var named = false;
            if (names[color]) {
              color = names[color];
              named = true;
            } else if (color == "transparent") {
              return { r: 0, g: 0, b: 0, a: 0, format: "name" };
            }
            var match;
            if (match = matchers.rgb.exec(color)) {
              return { r: match[1], g: match[2], b: match[3] };
            }
            if (match = matchers.rgba.exec(color)) {
              return { r: match[1], g: match[2], b: match[3], a: match[4] };
            }
            if (match = matchers.hsl.exec(color)) {
              return { h: match[1], s: match[2], l: match[3] };
            }
            if (match = matchers.hsla.exec(color)) {
              return { h: match[1], s: match[2], l: match[3], a: match[4] };
            }
            if (match = matchers.hsv.exec(color)) {
              return { h: match[1], s: match[2], v: match[3] };
            }
            if (match = matchers.hsva.exec(color)) {
              return { h: match[1], s: match[2], v: match[3], a: match[4] };
            }
            if (match = matchers.hex8.exec(color)) {
              return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                a: convertHexToDecimal(match[4]),
                format: named ? "name" : "hex8"
              };
            }
            if (match = matchers.hex6.exec(color)) {
              return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                format: named ? "name" : "hex"
              };
            }
            if (match = matchers.hex4.exec(color)) {
              return {
                r: parseIntFromHex(match[1] + "" + match[1]),
                g: parseIntFromHex(match[2] + "" + match[2]),
                b: parseIntFromHex(match[3] + "" + match[3]),
                a: convertHexToDecimal(match[4] + "" + match[4]),
                format: named ? "name" : "hex8"
              };
            }
            if (match = matchers.hex3.exec(color)) {
              return {
                r: parseIntFromHex(match[1] + "" + match[1]),
                g: parseIntFromHex(match[2] + "" + match[2]),
                b: parseIntFromHex(match[3] + "" + match[3]),
                format: named ? "name" : "hex"
              };
            }
            return false;
          }
          function validateWCAG2Parms(parms) {
            var level, size;
            parms = parms || { "level": "AA", "size": "small" };
            level = (parms.level || "AA").toUpperCase();
            size = (parms.size || "small").toLowerCase();
            if (level !== "AA" && level !== "AAA") {
              level = "AA";
            }
            if (size !== "small" && size !== "large") {
              size = "small";
            }
            return { "level": level, "size": size };
          }
          if (typeof module3 !== "undefined" && module3.exports) {
            module3.exports = tinycolor;
          } else if (typeof define2 === "function" && define2.amd) {
            define2(function() {
              return tinycolor;
            });
          } else {
            window.tinycolor = tinycolor;
          }
        })(Math);
      }, {}], 179: [function(require2, module3, exports3) {
        exports3 = module3.exports = trim;
        function trim(str) {
          return str.replace(/^\s*|\s*$/g, "");
        }
        exports3.left = function(str) {
          return str.replace(/^\s*/, "");
        };
        exports3.right = function(str) {
          return str.replace(/\s*$/, "");
        };
      }, {}], 180: [function(require2, module3, exports3) {
        "use strict";
        var punycode = require2("punycode");
        var util = require2("./util");
        exports3.parse = urlParse;
        exports3.resolve = urlResolve;
        exports3.resolveObject = urlResolveObject;
        exports3.format = urlFormat;
        exports3.Url = Url;
        function Url() {
          this.protocol = null;
          this.slashes = null;
          this.auth = null;
          this.host = null;
          this.port = null;
          this.hostname = null;
          this.hash = null;
          this.search = null;
          this.query = null;
          this.pathname = null;
          this.path = null;
          this.href = null;
        }
        var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
          "javascript": true,
          "javascript:": true
        }, hostlessProtocol = {
          "javascript": true,
          "javascript:": true
        }, slashedProtocol = {
          "http": true,
          "https": true,
          "ftp": true,
          "gopher": true,
          "file": true,
          "http:": true,
          "https:": true,
          "ftp:": true,
          "gopher:": true,
          "file:": true
        }, querystring = require2("querystring");
        function urlParse(url, parseQueryString, slashesDenoteHost) {
          if (url && util.isObject(url) && url instanceof Url)
            return url;
          var u = new Url();
          u.parse(url, parseQueryString, slashesDenoteHost);
          return u;
        }
        Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
          if (!util.isString(url)) {
            throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
          }
          var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
          uSplit[0] = uSplit[0].replace(slashRegex, "/");
          url = uSplit.join(splitter);
          var rest = url;
          rest = rest.trim();
          if (!slashesDenoteHost && url.split("#").length === 1) {
            var simplePath = simplePathPattern.exec(rest);
            if (simplePath) {
              this.path = rest;
              this.href = rest;
              this.pathname = simplePath[1];
              if (simplePath[2]) {
                this.search = simplePath[2];
                if (parseQueryString) {
                  this.query = querystring.parse(this.search.substr(1));
                } else {
                  this.query = this.search.substr(1);
                }
              } else if (parseQueryString) {
                this.search = "";
                this.query = {};
              }
              return this;
            }
          }
          var proto = protocolPattern.exec(rest);
          if (proto) {
            proto = proto[0];
            var lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.substr(proto.length);
          }
          if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var slashes = rest.substr(0, 2) === "//";
            if (slashes && !(proto && hostlessProtocol[proto])) {
              rest = rest.substr(2);
              this.slashes = true;
            }
          }
          if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
            var hostEnd = -1;
            for (var i = 0; i < hostEndingChars.length; i++) {
              var hec = rest.indexOf(hostEndingChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            var auth, atSign;
            if (hostEnd === -1) {
              atSign = rest.lastIndexOf("@");
            } else {
              atSign = rest.lastIndexOf("@", hostEnd);
            }
            if (atSign !== -1) {
              auth = rest.slice(0, atSign);
              rest = rest.slice(atSign + 1);
              this.auth = decodeURIComponent(auth);
            }
            hostEnd = -1;
            for (var i = 0; i < nonHostChars.length; i++) {
              var hec = rest.indexOf(nonHostChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            if (hostEnd === -1)
              hostEnd = rest.length;
            this.host = rest.slice(0, hostEnd);
            rest = rest.slice(hostEnd);
            this.parseHost();
            this.hostname = this.hostname || "";
            var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
            if (!ipv6Hostname) {
              var hostparts = this.hostname.split(/\./);
              for (var i = 0, l = hostparts.length; i < l; i++) {
                var part = hostparts[i];
                if (!part)
                  continue;
                if (!part.match(hostnamePartPattern)) {
                  var newpart = "";
                  for (var j = 0, k = part.length; j < k; j++) {
                    if (part.charCodeAt(j) > 127) {
                      newpart += "x";
                    } else {
                      newpart += part[j];
                    }
                  }
                  if (!newpart.match(hostnamePartPattern)) {
                    var validParts = hostparts.slice(0, i);
                    var notHost = hostparts.slice(i + 1);
                    var bit = part.match(hostnamePartStart);
                    if (bit) {
                      validParts.push(bit[1]);
                      notHost.unshift(bit[2]);
                    }
                    if (notHost.length) {
                      rest = "/" + notHost.join(".") + rest;
                    }
                    this.hostname = validParts.join(".");
                    break;
                  }
                }
              }
            }
            if (this.hostname.length > hostnameMaxLen) {
              this.hostname = "";
            } else {
              this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
              this.hostname = punycode.toASCII(this.hostname);
            }
            var p = this.port ? ":" + this.port : "";
            var h = this.hostname || "";
            this.host = h + p;
            this.href += this.host;
            if (ipv6Hostname) {
              this.hostname = this.hostname.substr(1, this.hostname.length - 2);
              if (rest[0] !== "/") {
                rest = "/" + rest;
              }
            }
          }
          if (!unsafeProtocol[lowerProto]) {
            for (var i = 0, l = autoEscape.length; i < l; i++) {
              var ae = autoEscape[i];
              if (rest.indexOf(ae) === -1)
                continue;
              var esc = encodeURIComponent(ae);
              if (esc === ae) {
                esc = escape(ae);
              }
              rest = rest.split(ae).join(esc);
            }
          }
          var hash = rest.indexOf("#");
          if (hash !== -1) {
            this.hash = rest.substr(hash);
            rest = rest.slice(0, hash);
          }
          var qm = rest.indexOf("?");
          if (qm !== -1) {
            this.search = rest.substr(qm);
            this.query = rest.substr(qm + 1);
            if (parseQueryString) {
              this.query = querystring.parse(this.query);
            }
            rest = rest.slice(0, qm);
          } else if (parseQueryString) {
            this.search = "";
            this.query = {};
          }
          if (rest)
            this.pathname = rest;
          if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
            this.pathname = "/";
          }
          if (this.pathname || this.search) {
            var p = this.pathname || "";
            var s = this.search || "";
            this.path = p + s;
          }
          this.href = this.format();
          return this;
        };
        function urlFormat(obj) {
          if (util.isString(obj))
            obj = urlParse(obj);
          if (!(obj instanceof Url))
            return Url.prototype.format.call(obj);
          return obj.format();
        }
        Url.prototype.format = function() {
          var auth = this.auth || "";
          if (auth) {
            auth = encodeURIComponent(auth);
            auth = auth.replace(/%3A/i, ":");
            auth += "@";
          }
          var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
          if (this.host) {
            host = auth + this.host;
          } else if (this.hostname) {
            host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
            if (this.port) {
              host += ":" + this.port;
            }
          }
          if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
            query = querystring.stringify(this.query);
          }
          var search = this.search || query && "?" + query || "";
          if (protocol && protocol.substr(-1) !== ":")
            protocol += ":";
          if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
            host = "//" + (host || "");
            if (pathname && pathname.charAt(0) !== "/")
              pathname = "/" + pathname;
          } else if (!host) {
            host = "";
          }
          if (hash && hash.charAt(0) !== "#")
            hash = "#" + hash;
          if (search && search.charAt(0) !== "?")
            search = "?" + search;
          pathname = pathname.replace(/[?#]/g, function(match) {
            return encodeURIComponent(match);
          });
          search = search.replace("#", "%23");
          return protocol + host + pathname + search + hash;
        };
        function urlResolve(source, relative) {
          return urlParse(source, false, true).resolve(relative);
        }
        Url.prototype.resolve = function(relative) {
          return this.resolveObject(urlParse(relative, false, true)).format();
        };
        function urlResolveObject(source, relative) {
          if (!source)
            return relative;
          return urlParse(source, false, true).resolveObject(relative);
        }
        Url.prototype.resolveObject = function(relative) {
          if (util.isString(relative)) {
            var rel = new Url();
            rel.parse(relative, false, true);
            relative = rel;
          }
          var result = new Url();
          var tkeys = Object.keys(this);
          for (var tk = 0; tk < tkeys.length; tk++) {
            var tkey = tkeys[tk];
            result[tkey] = this[tkey];
          }
          result.hash = relative.hash;
          if (relative.href === "") {
            result.href = result.format();
            return result;
          }
          if (relative.slashes && !relative.protocol) {
            var rkeys = Object.keys(relative);
            for (var rk = 0; rk < rkeys.length; rk++) {
              var rkey = rkeys[rk];
              if (rkey !== "protocol")
                result[rkey] = relative[rkey];
            }
            if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
              result.path = result.pathname = "/";
            }
            result.href = result.format();
            return result;
          }
          if (relative.protocol && relative.protocol !== result.protocol) {
            if (!slashedProtocol[relative.protocol]) {
              var keys = Object.keys(relative);
              for (var v = 0; v < keys.length; v++) {
                var k = keys[v];
                result[k] = relative[k];
              }
              result.href = result.format();
              return result;
            }
            result.protocol = relative.protocol;
            if (!relative.host && !hostlessProtocol[relative.protocol]) {
              var relPath = (relative.pathname || "").split("/");
              while (relPath.length && !(relative.host = relPath.shift()))
                ;
              if (!relative.host)
                relative.host = "";
              if (!relative.hostname)
                relative.hostname = "";
              if (relPath[0] !== "")
                relPath.unshift("");
              if (relPath.length < 2)
                relPath.unshift("");
              result.pathname = relPath.join("/");
            } else {
              result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || "";
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            if (result.pathname || result.search) {
              var p = result.pathname || "";
              var s = result.search || "";
              result.path = p + s;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
          }
          var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
          if (psychotic) {
            result.hostname = "";
            result.port = null;
            if (result.host) {
              if (srcPath[0] === "")
                srcPath[0] = result.host;
              else
                srcPath.unshift(result.host);
            }
            result.host = "";
            if (relative.protocol) {
              relative.hostname = null;
              relative.port = null;
              if (relative.host) {
                if (relPath[0] === "")
                  relPath[0] = relative.host;
                else
                  relPath.unshift(relative.host);
              }
              relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
          }
          if (isRelAbs) {
            result.host = relative.host || relative.host === "" ? relative.host : result.host;
            result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath;
          } else if (relPath.length) {
            if (!srcPath)
              srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative.search;
            result.query = relative.query;
          } else if (!util.isNullOrUndefined(relative.search)) {
            if (psychotic) {
              result.hostname = result.host = srcPath.shift();
              var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
              if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
              }
            }
            result.search = relative.search;
            result.query = relative.query;
            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
              result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
            }
            result.href = result.format();
            return result;
          }
          if (!srcPath.length) {
            result.pathname = null;
            if (result.search) {
              result.path = "/" + result.search;
            } else {
              result.path = null;
            }
            result.href = result.format();
            return result;
          }
          var last = srcPath.slice(-1)[0];
          var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
          var up = 0;
          for (var i = srcPath.length; i >= 0; i--) {
            last = srcPath[i];
            if (last === ".") {
              srcPath.splice(i, 1);
            } else if (last === "..") {
              srcPath.splice(i, 1);
              up++;
            } else if (up) {
              srcPath.splice(i, 1);
              up--;
            }
          }
          if (!mustEndAbs && !removeAllDots) {
            for (; up--; up) {
              srcPath.unshift("..");
            }
          }
          if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
            srcPath.unshift("");
          }
          if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
            srcPath.push("");
          }
          var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
          if (psychotic) {
            result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
            var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }
          mustEndAbs = mustEndAbs || result.host && srcPath.length;
          if (mustEndAbs && !isAbsolute) {
            srcPath.unshift("");
          }
          if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
          } else {
            result.pathname = srcPath.join("/");
          }
          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
          }
          result.auth = relative.auth || result.auth;
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        };
        Url.prototype.parseHost = function() {
          var host = this.host;
          var port = portPattern.exec(host);
          if (port) {
            port = port[0];
            if (port !== ":") {
              this.port = port.substr(1);
            }
            host = host.substr(0, host.length - port.length);
          }
          if (host)
            this.hostname = host;
        };
      }, { "./util": 181, "punycode": 134, "querystring": 137 }], 181: [function(require2, module3, exports3) {
        "use strict";
        module3.exports = {
          isString: function(arg) {
            return typeof arg === "string";
          },
          isObject: function(arg) {
            return typeof arg === "object" && arg !== null;
          },
          isNull: function(arg) {
            return arg === null;
          },
          isNullOrUndefined: function(arg) {
            return arg == null;
          }
        };
      }, {}], 182: [function(require2, module3, exports3) {
        (function(process) {
          ;
          (function() {
            var UTIF = {};
            if (typeof module3 == "object") {
              module3.exports = UTIF;
            } else {
              self.UTIF = UTIF;
            }
            var pako;
            if (typeof require2 == "function") {
              pako = require2("pako");
            } else {
              pako = self.pako;
            }
            function log() {
              if (typeof process == "undefined" || process.env.NODE_ENV == "development")
                console.log.apply(console, arguments);
            }
            (function(UTIF2, pako2) {
              (function() {
                var V = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(g) {
                  return typeof g;
                } : function(g) {
                  return g && "function" === typeof Symbol && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
                }, D = function() {
                  function g(g2) {
                    this.message = "JPEG error: " + g2;
                  }
                  g.prototype = Error();
                  g.prototype.name = "JpegError";
                  return g.constructor = g;
                }(), P = function() {
                  function g(g2, D2) {
                    this.message = g2;
                    this.g = D2;
                  }
                  g.prototype = Error();
                  g.prototype.name = "DNLMarkerError";
                  return g.constructor = g;
                }();
                (function() {
                  function g() {
                    this.M = null;
                    this.B = -1;
                  }
                  function W(a, d) {
                    for (var f = 0, e = [], b, B, k = 16; 0 < k && !a[k - 1]; )
                      k--;
                    e.push({ children: [], index: 0 });
                    var l = e[0], r;
                    for (b = 0; b < k; b++) {
                      for (B = 0; B < a[b]; B++) {
                        l = e.pop();
                        for (l.children[l.index] = d[f]; 0 < l.index; )
                          l = e.pop();
                        l.index++;
                        for (e.push(l); e.length <= b; )
                          e.push(r = { children: [], index: 0 }), l.children[l.index] = r.children, l = r;
                        f++;
                      }
                      b + 1 < k && (e.push(r = { children: [], index: 0 }), l.children[l.index] = r.children, l = r);
                    }
                    return e[0].children;
                  }
                  function X(a, d, f, e, b, B, k, l, r) {
                    function n() {
                      if (0 < x)
                        return x--, z >> x & 1;
                      z = a[d++];
                      if (255 === z) {
                        var c2 = a[d++];
                        if (c2) {
                          if (220 === c2 && g2) {
                            d += 2;
                            var b2 = a[d++] << 8 | a[d++];
                            if (0 < b2 && b2 !== f.g)
                              throw new P("Found DNL marker (0xFFDC) while parsing scan data", b2);
                          }
                          throw new D("unexpected marker " + (z << 8 | c2).toString(16));
                        }
                      }
                      x = 7;
                      return z >>> 7;
                    }
                    function q(a2) {
                      for (; ; ) {
                        a2 = a2[n()];
                        if ("number" === typeof a2)
                          return a2;
                        if ("object" !== ("undefined" === typeof a2 ? "undefined" : V(a2)))
                          throw new D("invalid huffman sequence");
                      }
                    }
                    function h(a2) {
                      for (var c2 = 0; 0 < a2; )
                        c2 = c2 << 1 | n(), a2--;
                      return c2;
                    }
                    function c(a2) {
                      if (1 === a2)
                        return 1 === n() ? 1 : -1;
                      var c2 = h(a2);
                      return c2 >= 1 << a2 - 1 ? c2 : c2 + (-1 << a2) + 1;
                    }
                    function C(a2, b2) {
                      var d2 = q(a2.D);
                      d2 = 0 === d2 ? 0 : c(d2);
                      a2.a[b2] = a2.m += d2;
                      for (d2 = 1; 64 > d2; ) {
                        var h2 = q(a2.o), k2 = h2 & 15;
                        h2 >>= 4;
                        if (0 === k2) {
                          if (15 > h2)
                            break;
                          d2 += 16;
                        } else
                          d2 += h2, a2.a[b2 + J[d2]] = c(k2), d2++;
                      }
                    }
                    function w(a2, d2) {
                      var b2 = q(a2.D);
                      b2 = 0 === b2 ? 0 : c(b2) << r;
                      a2.a[d2] = a2.m += b2;
                    }
                    function p(a2, c2) {
                      a2.a[c2] |= n() << r;
                    }
                    function m(a2, b2) {
                      if (0 < A)
                        A--;
                      else
                        for (var d2 = B; d2 <= k; ) {
                          var e2 = q(a2.o), f2 = e2 & 15;
                          e2 >>= 4;
                          if (0 === f2) {
                            if (15 > e2) {
                              A = h(e2) + (1 << e2) - 1;
                              break;
                            }
                            d2 += 16;
                          } else
                            d2 += e2, a2.a[b2 + J[d2]] = c(f2) * (1 << r), d2++;
                        }
                    }
                    function t(a2, d2) {
                      for (var b2 = B, e2 = 0, f2; b2 <= k; ) {
                        f2 = d2 + J[b2];
                        var l2 = 0 > a2.a[f2] ? -1 : 1;
                        switch (E) {
                          case 0:
                            e2 = q(a2.o);
                            f2 = e2 & 15;
                            e2 >>= 4;
                            if (0 === f2)
                              15 > e2 ? (A = h(e2) + (1 << e2), E = 4) : (e2 = 16, E = 1);
                            else {
                              if (1 !== f2)
                                throw new D("invalid ACn encoding");
                              Q = c(f2);
                              E = e2 ? 2 : 3;
                            }
                            continue;
                          case 1:
                          case 2:
                            a2.a[f2] ? a2.a[f2] += l2 * (n() << r) : (e2--, 0 === e2 && (E = 2 === E ? 3 : 0));
                            break;
                          case 3:
                            a2.a[f2] ? a2.a[f2] += l2 * (n() << r) : (a2.a[f2] = Q << r, E = 0);
                            break;
                          case 4:
                            a2.a[f2] && (a2.a[f2] += l2 * (n() << r));
                        }
                        b2++;
                      }
                      4 === E && (A--, 0 === A && (E = 0));
                    }
                    var g2 = 9 < arguments.length && void 0 !== arguments[9] ? arguments[9] : false, u = f.P, v = d, z = 0, x = 0, A = 0, E = 0, Q, K = e.length, F, L, M, I;
                    var R = f.S ? 0 === B ? 0 === l ? w : p : 0 === l ? m : t : C;
                    var G = 0;
                    var O = 1 === K ? e[0].c * e[0].l : u * f.O;
                    for (var S, T; G < O; ) {
                      var U = b ? Math.min(O - G, b) : O;
                      for (F = 0; F < K; F++)
                        e[F].m = 0;
                      A = 0;
                      if (1 === K) {
                        var y = e[0];
                        for (I = 0; I < U; I++)
                          R(y, 64 * ((y.c + 1) * (G / y.c | 0) + G % y.c)), G++;
                      } else
                        for (I = 0; I < U; I++) {
                          for (F = 0; F < K; F++)
                            for (y = e[F], S = y.h, T = y.j, L = 0; L < T; L++)
                              for (M = 0; M < S; M++)
                                R(y, 64 * ((y.c + 1) * ((G / u | 0) * y.j + L) + (G % u * y.h + M)));
                          G++;
                        }
                      x = 0;
                      (y = N(a, d)) && y.f && ((0, _util.warn)("decodeScan - unexpected MCU data, current marker is: " + y.f), d = y.offset);
                      y = y && y.F;
                      if (!y || 65280 >= y)
                        throw new D("marker was not found");
                      if (65488 <= y && 65495 >= y)
                        d += 2;
                      else
                        break;
                    }
                    (y = N(a, d)) && y.f && ((0, _util.warn)("decodeScan - unexpected Scan data, current marker is: " + y.f), d = y.offset);
                    return d - v;
                  }
                  function Y(a, d) {
                    for (var f = d.c, e = d.l, b = new Int16Array(64), B = 0; B < e; B++)
                      for (var k = 0; k < f; k++) {
                        var l = 64 * ((d.c + 1) * B + k), r = b, n = d.G, q = d.a;
                        if (!n)
                          throw new D("missing required Quantization Table.");
                        for (var h = 0; 64 > h; h += 8) {
                          var c = q[l + h];
                          var C = q[l + h + 1];
                          var w = q[l + h + 2];
                          var p = q[l + h + 3];
                          var m = q[l + h + 4];
                          var t = q[l + h + 5];
                          var g2 = q[l + h + 6];
                          var u = q[l + h + 7];
                          c *= n[h];
                          if (0 === (C | w | p | m | t | g2 | u))
                            c = 5793 * c + 512 >> 10, r[h] = c, r[h + 1] = c, r[h + 2] = c, r[h + 3] = c, r[h + 4] = c, r[h + 5] = c, r[h + 6] = c, r[h + 7] = c;
                          else {
                            C *= n[h + 1];
                            w *= n[h + 2];
                            p *= n[h + 3];
                            m *= n[h + 4];
                            t *= n[h + 5];
                            g2 *= n[h + 6];
                            u *= n[h + 7];
                            var v = 5793 * c + 128 >> 8;
                            var z = 5793 * m + 128 >> 8;
                            var x = w;
                            var A = g2;
                            m = 2896 * (C - u) + 128 >> 8;
                            u = 2896 * (C + u) + 128 >> 8;
                            p <<= 4;
                            t <<= 4;
                            v = v + z + 1 >> 1;
                            z = v - z;
                            c = 3784 * x + 1567 * A + 128 >> 8;
                            x = 1567 * x - 3784 * A + 128 >> 8;
                            A = c;
                            m = m + t + 1 >> 1;
                            t = m - t;
                            u = u + p + 1 >> 1;
                            p = u - p;
                            v = v + A + 1 >> 1;
                            A = v - A;
                            z = z + x + 1 >> 1;
                            x = z - x;
                            c = 2276 * m + 3406 * u + 2048 >> 12;
                            m = 3406 * m - 2276 * u + 2048 >> 12;
                            u = c;
                            c = 799 * p + 4017 * t + 2048 >> 12;
                            p = 4017 * p - 799 * t + 2048 >> 12;
                            t = c;
                            r[h] = v + u;
                            r[h + 7] = v - u;
                            r[h + 1] = z + t;
                            r[h + 6] = z - t;
                            r[h + 2] = x + p;
                            r[h + 5] = x - p;
                            r[h + 3] = A + m;
                            r[h + 4] = A - m;
                          }
                        }
                        for (n = 0; 8 > n; ++n)
                          c = r[n], C = r[n + 8], w = r[n + 16], p = r[n + 24], m = r[n + 32], t = r[n + 40], g2 = r[n + 48], u = r[n + 56], 0 === (C | w | p | m | t | g2 | u) ? (c = 5793 * c + 8192 >> 14, c = -2040 > c ? 0 : 2024 <= c ? 255 : c + 2056 >> 4, q[l + n] = c, q[l + n + 8] = c, q[l + n + 16] = c, q[l + n + 24] = c, q[l + n + 32] = c, q[l + n + 40] = c, q[l + n + 48] = c, q[l + n + 56] = c) : (v = 5793 * c + 2048 >> 12, z = 5793 * m + 2048 >> 12, x = w, A = g2, m = 2896 * (C - u) + 2048 >> 12, u = 2896 * (C + u) + 2048 >> 12, v = (v + z + 1 >> 1) + 4112, z = v - z, c = 3784 * x + 1567 * A + 2048 >> 12, x = 1567 * x - 3784 * A + 2048 >> 12, A = c, m = m + t + 1 >> 1, t = m - t, u = u + p + 1 >> 1, p = u - p, v = v + A + 1 >> 1, A = v - A, z = z + x + 1 >> 1, x = z - x, c = 2276 * m + 3406 * u + 2048 >> 12, m = 3406 * m - 2276 * u + 2048 >> 12, u = c, c = 799 * p + 4017 * t + 2048 >> 12, p = 4017 * p - 799 * t + 2048 >> 12, t = c, c = v + u, u = v - u, C = z + t, g2 = z - t, w = x + p, t = x - p, p = A + m, m = A - m, c = 16 > c ? 0 : 4080 <= c ? 255 : c >> 4, C = 16 > C ? 0 : 4080 <= C ? 255 : C >> 4, w = 16 > w ? 0 : 4080 <= w ? 255 : w >> 4, p = 16 > p ? 0 : 4080 <= p ? 255 : p >> 4, m = 16 > m ? 0 : 4080 <= m ? 255 : m >> 4, t = 16 > t ? 0 : 4080 <= t ? 255 : t >> 4, g2 = 16 > g2 ? 0 : 4080 <= g2 ? 255 : g2 >> 4, u = 16 > u ? 0 : 4080 <= u ? 255 : u >> 4, q[l + n] = c, q[l + n + 8] = C, q[l + n + 16] = w, q[l + n + 24] = p, q[l + n + 32] = m, q[l + n + 40] = t, q[l + n + 48] = g2, q[l + n + 56] = u);
                      }
                    return d.a;
                  }
                  function N(a, d) {
                    var f = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : d, e = a.length - 1;
                    f = f < d ? f : d;
                    if (d >= e)
                      return null;
                    var b = a[d] << 8 | a[d + 1];
                    if (65472 <= b && 65534 >= b)
                      return { f: null, F: b, offset: d };
                    for (var B = a[f] << 8 | a[f + 1]; !(65472 <= B && 65534 >= B); ) {
                      if (++f >= e)
                        return null;
                      B = a[f] << 8 | a[f + 1];
                    }
                    return { f: b.toString(16), F: B, offset: f };
                  }
                  var J = new Uint8Array([
                    0,
                    1,
                    8,
                    16,
                    9,
                    2,
                    3,
                    10,
                    17,
                    24,
                    32,
                    25,
                    18,
                    11,
                    4,
                    5,
                    12,
                    19,
                    26,
                    33,
                    40,
                    48,
                    41,
                    34,
                    27,
                    20,
                    13,
                    6,
                    7,
                    14,
                    21,
                    28,
                    35,
                    42,
                    49,
                    56,
                    57,
                    50,
                    43,
                    36,
                    29,
                    22,
                    15,
                    23,
                    30,
                    37,
                    44,
                    51,
                    58,
                    59,
                    52,
                    45,
                    38,
                    31,
                    39,
                    46,
                    53,
                    60,
                    61,
                    54,
                    47,
                    55,
                    62,
                    63
                  ]);
                  g.prototype = { parse: function(a) {
                    function d() {
                      var d2 = a[k] << 8 | a[k + 1];
                      k += 2;
                      return d2;
                    }
                    function f() {
                      var b2 = d();
                      b2 = k + b2 - 2;
                      var c2 = N(a, b2, k);
                      c2 && c2.f && ((0, _util.warn)("readDataBlock - incorrect length, current marker is: " + c2.f), b2 = c2.offset);
                      b2 = a.subarray(k, b2);
                      k += b2.length;
                      return b2;
                    }
                    function e(a2) {
                      for (var b2 = Math.ceil(a2.v / 8 / a2.s), c2 = Math.ceil(a2.g / 8 / a2.u), d2 = 0; d2 < a2.b.length; d2++) {
                        v = a2.b[d2];
                        var e2 = Math.ceil(Math.ceil(a2.v / 8) * v.h / a2.s), f2 = Math.ceil(Math.ceil(a2.g / 8) * v.j / a2.u);
                        v.a = new Int16Array(64 * c2 * v.j * (b2 * v.h + 1));
                        v.c = e2;
                        v.l = f2;
                      }
                      a2.P = b2;
                      a2.O = c2;
                    }
                    var b = (1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}).N, B = void 0 === b ? null : b, k = 0, l = null, r = 0;
                    b = [];
                    var n = [], q = [], h = d();
                    if (65496 !== h)
                      throw new D("SOI not found");
                    for (h = d(); 65497 !== h; ) {
                      switch (h) {
                        case 65504:
                        case 65505:
                        case 65506:
                        case 65507:
                        case 65508:
                        case 65509:
                        case 65510:
                        case 65511:
                        case 65512:
                        case 65513:
                        case 65514:
                        case 65515:
                        case 65516:
                        case 65517:
                        case 65518:
                        case 65519:
                        case 65534:
                          var c = f();
                          65518 === h && 65 === c[0] && 100 === c[1] && 111 === c[2] && 98 === c[3] && 101 === c[4] && (l = { version: c[5] << 8 | c[6], Y: c[7] << 8 | c[8], Z: c[9] << 8 | c[10], W: c[11] });
                          break;
                        case 65499:
                          h = d() + k - 2;
                          for (var g2; k < h; ) {
                            var w = a[k++], p = new Uint16Array(64);
                            if (0 === w >> 4)
                              for (c = 0; 64 > c; c++)
                                g2 = J[c], p[g2] = a[k++];
                            else if (1 === w >> 4)
                              for (c = 0; 64 > c; c++)
                                g2 = J[c], p[g2] = d();
                            else
                              throw new D("DQT - invalid table spec");
                            b[w & 15] = p;
                          }
                          break;
                        case 65472:
                        case 65473:
                        case 65474:
                          if (m)
                            throw new D("Only single frame JPEGs supported");
                          d();
                          var m = {};
                          m.X = 65473 === h;
                          m.S = 65474 === h;
                          m.precision = a[k++];
                          h = d();
                          m.g = B || h;
                          m.v = d();
                          m.b = [];
                          m.C = {};
                          c = a[k++];
                          for (h = p = w = 0; h < c; h++) {
                            g2 = a[k];
                            var t = a[k + 1] >> 4;
                            var H = a[k + 1] & 15;
                            w < t && (w = t);
                            p < H && (p = H);
                            t = m.b.push({ h: t, j: H, T: a[k + 2], G: null });
                            m.C[g2] = t - 1;
                            k += 3;
                          }
                          m.s = w;
                          m.u = p;
                          e(m);
                          break;
                        case 65476:
                          g2 = d();
                          for (h = 2; h < g2; ) {
                            w = a[k++];
                            p = new Uint8Array(16);
                            for (c = t = 0; 16 > c; c++, k++)
                              t += p[c] = a[k];
                            H = new Uint8Array(t);
                            for (c = 0; c < t; c++, k++)
                              H[c] = a[k];
                            h += 17 + t;
                            (0 === w >> 4 ? q : n)[w & 15] = W(p, H);
                          }
                          break;
                        case 65501:
                          d();
                          var u = d();
                          break;
                        case 65498:
                          c = 1 === ++r && !B;
                          d();
                          w = a[k++];
                          g2 = [];
                          for (h = 0; h < w; h++) {
                            p = m.C[a[k++]];
                            var v = m.b[p];
                            p = a[k++];
                            v.D = q[p >> 4];
                            v.o = n[p & 15];
                            g2.push(v);
                          }
                          h = a[k++];
                          w = a[k++];
                          p = a[k++];
                          try {
                            var z = X(a, k, m, g2, u, h, w, p >> 4, p & 15, c);
                            k += z;
                          } catch (x) {
                            if (x instanceof P)
                              return (0, _util.warn)('Attempting to re-parse JPEG image using "scanLines" parameter found in DNL marker (0xFFDC) segment.'), this.parse(a, { N: x.g });
                            throw x;
                          }
                          break;
                        case 65500:
                          k += 4;
                          break;
                        case 65535:
                          255 !== a[k] && k--;
                          break;
                        default:
                          if (255 === a[k - 3] && 192 <= a[k - 2] && 254 >= a[k - 2])
                            k -= 3;
                          else if ((c = N(a, k - 2)) && c.f)
                            (0, _util.warn)("JpegImage.parse - unexpected data, current marker is: " + c.f), k = c.offset;
                          else
                            throw new D("unknown marker " + h.toString(16));
                      }
                      h = d();
                    }
                    this.width = m.v;
                    this.height = m.g;
                    this.A = l;
                    this.b = [];
                    for (h = 0; h < m.b.length; h++) {
                      v = m.b[h];
                      if (u = b[v.T])
                        v.G = u;
                      this.b.push({ R: Y(m, v), U: v.h / m.s, V: v.j / m.u, c: v.c, l: v.l });
                    }
                    this.i = this.b.length;
                  }, L: function(a, d) {
                    var f = this.width / a, e = this.height / d, b, g2, k = this.b.length, l = a * d * k, r = new Uint8ClampedArray(l), n = new Uint32Array(a);
                    for (g2 = 0; g2 < k; g2++) {
                      var q = this.b[g2];
                      var h = q.U * f;
                      var c = q.V * e;
                      var C = g2;
                      var w = q.R;
                      var p = q.c + 1 << 3;
                      for (b = 0; b < a; b++)
                        q = 0 | b * h, n[b] = (q & 4294967288) << 3 | q & 7;
                      for (h = 0; h < d; h++)
                        for (q = 0 | h * c, q = p * (q & 4294967288) | (q & 7) << 3, b = 0; b < a; b++)
                          r[C] = w[q + n[b]], C += k;
                    }
                    if (e = this.M)
                      for (g2 = 0; g2 < l; )
                        for (f = q = 0; q < k; q++, g2++, f += 2)
                          r[g2] = (r[g2] * e[f] >> 8) + e[f + 1];
                    return r;
                  }, w: function() {
                    return this.A ? !!this.A.W : 3 === this.i ? 0 === this.B ? false : true : 1 === this.B ? true : false;
                  }, I: function(a) {
                    for (var d, f, e, b = 0, g2 = a.length; b < g2; b += 3)
                      d = a[b], f = a[b + 1], e = a[b + 2], a[b] = d - 179.456 + 1.402 * e, a[b + 1] = d + 135.459 - 0.344 * f - 0.714 * e, a[b + 2] = d - 226.816 + 1.772 * f;
                    return a;
                  }, K: function(a) {
                    for (var d, f, e, b, g2 = 0, k = 0, l = a.length; k < l; k += 4)
                      d = a[k], f = a[k + 1], e = a[k + 2], b = a[k + 3], a[g2++] = -122.67195406894 + f * (-660635669420364e-19 * f + 437130475926232e-18 * e - 54080610064599e-18 * d + 48449797120281e-17 * b - 0.154362151871126) + e * (-957964378445773e-18 * e + 817076911346625e-18 * d - 0.00477271405408747 * b + 1.53380253221734) + d * (961250184130688e-18 * d - 0.00266257332283933 * b + 0.48357088451265) + b * (-336197177618394e-18 * b + 0.484791561490776), a[g2++] = 107.268039397724 + f * (219927104525741e-19 * f - 640992018297945e-18 * e + 659397001245577e-18 * d + 426105652938837e-18 * b - 0.176491792462875) + e * (-778269941513683e-18 * e + 0.00130872261408275 * d + 770482631801132e-18 * b - 0.151051492775562) + d * (0.00126935368114843 * d - 0.00265090189010898 * b + 0.25802910206845) + b * (-318913117588328e-18 * b - 0.213742400323665), a[g2++] = -20.810012546947 + f * (-570115196973677e-18 * f - 263409051004589e-19 * e + 0.0020741088115012 * d - 0.00288260236853442 * b + 0.814272968359295) + e * (-153496057440975e-19 * e - 132689043961446e-18 * d + 560833691242812e-18 * b - 0.195152027534049) + d * (0.00174418132927582 * d - 0.00255243321439347 * b + 0.116935020465145) + b * (-343531996510555e-18 * b + 0.24165260232407);
                    return a.subarray(
                      0,
                      g2
                    );
                  }, J: function(a) {
                    for (var d, f, e, b = 0, g2 = a.length; b < g2; b += 4)
                      d = a[b], f = a[b + 1], e = a[b + 2], a[b] = 434.456 - d - 1.402 * e, a[b + 1] = 119.541 - d + 0.344 * f + 0.714 * e, a[b + 2] = 481.816 - d - 1.772 * f;
                    return a;
                  }, H: function(a) {
                    for (var d, f, e, b, g2 = 0, k = 1 / 255, l = 0, r = a.length; l < r; l += 4)
                      d = a[l] * k, f = a[l + 1] * k, e = a[l + 2] * k, b = a[l + 3] * k, a[g2++] = 255 + d * (-4.387332384609988 * d + 54.48615194189176 * f + 18.82290502165302 * e + 212.25662451639585 * b - 285.2331026137004) + f * (1.7149763477362134 * f - 5.6096736904047315 * e - 17.873870861415444 * b - 5.497006427196366) + e * (-2.5217340131683033 * e - 21.248923337353073 * b + 17.5119270841813) - b * (21.86122147463605 * b + 189.48180835922747), a[g2++] = 255 + d * (8.841041422036149 * d + 60.118027045597366 * f + 6.871425592049007 * e + 31.159100130055922 * b - 79.2970844816548) + f * (-15.310361306967817 * f + 17.575251261109482 * e + 131.35250912493976 * b - 190.9453302588951) + e * (4.444339102852739 * e + 9.8632861493405 * b - 24.86741582555878) - b * (20.737325471181034 * b + 187.80453709719578), a[g2++] = 255 + d * (0.8842522430003296 * d + 8.078677503112928 * f + 30.89978309703729 * e - 0.23883238689178934 * b - 14.183576799673286) + f * (10.49593273432072 * f + 63.02378494754052 * e + 50.606957656360734 * b - 112.23884253719248) + e * (0.03296041114873217 * e + 115.60384449646641 * b - 193.58209356861505) - b * (22.33816807309886 * b + 180.12613974708367);
                    return a.subarray(0, g2);
                  }, getData: function(a, d, f) {
                    if (4 < this.i)
                      throw new D("Unsupported color mode");
                    a = this.L(a, d);
                    if (1 === this.i && f) {
                      f = a.length;
                      d = new Uint8ClampedArray(3 * f);
                      for (var e = 0, b = 0; b < f; b++) {
                        var g2 = a[b];
                        d[e++] = g2;
                        d[e++] = g2;
                        d[e++] = g2;
                      }
                      return d;
                    }
                    if (3 === this.i && this.w())
                      return this.I(a);
                    if (4 === this.i) {
                      if (this.w())
                        return f ? this.K(a) : this.J(a);
                      if (f)
                        return this.H(a);
                    }
                    return a;
                  } };
                  UTIF2.JpegDecoder = g;
                })();
              })();
              UTIF2.encodeImage = function(rgba, w, h, metadata) {
                var idf = {
                  "t256": [w],
                  "t257": [h],
                  "t258": [8, 8, 8, 8],
                  "t259": [1],
                  "t262": [2],
                  "t273": [1e3],
                  // strips offset
                  "t277": [4],
                  "t278": [h],
                  /* rows per strip */
                  "t279": [w * h * 4],
                  // strip byte counts
                  "t282": [1],
                  "t283": [1],
                  "t284": [1],
                  "t286": [0],
                  "t287": [0],
                  "t296": [1],
                  "t305": ["Photopea (UTIF.js)"],
                  "t338": [1]
                };
                if (metadata)
                  for (var i in metadata)
                    idf[i] = metadata[i];
                var prfx = new Uint8Array(UTIF2.encode([idf]));
                var img = new Uint8Array(rgba);
                var data = new Uint8Array(1e3 + w * h * 4);
                for (var i = 0; i < prfx.length; i++)
                  data[i] = prfx[i];
                for (var i = 0; i < img.length; i++)
                  data[1e3 + i] = img[i];
                return data.buffer;
              };
              UTIF2.encode = function(ifds) {
                var data = new Uint8Array(2e4), offset = 4, bin = UTIF2._binBE;
                data[0] = 77;
                data[1] = 77;
                data[3] = 42;
                var ifdo = 8;
                bin.writeUint(data, offset, ifdo);
                offset += 4;
                for (var i = 0; i < ifds.length; i++) {
                  var noffs = UTIF2._writeIFD(bin, data, ifdo, ifds[i]);
                  ifdo = noffs[1];
                  if (i < ifds.length - 1)
                    bin.writeUint(data, noffs[0], ifdo);
                }
                return data.slice(0, ifdo).buffer;
              };
              UTIF2.decode = function(buff) {
                UTIF2.decode._decodeG3.allow2D = null;
                var data = new Uint8Array(buff), offset = 0;
                var id = UTIF2._binBE.readASCII(data, offset, 2);
                offset += 2;
                var bin = id == "II" ? UTIF2._binLE : UTIF2._binBE;
                var num = bin.readUshort(data, offset);
                offset += 2;
                var ifdo = bin.readUint(data, offset);
                offset += 4;
                var ifds = [];
                while (true) {
                  var noff = UTIF2._readIFD(bin, data, ifdo, ifds);
                  ifdo = bin.readUint(data, noff);
                  if (ifdo == 0)
                    break;
                }
                return ifds;
              };
              UTIF2.decodeImages = function(buff, ifds) {
                var data = new Uint8Array(buff);
                var id = UTIF2._binBE.readASCII(data, 0, 2);
                for (var ii = 0; ii < ifds.length; ii++) {
                  var img = ifds[ii];
                  if (img["t256"] == null)
                    continue;
                  img.isLE = id == "II";
                  img.width = img["t256"][0];
                  img.height = img["t257"][0];
                  var cmpr = img["t259"] ? img["t259"][0] : 1;
                  var fo = img["t266"] ? img["t266"][0] : 1;
                  if (img["t284"] && img["t284"][0] == 2)
                    log("PlanarConfiguration 2 should not be used!");
                  var bipp = (img["t258"] ? Math.min(32, img["t258"][0]) : 1) * (img["t277"] ? img["t277"][0] : 1);
                  var bipl = Math.ceil(img.width * bipp / 8) * 8;
                  var soff = img["t273"];
                  if (soff == null)
                    soff = img["t324"];
                  var bcnt = img["t279"];
                  if (cmpr == 1 && soff.length == 1)
                    bcnt = [img.height * (bipl >>> 3)];
                  if (bcnt == null)
                    bcnt = img["t325"];
                  var bytes = new Uint8Array(img.height * (bipl >>> 3)), bilen = 0;
                  if (img["t322"] != null) {
                    var tw = img["t322"][0], th = img["t323"][0];
                    var tx = Math.floor((img.width + tw - 1) / tw);
                    var ty = Math.floor((img.height + th - 1) / th);
                    var tbuff = new Uint8Array(Math.ceil(tw * th * bipp / 8) | 0);
                    for (var y = 0; y < ty; y++)
                      for (var x = 0; x < tx; x++) {
                        var i = y * tx + x;
                        for (var j = 0; j < tbuff.length; j++)
                          tbuff[j] = 0;
                        UTIF2.decode._decompress(img, data, soff[i], bcnt[i], cmpr, tbuff, 0, fo);
                        if (cmpr == 6)
                          bytes = tbuff;
                        else
                          UTIF2._copyTile(tbuff, Math.ceil(tw * bipp / 8) | 0, th, bytes, Math.ceil(img.width * bipp / 8) | 0, img.height, Math.ceil(x * tw * bipp / 8) | 0, y * th);
                      }
                    bilen = bytes.length * 8;
                  } else {
                    var rps = img["t278"] ? img["t278"][0] : img.height;
                    rps = Math.min(rps, img.height);
                    for (var i = 0; i < soff.length; i++) {
                      UTIF2.decode._decompress(img, data, soff[i], bcnt[i], cmpr, bytes, Math.ceil(bilen / 8) | 0, fo);
                      bilen += bipl * rps;
                    }
                    bilen = Math.min(bilen, bytes.length * 8);
                  }
                  img.data = new Uint8Array(bytes.buffer, 0, Math.ceil(bilen / 8) | 0);
                }
              };
              UTIF2.decode._decompress = function(img, data, off, len, cmpr, tgt, toff, fo) {
                if (false) {
                } else if (cmpr == 1)
                  for (var j = 0; j < len; j++)
                    tgt[toff + j] = data[off + j];
                else if (cmpr == 3)
                  UTIF2.decode._decodeG3(data, off, len, tgt, toff, img.width, fo);
                else if (cmpr == 4)
                  UTIF2.decode._decodeG4(data, off, len, tgt, toff, img.width, fo);
                else if (cmpr == 5)
                  UTIF2.decode._decodeLZW(data, off, tgt, toff);
                else if (cmpr == 6)
                  UTIF2.decode._decodeOldJPEG(img, data, off, len, tgt, toff);
                else if (cmpr == 7)
                  UTIF2.decode._decodeNewJPEG(img, data, off, len, tgt, toff);
                else if (cmpr == 8) {
                  var src = new Uint8Array(data.buffer, off, len);
                  var bin = pako2["inflate"](src);
                  for (var i = 0; i < bin.length; i++)
                    tgt[toff + i] = bin[i];
                } else if (cmpr == 32773)
                  UTIF2.decode._decodePackBits(data, off, len, tgt, toff);
                else if (cmpr == 32809)
                  UTIF2.decode._decodeThunder(data, off, len, tgt, toff);
                else
                  log("Unknown compression", cmpr);
                if (img["t317"] && img["t317"][0] == 2) {
                  var noc = img["t277"] ? img["t277"][0] : 1, h = img["t278"] ? img["t278"][0] : img.height, bpr = img.width * noc;
                  for (var y = 0; y < h; y++) {
                    var ntoff = toff + y * bpr;
                    if (noc == 3)
                      for (var j = 3; j < bpr; j += 3) {
                        tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - 3] & 255;
                        tgt[ntoff + j + 1] = tgt[ntoff + j + 1] + tgt[ntoff + j - 2] & 255;
                        tgt[ntoff + j + 2] = tgt[ntoff + j + 2] + tgt[ntoff + j - 1] & 255;
                      }
                    else
                      for (var j = noc; j < bpr; j++)
                        tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - noc] & 255;
                  }
                }
              };
              UTIF2.decode._decodeNikon = function(data, off, len, tgt, toff) {
                var nikon_tree = [
                  [
                    0,
                    1,
                    5,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    2,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    /* 12-bit lossy */
                    5,
                    4,
                    3,
                    6,
                    2,
                    7,
                    1,
                    0,
                    8,
                    9,
                    11,
                    10,
                    12
                  ],
                  [
                    0,
                    1,
                    5,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    2,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    /* 12-bit lossy after split */
                    57,
                    90,
                    56,
                    39,
                    22,
                    5,
                    4,
                    3,
                    2,
                    1,
                    0,
                    11,
                    12,
                    12
                  ],
                  [
                    0,
                    1,
                    4,
                    2,
                    3,
                    1,
                    2,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    /* 12-bit lossless */
                    5,
                    4,
                    6,
                    3,
                    7,
                    2,
                    8,
                    1,
                    9,
                    0,
                    10,
                    11,
                    12
                  ],
                  [
                    0,
                    1,
                    4,
                    3,
                    1,
                    1,
                    1,
                    1,
                    1,
                    2,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    /* 14-bit lossy */
                    5,
                    6,
                    4,
                    7,
                    8,
                    3,
                    9,
                    2,
                    1,
                    0,
                    10,
                    11,
                    12,
                    13,
                    14
                  ],
                  [
                    0,
                    1,
                    5,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    1,
                    2,
                    0,
                    0,
                    0,
                    0,
                    0,
                    /* 14-bit lossy after split */
                    8,
                    92,
                    75,
                    58,
                    41,
                    7,
                    6,
                    5,
                    4,
                    3,
                    2,
                    1,
                    0,
                    13,
                    14
                  ],
                  [
                    0,
                    1,
                    4,
                    2,
                    2,
                    3,
                    1,
                    2,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    /* 14-bit lossless */
                    7,
                    6,
                    8,
                    5,
                    9,
                    4,
                    10,
                    3,
                    11,
                    12,
                    2,
                    0,
                    1,
                    13,
                    14
                  ]
                ];
                var ver0, ver1, vpred, hpred, csize;
                var i, min, max, step = 0, huff = 0, split = 0, row, col, len, shl, diff;
                log(data.slice(off, off + 100));
                ver0 = data[off];
                off++;
                ver1 = data[off];
                off++;
                log(ver0.toString(16), ver1.toString(16), len);
              };
              UTIF2.decode._decodeNewJPEG = function(img, data, off, len, tgt, toff) {
                var tables = img["t347"], tlen = tables ? tables.length : 0, buff = new Uint8Array(tlen + len);
                if (tables) {
                  var SOI = 216, EOI2 = 217, boff = 0;
                  for (var i = 0; i < tlen - 1; i++) {
                    if (tables[i] == 255 && tables[i + 1] == EOI2)
                      break;
                    buff[boff++] = tables[i];
                  }
                  var byte1 = data[off], byte2 = data[off + 1];
                  if (byte1 != 255 || byte2 != SOI) {
                    buff[boff++] = byte1;
                    buff[boff++] = byte2;
                  }
                  for (var i = 2; i < len; i++)
                    buff[boff++] = data[off + i];
                } else
                  for (var i = 0; i < len; i++)
                    buff[i] = data[off + i];
                if (img["t262"] == 32803) {
                  var bps = img["t258"][0], dcdr = new LosslessJpegDecoder();
                  var out = dcdr.decode(buff), olen = out.length;
                  if (false) {
                  } else if (bps == 16)
                    for (var i = 0; i < olen; i++) {
                      tgt[toff++] = out[i] & 255;
                      tgt[toff++] = out[i] >>> 8;
                    }
                  else if (bps == 12)
                    for (var i = 0; i < olen; i += 2) {
                      tgt[toff++] = out[i] >>> 4;
                      tgt[toff++] = (out[i] << 4 | out[i + 1] >>> 8) & 255;
                      tgt[toff++] = out[i + 1] & 255;
                    }
                  else
                    throw new Error("unsupported bit depth " + bps);
                } else {
                  var parser = new UTIF2.JpegDecoder();
                  parser.parse(buff);
                  var decoded = parser.getData(parser.width, parser.height);
                  for (var i = 0; i < decoded.length; i++)
                    tgt[toff + i] = decoded[i];
                }
                if (img["t262"][0] == 6)
                  img["t262"][0] = 2;
              };
              UTIF2.decode._decodeOldJPEGInit = function(img, data, off, len) {
                var SOI = 216, EOI2 = 217, DQT = 219, DHT = 196, DRI = 221, SOF0 = 192, SOS2 = 218;
                var joff = 0, soff = 0, tables, sosMarker2, isTiled = false, i, j, k;
                var jpgIchgFmt = img["t513"], jifoff = jpgIchgFmt ? jpgIchgFmt[0] : 0;
                var jpgIchgFmtLen = img["t514"], jiflen = jpgIchgFmtLen ? jpgIchgFmtLen[0] : 0;
                var soffTag = img["t324"] || img["t273"] || jpgIchgFmt;
                var ycbcrss = img["t530"], ssx = 0, ssy = 0;
                var spp = img["t277"] ? img["t277"][0] : 1;
                var jpgresint = img["t515"];
                if (soffTag) {
                  soff = soffTag[0];
                  isTiled = soffTag.length > 1;
                }
                if (!isTiled) {
                  if (data[off] == 255 && data[off + 1] == SOI)
                    return { jpegOffset: off };
                  if (jpgIchgFmt != null) {
                    if (data[off + jifoff] == 255 && data[off + jifoff + 1] == SOI)
                      joff = off + jifoff;
                    else
                      log("JPEGInterchangeFormat does not point to SOI");
                    if (jpgIchgFmtLen == null)
                      log("JPEGInterchangeFormatLength field is missing");
                    else if (jifoff >= soff || jifoff + jiflen <= soff)
                      log("JPEGInterchangeFormatLength field value is invalid");
                    if (joff != null)
                      return { jpegOffset: joff };
                  }
                }
                if (ycbcrss != null) {
                  ssx = ycbcrss[0];
                  ssy = ycbcrss[1];
                }
                if (jpgIchgFmt != null) {
                  if (jpgIchgFmtLen != null)
                    if (jiflen >= 2 && jifoff + jiflen <= soff) {
                      if (data[off + jifoff + jiflen - 2] == 255 && data[off + jifoff + jiflen - 1] == SOI)
                        tables = new Uint8Array(jiflen - 2);
                      else
                        tables = new Uint8Array(jiflen);
                      for (i = 0; i < tables.length; i++)
                        tables[i] = data[off + jifoff + i];
                      log("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
                    } else
                      log("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
                }
                if (tables == null) {
                  var ooff = 0, out = [];
                  out[ooff++] = 255;
                  out[ooff++] = SOI;
                  var qtables = img["t519"];
                  if (qtables == null)
                    throw new Error("JPEGQTables tag is missing");
                  for (i = 0; i < qtables.length; i++) {
                    out[ooff++] = 255;
                    out[ooff++] = DQT;
                    out[ooff++] = 0;
                    out[ooff++] = 67;
                    out[ooff++] = i;
                    for (j = 0; j < 64; j++)
                      out[ooff++] = data[off + qtables[i] + j];
                  }
                  for (k = 0; k < 2; k++) {
                    var htables = img[k == 0 ? "t520" : "t521"];
                    if (htables == null)
                      throw new Error((k == 0 ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
                    for (i = 0; i < htables.length; i++) {
                      out[ooff++] = 255;
                      out[ooff++] = DHT;
                      var nc = 19;
                      for (j = 0; j < 16; j++)
                        nc += data[off + htables[i] + j];
                      out[ooff++] = nc >>> 8;
                      out[ooff++] = nc & 255;
                      out[ooff++] = i | k << 4;
                      for (j = 0; j < 16; j++)
                        out[ooff++] = data[off + htables[i] + j];
                      for (j = 0; j < nc; j++)
                        out[ooff++] = data[off + htables[i] + 16 + j];
                    }
                  }
                  out[ooff++] = 255;
                  out[ooff++] = SOF0;
                  out[ooff++] = 0;
                  out[ooff++] = 8 + 3 * spp;
                  out[ooff++] = 8;
                  out[ooff++] = img.height >>> 8 & 255;
                  out[ooff++] = img.height & 255;
                  out[ooff++] = img.width >>> 8 & 255;
                  out[ooff++] = img.width & 255;
                  out[ooff++] = spp;
                  if (spp == 1) {
                    out[ooff++] = 1;
                    out[ooff++] = 17;
                    out[ooff++] = 0;
                  } else
                    for (i = 0; i < 3; i++) {
                      out[ooff++] = i + 1;
                      out[ooff++] = i != 0 ? 17 : (ssx & 15) << 4 | ssy & 15;
                      out[ooff++] = i;
                    }
                  if (jpgresint != null && jpgresint[0] != 0) {
                    out[ooff++] = 255;
                    out[ooff++] = DRI;
                    out[ooff++] = 0;
                    out[ooff++] = 4;
                    out[ooff++] = jpgresint[0] >>> 8 & 255;
                    out[ooff++] = jpgresint[0] & 255;
                  }
                  tables = new Uint8Array(out);
                }
                var sofpos = -1;
                i = 0;
                while (i < tables.length - 1) {
                  if (tables[i] == 255 && tables[i + 1] == SOF0) {
                    sofpos = i;
                    break;
                  }
                  i++;
                }
                if (sofpos == -1) {
                  var tmptab = new Uint8Array(tables.length + 10 + 3 * spp);
                  tmptab.set(tables);
                  var tmpoff = tables.length;
                  sofpos = tables.length;
                  tables = tmptab;
                  tables[tmpoff++] = 255;
                  tables[tmpoff++] = SOF0;
                  tables[tmpoff++] = 0;
                  tables[tmpoff++] = 8 + 3 * spp;
                  tables[tmpoff++] = 8;
                  tables[tmpoff++] = img.height >>> 8 & 255;
                  tables[tmpoff++] = img.height & 255;
                  tables[tmpoff++] = img.width >>> 8 & 255;
                  tables[tmpoff++] = img.width & 255;
                  tables[tmpoff++] = spp;
                  if (spp == 1) {
                    tables[tmpoff++] = 1;
                    tables[tmpoff++] = 17;
                    tables[tmpoff++] = 0;
                  } else
                    for (i = 0; i < 3; i++) {
                      tables[tmpoff++] = i + 1;
                      tables[tmpoff++] = i != 0 ? 17 : (ssx & 15) << 4 | ssy & 15;
                      tables[tmpoff++] = i;
                    }
                }
                if (data[soff] == 255 && data[soff + 1] == SOS2) {
                  var soslen = data[soff + 2] << 8 | data[soff + 3];
                  sosMarker2 = new Uint8Array(soslen + 2);
                  sosMarker2[0] = data[soff];
                  sosMarker2[1] = data[soff + 1];
                  sosMarker2[2] = data[soff + 2];
                  sosMarker2[3] = data[soff + 3];
                  for (i = 0; i < soslen - 2; i++)
                    sosMarker2[i + 4] = data[soff + i + 4];
                } else {
                  sosMarker2 = new Uint8Array(2 + 6 + 2 * spp);
                  var sosoff = 0;
                  sosMarker2[sosoff++] = 255;
                  sosMarker2[sosoff++] = SOS2;
                  sosMarker2[sosoff++] = 0;
                  sosMarker2[sosoff++] = 6 + 2 * spp;
                  sosMarker2[sosoff++] = spp;
                  if (spp == 1) {
                    sosMarker2[sosoff++] = 1;
                    sosMarker2[sosoff++] = 0;
                  } else
                    for (i = 0; i < 3; i++) {
                      sosMarker2[sosoff++] = i + 1;
                      sosMarker2[sosoff++] = i << 4 | i;
                    }
                  sosMarker2[sosoff++] = 0;
                  sosMarker2[sosoff++] = 63;
                  sosMarker2[sosoff++] = 0;
                }
                return { jpegOffset: off, tables, sosMarker: sosMarker2, sofPosition: sofpos };
              };
              UTIF2.decode._decodeOldJPEG = function(img, data, off, len, tgt, toff) {
                var i, dlen, tlen, buff, buffoff;
                var jpegData = UTIF2.decode._decodeOldJPEGInit(img, data, off, len);
                if (jpegData.jpegOffset != null) {
                  dlen = off + len - jpegData.jpegOffset;
                  buff = new Uint8Array(dlen);
                  for (i = 0; i < dlen; i++)
                    buff[i] = data[jpegData.jpegOffset + i];
                } else {
                  tlen = jpegData.tables.length;
                  buff = new Uint8Array(tlen + jpegData.sosMarker.length + len + 2);
                  buff.set(jpegData.tables);
                  buffoff = tlen;
                  buff[jpegData.sofPosition + 5] = img.height >>> 8 & 255;
                  buff[jpegData.sofPosition + 6] = img.height & 255;
                  buff[jpegData.sofPosition + 7] = img.width >>> 8 & 255;
                  buff[jpegData.sofPosition + 8] = img.width & 255;
                  if (data[off] != 255 || data[off + 1] != SOS) {
                    buff.set(jpegData.sosMarker, bufoff);
                    bufoff += sosMarker.length;
                  }
                  for (i = 0; i < len; i++)
                    buff[bufoff++] = data[off + i];
                  buff[bufoff++] = 255;
                  buff[bufoff++] = EOI;
                }
                var parser = new UTIF2.JpegDecoder();
                parser.parse(buff);
                var decoded = parser.getData(parser.width, parser.height);
                for (var i = 0; i < decoded.length; i++)
                  tgt[toff + i] = decoded[i];
                if (img["t262"][0] == 6)
                  img["t262"][0] = 2;
              };
              UTIF2.decode._decodePackBits = function(data, off, len, tgt, toff) {
                var sa = new Int8Array(data.buffer), ta = new Int8Array(tgt.buffer), lim = off + len;
                while (off < lim) {
                  var n = sa[off];
                  off++;
                  if (n >= 0 && n < 128)
                    for (var i = 0; i < n + 1; i++) {
                      ta[toff] = sa[off];
                      toff++;
                      off++;
                    }
                  if (n >= -127 && n < 0) {
                    for (var i = 0; i < -n + 1; i++) {
                      ta[toff] = sa[off];
                      toff++;
                    }
                    off++;
                  }
                }
              };
              UTIF2.decode._decodeThunder = function(data, off, len, tgt, toff) {
                var d2 = [0, 1, 0, -1], d3 = [0, 1, 2, 3, 0, -3, -2, -1];
                var lim = off + len, qoff = toff * 2, px = 0;
                while (off < lim) {
                  var b = data[off], msk = b >>> 6, n = b & 63;
                  off++;
                  if (msk == 3) {
                    px = n & 15;
                    tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
                    qoff++;
                  }
                  if (msk == 0)
                    for (var i = 0; i < n; i++) {
                      tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
                      qoff++;
                    }
                  if (msk == 2)
                    for (var i = 0; i < 2; i++) {
                      var d = n >>> 3 * (1 - i) & 7;
                      if (d != 4) {
                        px += d3[d];
                        tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
                        qoff++;
                      }
                    }
                  if (msk == 1)
                    for (var i = 0; i < 3; i++) {
                      var d = n >>> 2 * (2 - i) & 3;
                      if (d != 2) {
                        px += d2[d];
                        tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1);
                        qoff++;
                      }
                    }
                }
              };
              UTIF2.decode._dmap = { "1": 0, "011": 1, "000011": 2, "0000011": 3, "010": -1, "000010": -2, "0000010": -3 };
              UTIF2.decode._lens = function() {
                var addKeys = function(lens, arr, i0, inc) {
                  for (var i = 0; i < arr.length; i++)
                    lens[arr[i]] = i0 + i * inc;
                };
                var termW = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100";
                var termB = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111";
                var makeW = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011";
                var makeB = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101";
                var makeA = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
                termW = termW.split(",");
                termB = termB.split(",");
                makeW = makeW.split(",");
                makeB = makeB.split(",");
                makeA = makeA.split(",");
                var lensW = {}, lensB = {};
                addKeys(lensW, termW, 0, 1);
                addKeys(lensW, makeW, 64, 64);
                addKeys(lensW, makeA, 1792, 64);
                addKeys(lensB, termB, 0, 1);
                addKeys(lensB, makeB, 64, 64);
                addKeys(lensB, makeA, 1792, 64);
                return [lensW, lensB];
              }();
              UTIF2.decode._decodeG4 = function(data, off, slen, tgt, toff, w, fo) {
                var U = UTIF2.decode, boff = off << 3, len = 0, wrd = "";
                var line = [], pline = [];
                for (var i = 0; i < w; i++)
                  pline.push(0);
                pline = U._makeDiff(pline);
                var a0 = 0, a1 = 0, a2 = 0, b1 = 0, b2 = 0, clr = 0;
                var y = 0, mode = "", toRead = 0;
                var bipl = Math.ceil(w / 8) * 8;
                while (boff >>> 3 < off + slen) {
                  b1 = U._findDiff(pline, a0 + (a0 == 0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr);
                  var bit = 0;
                  if (fo == 1)
                    bit = data[boff >>> 3] >>> 7 - (boff & 7) & 1;
                  if (fo == 2)
                    bit = data[boff >>> 3] >>> (boff & 7) & 1;
                  boff++;
                  wrd += bit;
                  if (mode == "H") {
                    if (U._lens[clr][wrd] != null) {
                      var dl = U._lens[clr][wrd];
                      wrd = "";
                      len += dl;
                      if (dl < 64) {
                        U._addNtimes(line, len, clr);
                        a0 += len;
                        clr = 1 - clr;
                        len = 0;
                        toRead--;
                        if (toRead == 0)
                          mode = "";
                      }
                    }
                  } else {
                    if (wrd == "0001") {
                      wrd = "";
                      U._addNtimes(line, b2 - a0, clr);
                      a0 = b2;
                    }
                    if (wrd == "001") {
                      wrd = "";
                      mode = "H";
                      toRead = 2;
                    }
                    if (U._dmap[wrd] != null) {
                      a1 = b1 + U._dmap[wrd];
                      U._addNtimes(line, a1 - a0, clr);
                      a0 = a1;
                      wrd = "";
                      clr = 1 - clr;
                    }
                  }
                  if (line.length == w && mode == "") {
                    U._writeBits(line, tgt, toff * 8 + y * bipl);
                    clr = 0;
                    y++;
                    a0 = 0;
                    pline = U._makeDiff(line);
                    line = [];
                  }
                }
              };
              UTIF2.decode._findDiff = function(line, x, clr) {
                for (var i = 0; i < line.length; i += 2)
                  if (line[i] >= x && line[i + 1] == clr)
                    return line[i];
              };
              UTIF2.decode._makeDiff = function(line) {
                var out = [];
                if (line[0] == 1)
                  out.push(0, 1);
                for (var i = 1; i < line.length; i++)
                  if (line[i - 1] != line[i])
                    out.push(i, line[i]);
                out.push(line.length, 0, line.length, 1);
                return out;
              };
              UTIF2.decode._decodeG3 = function(data, off, slen, tgt, toff, w, fo) {
                var U = UTIF2.decode, boff = off << 3, len = 0, wrd = "";
                var line = [], pline = [];
                for (var i = 0; i < w; i++)
                  line.push(0);
                var a0 = 0, a1 = 0, a2 = 0, b1 = 0, b2 = 0, clr = 0;
                var y = -1, mode = "", toRead = 0, is1D = false;
                var bipl = Math.ceil(w / 8) * 8;
                while (boff >>> 3 < off + slen) {
                  b1 = U._findDiff(pline, a0 + (a0 == 0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr);
                  var bit = 0;
                  if (fo == 1)
                    bit = data[boff >>> 3] >>> 7 - (boff & 7) & 1;
                  if (fo == 2)
                    bit = data[boff >>> 3] >>> (boff & 7) & 1;
                  boff++;
                  wrd += bit;
                  if (is1D) {
                    if (U._lens[clr][wrd] != null) {
                      var dl = U._lens[clr][wrd];
                      wrd = "";
                      len += dl;
                      if (dl < 64) {
                        U._addNtimes(line, len, clr);
                        clr = 1 - clr;
                        len = 0;
                      }
                    }
                  } else {
                    if (mode == "H") {
                      if (U._lens[clr][wrd] != null) {
                        var dl = U._lens[clr][wrd];
                        wrd = "";
                        len += dl;
                        if (dl < 64) {
                          U._addNtimes(line, len, clr);
                          a0 += len;
                          clr = 1 - clr;
                          len = 0;
                          toRead--;
                          if (toRead == 0)
                            mode = "";
                        }
                      }
                    } else {
                      if (wrd == "0001") {
                        wrd = "";
                        U._addNtimes(line, b2 - a0, clr);
                        a0 = b2;
                      }
                      if (wrd == "001") {
                        wrd = "";
                        mode = "H";
                        toRead = 2;
                      }
                      if (U._dmap[wrd] != null) {
                        a1 = b1 + U._dmap[wrd];
                        U._addNtimes(line, a1 - a0, clr);
                        a0 = a1;
                        wrd = "";
                        clr = 1 - clr;
                      }
                    }
                  }
                  if (wrd.endsWith("000000000001")) {
                    if (y >= 0)
                      U._writeBits(line, tgt, toff * 8 + y * bipl);
                    if (fo == 1)
                      is1D = (data[boff >>> 3] >>> 7 - (boff & 7) & 1) == 1;
                    if (fo == 2)
                      is1D = (data[boff >>> 3] >>> (boff & 7) & 1) == 1;
                    boff++;
                    if (U._decodeG3.allow2D == null)
                      U._decodeG3.allow2D = is1D;
                    if (!U._decodeG3.allow2D) {
                      is1D = true;
                      boff--;
                    }
                    wrd = "";
                    clr = 0;
                    y++;
                    a0 = 0;
                    pline = U._makeDiff(line);
                    line = [];
                  }
                }
                if (line.length == w)
                  U._writeBits(line, tgt, toff * 8 + y * bipl);
              };
              UTIF2.decode._addNtimes = function(arr, n, val) {
                for (var i = 0; i < n; i++)
                  arr.push(val);
              };
              UTIF2.decode._writeBits = function(bits, tgt, boff) {
                for (var i = 0; i < bits.length; i++)
                  tgt[boff + i >>> 3] |= bits[i] << 7 - (boff + i & 7);
              };
              UTIF2.decode._decodeLZW = function(data, off, tgt, toff) {
                if (UTIF2.decode._lzwTab == null) {
                  var tb = new Uint32Array(65535), tn = new Uint16Array(65535), chr = new Uint8Array(2e6);
                  for (var i = 0; i < 256; i++) {
                    chr[i << 2] = i;
                    tb[i] = i << 2;
                    tn[i] = 1;
                  }
                  UTIF2.decode._lzwTab = [tb, tn, chr];
                }
                var copy = UTIF2.decode._copyData;
                var tab = UTIF2.decode._lzwTab[0], tln = UTIF2.decode._lzwTab[1], chr = UTIF2.decode._lzwTab[2], totl = 258, chrl = 258 << 2;
                var bits = 9, boff = off << 3;
                var ClearCode = 256, EoiCode = 257;
                var v = 0, Code = 0, OldCode = 0;
                while (true) {
                  v = data[boff >>> 3] << 16 | data[boff + 8 >>> 3] << 8 | data[boff + 16 >>> 3];
                  Code = v >> 24 - (boff & 7) - bits & (1 << bits) - 1;
                  boff += bits;
                  if (Code == EoiCode)
                    break;
                  if (Code == ClearCode) {
                    bits = 9;
                    totl = 258;
                    chrl = 258 << 2;
                    v = data[boff >>> 3] << 16 | data[boff + 8 >>> 3] << 8 | data[boff + 16 >>> 3];
                    Code = v >> 24 - (boff & 7) - bits & (1 << bits) - 1;
                    boff += bits;
                    if (Code == EoiCode)
                      break;
                    tgt[toff] = Code;
                    toff++;
                  } else if (Code < totl) {
                    var cd = tab[Code], cl = tln[Code];
                    copy(chr, cd, tgt, toff, cl);
                    toff += cl;
                    if (OldCode >= totl) {
                      tab[totl] = chrl;
                      chr[tab[totl]] = cd[0];
                      tln[totl] = 1;
                      chrl = chrl + 1 + 3 & ~3;
                      totl++;
                    } else {
                      tab[totl] = chrl;
                      var nit = tab[OldCode], nil = tln[OldCode];
                      copy(chr, nit, chr, chrl, nil);
                      chr[chrl + nil] = chr[cd];
                      nil++;
                      tln[totl] = nil;
                      totl++;
                      chrl = chrl + nil + 3 & ~3;
                    }
                    if (totl + 1 == 1 << bits)
                      bits++;
                  } else {
                    if (OldCode >= totl) {
                      tab[totl] = chrl;
                      tln[totl] = 0;
                      totl++;
                    } else {
                      tab[totl] = chrl;
                      var nit = tab[OldCode], nil = tln[OldCode];
                      copy(chr, nit, chr, chrl, nil);
                      chr[chrl + nil] = chr[chrl];
                      nil++;
                      tln[totl] = nil;
                      totl++;
                      copy(chr, chrl, tgt, toff, nil);
                      toff += nil;
                      chrl = chrl + nil + 3 & ~3;
                    }
                    if (totl + 1 == 1 << bits)
                      bits++;
                  }
                  OldCode = Code;
                }
              };
              UTIF2.decode._copyData = function(s, so, t, to, l) {
                for (var i = 0; i < l; i += 4) {
                  t[to + i] = s[so + i];
                  t[to + i + 1] = s[so + i + 1];
                  t[to + i + 2] = s[so + i + 2];
                  t[to + i + 3] = s[so + i + 3];
                }
              };
              UTIF2.tags = {
                254: "NewSubfileType",
                255: "SubfileType",
                256: "ImageWidth",
                257: "ImageLength",
                258: "BitsPerSample",
                259: "Compression",
                262: "PhotometricInterpretation",
                266: "FillOrder",
                269: "DocumentName",
                270: "ImageDescription",
                271: "Make",
                272: "Model",
                273: "StripOffset",
                274: "Orientation",
                277: "SamplesPerPixel",
                278: "RowsPerStrip",
                279: "StripByteCounts",
                280: "MinSampleValue",
                281: "MaxSampleValue",
                282: "XResolution",
                283: "YResolution",
                284: "PlanarConfiguration",
                285: "PageName",
                286: "XPosition",
                287: "YPosition",
                292: "T4Options",
                296: "ResolutionUnit",
                297: "PageNumber",
                305: "Software",
                306: "DateTime",
                315: "Artist",
                316: "HostComputer",
                317: "Predictor",
                318: "WhitePoint",
                319: "PrimaryChromaticities",
                320: "ColorMap",
                321: "HalftoneHints",
                322: "TileWidth",
                323: "TileLength",
                324: "TileOffset",
                325: "TileByteCounts",
                330: "SubIFDs",
                336: "DotRange",
                338: "ExtraSample",
                339: "SampleFormat",
                347: "JPEGTables",
                512: "JPEGProc",
                513: "JPEGInterchangeFormat",
                514: "JPEGInterchangeFormatLength",
                519: "JPEGQTables",
                520: "JPEGDCTables",
                521: "JPEGACTables",
                529: "YCbCrCoefficients",
                530: "YCbCrSubSampling",
                531: "YCbCrPositioning",
                532: "ReferenceBlackWhite",
                700: "XMP",
                33421: "CFARepeatPatternDim",
                33422: "CFAPattern",
                33432: "Copyright",
                33434: "ExposureTime",
                33437: "FNumber",
                33723: "IPTC/NAA",
                34377: "Photoshop",
                34665: "ExifIFD",
                34675: "ICC Profile",
                34850: "ExposureProgram",
                34853: "GPSInfo",
                34855: "ISOSpeedRatings",
                34858: "TimeZoneOffset",
                34859: "SelfTimeMode",
                36867: "DateTimeOriginal",
                36868: "DateTimeDigitized",
                37377: "ShutterSpeedValue",
                37378: "ApertureValue",
                37380: "ExposureBiasValue",
                37383: "MeteringMode",
                37385: "Flash",
                37386: "FocalLength",
                37390: "FocalPlaneXResolution",
                37391: "FocalPlaneYResolution",
                37392: "FocalPlaneResolutionUnit",
                37393: "ImageNumber",
                37398: "TIFF/EPStandardID",
                37399: "SensingMethod",
                37500: "MakerNote",
                37510: "UserComment",
                37724: "ImageSourceData",
                40092: "XPComment",
                40094: "XPKeywords",
                40961: "ColorSpace",
                40962: "PixelXDimension",
                40963: "PixelXDimension",
                41486: "FocalPlaneXResolution",
                41487: "FocalPlaneYResolution",
                41488: "FocalPlaneResolutionUnit",
                41985: "CustomRendered",
                41986: "ExposureMode",
                41987: "WhiteBalance",
                41990: "SceneCaptureType",
                50706: "DNGVersion",
                50707: "DNGBackwardVersion",
                50708: "UniqueCameraModel",
                50709: "LocalizedCameraModel",
                50710: "CFAPlaneColor",
                50711: "CFALayout",
                50712: "LinearizationTable",
                50713: "BlackLevelRepeatDim",
                50714: "BlackLevel",
                50716: "BlackLevelDeltaV",
                50717: "WhiteLevel",
                50718: "DefaultScale",
                50719: "DefaultCropOrigin",
                50720: "DefaultCropSize",
                50733: "BayerGreenSplit",
                50738: "AntiAliasStrength",
                50721: "ColorMatrix1",
                50722: "ColorMatrix2",
                50723: "CameraCalibration1",
                50724: "CameraCalibration2",
                50727: "AnalogBalance",
                50728: "AsShotNeutral",
                50730: "BaselineExposure",
                50731: "BaselineNoise",
                50732: "BaselineSharpness",
                50734: "LinearResponseLimit",
                50735: "CameraSerialNumber",
                50736: "LensInfo",
                50739: "ShadowScale",
                50740: "DNGPrivateData",
                50741: "MakerNoteSafety",
                50778: "CalibrationIlluminant1",
                50779: "CalibrationIlluminant2",
                50780: "BestQualityScale",
                50781: "RawDataUniqueID",
                50827: "OriginalRawFileName",
                50829: "ActiveArea",
                50830: "MaskedAreas",
                50931: "CameraCalibrationSignature",
                50932: "ProfileCalibrationSignature",
                50935: "NoiseReductionApplied",
                50936: "ProfileName",
                50937: "ProfileHueSatMapDims",
                50938: "ProfileHueSatMapData1",
                50939: "ProfileHueSatMapData2",
                50940: "ProfileToneCurve",
                50941: "ProfileEmbedPolicy",
                50942: "ProfileCopyright",
                50964: "ForwardMatrix1",
                50965: "ForwardMatrix2",
                50966: "PreviewApplicationName",
                50967: "PreviewApplicationVersion",
                50969: "PreviewSettingsDigest",
                50970: "PreviewColorSpace",
                50971: "PreviewDateTime",
                50972: "RawImageDigest",
                51008: "OpcodeList1",
                51009: "OpcodeList2",
                51022: "OpcodeList3",
                51041: "NoiseProfile",
                51089: "OriginalDefaultFinalSize",
                51090: "OriginalBestQualityFinalSize",
                51091: "OriginalDefaultCropSize",
                51125: "DefaultUserCrop"
              };
              UTIF2.ttypes = { 256: 3, 257: 3, 258: 3, 259: 3, 262: 3, 273: 4, 274: 3, 277: 3, 278: 4, 279: 4, 282: 5, 283: 5, 284: 3, 286: 5, 287: 5, 296: 3, 305: 2, 306: 2, 338: 3, 513: 4, 514: 4, 34665: 4 };
              UTIF2._readIFD = function(bin, data, offset, ifds) {
                var cnt = bin.readUshort(data, offset);
                offset += 2;
                var ifd = {};
                ifds.push(ifd);
                for (var i = 0; i < cnt; i++) {
                  var tag = bin.readUshort(data, offset);
                  offset += 2;
                  var type = bin.readUshort(data, offset);
                  offset += 2;
                  var num = bin.readUint(data, offset);
                  offset += 4;
                  var voff = bin.readUint(data, offset);
                  offset += 4;
                  var arr = [];
                  ifd["t" + tag] = arr;
                  if (type == 1 || type == 7) {
                    for (var j = 0; j < num; j++)
                      arr.push(data[(num < 5 ? offset - 4 : voff) + j]);
                  }
                  if (type == 2) {
                    arr.push(bin.readASCII(data, num < 5 ? offset - 4 : voff, num - 1));
                  }
                  if (type == 3) {
                    for (var j = 0; j < num; j++)
                      arr.push(bin.readUshort(data, (num < 3 ? offset - 4 : voff) + 2 * j));
                  }
                  if (type == 4) {
                    for (var j = 0; j < num; j++)
                      arr.push(bin.readUint(data, (num < 2 ? offset - 4 : voff) + 4 * j));
                  }
                  if (type == 5) {
                    for (var j = 0; j < num; j++)
                      arr.push(bin.readUint(data, voff + j * 8) / bin.readUint(data, voff + j * 8 + 4));
                  }
                  if (type == 8) {
                    for (var j = 0; j < num; j++)
                      arr.push(bin.readShort(data, (num < 3 ? offset - 4 : voff) + 2 * j));
                  }
                  if (type == 9) {
                    for (var j = 0; j < num; j++)
                      arr.push(bin.readInt(data, (num < 2 ? offset - 4 : voff) + 4 * j));
                  }
                  if (type == 10) {
                    for (var j = 0; j < num; j++)
                      arr.push(bin.readInt(data, voff + j * 8) / bin.readInt(data, voff + j * 8 + 4));
                  }
                  if (type == 11) {
                    for (var j = 0; j < num; j++)
                      arr.push(bin.readFloat(data, voff + j * 4));
                  }
                  if (type == 12) {
                    for (var j = 0; j < num; j++)
                      arr.push(bin.readDouble(data, voff + j * 8));
                  }
                  if (num != 0 && arr.length == 0)
                    log("unknown TIFF tag type: ", type, "num:", num);
                  if (tag == 330)
                    for (var j = 0; j < num; j++)
                      UTIF2._readIFD(bin, data, arr[j], ifds);
                }
                return offset;
              };
              UTIF2._writeIFD = function(bin, data, offset, ifd) {
                var keys = Object.keys(ifd);
                bin.writeUshort(data, offset, keys.length);
                offset += 2;
                var eoff = offset + keys.length * 12 + 4;
                for (var ki = 0; ki < keys.length; ki++) {
                  var key = keys[ki];
                  var tag = parseInt(key.slice(1)), type = UTIF2.ttypes[tag];
                  if (type == null)
                    throw new Error("unknown type of tag: " + tag);
                  var val = ifd[key];
                  if (type == 2)
                    val = val[0] + "\0";
                  var num = val.length;
                  bin.writeUshort(data, offset, tag);
                  offset += 2;
                  bin.writeUshort(data, offset, type);
                  offset += 2;
                  bin.writeUint(data, offset, num);
                  offset += 4;
                  var dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][type] * num;
                  var toff = offset;
                  if (dlen > 4) {
                    bin.writeUint(data, offset, eoff);
                    toff = eoff;
                  }
                  if (type == 2) {
                    bin.writeASCII(data, toff, val);
                  }
                  if (type == 3) {
                    for (var i = 0; i < num; i++)
                      bin.writeUshort(data, toff + 2 * i, val[i]);
                  }
                  if (type == 4) {
                    for (var i = 0; i < num; i++)
                      bin.writeUint(data, toff + 4 * i, val[i]);
                  }
                  if (type == 5) {
                    for (var i = 0; i < num; i++) {
                      bin.writeUint(data, toff + 8 * i, Math.round(val[i] * 1e4));
                      bin.writeUint(data, toff + 8 * i + 4, 1e4);
                    }
                  }
                  if (type == 12) {
                    for (var i = 0; i < num; i++)
                      bin.writeDouble(data, toff + 8 * i, val[i]);
                  }
                  if (dlen > 4) {
                    dlen += dlen & 1;
                    eoff += dlen;
                  }
                  offset += 4;
                }
                return [offset, eoff];
              };
              UTIF2.toRGBA8 = function(out) {
                var w = out.width, h = out.height, area = w * h, qarea = area * 4, data = out.data;
                var img = new Uint8Array(area * 4);
                var intp = out["t262"][0], bps = out["t258"] ? Math.min(32, out["t258"][0]) : 1, isLE = out.isLE ? 1 : 0;
                if (false) {
                } else if (intp == 0) {
                  var bpl = Math.ceil(bps * w / 8);
                  for (var y = 0; y < h; y++) {
                    var off = y * bpl, io = y * w;
                    if (bps == 1)
                      for (var i = 0; i < w; i++) {
                        var qi = io + i << 2, px = data[off + (i >> 3)] >> 7 - (i & 7) & 1;
                        img[qi] = img[qi + 1] = img[qi + 2] = (1 - px) * 255;
                        img[qi + 3] = 255;
                      }
                    if (bps == 4)
                      for (var i = 0; i < w; i++) {
                        var qi = io + i << 2, px = data[off + (i >> 1)] >> 4 - 4 * (i & 1) & 15;
                        img[qi] = img[qi + 1] = img[qi + 2] = (15 - px) * 17;
                        img[qi + 3] = 255;
                      }
                    if (bps == 8)
                      for (var i = 0; i < w; i++) {
                        var qi = io + i << 2, px = data[off + i];
                        img[qi] = img[qi + 1] = img[qi + 2] = 255 - px;
                        img[qi + 3] = 255;
                      }
                  }
                } else if (intp == 1) {
                  var bpl = Math.ceil(bps * w / 8);
                  for (var y = 0; y < h; y++) {
                    var off = y * bpl, io = y * w;
                    if (bps == 1)
                      for (var i = 0; i < w; i++) {
                        var qi = io + i << 2, px = data[off + (i >> 3)] >> 7 - (i & 7) & 1;
                        img[qi] = img[qi + 1] = img[qi + 2] = px * 255;
                        img[qi + 3] = 255;
                      }
                    if (bps == 2)
                      for (var i = 0; i < w; i++) {
                        var qi = io + i << 2, px = data[off + (i >> 2)] >> 6 - 2 * (i & 3) & 3;
                        img[qi] = img[qi + 1] = img[qi + 2] = px * 85;
                        img[qi + 3] = 255;
                      }
                    if (bps == 8)
                      for (var i = 0; i < w; i++) {
                        var qi = io + i << 2, px = data[off + i];
                        img[qi] = img[qi + 1] = img[qi + 2] = px;
                        img[qi + 3] = 255;
                      }
                    if (bps == 16)
                      for (var i = 0; i < w; i++) {
                        var qi = io + i << 2, px = data[off + (2 * i + isLE)];
                        img[qi] = img[qi + 1] = img[qi + 2] = Math.min(255, px);
                        img[qi + 3] = 255;
                      }
                  }
                } else if (intp == 2) {
                  if (bps == 8) {
                    if (out["t338"]) {
                      if (out["t338"][0] > 0)
                        for (var i = 0; i < qarea; i++)
                          img[i] = data[i];
                      else
                        for (var i = 0; i < qarea; i += 4) {
                          img[i] = data[i];
                          img[i + 1] = data[i + 1];
                          img[i + 2] = data[i + 2];
                          img[i + 3] = 255;
                        }
                    } else {
                      var smpls = out["t258"] ? out["t258"].length : 3;
                      if (smpls == 4)
                        for (var i = 0; i < qarea; i++)
                          img[i] = data[i];
                      if (smpls == 3)
                        for (var i = 0; i < area; i++) {
                          var qi = i << 2, ti = i * 3;
                          img[qi] = data[ti];
                          img[qi + 1] = data[ti + 1];
                          img[qi + 2] = data[ti + 2];
                          img[qi + 3] = 255;
                        }
                    }
                  } else
                    for (var i = 0; i < area; i++) {
                      var qi = i << 2, ti = i * 6;
                      img[qi] = data[ti];
                      img[qi + 1] = data[ti + 2];
                      img[qi + 2] = data[ti + 4];
                      img[qi + 3] = 255;
                    }
                } else if (intp == 3) {
                  var map = out["t320"];
                  for (var i = 0; i < area; i++) {
                    var qi = i << 2, mi = data[i];
                    img[qi] = map[mi] >> 8;
                    img[qi + 1] = map[256 + mi] >> 8;
                    img[qi + 2] = map[512 + mi] >> 8;
                    img[qi + 3] = 255;
                  }
                } else if (intp == 5) {
                  var smpls = out["t258"] ? out["t258"].length : 4;
                  var gotAlpha = smpls > 4 ? 1 : 0;
                  for (var i = 0; i < area; i++) {
                    var qi = i << 2, si = i * smpls;
                    var C = 255 - data[si], M = 255 - data[si + 1], Y = 255 - data[si + 2], K = (255 - data[si + 3]) * (1 / 255);
                    img[qi] = ~~(C * K + 0.5);
                    img[qi + 1] = ~~(M * K + 0.5);
                    img[qi + 2] = ~~(Y * K + 0.5);
                    img[qi + 3] = 255 * (1 - gotAlpha) + data[si + 4] * gotAlpha;
                  }
                } else
                  log("Unknown Photometric interpretation: " + intp);
                return img;
              };
              UTIF2.replaceIMG = function() {
                var imgs = document.getElementsByTagName("img");
                for (var i = 0; i < imgs.length; i++) {
                  var img = imgs[i], src = img.getAttribute("src");
                  if (src == null)
                    continue;
                  var suff = src.split(".").pop().toLowerCase();
                  if (suff != "tif" && suff != "tiff")
                    continue;
                  var xhr = new XMLHttpRequest();
                  UTIF2._xhrs.push(xhr);
                  UTIF2._imgs.push(img);
                  xhr.open("GET", src);
                  xhr.responseType = "arraybuffer";
                  xhr.onload = UTIF2._imgLoaded;
                  xhr.send();
                }
              };
              UTIF2._xhrs = [];
              UTIF2._imgs = [];
              UTIF2._imgLoaded = function(e) {
                var buff = e.target.response;
                var ifds = UTIF2.decode(buff), page = ifds[0];
                UTIF2.decodeImages(buff, ifds);
                var rgba = UTIF2.toRGBA8(page), w = page.width, h = page.height;
                var ind = UTIF2._xhrs.indexOf(e.target), img = UTIF2._imgs[ind];
                UTIF2._xhrs.splice(ind, 1);
                UTIF2._imgs.splice(ind, 1);
                var cnv = document.createElement("canvas");
                cnv.width = w;
                cnv.height = h;
                var ctx = cnv.getContext("2d"), imgd = ctx.createImageData(w, h);
                for (var i = 0; i < rgba.length; i++)
                  imgd.data[i] = rgba[i];
                ctx.putImageData(imgd, 0, 0);
                var attr = ["style", "class", "id"];
                for (var i = 0; i < attr.length; i++)
                  cnv.setAttribute(attr[i], img.getAttribute(attr[i]));
                img.parentNode.replaceChild(cnv, img);
              };
              UTIF2._binBE = {
                nextZero: function(data, o) {
                  while (data[o] != 0)
                    o++;
                  return o;
                },
                readUshort: function(buff, p) {
                  return buff[p] << 8 | buff[p + 1];
                },
                readShort: function(buff, p) {
                  var a = UTIF2._binBE.ui8;
                  a[0] = buff[p + 1];
                  a[1] = buff[p + 0];
                  return UTIF2._binBE.i16[0];
                },
                readInt: function(buff, p) {
                  var a = UTIF2._binBE.ui8;
                  a[0] = buff[p + 3];
                  a[1] = buff[p + 2];
                  a[2] = buff[p + 1];
                  a[3] = buff[p + 0];
                  return UTIF2._binBE.i32[0];
                },
                readUint: function(buff, p) {
                  var a = UTIF2._binBE.ui8;
                  a[0] = buff[p + 3];
                  a[1] = buff[p + 2];
                  a[2] = buff[p + 1];
                  a[3] = buff[p + 0];
                  return UTIF2._binBE.ui32[0];
                },
                readASCII: function(buff, p, l) {
                  var s = "";
                  for (var i = 0; i < l; i++)
                    s += String.fromCharCode(buff[p + i]);
                  return s;
                },
                readFloat: function(buff, p) {
                  var a = UTIF2._binBE.ui8;
                  for (var i = 0; i < 4; i++)
                    a[i] = buff[p + 3 - i];
                  return UTIF2._binBE.fl32[0];
                },
                readDouble: function(buff, p) {
                  var a = UTIF2._binBE.ui8;
                  for (var i = 0; i < 8; i++)
                    a[i] = buff[p + 7 - i];
                  return UTIF2._binBE.fl64[0];
                },
                writeUshort: function(buff, p, n) {
                  buff[p] = n >> 8 & 255;
                  buff[p + 1] = n & 255;
                },
                writeUint: function(buff, p, n) {
                  buff[p] = n >> 24 & 255;
                  buff[p + 1] = n >> 16 & 255;
                  buff[p + 2] = n >> 8 & 255;
                  buff[p + 3] = n >> 0 & 255;
                },
                writeASCII: function(buff, p, s) {
                  for (var i = 0; i < s.length; i++)
                    buff[p + i] = s.charCodeAt(i);
                },
                writeDouble: function(buff, p, n) {
                  UTIF2._binBE.fl64[0] = n;
                  for (var i = 0; i < 8; i++)
                    buff[p + i] = UTIF2._binBE.ui8[7 - i];
                }
              };
              UTIF2._binBE.ui8 = new Uint8Array(8);
              UTIF2._binBE.i16 = new Int16Array(UTIF2._binBE.ui8.buffer);
              UTIF2._binBE.i32 = new Int32Array(UTIF2._binBE.ui8.buffer);
              UTIF2._binBE.ui32 = new Uint32Array(UTIF2._binBE.ui8.buffer);
              UTIF2._binBE.fl32 = new Float32Array(UTIF2._binBE.ui8.buffer);
              UTIF2._binBE.fl64 = new Float64Array(UTIF2._binBE.ui8.buffer);
              UTIF2._binLE = {
                nextZero: UTIF2._binBE.nextZero,
                readUshort: function(buff, p) {
                  return buff[p + 1] << 8 | buff[p];
                },
                readShort: function(buff, p) {
                  var a = UTIF2._binBE.ui8;
                  a[0] = buff[p + 0];
                  a[1] = buff[p + 1];
                  return UTIF2._binBE.i16[0];
                },
                readInt: function(buff, p) {
                  var a = UTIF2._binBE.ui8;
                  a[0] = buff[p + 0];
                  a[1] = buff[p + 1];
                  a[2] = buff[p + 2];
                  a[3] = buff[p + 3];
                  return UTIF2._binBE.i32[0];
                },
                readUint: function(buff, p) {
                  var a = UTIF2._binBE.ui8;
                  a[0] = buff[p + 0];
                  a[1] = buff[p + 1];
                  a[2] = buff[p + 2];
                  a[3] = buff[p + 3];
                  return UTIF2._binBE.ui32[0];
                },
                readASCII: UTIF2._binBE.readASCII,
                readFloat: function(buff, p) {
                  var a = UTIF2._binBE.ui8;
                  for (var i = 0; i < 4; i++)
                    a[i] = buff[p + i];
                  return UTIF2._binBE.fl32[0];
                },
                readDouble: function(buff, p) {
                  var a = UTIF2._binBE.ui8;
                  for (var i = 0; i < 8; i++)
                    a[i] = buff[p + i];
                  return UTIF2._binBE.fl64[0];
                }
              };
              UTIF2._copyTile = function(tb, tw, th, b, w, h, xoff, yoff) {
                var xlim = Math.min(tw, w - xoff);
                var ylim = Math.min(th, h - yoff);
                for (var y = 0; y < ylim; y++) {
                  var tof = (yoff + y) * w + xoff;
                  var sof = y * tw;
                  for (var x = 0; x < xlim; x++)
                    b[tof + x] = tb[sof + x];
                }
              };
            })(UTIF, pako);
          })();
        }).call(this, require2("_process"));
      }, { "_process": 133, "pako": 86 }], 183: [function(require2, module3, exports3) {
        (function(global2) {
          module3.exports = deprecate;
          function deprecate(fn, msg) {
            if (config("noDeprecation")) {
              return fn;
            }
            var warned = false;
            function deprecated() {
              if (!warned) {
                if (config("throwDeprecation")) {
                  throw new Error(msg);
                } else if (config("traceDeprecation")) {
                  console.trace(msg);
                } else {
                  console.warn(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }
            return deprecated;
          }
          function config(name) {
            try {
              if (!global2.localStorage)
                return false;
            } catch (_) {
              return false;
            }
            var val = global2.localStorage[name];
            if (null == val)
              return false;
            return String(val).toLowerCase() === "true";
          }
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
      }, {}], 184: [function(require2, module3, exports3) {
        arguments[4][26][0].apply(exports3, arguments);
      }, { "dup": 26 }], 185: [function(require2, module3, exports3) {
        arguments[4][27][0].apply(exports3, arguments);
      }, { "dup": 27 }], 186: [function(require2, module3, exports3) {
        arguments[4][28][0].apply(exports3, arguments);
      }, { "./support/isBuffer": 185, "_process": 133, "dup": 28, "inherits": 184 }], 187: [function(require2, module3, exports3) {
        "use strict";
        var window2 = require2("global/window");
        var isFunction = require2("is-function");
        var parseHeaders = require2("parse-headers");
        var xtend = require2("xtend");
        module3.exports = createXHR;
        module3.exports.default = createXHR;
        createXHR.XMLHttpRequest = window2.XMLHttpRequest || noop;
        createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest() ? createXHR.XMLHttpRequest : window2.XDomainRequest;
        forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
          createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
            options = initParams(uri, options, callback);
            options.method = method.toUpperCase();
            return _createXHR(options);
          };
        });
        function forEachArray(array, iterator) {
          for (var i = 0; i < array.length; i++) {
            iterator(array[i]);
          }
        }
        function isEmpty(obj) {
          for (var i in obj) {
            if (obj.hasOwnProperty(i))
              return false;
          }
          return true;
        }
        function initParams(uri, options, callback) {
          var params = uri;
          if (isFunction(options)) {
            callback = options;
            if (typeof uri === "string") {
              params = { uri };
            }
          } else {
            params = xtend(options, { uri });
          }
          params.callback = callback;
          return params;
        }
        function createXHR(uri, options, callback) {
          options = initParams(uri, options, callback);
          return _createXHR(options);
        }
        function _createXHR(options) {
          if (typeof options.callback === "undefined") {
            throw new Error("callback argument missing");
          }
          var called = false;
          var callback = function cbOnce(err, response, body2) {
            if (!called) {
              called = true;
              options.callback(err, response, body2);
            }
          };
          function readystatechange() {
            if (xhr.readyState === 4) {
              setTimeout(loadFunc, 0);
            }
          }
          function getBody() {
            var body2 = void 0;
            if (xhr.response) {
              body2 = xhr.response;
            } else {
              body2 = xhr.responseText || getXml(xhr);
            }
            if (isJson) {
              try {
                body2 = JSON.parse(body2);
              } catch (e) {
              }
            }
            return body2;
          }
          function errorFunc(evt) {
            clearTimeout(timeoutTimer);
            if (!(evt instanceof Error)) {
              evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"));
            }
            evt.statusCode = 0;
            return callback(evt, failureResponse);
          }
          function loadFunc() {
            if (aborted)
              return;
            var status;
            clearTimeout(timeoutTimer);
            if (options.useXDR && xhr.status === void 0) {
              status = 200;
            } else {
              status = xhr.status === 1223 ? 204 : xhr.status;
            }
            var response = failureResponse;
            var err = null;
            if (status !== 0) {
              response = {
                body: getBody(),
                statusCode: status,
                method,
                headers: {},
                url: uri,
                rawRequest: xhr
              };
              if (xhr.getAllResponseHeaders) {
                response.headers = parseHeaders(xhr.getAllResponseHeaders());
              }
            } else {
              err = new Error("Internal XMLHttpRequest Error");
            }
            return callback(err, response, response.body);
          }
          var xhr = options.xhr || null;
          if (!xhr) {
            if (options.cors || options.useXDR) {
              xhr = new createXHR.XDomainRequest();
            } else {
              xhr = new createXHR.XMLHttpRequest();
            }
          }
          var key;
          var aborted;
          var uri = xhr.url = options.uri || options.url;
          var method = xhr.method = options.method || "GET";
          var body = options.body || options.data;
          var headers = xhr.headers = options.headers || {};
          var sync = !!options.sync;
          var isJson = false;
          var timeoutTimer;
          var failureResponse = {
            body: void 0,
            headers: {},
            statusCode: 0,
            method,
            url: uri,
            rawRequest: xhr
          };
          if ("json" in options && options.json !== false) {
            isJson = true;
            headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json");
            if (method !== "GET" && method !== "HEAD") {
              headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json");
              body = JSON.stringify(options.json === true ? body : options.json);
            }
          }
          xhr.onreadystatechange = readystatechange;
          xhr.onload = loadFunc;
          xhr.onerror = errorFunc;
          xhr.onprogress = function() {
          };
          xhr.onabort = function() {
            aborted = true;
          };
          xhr.ontimeout = errorFunc;
          xhr.open(method, uri, !sync, options.username, options.password);
          if (!sync) {
            xhr.withCredentials = !!options.withCredentials;
          }
          if (!sync && options.timeout > 0) {
            timeoutTimer = setTimeout(function() {
              if (aborted)
                return;
              aborted = true;
              xhr.abort("timeout");
              var e = new Error("XMLHttpRequest timeout");
              e.code = "ETIMEDOUT";
              errorFunc(e);
            }, options.timeout);
          }
          if (xhr.setRequestHeader) {
            for (key in headers) {
              if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
              }
            }
          } else if (options.headers && !isEmpty(options.headers)) {
            throw new Error("Headers cannot be set on an XDomainRequest object");
          }
          if ("responseType" in options) {
            xhr.responseType = options.responseType;
          }
          if ("beforeSend" in options && typeof options.beforeSend === "function") {
            options.beforeSend(xhr);
          }
          xhr.send(body || null);
          return xhr;
        }
        function getXml(xhr) {
          try {
            if (xhr.responseType === "document") {
              return xhr.responseXML;
            }
            var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
            if (xhr.responseType === "" && !firefoxBugTakenEffect) {
              return xhr.responseXML;
            }
          } catch (e) {
          }
          return null;
        }
        function noop() {
        }
      }, { "global/window": 71, "is-function": 78, "parse-headers": 106, "xtend": 189 }], 188: [function(require2, module3, exports3) {
        module3.exports = function xmlparser() {
          if (typeof self.DOMParser !== "undefined") {
            return function(str) {
              var parser = new self.DOMParser();
              return parser.parseFromString(str, "application/xml");
            };
          }
          if (typeof self.ActiveXObject !== "undefined" && new self.ActiveXObject("Microsoft.XMLDOM")) {
            return function(str) {
              var xmlDoc = new self.ActiveXObject("Microsoft.XMLDOM");
              xmlDoc.async = "false";
              xmlDoc.loadXML(str);
              return xmlDoc;
            };
          }
          return function(str) {
            var div = document.createElement("div");
            div.innerHTML = str;
            return div;
          };
        }();
      }, {}], 189: [function(require2, module3, exports3) {
        module3.exports = extend;
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        function extend() {
          var target = {};
          for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        }
      }, {}], 190: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.srcOver = srcOver;
        exports3.dstOver = dstOver;
        exports3.multiply = multiply;
        exports3.add = add;
        exports3.screen = screen;
        exports3.overlay = overlay;
        exports3.darken = darken;
        exports3.lighten = lighten;
        exports3.hardLight = hardLight;
        exports3.difference = difference;
        exports3.exclusion = exclusion;
        function srcOver(src, dst) {
          var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          src.a *= ops;
          var a = dst.a + src.a - dst.a * src.a;
          var r = (src.r * src.a + dst.r * dst.a * (1 - src.a)) / a;
          var g = (src.g * src.a + dst.g * dst.a * (1 - src.a)) / a;
          var b = (src.b * src.a + dst.b * dst.a * (1 - src.a)) / a;
          return {
            r,
            g,
            b,
            a
          };
        }
        function dstOver(src, dst) {
          var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          src.a *= ops;
          var a = dst.a + src.a - dst.a * src.a;
          var r = (dst.r * dst.a + src.r * src.a * (1 - dst.a)) / a;
          var g = (dst.g * dst.a + src.g * src.a * (1 - dst.a)) / a;
          var b = (dst.b * dst.a + src.b * src.a * (1 - dst.a)) / a;
          return {
            r,
            g,
            b,
            a
          };
        }
        function multiply(src, dst) {
          var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          src.a *= ops;
          var a = dst.a + src.a - dst.a * src.a;
          var sra = src.r * src.a;
          var sga = src.g * src.a;
          var sba = src.b * src.a;
          var dra = dst.r * dst.a;
          var dga = dst.g * dst.a;
          var dba = dst.b * dst.a;
          var r = (sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
          var g = (sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
          var b = (sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
          return {
            r,
            g,
            b,
            a
          };
        }
        function add(src, dst) {
          var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          src.a *= ops;
          var a = dst.a + src.a - dst.a * src.a;
          var sra = src.r * src.a;
          var sga = src.g * src.a;
          var sba = src.b * src.a;
          var dra = dst.r * dst.a;
          var dga = dst.g * dst.a;
          var dba = dst.b * dst.a;
          var r = (sra + dra) / a;
          var g = (sga + dga) / a;
          var b = (sba + dba) / a;
          return {
            r,
            g,
            b,
            a
          };
        }
        function screen(src, dst) {
          var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          src.a *= ops;
          var a = dst.a + src.a - dst.a * src.a;
          var sra = src.r * src.a;
          var sga = src.g * src.a;
          var sba = src.b * src.a;
          var dra = dst.r * dst.a;
          var dga = dst.g * dst.a;
          var dba = dst.b * dst.a;
          var r = (sra * dst.a + dra * src.a - sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
          var g = (sga * dst.a + dga * src.a - sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
          var b = (sba * dst.a + dba * src.a - sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
          return {
            r,
            g,
            b,
            a
          };
        }
        function overlay(src, dst) {
          var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          src.a *= ops;
          var a = dst.a + src.a - dst.a * src.a;
          var sra = src.r * src.a;
          var sga = src.g * src.a;
          var sba = src.b * src.a;
          var dra = dst.r * dst.a;
          var dga = dst.g * dst.a;
          var dba = dst.b * dst.a;
          var r = (2 * dra <= dst.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a;
          var g = (2 * dga <= dst.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a;
          var b = (2 * dba <= dst.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a;
          return {
            r,
            g,
            b,
            a
          };
        }
        function darken(src, dst) {
          var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          src.a *= ops;
          var a = dst.a + src.a - dst.a * src.a;
          var sra = src.r * src.a;
          var sga = src.g * src.a;
          var sba = src.b * src.a;
          var dra = dst.r * dst.a;
          var dga = dst.g * dst.a;
          var dba = dst.b * dst.a;
          var r = (Math.min(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
          var g = (Math.min(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
          var b = (Math.min(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
          return {
            r,
            g,
            b,
            a
          };
        }
        function lighten(src, dst) {
          var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          src.a *= ops;
          var a = dst.a + src.a - dst.a * src.a;
          var sra = src.r * src.a;
          var sga = src.g * src.a;
          var sba = src.b * src.a;
          var dra = dst.r * dst.a;
          var dga = dst.g * dst.a;
          var dba = dst.b * dst.a;
          var r = (Math.max(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
          var g = (Math.max(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
          var b = (Math.max(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
          return {
            r,
            g,
            b,
            a
          };
        }
        function hardLight(src, dst) {
          var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          src.a *= ops;
          var a = dst.a + src.a - dst.a * src.a;
          var sra = src.r * src.a;
          var sga = src.g * src.a;
          var sba = src.b * src.a;
          var dra = dst.r * dst.a;
          var dga = dst.g * dst.a;
          var dba = dst.b * dst.a;
          var r = (2 * sra <= src.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a;
          var g = (2 * sga <= src.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a;
          var b = (2 * sba <= src.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a;
          return {
            r,
            g,
            b,
            a
          };
        }
        function difference(src, dst) {
          var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          src.a *= ops;
          var a = dst.a + src.a - dst.a * src.a;
          var sra = src.r * src.a;
          var sga = src.g * src.a;
          var sba = src.b * src.a;
          var dra = dst.r * dst.a;
          var dga = dst.g * dst.a;
          var dba = dst.b * dst.a;
          var r = (sra + dra - 2 * Math.min(sra * dst.a, dra * src.a)) / a;
          var g = (sga + dga - 2 * Math.min(sga * dst.a, dga * src.a)) / a;
          var b = (sba + dba - 2 * Math.min(sba * dst.a, dba * src.a)) / a;
          return {
            r,
            g,
            b,
            a
          };
        }
        function exclusion(src, dst) {
          var ops = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
          src.a *= ops;
          var a = dst.a + src.a - dst.a * src.a;
          var sra = src.r * src.a;
          var sga = src.g * src.a;
          var sba = src.b * src.a;
          var dra = dst.r * dst.a;
          var dga = dst.g * dst.a;
          var dba = dst.b * dst.a;
          var r = (sra * dst.a + dra * src.a - 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a;
          var g = (sga * dst.a + dga * src.a - 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a;
          var b = (sba * dst.a + dba * src.a - 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a;
          return {
            r,
            g,
            b,
            a
          };
        }
      }, {}], 191: [function(require2, module3, exports3) {
        "use strict";
        var _interopRequireWildcard = require2("@babel/runtime/helpers/interopRequireWildcard");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = composite;
        var _utils = require2("@jimp/utils");
        var constants = _interopRequireWildcard(require2("../constants"));
        var compositeModes = _interopRequireWildcard(require2("./composite-modes"));
        function composite(src, x, y) {
          var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          var cb = arguments.length > 4 ? arguments[4] : void 0;
          if (typeof options === "function") {
            cb = options;
            options = {};
          }
          if (!(src instanceof this.constructor)) {
            return _utils.throwError.call(this, "The source must be a Jimp image", cb);
          }
          if (typeof x !== "number" || typeof y !== "number") {
            return _utils.throwError.call(this, "x and y must be numbers", cb);
          }
          var _options = options, mode = _options.mode, opacitySource = _options.opacitySource, opacityDest = _options.opacityDest;
          if (!mode) {
            mode = constants.BLEND_SOURCE_OVER;
          }
          if (typeof opacitySource !== "number" || opacitySource < 0 || opacitySource > 1) {
            opacitySource = 1;
          }
          if (typeof opacityDest !== "number" || opacityDest < 0 || opacityDest > 1) {
            opacityDest = 1;
          }
          var blendmode = compositeModes[mode];
          x = Math.round(x);
          y = Math.round(y);
          var baseImage = this;
          if (opacityDest !== 1) {
            baseImage.opacity(opacityDest);
          }
          src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function(sx, sy, idx) {
            var dstIdx = baseImage.getPixelIndex(x + sx, y + sy, constants.EDGE_CROP);
            var blended = blendmode({
              r: this.bitmap.data[idx + 0] / 255,
              g: this.bitmap.data[idx + 1] / 255,
              b: this.bitmap.data[idx + 2] / 255,
              a: this.bitmap.data[idx + 3] / 255
            }, {
              r: baseImage.bitmap.data[dstIdx + 0] / 255,
              g: baseImage.bitmap.data[dstIdx + 1] / 255,
              b: baseImage.bitmap.data[dstIdx + 2] / 255,
              a: baseImage.bitmap.data[dstIdx + 3] / 255
            }, opacitySource);
            baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(blended.r * 255);
            baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(blended.g * 255);
            baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(blended.b * 255);
            baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(blended.a * 255);
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
        module3.exports = exports3.default;
      }, { "../constants": 192, "./composite-modes": 190, "@babel/runtime/helpers/interopRequireWildcard": 12, "@jimp/utils": 235 }], 192: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.EDGE_CROP = exports3.EDGE_WRAP = exports3.EDGE_EXTEND = exports3.BLEND_EXCLUSION = exports3.BLEND_DIFFERENCE = exports3.BLEND_HARDLIGHT = exports3.BLEND_LIGHTEN = exports3.BLEND_DARKEN = exports3.BLEND_OVERLAY = exports3.BLEND_SCREEN = exports3.BLEND_ADD = exports3.BLEND_MULTIPLY = exports3.BLEND_DESTINATION_OVER = exports3.BLEND_SOURCE_OVER = exports3.VERTICAL_ALIGN_BOTTOM = exports3.VERTICAL_ALIGN_MIDDLE = exports3.VERTICAL_ALIGN_TOP = exports3.HORIZONTAL_ALIGN_RIGHT = exports3.HORIZONTAL_ALIGN_CENTER = exports3.HORIZONTAL_ALIGN_LEFT = exports3.AUTO = void 0;
        var AUTO = -1;
        exports3.AUTO = AUTO;
        var HORIZONTAL_ALIGN_LEFT = 1;
        exports3.HORIZONTAL_ALIGN_LEFT = HORIZONTAL_ALIGN_LEFT;
        var HORIZONTAL_ALIGN_CENTER = 2;
        exports3.HORIZONTAL_ALIGN_CENTER = HORIZONTAL_ALIGN_CENTER;
        var HORIZONTAL_ALIGN_RIGHT = 4;
        exports3.HORIZONTAL_ALIGN_RIGHT = HORIZONTAL_ALIGN_RIGHT;
        var VERTICAL_ALIGN_TOP = 8;
        exports3.VERTICAL_ALIGN_TOP = VERTICAL_ALIGN_TOP;
        var VERTICAL_ALIGN_MIDDLE = 16;
        exports3.VERTICAL_ALIGN_MIDDLE = VERTICAL_ALIGN_MIDDLE;
        var VERTICAL_ALIGN_BOTTOM = 32;
        exports3.VERTICAL_ALIGN_BOTTOM = VERTICAL_ALIGN_BOTTOM;
        var BLEND_SOURCE_OVER = "srcOver";
        exports3.BLEND_SOURCE_OVER = BLEND_SOURCE_OVER;
        var BLEND_DESTINATION_OVER = "dstOver";
        exports3.BLEND_DESTINATION_OVER = BLEND_DESTINATION_OVER;
        var BLEND_MULTIPLY = "multiply";
        exports3.BLEND_MULTIPLY = BLEND_MULTIPLY;
        var BLEND_ADD = "add";
        exports3.BLEND_ADD = BLEND_ADD;
        var BLEND_SCREEN = "screen";
        exports3.BLEND_SCREEN = BLEND_SCREEN;
        var BLEND_OVERLAY = "overlay";
        exports3.BLEND_OVERLAY = BLEND_OVERLAY;
        var BLEND_DARKEN = "darken";
        exports3.BLEND_DARKEN = BLEND_DARKEN;
        var BLEND_LIGHTEN = "lighten";
        exports3.BLEND_LIGHTEN = BLEND_LIGHTEN;
        var BLEND_HARDLIGHT = "hardLight";
        exports3.BLEND_HARDLIGHT = BLEND_HARDLIGHT;
        var BLEND_DIFFERENCE = "difference";
        exports3.BLEND_DIFFERENCE = BLEND_DIFFERENCE;
        var BLEND_EXCLUSION = "exclusion";
        exports3.BLEND_EXCLUSION = BLEND_EXCLUSION;
        var EDGE_EXTEND = 1;
        exports3.EDGE_EXTEND = EDGE_EXTEND;
        var EDGE_WRAP = 2;
        exports3.EDGE_WRAP = EDGE_WRAP;
        var EDGE_CROP = 3;
        exports3.EDGE_CROP = EDGE_CROP;
      }, {}], 193: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var _interopRequireWildcard = require2("@babel/runtime/helpers/interopRequireWildcard");
          var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.addConstants = addConstants;
          exports3.addJimpMethods = addJimpMethods;
          exports3.jimpEvMethod = jimpEvMethod;
          exports3.jimpEvChange = jimpEvChange;
          Object.defineProperty(exports3, "addType", {
            enumerable: true,
            get: function get() {
              return MIME.addType;
            }
          });
          exports3["default"] = void 0;
          var _construct2 = _interopRequireDefault(require2("@babel/runtime/helpers/construct"));
          var _slicedToArray2 = _interopRequireDefault(require2("@babel/runtime/helpers/slicedToArray"));
          var _classCallCheck2 = _interopRequireDefault(require2("@babel/runtime/helpers/classCallCheck"));
          var _createClass2 = _interopRequireDefault(require2("@babel/runtime/helpers/createClass"));
          var _possibleConstructorReturn2 = _interopRequireDefault(require2("@babel/runtime/helpers/possibleConstructorReturn"));
          var _getPrototypeOf2 = _interopRequireDefault(require2("@babel/runtime/helpers/getPrototypeOf"));
          var _assertThisInitialized2 = _interopRequireDefault(require2("@babel/runtime/helpers/assertThisInitialized"));
          var _inherits2 = _interopRequireDefault(require2("@babel/runtime/helpers/inherits"));
          var _defineProperty2 = _interopRequireDefault(require2("@babel/runtime/helpers/defineProperty"));
          var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
          var _fs = _interopRequireDefault(require2("fs"));
          var _path = _interopRequireDefault(require2("path"));
          var _events = _interopRequireDefault(require2("events"));
          var _utils = require2("@jimp/utils");
          var _anyBase = _interopRequireDefault(require2("any-base"));
          var _mkdirp = _interopRequireDefault(require2("mkdirp"));
          var _pixelmatch = _interopRequireDefault(require2("pixelmatch"));
          var _tinycolor = _interopRequireDefault(require2("tinycolor2"));
          var _phash = _interopRequireDefault(require2("./modules/phash"));
          var _request = _interopRequireDefault(require2("./request"));
          var _composite = _interopRequireDefault(require2("./composite"));
          var _promisify = _interopRequireDefault(require2("./utils/promisify"));
          var MIME = _interopRequireWildcard(require2("./utils/mime"));
          var _imageBitmap = require2("./utils/image-bitmap");
          var constants = _interopRequireWildcard(require2("./constants"));
          var alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_";
          var maxHashLength = [NaN, NaN];
          for (var i = 2; i < 65; i++) {
            var maxHash = (0, _anyBase["default"])(_anyBase["default"].BIN, alphabet.slice(0, i))(new Array(64 + 1).join("1"));
            maxHashLength.push(maxHash.length);
          }
          function noop() {
          }
          function isArrayBuffer(test) {
            return Object.prototype.toString.call(test).toLowerCase().indexOf("arraybuffer") > -1;
          }
          function bufferFromArrayBuffer(arrayBuffer) {
            var buffer = Buffer.alloc(arrayBuffer.byteLength);
            var view = new Uint8Array(arrayBuffer);
            for (var _i = 0; _i < buffer.length; ++_i) {
              buffer[_i] = view[_i];
            }
            return buffer;
          }
          function loadFromURL(options, cb) {
            (0, _request["default"])(options, function(err, response, data) {
              if (err) {
                return cb(err);
              }
              if ("headers" in response && "location" in response.headers) {
                options.url = response.headers.location;
                return loadFromURL(options, cb);
              }
              if ((0, _typeof2["default"])(data) === "object" && Buffer.isBuffer(data)) {
                return cb(null, data);
              }
              var msg = "Could not load Buffer from <" + options.url + "> (HTTP: " + response.statusCode + ")";
              return new Error(msg);
            });
          }
          function loadBufferFromPath(src, cb) {
            if (_fs["default"] && typeof _fs["default"].readFile === "function" && !src.match(/^(http|ftp)s?:\/\/./)) {
              _fs["default"].readFile(src, cb);
            } else {
              loadFromURL({
                url: src
              }, cb);
            }
          }
          function isRawRGBAData(obj) {
            return obj && (0, _typeof2["default"])(obj) === "object" && typeof obj.width === "number" && typeof obj.height === "number" && (Buffer.isBuffer(obj.data) || obj.data instanceof Uint8Array || typeof Uint8ClampedArray === "function" && obj.data instanceof Uint8ClampedArray) && (obj.data.length === obj.width * obj.height * 4 || obj.data.length === obj.width * obj.height * 3);
          }
          function makeRGBABufferFromRGB(buffer) {
            if (buffer.length % 3 !== 0) {
              throw new Error("Buffer length is incorrect");
            }
            var rgbaBuffer = Buffer.allocUnsafe(buffer.length / 3 * 4);
            var j = 0;
            for (var _i2 = 0; _i2 < buffer.length; _i2++) {
              rgbaBuffer[j] = buffer[_i2];
              if ((_i2 + 1) % 3 === 0) {
                rgbaBuffer[++j] = 255;
              }
              j++;
            }
            return rgbaBuffer;
          }
          var emptyBitmap = {
            data: null,
            width: null,
            height: null
          };
          var Jimp = function(_EventEmitter) {
            (0, _inherits2["default"])(Jimp2, _EventEmitter);
            function Jimp2() {
              var _this;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              (0, _classCallCheck2["default"])(this, Jimp2);
              _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Jimp2).call(this));
              (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "bitmap", emptyBitmap);
              (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_background", 0);
              (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_originalMime", Jimp2.MIME_PNG);
              (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_exif", null);
              (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_rgba", true);
              (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "writeAsync", function(path2) {
                return (0, _promisify["default"])(_this.write, (0, _assertThisInitialized2["default"])(_this), path2);
              });
              (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getBase64Async", function(mime) {
                return (0, _promisify["default"])(_this.getBase64, (0, _assertThisInitialized2["default"])(_this), mime);
              });
              (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getBuffer", _imageBitmap.getBuffer);
              (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getBufferAsync", _imageBitmap.getBufferAsync);
              (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "getPixelColour", _this.getPixelColor);
              (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "setPixelColour", _this.setPixelColor);
              var jimpInstance = (0, _assertThisInitialized2["default"])(_this);
              var cb = noop;
              if (isArrayBuffer(args[0])) {
                args[0] = bufferFromArrayBuffer(args[0]);
              }
              function finish() {
                for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args2[_key2] = arguments[_key2];
                }
                var err = args2[0];
                var evData = err || {};
                evData.methodName = "constructor";
                setTimeout(function() {
                  var _cb;
                  if (err && cb === noop) {
                    jimpInstance.emitError("constructor", err);
                  } else if (!err) {
                    jimpInstance.emitMulti("constructor", "initialized");
                  }
                  (_cb = cb).call.apply(_cb, [jimpInstance].concat(args2));
                }, 1);
              }
              if (typeof args[0] === "number" && typeof args[1] === "number" || parseInt(args[0], 10) && parseInt(args[1], 10)) {
                var w = parseInt(args[0], 10);
                var h = parseInt(args[1], 10);
                cb = args[2];
                if (typeof args[2] === "number") {
                  _this._background = args[2];
                  cb = args[3];
                }
                if (typeof args[2] === "string") {
                  _this._background = Jimp2.cssColorToHex(args[2]);
                  cb = args[3];
                }
                if (typeof cb === "undefined") {
                  cb = noop;
                }
                if (typeof cb !== "function") {
                  return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), "cb must be a function", finish));
                }
                _this.bitmap = {
                  data: Buffer.alloc(w * h * 4),
                  width: w,
                  height: h
                };
                for (var _i3 = 0; _i3 < _this.bitmap.data.length; _i3 += 4) {
                  _this.bitmap.data.writeUInt32BE(_this._background, _i3);
                }
                finish(null, (0, _assertThisInitialized2["default"])(_this));
              } else if ((0, _typeof2["default"])(args[0]) === "object" && args[0].url) {
                cb = args[1] || noop;
                if (typeof cb !== "function") {
                  return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), "cb must be a function", finish));
                }
                loadFromURL(args[0], function(err, data2) {
                  if (err) {
                    return _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), err, finish);
                  }
                  _this.parseBitmap(data2, args[0].url, finish);
                });
              } else if (args[0] instanceof Jimp2) {
                var original = args[0];
                cb = args[1];
                if (typeof cb === "undefined") {
                  cb = noop;
                }
                if (typeof cb !== "function") {
                  return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), "cb must be a function", finish));
                }
                _this.bitmap = {
                  data: Buffer.from(original.bitmap.data),
                  width: original.bitmap.width,
                  height: original.bitmap.height
                };
                _this._quality = original._quality;
                _this._deflateLevel = original._deflateLevel;
                _this._deflateStrategy = original._deflateStrategy;
                _this._filterType = original._filterType;
                _this._rgba = original._rgba;
                _this._background = original._background;
                _this._originalMime = original._originalMime;
                finish(null, (0, _assertThisInitialized2["default"])(_this));
              } else if (isRawRGBAData(args[0])) {
                var imageData = args[0];
                cb = args[1] || noop;
                var isRGBA = imageData.width * imageData.height * 4 === imageData.data.length;
                var buffer = isRGBA ? Buffer.from(imageData.data) : makeRGBABufferFromRGB(imageData.data);
                _this.bitmap = {
                  data: buffer,
                  width: imageData.width,
                  height: imageData.height
                };
                finish(null, (0, _assertThisInitialized2["default"])(_this));
              } else if (typeof args[0] === "string") {
                var path = args[0];
                cb = args[1];
                if (typeof cb === "undefined") {
                  cb = noop;
                }
                if (typeof cb !== "function") {
                  return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), "cb must be a function", finish));
                }
                loadBufferFromPath(path, function(err, data2) {
                  if (err) {
                    return _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), err, finish);
                  }
                  _this.parseBitmap(data2, path, finish);
                });
              } else if ((0, _typeof2["default"])(args[0]) === "object" && Buffer.isBuffer(args[0])) {
                var data = args[0];
                cb = args[1];
                if (typeof cb !== "function") {
                  return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), "cb must be a function", finish));
                }
                _this.parseBitmap(data, null, finish);
              } else {
                cb = args[args.length - 1];
                if (typeof cb !== "function") {
                  cb = args[args.length - 2];
                  if (typeof cb !== "function") {
                    cb = noop;
                  }
                }
                var extraConstructor = Jimp2.__extraConstructors.find(function(c) {
                  return c.test.apply(c, args);
                });
                if (extraConstructor) {
                  new Promise(function(resolve, reject) {
                    var _extraConstructor$run;
                    return (_extraConstructor$run = extraConstructor.run).call.apply(_extraConstructor$run, [(0, _assertThisInitialized2["default"])(_this), resolve, reject].concat(args));
                  }).then(function() {
                    return finish(null, (0, _assertThisInitialized2["default"])(_this));
                  })["catch"](finish);
                } else {
                  return (0, _possibleConstructorReturn2["default"])(_this, _utils.throwError.call((0, _assertThisInitialized2["default"])(_this), "No matching constructor overloading was found. Please see the docs for how to call the Jimp constructor.", finish));
                }
              }
              return _this;
            }
            (0, _createClass2["default"])(Jimp2, [{
              key: "parseBitmap",
              value: function parseBitmap(data, path, finish) {
                _imageBitmap.parseBitmap.call(this, data, null, finish);
              }
              /**
               * Sets the type of the image (RGB or RGBA) when saving in a format that supports transparency (default is RGBA)
               * @param {boolean} bool A Boolean, true to use RGBA or false to use RGB
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
            }, {
              key: "rgba",
              value: function rgba(bool, cb) {
                if (typeof bool !== "boolean") {
                  return _utils.throwError.call(this, "bool must be a boolean, true for RGBA or false for RGB", cb);
                }
                this._rgba = bool;
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, this);
                }
                return this;
              }
              /**
               * Emit for multiple listeners
               * @param {string} methodName name of the method to emit an error for
               * @param {string} eventName name of the eventName to emit an error for
               * @param {object} data to emit
               */
            }, {
              key: "emitMulti",
              value: function emitMulti(methodName, eventName) {
                var data = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
                data = Object.assign(data, {
                  methodName,
                  eventName
                });
                this.emit("any", data);
                if (methodName) {
                  this.emit(methodName, data);
                }
                this.emit(eventName, data);
              }
            }, {
              key: "emitError",
              value: function emitError(methodName, err) {
                this.emitMulti(methodName, "error", err);
              }
              /**
               * Get the current height of the image
               * @return {number} height of the image
               */
            }, {
              key: "getHeight",
              value: function getHeight() {
                return this.bitmap.height;
              }
              /**
               * Get the current width of the image
               * @return {number} width of the image
               */
            }, {
              key: "getWidth",
              value: function getWidth() {
                return this.bitmap.width;
              }
              /**
               * Nicely format Jimp object when sent to the console e.g. console.log(image)
               * @returns {string} pretty printed
               */
            }, {
              key: "inspect",
              value: function inspect() {
                return "<Jimp " + (this.bitmap === emptyBitmap ? "pending..." : this.bitmap.width + "x" + this.bitmap.height) + ">";
              }
              /**
               * Nicely format Jimp object when converted to a string
               * @returns {string} pretty printed
               */
            }, {
              key: "toString",
              value: function toString() {
                return "[object Jimp]";
              }
              /**
               * Returns the original MIME of the image (default: "image/png")
               * @returns {string} the MIME
               */
            }, {
              key: "getMIME",
              value: function getMIME() {
                var mime = this._originalMime || Jimp2.MIME_PNG;
                return mime;
              }
              /**
               * Returns the appropriate file extension for the original MIME of the image (default: "png")
               * @returns {string} the file extension
               */
            }, {
              key: "getExtension",
              value: function getExtension() {
                var mime = this.getMIME();
                return MIME.getExtension(mime);
              }
              /**
               * Writes the image to a file
               * @param {string} path a path to the destination file
               * @param {function(Error, Jimp)} cb (optional) a function to call when the image is saved to disk
               * @returns {Jimp} this for chaining of methods
               */
            }, {
              key: "write",
              value: function write(path, cb) {
                var _this2 = this;
                if (!_fs["default"] || !_fs["default"].createWriteStream) {
                  throw new Error("Cant access the filesystem. You can use the getBase64 method.");
                }
                if (typeof path !== "string") {
                  return _utils.throwError.call(this, "path must be a string", cb);
                }
                if (typeof cb === "undefined") {
                  cb = noop;
                }
                if (typeof cb !== "function") {
                  return _utils.throwError.call(this, "cb must be a function", cb);
                }
                var mime = MIME.getType(path) || this.getMIME();
                var pathObj = _path["default"].parse(path);
                if (pathObj.dir) {
                  _mkdirp["default"].sync(pathObj.dir);
                }
                this.getBuffer(mime, function(err, buffer) {
                  if (err) {
                    return _utils.throwError.call(_this2, err, cb);
                  }
                  var stream = _fs["default"].createWriteStream(path);
                  stream.on("open", function() {
                    stream.write(buffer);
                    stream.end();
                  }).on("error", function(err2) {
                    return _utils.throwError.call(_this2, err2, cb);
                  });
                  stream.on("finish", function() {
                    cb.call(_this2, null, _this2);
                  });
                });
                return this;
              }
            }, {
              key: "getBase64",
              /**
               * Converts the image to a base 64 string
               * @param {string} mime the mime type of the image data to be created
               * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
               * @returns {Jimp} this for chaining of methods
               */
              value: function getBase64(mime, cb) {
                if (mime === Jimp2.AUTO) {
                  mime = this.getMIME();
                }
                if (typeof mime !== "string") {
                  return _utils.throwError.call(this, "mime must be a string", cb);
                }
                if (typeof cb !== "function") {
                  return _utils.throwError.call(this, "cb must be a function", cb);
                }
                this.getBuffer(mime, function(err, data) {
                  if (err) {
                    return _utils.throwError.call(this, err, cb);
                  }
                  var src = "data:" + mime + ";base64," + data.toString("base64");
                  cb.call(this, null, src);
                });
                return this;
              }
            }, {
              key: "hash",
              /**
               * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>. And pads the string. Can configure base.
               * @param {number} base (optional) a number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimal, 16 is hex, 64 is base 64). Defaults to 64.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {string} a string representing the hash
               */
              value: function hash(base, cb) {
                base = base || 64;
                if (typeof base === "function") {
                  cb = base;
                  base = 64;
                }
                if (typeof base !== "number") {
                  return _utils.throwError.call(this, "base must be a number", cb);
                }
                if (base < 2 || base > 64) {
                  return _utils.throwError.call(this, "base must be a number between 2 and 64", cb);
                }
                var hash2 = this.pHash();
                hash2 = (0, _anyBase["default"])(_anyBase["default"].BIN, alphabet.slice(0, base))(hash2);
                while (hash2.length < maxHashLength[base]) {
                  hash2 = "0" + hash2;
                }
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, hash2);
                }
                return hash2;
              }
              /**
               * Calculates the perceptual hash
               * @returns {number} the perceptual hash
               */
            }, {
              key: "pHash",
              value: function pHash() {
                var pHash2 = new _phash["default"]();
                return pHash2.getHash(this);
              }
              /**
               * Calculates the hamming distance of the current image and a hash based on their perceptual hash
               * @param {hash} compareHash hash to compare to
               * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical
               */
            }, {
              key: "distanceFromHash",
              value: function distanceFromHash(compareHash) {
                var pHash = new _phash["default"]();
                var currentHash = pHash.getHash(this);
                return pHash.distance(currentHash, compareHash);
              }
              /**
               * Converts the image to a buffer
               * @param {string} mime the mime type of the image buffer to be created
               * @param {function(Error, Jimp)} cb a Node-style function to call with the buffer as the second argument
               * @returns {Jimp} this for chaining of methods
               */
            }, {
              key: "getPixelIndex",
              /**
               * Returns the offset of a pixel in the bitmap buffer
               * @param {number} x the x coordinate
               * @param {number} y the y coordinate
               * @param {string} edgeHandling (optional) define how to sum pixels from outside the border
               * @param {number} cb (optional) a callback for when complete
               * @returns {number} the index of the pixel or -1 if not found
               */
              value: function getPixelIndex(x, y, edgeHandling, cb) {
                var xi;
                var yi;
                if (typeof edgeHandling === "function" && typeof cb === "undefined") {
                  cb = edgeHandling;
                  edgeHandling = null;
                }
                if (!edgeHandling) {
                  edgeHandling = Jimp2.EDGE_EXTEND;
                }
                if (typeof x !== "number" || typeof y !== "number") {
                  return _utils.throwError.call(this, "x and y must be numbers", cb);
                }
                x = Math.round(x);
                y = Math.round(y);
                xi = x;
                yi = y;
                if (edgeHandling === Jimp2.EDGE_EXTEND) {
                  if (x < 0)
                    xi = 0;
                  if (x >= this.bitmap.width)
                    xi = this.bitmap.width - 1;
                  if (y < 0)
                    yi = 0;
                  if (y >= this.bitmap.height)
                    yi = this.bitmap.height - 1;
                }
                if (edgeHandling === Jimp2.EDGE_WRAP) {
                  if (x < 0) {
                    xi = this.bitmap.width + x;
                  }
                  if (x >= this.bitmap.width) {
                    xi = x % this.bitmap.width;
                  }
                  if (y < 0) {
                    xi = this.bitmap.height + y;
                  }
                  if (y >= this.bitmap.height) {
                    yi = y % this.bitmap.height;
                  }
                }
                var i2 = this.bitmap.width * yi + xi << 2;
                if (xi < 0 || xi >= this.bitmap.width) {
                  i2 = -1;
                }
                if (yi < 0 || yi >= this.bitmap.height) {
                  i2 = -1;
                }
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, i2);
                }
                return i2;
              }
              /**
               * Returns the hex colour value of a pixel
               * @param {number} x the x coordinate
               * @param {number} y the y coordinate
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {number} the color of the pixel
               */
            }, {
              key: "getPixelColor",
              value: function getPixelColor(x, y, cb) {
                if (typeof x !== "number" || typeof y !== "number")
                  return _utils.throwError.call(this, "x and y must be numbers", cb);
                x = Math.round(x);
                y = Math.round(y);
                var idx = this.getPixelIndex(x, y);
                var hex = this.bitmap.data.readUInt32BE(idx);
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, hex);
                }
                return hex;
              }
            }, {
              key: "setPixelColor",
              /**
               * Returns the hex colour value of a pixel
               * @param {number} hex color to set
               * @param {number} x the x coordinate
               * @param {number} y the y coordinate
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {number} the index of the pixel or -1 if not found
               */
              value: function setPixelColor(hex, x, y, cb) {
                if (typeof hex !== "number" || typeof x !== "number" || typeof y !== "number")
                  return _utils.throwError.call(this, "hex, x and y must be numbers", cb);
                x = Math.round(x);
                y = Math.round(y);
                var idx = this.getPixelIndex(x, y);
                this.bitmap.data.writeUInt32BE(hex, idx);
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, this);
                }
                return this;
              }
            }, {
              key: "hasAlpha",
              /**
               * Determine if the image contains opaque pixels.
               * @return {boolean} hasAlpha whether the image contains opaque pixels
               */
              value: function hasAlpha() {
                for (var yIndex = 0; yIndex < this.bitmap.height; yIndex++) {
                  for (var xIndex = 0; xIndex < this.bitmap.width; xIndex++) {
                    var idx = this.bitmap.width * yIndex + xIndex << 2;
                    var alpha = this.bitmap.data[idx + 3];
                    if (alpha !== 255) {
                      return true;
                    }
                  }
                }
                return false;
              }
              /**
               * Iterate scan through a region of the bitmap
               * @param {number} x the x coordinate to begin the scan at
               * @param {number} y the y coordinate to begin the scan at
               * @param w the width of the scan region
               * @param h the height of the scan region
               * @returns {IterableIterator<{x: number, y: number, idx: number, image: Jimp}>}
               */
            }, {
              key: "scanIterator",
              value: function scanIterator(x, y, w, h) {
                if (typeof x !== "number" || typeof y !== "number") {
                  return _utils.throwError.call(this, "x and y must be numbers");
                }
                if (typeof w !== "number" || typeof h !== "number") {
                  return _utils.throwError.call(this, "w and h must be numbers");
                }
                return (0, _utils.scanIterator)(this, x, y, w, h);
              }
            }]);
            return Jimp2;
          }(_events["default"]);
          function addConstants(constants2) {
            var jimpInstance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Jimp;
            Object.entries(constants2).forEach(function(_ref) {
              var _ref2 = (0, _slicedToArray2["default"])(_ref, 2), name = _ref2[0], value = _ref2[1];
              jimpInstance[name] = value;
            });
          }
          function addJimpMethods(methods) {
            var jimpInstance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Jimp;
            Object.entries(methods).forEach(function(_ref3) {
              var _ref4 = (0, _slicedToArray2["default"])(_ref3, 2), name = _ref4[0], value = _ref4[1];
              jimpInstance.prototype[name] = value;
            });
          }
          addConstants(constants);
          addJimpMethods({
            composite: _composite["default"]
          });
          Jimp.__extraConstructors = [];
          Jimp.appendConstructorOption = function(name, test, run) {
            Jimp.__extraConstructors.push({
              name,
              test,
              run
            });
          };
          Jimp.read = function() {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }
            return new Promise(function(resolve, reject) {
              (0, _construct2["default"])(Jimp, args.concat([function(err, image) {
                if (err)
                  reject(err);
                else
                  resolve(image);
              }]));
            });
          };
          Jimp.create = Jimp.read;
          Jimp.rgbaToInt = function(r, g, b, a, cb) {
            if (typeof r !== "number" || typeof g !== "number" || typeof b !== "number" || typeof a !== "number") {
              return _utils.throwError.call(this, "r, g, b and a must be numbers", cb);
            }
            if (r < 0 || r > 255) {
              return _utils.throwError.call(this, "r must be between 0 and 255", cb);
            }
            if (g < 0 || g > 255) {
              _utils.throwError.call(this, "g must be between 0 and 255", cb);
            }
            if (b < 0 || b > 255) {
              return _utils.throwError.call(this, "b must be between 0 and 255", cb);
            }
            if (a < 0 || a > 255) {
              return _utils.throwError.call(this, "a must be between 0 and 255", cb);
            }
            r = Math.round(r);
            b = Math.round(b);
            g = Math.round(g);
            a = Math.round(a);
            var i2 = r * Math.pow(256, 3) + g * Math.pow(256, 2) + b * Math.pow(256, 1) + a * Math.pow(256, 0);
            if ((0, _utils.isNodePattern)(cb)) {
              cb.call(this, null, i2);
            }
            return i2;
          };
          Jimp.intToRGBA = function(i2, cb) {
            if (typeof i2 !== "number") {
              return _utils.throwError.call(this, "i must be a number", cb);
            }
            var rgba = {};
            rgba.r = Math.floor(i2 / Math.pow(256, 3));
            rgba.g = Math.floor((i2 - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));
            rgba.b = Math.floor((i2 - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));
            rgba.a = Math.floor((i2 - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));
            if ((0, _utils.isNodePattern)(cb)) {
              cb.call(this, null, rgba);
            }
            return rgba;
          };
          Jimp.cssColorToHex = function(cssColor) {
            cssColor = cssColor || 0;
            if (typeof cssColor === "number")
              return Number(cssColor);
            return parseInt((0, _tinycolor["default"])(cssColor).toHex8(), 16);
          };
          Jimp.limit255 = function(n) {
            n = Math.max(n, 0);
            n = Math.min(n, 255);
            return n;
          };
          Jimp.diff = function(img1, img2) {
            var threshold = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.1;
            if (!(img1 instanceof Jimp) || !(img2 instanceof Jimp))
              return _utils.throwError.call(this, "img1 and img2 must be an Jimp images");
            var bmp1 = img1.bitmap;
            var bmp2 = img2.bitmap;
            if (bmp1.width !== bmp2.width || bmp1.height !== bmp2.height) {
              if (bmp1.width * bmp1.height > bmp2.width * bmp2.height) {
                img1 = img1.cloneQuiet().resize(bmp2.width, bmp2.height);
              } else {
                img2 = img2.cloneQuiet().resize(bmp1.width, bmp1.height);
              }
            }
            if (typeof threshold !== "number" || threshold < 0 || threshold > 1) {
              return _utils.throwError.call(this, "threshold must be a number between 0 and 1");
            }
            var diff = new Jimp(bmp1.width, bmp1.height, 4294967295);
            var numDiffPixels = (0, _pixelmatch["default"])(bmp1.data, bmp2.data, diff.bitmap.data, diff.bitmap.width, diff.bitmap.height, {
              threshold
            });
            return {
              percent: numDiffPixels / (diff.bitmap.width * diff.bitmap.height),
              image: diff
            };
          };
          Jimp.distance = function(img1, img2) {
            var phash = new _phash["default"]();
            var hash1 = phash.getHash(img1);
            var hash2 = phash.getHash(img2);
            return phash.distance(hash1, hash2);
          };
          Jimp.compareHashes = function(hash1, hash2) {
            var phash = new _phash["default"]();
            return phash.distance(hash1, hash2);
          };
          Jimp.colorDiff = function(rgba1, rgba2) {
            var pow = function pow2(n) {
              return Math.pow(n, 2);
            };
            var max = Math.max;
            var maxVal = 255 * 255 * 3;
            if (rgba1.a !== 0 && !rgba1.a) {
              rgba1.a = 255;
            }
            if (rgba2.a !== 0 && !rgba2.a) {
              rgba2.a = 255;
            }
            return (max(pow(rgba1.r - rgba2.r), pow(rgba1.r - rgba2.r - rgba1.a + rgba2.a)) + max(pow(rgba1.g - rgba2.g), pow(rgba1.g - rgba2.g - rgba1.a + rgba2.a)) + max(pow(rgba1.b - rgba2.b), pow(rgba1.b - rgba2.b - rgba1.a + rgba2.a))) / maxVal;
          };
          function jimpEvMethod(methodName, evName, method) {
            var evNameBefore = "before-" + evName;
            var evNameAfter = evName.replace(/e$/, "") + "ed";
            Jimp.prototype[methodName] = function() {
              var wrappedCb;
              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args[_key4] = arguments[_key4];
              }
              var cb = args[method.length - 1];
              var jimpInstance = this;
              if (typeof cb === "function") {
                wrappedCb = function wrappedCb2() {
                  for (var _len5 = arguments.length, args2 = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                    args2[_key5] = arguments[_key5];
                  }
                  var err = args2[0], data = args2[1];
                  if (err) {
                    jimpInstance.emitError(methodName, err);
                  } else {
                    jimpInstance.emitMulti(methodName, evNameAfter, (0, _defineProperty2["default"])({}, methodName, data));
                  }
                  cb.apply(this, args2);
                };
                args[args.length - 1] = wrappedCb;
              } else {
                wrappedCb = false;
              }
              this.emitMulti(methodName, evNameBefore);
              var result;
              try {
                result = method.apply(this, args);
                if (!wrappedCb) {
                  this.emitMulti(methodName, evNameAfter, (0, _defineProperty2["default"])({}, methodName, result));
                }
              } catch (error) {
                error.methodName = methodName;
                this.emitError(methodName, error);
              }
              return result;
            };
            Jimp.prototype[methodName + "Quiet"] = method;
          }
          jimpEvMethod("clone", "clone", function(cb) {
            var clone = new Jimp(this);
            if ((0, _utils.isNodePattern)(cb)) {
              cb.call(clone, null, clone);
            }
            return clone;
          });
          function jimpEvChange(methodName, method) {
            jimpEvMethod(methodName, "change", method);
          }
          jimpEvChange("background", function(hex, cb) {
            if (typeof hex !== "number") {
              return _utils.throwError.call(this, "hex must be a hexadecimal rgba value", cb);
            }
            this._background = hex;
            if ((0, _utils.isNodePattern)(cb)) {
              cb.call(this, null, this);
            }
            return this;
          });
          jimpEvChange("scan", function(x, y, w, h, f, cb) {
            if (typeof x !== "number" || typeof y !== "number") {
              return _utils.throwError.call(this, "x and y must be numbers", cb);
            }
            if (typeof w !== "number" || typeof h !== "number") {
              return _utils.throwError.call(this, "w and h must be numbers", cb);
            }
            if (typeof f !== "function") {
              return _utils.throwError.call(this, "f must be a function", cb);
            }
            var result = (0, _utils.scan)(this, x, y, w, h, f);
            if ((0, _utils.isNodePattern)(cb)) {
              cb.call(this, null, result);
            }
            return result;
          });
          if (true) {
            var gl;
            if (typeof window !== "undefined" && (typeof window === "undefined" ? "undefined" : (0, _typeof2["default"])(window)) === "object") {
              gl = window;
            }
            if (typeof self !== "undefined" && (typeof self === "undefined" ? "undefined" : (0, _typeof2["default"])(self)) === "object") {
              gl = self;
            }
            gl.Jimp = Jimp;
            gl.Buffer = Buffer;
          }
          var _default = Jimp;
          exports3["default"] = _default;
        }).call(this, require2("buffer").Buffer);
      }, { "./composite": 191, "./constants": 192, "./modules/phash": 194, "./request": 195, "./utils/image-bitmap": 196, "./utils/mime": 197, "./utils/promisify": 198, "@babel/runtime/helpers/assertThisInitialized": 3, "@babel/runtime/helpers/classCallCheck": 4, "@babel/runtime/helpers/construct": 5, "@babel/runtime/helpers/createClass": 6, "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/getPrototypeOf": 9, "@babel/runtime/helpers/inherits": 10, "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/interopRequireWildcard": 12, "@babel/runtime/helpers/possibleConstructorReturn": 17, "@babel/runtime/helpers/slicedToArray": 19, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235, "any-base": 23, "buffer": 48, "events": 52, "fs": 47, "mkdirp": 83, "path": 107, "pixelmatch": 109, "tinycolor2": 178 }], 194: [function(require2, module3, exports3) {
        "use strict";
        function ImagePHash(size, smallerSize) {
          this.size = this.size || size;
          this.smallerSize = this.smallerSize || smallerSize;
          initCoefficients(this.size);
        }
        ImagePHash.prototype.size = 32;
        ImagePHash.prototype.smallerSize = 8;
        ImagePHash.prototype.distance = function(s1, s2) {
          var counter = 0;
          for (var k = 0; k < s1.length; k++) {
            if (s1[k] !== s2[k]) {
              counter++;
            }
          }
          return counter / s1.length;
        };
        ImagePHash.prototype.getHash = function(img) {
          img = img.clone().resize(this.size, this.size);
          img.grayscale();
          var vals = [];
          for (var x = 0; x < img.bitmap.width; x++) {
            vals[x] = [];
            for (var y = 0; y < img.bitmap.height; y++) {
              vals[x][y] = intToRGBA(img.getPixelColor(x, y)).b;
            }
          }
          var dctVals = applyDCT(vals, this.size);
          var total = 0;
          for (var _x = 0; _x < this.smallerSize; _x++) {
            for (var _y = 0; _y < this.smallerSize; _y++) {
              total += dctVals[_x][_y];
            }
          }
          var avg = total / (this.smallerSize * this.smallerSize);
          var hash = "";
          for (var _x2 = 0; _x2 < this.smallerSize; _x2++) {
            for (var _y2 = 0; _y2 < this.smallerSize; _y2++) {
              hash += dctVals[_x2][_y2] > avg ? "1" : "0";
            }
          }
          return hash;
        };
        function intToRGBA(i) {
          var rgba = {};
          rgba.r = Math.floor(i / Math.pow(256, 3));
          rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));
          rgba.b = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1));
          rgba.a = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0));
          return rgba;
        }
        var c = [];
        function initCoefficients(size) {
          for (var i = 1; i < size; i++) {
            c[i] = 1;
          }
          c[0] = 1 / Math.sqrt(2);
        }
        function applyDCT(f, size) {
          var N = size;
          var F = [];
          for (var u = 0; u < N; u++) {
            F[u] = [];
            for (var v = 0; v < N; v++) {
              var sum = 0;
              for (var i = 0; i < N; i++) {
                for (var j = 0; j < N; j++) {
                  sum += Math.cos((2 * i + 1) / (2 * N) * u * Math.PI) * Math.cos((2 * j + 1) / (2 * N) * v * Math.PI) * f[i][j];
                }
              }
              sum *= c[u] * c[v] / 4;
              F[u][v] = sum;
            }
          }
          return F;
        }
        module3.exports = ImagePHash;
      }, {}], 195: [function(require2, module3, exports3) {
        (function(process, Buffer) {
          "use strict";
          var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
          var _defineProperty2 = _interopRequireDefault(require2("@babel/runtime/helpers/defineProperty"));
          var _extends2 = _interopRequireDefault(require2("@babel/runtime/helpers/extends"));
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly)
                symbols = symbols.filter(function(sym) {
                  return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i = 1; i < arguments.length; i++) {
              var source = arguments[i] != null ? arguments[i] : {};
              if (i % 2) {
                ownKeys(source, true).forEach(function(key) {
                  (0, _defineProperty2["default"])(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(source).forEach(function(key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target;
          }
          if (process.browser || true) {
            module3.exports = function(options, cb) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", options.url, true);
              xhr.responseType = "arraybuffer";
              xhr.addEventListener("load", function() {
                if (xhr.status < 400) {
                  try {
                    var data = Buffer.from(this.response);
                    cb(null, xhr, data);
                  } catch (error) {
                    return cb(new Error("Response is not a buffer for url " + options.url + ". Error: " + error.message));
                  }
                } else {
                  cb(new Error("HTTP Status " + xhr.status + " for url " + options.url));
                }
              });
              xhr.addEventListener("error", function(e) {
                cb(e);
              });
              xhr.send();
            };
          } else {
            module3.exports = function(_ref, cb) {
              var options = (0, _extends2["default"])({}, _ref);
              var p = require2("phin");
              p(_objectSpread({
                compression: true
              }, options), function(err, res) {
                if (err === null) {
                  cb(null, res, res.body);
                } else {
                  cb(err);
                }
              });
            };
          }
        }).call(this, require2("_process"), require2("buffer").Buffer);
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/extends": 8, "@babel/runtime/helpers/interopRequireDefault": 11, "_process": 133, "buffer": 48, "phin": 108 }], 196: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var _interopRequireWildcard = require2("@babel/runtime/helpers/interopRequireWildcard");
          var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3.parseBitmap = parseBitmap;
          exports3.getBuffer = getBuffer;
          exports3.getBufferAsync = getBufferAsync;
          var _slicedToArray2 = _interopRequireDefault(require2("@babel/runtime/helpers/slicedToArray"));
          var _fileType = _interopRequireDefault(require2("file-type"));
          var _exifParser = _interopRequireDefault(require2("exif-parser"));
          var _utils = require2("@jimp/utils");
          var constants = _interopRequireWildcard(require2("../constants"));
          var MIME = _interopRequireWildcard(require2("./mime"));
          var _promisify = _interopRequireDefault(require2("./promisify"));
          function getMIMEFromBuffer(buffer, path) {
            var fileTypeFromBuffer = (0, _fileType["default"])(buffer);
            if (fileTypeFromBuffer) {
              return fileTypeFromBuffer.mime;
            }
            if (path) {
              return MIME.getType(path);
            }
            return null;
          }
          function getExifOrientation(img) {
            return img._exif && img._exif.tags && img._exif.tags.Orientation || 1;
          }
          function getExifOrientationTransformation(img) {
            var w = img.getWidth();
            var h = img.getHeight();
            switch (getExifOrientation(img)) {
              case 1:
                return null;
              case 2:
                return function(x, y) {
                  return [w - x - 1, y];
                };
              case 3:
                return function(x, y) {
                  return [w - x - 1, h - y - 1];
                };
              case 4:
                return function(x, y) {
                  return [x, h - y - 1];
                };
              case 5:
                return function(x, y) {
                  return [y, x];
                };
              case 6:
                return function(x, y) {
                  return [y, h - x - 1];
                };
              case 7:
                return function(x, y) {
                  return [w - y - 1, h - x - 1];
                };
              case 8:
                return function(x, y) {
                  return [w - y - 1, x];
                };
              default:
                return null;
            }
          }
          function transformBitmap(img, width, height, transformation) {
            var _data = img.bitmap.data;
            var _width = img.bitmap.width;
            var data = Buffer.alloc(_data.length);
            for (var x = 0; x < width; x++) {
              for (var y = 0; y < height; y++) {
                var _transformation = transformation(x, y), _transformation2 = (0, _slicedToArray2["default"])(_transformation, 2), _x = _transformation2[0], _y = _transformation2[1];
                var idx = width * y + x << 2;
                var _idx = _width * _y + _x << 2;
                var pixel = _data.readUInt32BE(_idx);
                data.writeUInt32BE(pixel, idx);
              }
            }
            img.bitmap.data = data;
            img.bitmap.width = width;
            img.bitmap.height = height;
          }
          function exifRotate(img) {
            if (getExifOrientation(img) < 2)
              return;
            var transformation = getExifOrientationTransformation(img);
            var swapDimensions = getExifOrientation(img) > 4;
            var newWidth = swapDimensions ? img.bitmap.height : img.bitmap.width;
            var newHeight = swapDimensions ? img.bitmap.width : img.bitmap.height;
            transformBitmap(img, newWidth, newHeight, transformation);
          }
          function parseBitmap(data, path, cb) {
            var mime = getMIMEFromBuffer(data, path);
            if (typeof mime !== "string") {
              return cb(new Error("Could not find MIME for Buffer <" + path + ">"));
            }
            this._originalMime = mime.toLowerCase();
            try {
              var _mime = this.getMIME();
              if (this.constructor.decoders[_mime]) {
                this.bitmap = this.constructor.decoders[_mime](data);
              } else {
                return _utils.throwError.call(this, "Unsupported MIME type: " + _mime, cb);
              }
            } catch (error) {
              return cb.call(this, error, this);
            }
            try {
              this._exif = _exifParser["default"].create(data).parse();
              exifRotate(this);
            } catch (error) {
            }
            cb.call(this, null, this);
            return this;
          }
          function compositeBitmapOverBackground(Jimp, image) {
            return new Jimp(image.bitmap.width, image.bitmap.height, image._background).composite(image, 0, 0).bitmap;
          }
          function getBuffer(mime, cb) {
            if (mime === constants.AUTO) {
              mime = this.getMIME();
            }
            if (typeof mime !== "string") {
              return _utils.throwError.call(this, "mime must be a string", cb);
            }
            if (typeof cb !== "function") {
              return _utils.throwError.call(this, "cb must be a function", cb);
            }
            mime = mime.toLowerCase();
            if (this._rgba && this.constructor.hasAlpha[mime]) {
              this.bitmap.data = Buffer.from(this.bitmap.data);
            } else {
              this.bitmap.data = compositeBitmapOverBackground(this.constructor, this).data;
            }
            if (this.constructor.encoders[mime]) {
              var buffer = this.constructor.encoders[mime](this);
              cb.call(this, null, buffer);
            } else {
              cb.call(this, "Unsupported MIME type: " + mime);
            }
            return this;
          }
          function getBufferAsync(mime) {
            return (0, _promisify["default"])(getBuffer, this, mime);
          }
        }).call(this, require2("buffer").Buffer);
      }, { "../constants": 192, "./mime": 197, "./promisify": 198, "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/interopRequireWildcard": 12, "@babel/runtime/helpers/slicedToArray": 19, "@jimp/utils": 235, "buffer": 48, "exif-parser": 53, "file-type": 62 }], 197: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.getExtension = exports3.getType = exports3.addType = void 0;
        var mimeTypes = {};
        var findType = function findType2(extension) {
          return Object.entries(mimeTypes).find(function(type) {
            return type[1].includes(extension);
          }) || [];
        };
        var addType = function addType2(mime, extensions) {
          mimeTypes[mime] = extensions;
        };
        exports3.addType = addType;
        var getType = function getType2(path) {
          var pathParts = path.split("/").slice(-1);
          var extension = pathParts[pathParts.length - 1].split(".").pop();
          var type = findType(extension);
          return type[0];
        };
        exports3.getType = getType;
        var getExtension = function getExtension2(type) {
          return (mimeTypes[type.toLowerCase()] || [])[0];
        };
        exports3.getExtension = getExtension;
      }, {}], 198: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var promisify = function promisify2(fun, ctx) {
          for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }
          return new Promise(function(resolve, reject) {
            args.push(function(err, data) {
              if (err) {
                reject(err);
              }
              resolve(data);
            });
            fun.bind(ctx).apply(void 0, args);
          });
        };
        var _default = promisify;
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, {}], 199: [function(require2, module3, exports3) {
        "use strict";
        var _interopRequireWildcard = require2("@babel/runtime/helpers/interopRequireWildcard");
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = configure;
        var _toConsumableArray2 = _interopRequireDefault(require2("@babel/runtime/helpers/toConsumableArray"));
        var _defineProperty2 = _interopRequireDefault(require2("@babel/runtime/helpers/defineProperty"));
        var _slicedToArray2 = _interopRequireDefault(require2("@babel/runtime/helpers/slicedToArray"));
        var _core = _interopRequireWildcard(require2("@jimp/core"));
        function ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            if (enumerableOnly)
              symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
            keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i] != null ? arguments[i] : {};
            if (i % 2) {
              ownKeys(source, true).forEach(function(key) {
                (0, _defineProperty2["default"])(target, key, source[key]);
              });
            } else if (Object.getOwnPropertyDescriptors) {
              Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
            } else {
              ownKeys(source).forEach(function(key) {
                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
              });
            }
          }
          return target;
        }
        function configure(configuration) {
          var jimpInstance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _core["default"];
          var jimpConfig = {
            hasAlpha: {},
            encoders: {},
            decoders: {},
            "class": {},
            constants: {}
          };
          function addToConfig(newConfig) {
            Object.entries(newConfig).forEach(function(_ref) {
              var _ref2 = (0, _slicedToArray2["default"])(_ref, 2), key = _ref2[0], value = _ref2[1];
              jimpConfig[key] = _objectSpread({}, jimpConfig[key], {}, value);
            });
          }
          function addImageType(typeModule) {
            var type = typeModule();
            if (Array.isArray(type.mime)) {
              _core.addType.apply(void 0, (0, _toConsumableArray2["default"])(type.mime));
            } else {
              Object.entries(type.mime).forEach(function(mimeType) {
                return _core.addType.apply(void 0, (0, _toConsumableArray2["default"])(mimeType));
              });
            }
            delete type.mime;
            addToConfig(type);
          }
          function addPlugin(pluginModule) {
            var plugin = pluginModule(_core.jimpEvChange) || {};
            if (!plugin["class"] && !plugin.constants) {
              addToConfig({
                "class": plugin
              });
            } else {
              addToConfig(plugin);
            }
          }
          if (configuration.types) {
            configuration.types.forEach(addImageType);
            jimpInstance.decoders = _objectSpread({}, jimpInstance.decoders, {}, jimpConfig.decoders);
            jimpInstance.encoders = _objectSpread({}, jimpInstance.encoders, {}, jimpConfig.encoders);
            jimpInstance.hasAlpha = _objectSpread({}, jimpInstance.hasAlpha, {}, jimpConfig.hasAlpha);
          }
          if (configuration.plugins) {
            configuration.plugins.forEach(addPlugin);
          }
          (0, _core.addJimpMethods)(jimpConfig["class"], jimpInstance);
          (0, _core.addConstants)(jimpConfig.constants, jimpInstance);
          return _core["default"];
        }
        module3.exports = exports3.default;
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/interopRequireWildcard": 12, "@babel/runtime/helpers/slicedToArray": 19, "@babel/runtime/helpers/toConsumableArray": 20, "@jimp/core": 193 }], 200: [function(require2, module3, exports3) {
        "use strict";
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _custom = _interopRequireDefault(require2("@jimp/custom"));
        var _types = _interopRequireDefault(require2("@jimp/types"));
        var _plugins = _interopRequireDefault(require2("@jimp/plugins"));
        var _default = (0, _custom["default"])({
          types: [_types["default"]],
          plugins: [_plugins["default"]]
        });
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/custom": 199, "@jimp/plugins": 228, "@jimp/types": 234 }], 201: [function(require2, module3, exports3) {
        "use strict";
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
        var _utils = require2("@jimp/utils");
        var _default = function _default2() {
          return {
            /**
             * Blits a source image on to this image
             * @param {Jimp} src the source Jimp instance
             * @param {number} x the x position to blit the image
             * @param {number} y the y position to blit the image
             * @param {number} srcx (optional) the x position from which to crop the source image
             * @param {number} srcy (optional) the y position from which to crop the source image
             * @param {number} srcw (optional) the width to which to crop the source image
             * @param {number} srch (optional) the height to which to crop the source image
             * @param {function(Error, Jimp)} cb (optional) a callback for when complete
             * @returns {Jimp} this for chaining of methods
             */
            blit: function blit(src, x, y, srcx, srcy, srcw, srch, cb) {
              if (!(src instanceof this.constructor)) {
                return _utils.throwError.call(this, "The source must be a Jimp image", cb);
              }
              if (typeof x !== "number" || typeof y !== "number") {
                return _utils.throwError.call(this, "x and y must be numbers", cb);
              }
              if (typeof srcx === "function") {
                cb = srcx;
                srcx = 0;
                srcy = 0;
                srcw = src.bitmap.width;
                srch = src.bitmap.height;
              } else if ((0, _typeof2["default"])(srcx) === (0, _typeof2["default"])(srcy) && (0, _typeof2["default"])(srcy) === (0, _typeof2["default"])(srcw) && (0, _typeof2["default"])(srcw) === (0, _typeof2["default"])(srch)) {
                srcx = srcx || 0;
                srcy = srcy || 0;
                srcw = srcw || src.bitmap.width;
                srch = srch || src.bitmap.height;
              } else {
                return _utils.throwError.call(this, "srcx, srcy, srcw, srch must be numbers", cb);
              }
              x = Math.round(x);
              y = Math.round(y);
              srcx = Math.round(srcx);
              srcy = Math.round(srcy);
              srcw = Math.round(srcw);
              srch = Math.round(srch);
              var maxWidth = this.bitmap.width;
              var maxHeight = this.bitmap.height;
              var baseImage = this;
              src.scanQuiet(srcx, srcy, srcw, srch, function(sx, sy, idx) {
                var xOffset = x + sx - srcx;
                var yOffset = y + sy - srcy;
                if (xOffset >= 0 && yOffset >= 0 && maxWidth - xOffset > 0 && maxHeight - yOffset > 0) {
                  var dstIdx = baseImage.getPixelIndex(xOffset, yOffset);
                  var _src = {
                    r: this.bitmap.data[idx],
                    g: this.bitmap.data[idx + 1],
                    b: this.bitmap.data[idx + 2],
                    a: this.bitmap.data[idx + 3]
                  };
                  var dst = {
                    r: baseImage.bitmap.data[dstIdx],
                    g: baseImage.bitmap.data[dstIdx + 1],
                    b: baseImage.bitmap.data[dstIdx + 2],
                    a: baseImage.bitmap.data[dstIdx + 3]
                  };
                  baseImage.bitmap.data[dstIdx] = (_src.a * (_src.r - dst.r) - dst.r + 255 >> 8) + dst.r;
                  baseImage.bitmap.data[dstIdx + 1] = (_src.a * (_src.g - dst.g) - dst.g + 255 >> 8) + dst.g;
                  baseImage.bitmap.data[dstIdx + 2] = (_src.a * (_src.b - dst.b) - dst.b + 255 >> 8) + dst.b;
                  baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(dst.a + _src.a);
                }
              });
              if ((0, _utils.isNodePattern)(cb)) {
                cb.call(this, null, this);
              }
              return this;
            }
          };
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235 }], 202: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.shgTable = exports3.mulTable = void 0;
        var mulTable = [1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1];
        exports3.mulTable = mulTable;
        var shgTable = [0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18];
        exports3.shgTable = shgTable;
      }, {}], 203: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _utils = require2("@jimp/utils");
        var _blurTables = require2("./blur-tables");
        var _default = function _default2() {
          return {
            /**
             * A fast blur algorithm that produces similar effect to a Gaussian blur - but MUCH quicker
             * @param {number} r the pixel radius of the blur
             * @param {function(Error, Jimp)} cb (optional) a callback for when complete
             * @returns {Jimp} this for chaining of methods
             */
            blur: function blur(r, cb) {
              if (typeof r !== "number")
                return _utils.throwError.call(this, "r must be a number", cb);
              if (r < 1)
                return _utils.throwError.call(this, "r must be greater than 0", cb);
              var rsum;
              var gsum;
              var bsum;
              var asum;
              var x;
              var y;
              var i;
              var p;
              var p1;
              var p2;
              var yp;
              var yi;
              var yw;
              var pa;
              var wm = this.bitmap.width - 1;
              var hm = this.bitmap.height - 1;
              var rad1 = r + 1;
              var mulSum = _blurTables.mulTable[r];
              var shgSum = _blurTables.shgTable[r];
              var red = [];
              var green = [];
              var blue = [];
              var alpha = [];
              var vmin = [];
              var vmax = [];
              var iterations = 2;
              while (iterations-- > 0) {
                yi = 0;
                yw = 0;
                for (y = 0; y < this.bitmap.height; y++) {
                  rsum = this.bitmap.data[yw] * rad1;
                  gsum = this.bitmap.data[yw + 1] * rad1;
                  bsum = this.bitmap.data[yw + 2] * rad1;
                  asum = this.bitmap.data[yw + 3] * rad1;
                  for (i = 1; i <= r; i++) {
                    p = yw + ((i > wm ? wm : i) << 2);
                    rsum += this.bitmap.data[p++];
                    gsum += this.bitmap.data[p++];
                    bsum += this.bitmap.data[p++];
                    asum += this.bitmap.data[p];
                  }
                  for (x = 0; x < this.bitmap.width; x++) {
                    red[yi] = rsum;
                    green[yi] = gsum;
                    blue[yi] = bsum;
                    alpha[yi] = asum;
                    if (y === 0) {
                      vmin[x] = ((p = x + rad1) < wm ? p : wm) << 2;
                      vmax[x] = (p = x - r) > 0 ? p << 2 : 0;
                    }
                    p1 = yw + vmin[x];
                    p2 = yw + vmax[x];
                    rsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];
                    gsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];
                    bsum += this.bitmap.data[p1++] - this.bitmap.data[p2++];
                    asum += this.bitmap.data[p1] - this.bitmap.data[p2];
                    yi++;
                  }
                  yw += this.bitmap.width << 2;
                }
                for (x = 0; x < this.bitmap.width; x++) {
                  yp = x;
                  rsum = red[yp] * rad1;
                  gsum = green[yp] * rad1;
                  bsum = blue[yp] * rad1;
                  asum = alpha[yp] * rad1;
                  for (i = 1; i <= r; i++) {
                    yp += i > hm ? 0 : this.bitmap.width;
                    rsum += red[yp];
                    gsum += green[yp];
                    bsum += blue[yp];
                    asum += alpha[yp];
                  }
                  yi = x << 2;
                  for (y = 0; y < this.bitmap.height; y++) {
                    pa = asum * mulSum >>> shgSum;
                    this.bitmap.data[yi + 3] = pa;
                    if (pa > 255) {
                      this.bitmap.data[yi + 3] = 255;
                    }
                    if (pa > 0) {
                      pa = 255 / pa;
                      this.bitmap.data[yi] = (rsum * mulSum >>> shgSum) * pa;
                      this.bitmap.data[yi + 1] = (gsum * mulSum >>> shgSum) * pa;
                      this.bitmap.data[yi + 2] = (bsum * mulSum >>> shgSum) * pa;
                    } else {
                      this.bitmap.data[yi + 2] = 0;
                      this.bitmap.data[yi + 1] = 0;
                      this.bitmap.data[yi] = 0;
                    }
                    if (x === 0) {
                      vmin[y] = ((p = y + rad1) < hm ? p : hm) * this.bitmap.width;
                      vmax[y] = (p = y - r) > 0 ? p * this.bitmap.width : 0;
                    }
                    p1 = x + vmin[y];
                    p2 = x + vmax[y];
                    rsum += red[p1] - red[p2];
                    gsum += green[p1] - green[p2];
                    bsum += blue[p1] - blue[p2];
                    asum += alpha[p1] - alpha[p2];
                    yi += this.bitmap.width << 2;
                  }
                }
              }
              if ((0, _utils.isNodePattern)(cb)) {
                cb.call(this, null, this);
              }
              return this;
            }
          };
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "./blur-tables": 202, "@jimp/utils": 235 }], 204: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _utils = require2("@jimp/utils");
        var _default = function _default2() {
          return {
            circle: function circle() {
              var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              var cb = arguments.length > 1 ? arguments[1] : void 0;
              if (typeof options === "function") {
                cb = options;
                options = {};
              }
              var radius = options.radius || (this.bitmap.width > this.bitmap.height ? this.bitmap.height : this.bitmap.width) / 2;
              var center = {
                x: typeof options.x === "number" ? options.x : this.bitmap.width / 2,
                y: typeof options.y === "number" ? options.y : this.bitmap.height / 2
              };
              this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
                var curR = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));
                if (radius - curR <= 0) {
                  this.bitmap.data[idx + 3] = 0;
                } else if (radius - curR < 1) {
                  this.bitmap.data[idx + 3] = 255 * (radius - curR);
                }
              });
              if ((0, _utils.isNodePattern)(cb)) {
                cb.call(this, null, this);
              }
              return this;
            }
          };
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@jimp/utils": 235 }], 205: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3["default"] = void 0;
          var _toConsumableArray2 = _interopRequireDefault(require2("@babel/runtime/helpers/toConsumableArray"));
          var _tinycolor = _interopRequireDefault(require2("tinycolor2"));
          var _utils = require2("@jimp/utils");
          function applyKernel(im, kernel, x, y) {
            var value = [0, 0, 0];
            var size = (kernel.length - 1) / 2;
            for (var kx = 0; kx < kernel.length; kx += 1) {
              for (var ky = 0; ky < kernel[kx].length; ky += 1) {
                var idx = im.getPixelIndex(x + kx - size, y + ky - size);
                value[0] += im.bitmap.data[idx] * kernel[kx][ky];
                value[1] += im.bitmap.data[idx + 1] * kernel[kx][ky];
                value[2] += im.bitmap.data[idx + 2] * kernel[kx][ky];
              }
            }
            return value;
          }
          var isDef = function isDef2(v) {
            return typeof v !== "undefined" && v !== null;
          };
          function greyscale(cb) {
            this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
              var grey = parseInt(0.2126 * this.bitmap.data[idx] + 0.7152 * this.bitmap.data[idx + 1] + 0.0722 * this.bitmap.data[idx + 2], 10);
              this.bitmap.data[idx] = grey;
              this.bitmap.data[idx + 1] = grey;
              this.bitmap.data[idx + 2] = grey;
            });
            if ((0, _utils.isNodePattern)(cb)) {
              cb.call(this, null, this);
            }
            return this;
          }
          function mix(clr, clr2) {
            var p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 50;
            return {
              r: (clr2.r - clr.r) * (p / 100) + clr.r,
              g: (clr2.g - clr.g) * (p / 100) + clr.g,
              b: (clr2.b - clr.b) * (p / 100) + clr.b
            };
          }
          function colorFn(actions, cb) {
            var _this = this;
            if (!actions || !Array.isArray(actions)) {
              return _utils.throwError.call(this, "actions must be an array", cb);
            }
            actions = actions.map(function(action) {
              if (action.apply === "xor" || action.apply === "mix") {
                action.params[0] = (0, _tinycolor["default"])(action.params[0]).toRgb();
              }
              return action;
            });
            this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
              var clr = {
                r: _this.bitmap.data[idx],
                g: _this.bitmap.data[idx + 1],
                b: _this.bitmap.data[idx + 2]
              };
              var colorModifier = function colorModifier2(i, amount) {
                return _this.constructor.limit255(clr[i] + amount);
              };
              actions.forEach(function(action) {
                if (action.apply === "mix") {
                  clr = mix(clr, action.params[0], action.params[1]);
                } else if (action.apply === "tint") {
                  clr = mix(clr, {
                    r: 255,
                    g: 255,
                    b: 255
                  }, action.params[0]);
                } else if (action.apply === "shade") {
                  clr = mix(clr, {
                    r: 0,
                    g: 0,
                    b: 0
                  }, action.params[0]);
                } else if (action.apply === "xor") {
                  clr = {
                    r: clr.r ^ action.params[0].r,
                    g: clr.g ^ action.params[0].g,
                    b: clr.b ^ action.params[0].b
                  };
                } else if (action.apply === "red") {
                  clr.r = colorModifier("r", action.params[0]);
                } else if (action.apply === "green") {
                  clr.g = colorModifier("g", action.params[0]);
                } else if (action.apply === "blue") {
                  clr.b = colorModifier("b", action.params[0]);
                } else {
                  var _clr;
                  if (action.apply === "hue") {
                    action.apply = "spin";
                  }
                  clr = (0, _tinycolor["default"])(clr);
                  if (!clr[action.apply]) {
                    return _utils.throwError.call(_this, "action " + action.apply + " not supported", cb);
                  }
                  clr = (_clr = clr)[action.apply].apply(_clr, (0, _toConsumableArray2["default"])(action.params)).toRgb();
                }
              });
              _this.bitmap.data[idx] = clr.r;
              _this.bitmap.data[idx + 1] = clr.g;
              _this.bitmap.data[idx + 2] = clr.b;
            });
            if ((0, _utils.isNodePattern)(cb)) {
              cb.call(this, null, this);
            }
            return this;
          }
          var _default = function _default2() {
            return {
              /**
               * Adjusts the brightness of the image
               * @param {number} val the amount to adjust the brightness, a number between -1 and +1
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              brightness: function brightness(val, cb) {
                if (typeof val !== "number") {
                  return _utils.throwError.call(this, "val must be numbers", cb);
                }
                if (val < -1 || val > 1) {
                  return _utils.throwError.call(this, "val must be a number between -1 and +1", cb);
                }
                this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
                  if (val < 0) {
                    this.bitmap.data[idx] = this.bitmap.data[idx] * (1 + val);
                    this.bitmap.data[idx + 1] = this.bitmap.data[idx + 1] * (1 + val);
                    this.bitmap.data[idx + 2] = this.bitmap.data[idx + 2] * (1 + val);
                  } else {
                    this.bitmap.data[idx] = this.bitmap.data[idx] + (255 - this.bitmap.data[idx]) * val;
                    this.bitmap.data[idx + 1] = this.bitmap.data[idx + 1] + (255 - this.bitmap.data[idx + 1]) * val;
                    this.bitmap.data[idx + 2] = this.bitmap.data[idx + 2] + (255 - this.bitmap.data[idx + 2]) * val;
                  }
                });
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, this);
                }
                return this;
              },
              /**
               * Adjusts the contrast of the image
               * @param {number} val the amount to adjust the contrast, a number between -1 and +1
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              contrast: function contrast(val, cb) {
                if (typeof val !== "number") {
                  return _utils.throwError.call(this, "val must be numbers", cb);
                }
                if (val < -1 || val > 1) {
                  return _utils.throwError.call(this, "val must be a number between -1 and +1", cb);
                }
                var factor = (val + 1) / (1 - val);
                function adjust(value) {
                  value = Math.floor(factor * (value - 127) + 127);
                  return value < 0 ? 0 : value > 255 ? 255 : value;
                }
                this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
                  this.bitmap.data[idx] = adjust(this.bitmap.data[idx]);
                  this.bitmap.data[idx + 1] = adjust(this.bitmap.data[idx + 1]);
                  this.bitmap.data[idx + 2] = adjust(this.bitmap.data[idx + 2]);
                });
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, this);
                }
                return this;
              },
              /**
               * Apply a posterize effect
               * @param {number} n the amount to adjust the contrast, minimum threshold is two
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              posterize: function posterize(n, cb) {
                if (typeof n !== "number") {
                  return _utils.throwError.call(this, "n must be numbers", cb);
                }
                if (n < 2) {
                  n = 2;
                }
                this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
                  this.bitmap.data[idx] = Math.floor(this.bitmap.data[idx] / 255 * (n - 1)) / (n - 1) * 255;
                  this.bitmap.data[idx + 1] = Math.floor(this.bitmap.data[idx + 1] / 255 * (n - 1)) / (n - 1) * 255;
                  this.bitmap.data[idx + 2] = Math.floor(this.bitmap.data[idx + 2] / 255 * (n - 1)) / (n - 1) * 255;
                });
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, this);
                }
                return this;
              },
              /**
               * Removes colour from the image using ITU Rec 709 luminance values
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              greyscale,
              // Alias of greyscale for our American friends
              grayscale: greyscale,
              /**
               * Multiplies the opacity of each pixel by a factor between 0 and 1
               * @param {number} f A number, the factor by which to multiply the opacity of each pixel
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              opacity: function opacity(f, cb) {
                if (typeof f !== "number")
                  return _utils.throwError.call(this, "f must be a number", cb);
                if (f < 0 || f > 1)
                  return _utils.throwError.call(this, "f must be a number from 0 to 1", cb);
                this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
                  var v = this.bitmap.data[idx + 3] * f;
                  this.bitmap.data[idx + 3] = v;
                });
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, this);
                }
                return this;
              },
              /**
               * Applies a sepia tone to the image
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              sepia: function sepia(cb) {
                this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
                  var red = this.bitmap.data[idx];
                  var green = this.bitmap.data[idx + 1];
                  var blue = this.bitmap.data[idx + 2];
                  red = red * 0.393 + green * 0.769 + blue * 0.189;
                  green = red * 0.349 + green * 0.686 + blue * 0.168;
                  blue = red * 0.272 + green * 0.534 + blue * 0.131;
                  this.bitmap.data[idx] = red < 255 ? red : 255;
                  this.bitmap.data[idx + 1] = green < 255 ? green : 255;
                  this.bitmap.data[idx + 2] = blue < 255 ? blue : 255;
                });
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, this);
                }
                return this;
              },
              /**
               * Fades each pixel by a factor between 0 and 1
               * @param {number} f A number from 0 to 1. 0 will haven no effect. 1 will turn the image completely transparent.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              fade: function fade(f, cb) {
                if (typeof f !== "number") {
                  return _utils.throwError.call(this, "f must be a number", cb);
                }
                if (f < 0 || f > 1) {
                  return _utils.throwError.call(this, "f must be a number from 0 to 1", cb);
                }
                this.opacity(1 - f);
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, this);
                }
                return this;
              },
              /**
               * Adds each element of the image to its local neighbors, weighted by the kernel
               * @param {array} kernel a matrix to weight the neighbors sum
               * @param {string} edgeHandling (optional) define how to sum pixels from outside the border
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              convolution: function convolution(kernel, edgeHandling, cb) {
                if (typeof edgeHandling === "function" && typeof cb === "undefined") {
                  cb = edgeHandling;
                  edgeHandling = null;
                }
                if (!edgeHandling) {
                  edgeHandling = this.constructor.EDGE_EXTEND;
                }
                var newData = Buffer.from(this.bitmap.data);
                var kRows = kernel.length;
                var kCols = kernel[0].length;
                var rowEnd = Math.floor(kRows / 2);
                var colEnd = Math.floor(kCols / 2);
                var rowIni = -rowEnd;
                var colIni = -colEnd;
                var weight;
                var rSum;
                var gSum;
                var bSum;
                var ri;
                var gi;
                var bi;
                var xi;
                var yi;
                var idxi;
                this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
                  bSum = 0;
                  gSum = 0;
                  rSum = 0;
                  for (var row = rowIni; row <= rowEnd; row++) {
                    for (var col = colIni; col <= colEnd; col++) {
                      xi = x + col;
                      yi = y + row;
                      weight = kernel[row + rowEnd][col + colEnd];
                      idxi = this.getPixelIndex(xi, yi, edgeHandling);
                      if (idxi === -1) {
                        bi = 0;
                        gi = 0;
                        ri = 0;
                      } else {
                        ri = this.bitmap.data[idxi + 0];
                        gi = this.bitmap.data[idxi + 1];
                        bi = this.bitmap.data[idxi + 2];
                      }
                      rSum += weight * ri;
                      gSum += weight * gi;
                      bSum += weight * bi;
                    }
                  }
                  if (rSum < 0) {
                    rSum = 0;
                  }
                  if (gSum < 0) {
                    gSum = 0;
                  }
                  if (bSum < 0) {
                    bSum = 0;
                  }
                  if (rSum > 255) {
                    rSum = 255;
                  }
                  if (gSum > 255) {
                    gSum = 255;
                  }
                  if (bSum > 255) {
                    bSum = 255;
                  }
                  newData[idx + 0] = rSum;
                  newData[idx + 1] = gSum;
                  newData[idx + 2] = bSum;
                });
                this.bitmap.data = newData;
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, this);
                }
                return this;
              },
              /**
               * Set the alpha channel on every pixel to fully opaque
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              opaque: function opaque(cb) {
                this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
                  this.bitmap.data[idx + 3] = 255;
                });
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, this);
                }
                return this;
              },
              /**
               * Pixelates the image or a region
               * @param {number} size the size of the pixels
               * @param {number} x (optional) the x position of the region to pixelate
               * @param {number} y (optional) the y position of the region to pixelate
               * @param {number} w (optional) the width of the region to pixelate
               * @param {number} h (optional) the height of the region to pixelate
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              pixelate: function pixelate(size, x, y, w, h, cb) {
                if (typeof x === "function") {
                  cb = x;
                  h = null;
                  w = null;
                  y = null;
                  x = null;
                } else {
                  if (typeof size !== "number") {
                    return _utils.throwError.call(this, "size must be a number", cb);
                  }
                  if (isDef(x) && typeof x !== "number") {
                    return _utils.throwError.call(this, "x must be a number", cb);
                  }
                  if (isDef(y) && typeof y !== "number") {
                    return _utils.throwError.call(this, "y must be a number", cb);
                  }
                  if (isDef(w) && typeof w !== "number") {
                    return _utils.throwError.call(this, "w must be a number", cb);
                  }
                  if (isDef(h) && typeof h !== "number") {
                    return _utils.throwError.call(this, "h must be a number", cb);
                  }
                }
                var kernel = [[1 / 16, 2 / 16, 1 / 16], [2 / 16, 4 / 16, 2 / 16], [1 / 16, 2 / 16, 1 / 16]];
                x = x || 0;
                y = y || 0;
                w = isDef(w) ? w : this.bitmap.width - x;
                h = isDef(h) ? h : this.bitmap.height - y;
                var source = this.cloneQuiet();
                this.scanQuiet(x, y, w, h, function(xx, yx, idx) {
                  xx = size * Math.floor(xx / size);
                  yx = size * Math.floor(yx / size);
                  var value = applyKernel(source, kernel, xx, yx);
                  this.bitmap.data[idx] = value[0];
                  this.bitmap.data[idx + 1] = value[1];
                  this.bitmap.data[idx + 2] = value[2];
                });
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, this);
                }
                return this;
              },
              /**
               * Applies a convolution kernel to the image or a region
               * @param {array} kernel the convolution kernel
               * @param {number} x (optional) the x position of the region to apply convolution to
               * @param {number} y (optional) the y position of the region to apply convolution to
               * @param {number} w (optional) the width of the region to apply convolution to
               * @param {number} h (optional) the height of the region to apply convolution to
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              convolute: function convolute(kernel, x, y, w, h, cb) {
                if (!Array.isArray(kernel))
                  return _utils.throwError.call(this, "the kernel must be an array", cb);
                if (typeof x === "function") {
                  cb = x;
                  x = null;
                  y = null;
                  w = null;
                  h = null;
                } else {
                  if (isDef(x) && typeof x !== "number") {
                    return _utils.throwError.call(this, "x must be a number", cb);
                  }
                  if (isDef(y) && typeof y !== "number") {
                    return _utils.throwError.call(this, "y must be a number", cb);
                  }
                  if (isDef(w) && typeof w !== "number") {
                    return _utils.throwError.call(this, "w must be a number", cb);
                  }
                  if (isDef(h) && typeof h !== "number") {
                    return _utils.throwError.call(this, "h must be a number", cb);
                  }
                }
                var ksize = (kernel.length - 1) / 2;
                x = isDef(x) ? x : ksize;
                y = isDef(y) ? y : ksize;
                w = isDef(w) ? w : this.bitmap.width - x;
                h = isDef(h) ? h : this.bitmap.height - y;
                var source = this.cloneQuiet();
                this.scanQuiet(x, y, w, h, function(xx, yx, idx) {
                  var value = applyKernel(source, kernel, xx, yx);
                  this.bitmap.data[idx] = this.constructor.limit255(value[0]);
                  this.bitmap.data[idx + 1] = this.constructor.limit255(value[1]);
                  this.bitmap.data[idx + 2] = this.constructor.limit255(value[2]);
                });
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, this);
                }
                return this;
              },
              /**
               * Apply multiple color modification rules
               * @param {array} actions list of color modification rules, in following format: { apply: '<rule-name>', params: [ <rule-parameters> ]  }
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp }this for chaining of methods
               */
              color: colorFn,
              colour: colorFn
            };
          };
          exports3["default"] = _default;
          module3.exports = exports3.default;
        }).call(this, require2("buffer").Buffer);
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/toConsumableArray": 20, "@jimp/utils": 235, "buffer": 48, "tinycolor2": 178 }], 206: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _utils = require2("@jimp/utils");
        var _default = function _default2() {
          return {
            contain: function contain(w, h, alignBits, mode, cb) {
              if (typeof w !== "number" || typeof h !== "number") {
                return _utils.throwError.call(this, "w and h must be numbers", cb);
              }
              if (typeof alignBits === "string") {
                if (typeof mode === "function" && typeof cb === "undefined")
                  cb = mode;
                mode = alignBits;
                alignBits = null;
              }
              if (typeof alignBits === "function") {
                if (typeof cb === "undefined")
                  cb = alignBits;
                mode = null;
                alignBits = null;
              }
              if (typeof mode === "function" && typeof cb === "undefined") {
                cb = mode;
                mode = null;
              }
              alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;
              var hbits = alignBits & (1 << 3) - 1;
              var vbits = alignBits >> 3;
              if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1))) {
                return _utils.throwError.call(this, "only use one flag per alignment direction", cb);
              }
              var alignH = hbits >> 1;
              var alignV = vbits >> 1;
              var f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;
              var c = this.cloneQuiet().scale(f, mode);
              this.resize(w, h, mode);
              this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
                this.bitmap.data.writeUInt32BE(this._background, idx);
              });
              this.blit(c, (this.bitmap.width - c.bitmap.width) / 2 * alignH, (this.bitmap.height - c.bitmap.height) / 2 * alignV);
              if ((0, _utils.isNodePattern)(cb)) {
                cb.call(this, null, this);
              }
              return this;
            }
          };
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@jimp/utils": 235 }], 207: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _utils = require2("@jimp/utils");
        var _default = function _default2() {
          return {
            cover: function cover(w, h, alignBits, mode, cb) {
              if (typeof w !== "number" || typeof h !== "number") {
                return _utils.throwError.call(this, "w and h must be numbers", cb);
              }
              if (alignBits && typeof alignBits === "function" && typeof cb === "undefined") {
                cb = alignBits;
                alignBits = null;
                mode = null;
              } else if (typeof mode === "function" && typeof cb === "undefined") {
                cb = mode;
                mode = null;
              }
              alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE;
              var hbits = alignBits & (1 << 3) - 1;
              var vbits = alignBits >> 3;
              if (!(hbits !== 0 && !(hbits & hbits - 1) || vbits !== 0 && !(vbits & vbits - 1)))
                return _utils.throwError.call(this, "only use one flag per alignment direction", cb);
              var alignH = hbits >> 1;
              var alignV = vbits >> 1;
              var f = w / h > this.bitmap.width / this.bitmap.height ? w / this.bitmap.width : h / this.bitmap.height;
              this.scale(f, mode);
              this.crop((this.bitmap.width - w) / 2 * alignH, (this.bitmap.height - h) / 2 * alignV, w, h);
              if ((0, _utils.isNodePattern)(cb)) {
                cb.call(this, null, this);
              }
              return this;
            }
          };
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@jimp/utils": 235 }], 208: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3["default"] = pluginCrop;
          var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
          var _utils = require2("@jimp/utils");
          function pluginCrop(event) {
            event("crop", function(x, y, w, h, cb) {
              if (typeof x !== "number" || typeof y !== "number")
                return _utils.throwError.call(this, "x and y must be numbers", cb);
              if (typeof w !== "number" || typeof h !== "number")
                return _utils.throwError.call(this, "w and h must be numbers", cb);
              x = Math.round(x);
              y = Math.round(y);
              w = Math.round(w);
              h = Math.round(h);
              if (x === 0 && w === this.bitmap.width) {
                var start = w * y + x << 2;
                var end = start + h * w << 2;
                this.bitmap.data = this.bitmap.data.slice(start, end);
              } else {
                var bitmap = Buffer.allocUnsafe(w * h * 4);
                var offset = 0;
                this.scanQuiet(x, y, w, h, function(x2, y2, idx) {
                  var data = this.bitmap.data.readUInt32BE(idx, true);
                  bitmap.writeUInt32BE(data, offset, true);
                  offset += 4;
                });
                this.bitmap.data = bitmap;
              }
              this.bitmap.width = w;
              this.bitmap.height = h;
              if ((0, _utils.isNodePattern)(cb)) {
                cb.call(this, null, this);
              }
              return this;
            });
            return {
              "class": {
                /**
                 * Autocrop same color borders from this image
                 * @param {number} tolerance (optional): a percent value of tolerance for pixels color difference (default: 0.0002%)
                 * @param {boolean} cropOnlyFrames (optional): flag to crop only real frames: all 4 sides of the image must have some border (default: true)
                 * @param {function(Error, Jimp)} cb (optional): a callback for when complete (default: no callback)
                 * @returns {Jimp} this for chaining of methods
                 */
                autocrop: function autocrop() {
                  var w = this.bitmap.width;
                  var h = this.bitmap.height;
                  var minPixelsPerSide = 1;
                  var cb;
                  var leaveBorder = 0;
                  var tolerance = 2e-4;
                  var cropOnlyFrames = true;
                  var cropSymmetric = false;
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }
                  for (var a = 0, len = args.length; a < len; a++) {
                    if (typeof args[a] === "number") {
                      tolerance = args[a];
                    }
                    if (typeof args[a] === "boolean") {
                      cropOnlyFrames = args[a];
                    }
                    if (typeof args[a] === "function") {
                      cb = args[a];
                    }
                    if ((0, _typeof2["default"])(args[a]) === "object") {
                      var config = args[a];
                      if (typeof config.tolerance !== "undefined") {
                        tolerance = config.tolerance;
                      }
                      if (typeof config.cropOnlyFrames !== "undefined") {
                        cropOnlyFrames = config.cropOnlyFrames;
                      }
                      if (typeof config.cropSymmetric !== "undefined") {
                        cropSymmetric = config.cropSymmetric;
                      }
                      if (typeof config.leaveBorder !== "undefined") {
                        leaveBorder = config.leaveBorder;
                      }
                    }
                  }
                  var colorTarget = this.getPixelColor(0, 0);
                  var rgba1 = this.constructor.intToRGBA(colorTarget);
                  var northPixelsToCrop = 0;
                  var eastPixelsToCrop = 0;
                  var southPixelsToCrop = 0;
                  var westPixelsToCrop = 0;
                  colorTarget = this.getPixelColor(0, 0);
                  north:
                    for (var y = 0; y < h - minPixelsPerSide; y++) {
                      for (var x = 0; x < w; x++) {
                        var colorXY = this.getPixelColor(x, y);
                        var rgba2 = this.constructor.intToRGBA(colorXY);
                        if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) {
                          break north;
                        }
                      }
                      northPixelsToCrop++;
                    }
                  colorTarget = this.getPixelColor(w, 0);
                  east:
                    for (var _x = 0; _x < w - minPixelsPerSide; _x++) {
                      for (var _y = 0 + northPixelsToCrop; _y < h; _y++) {
                        var _colorXY = this.getPixelColor(_x, _y);
                        var _rgba = this.constructor.intToRGBA(_colorXY);
                        if (this.constructor.colorDiff(rgba1, _rgba) > tolerance) {
                          break east;
                        }
                      }
                      eastPixelsToCrop++;
                    }
                  colorTarget = this.getPixelColor(0, h);
                  south:
                    for (var _y2 = h - 1; _y2 >= northPixelsToCrop + minPixelsPerSide; _y2--) {
                      for (var _x2 = w - eastPixelsToCrop - 1; _x2 >= 0; _x2--) {
                        var _colorXY2 = this.getPixelColor(_x2, _y2);
                        var _rgba2 = this.constructor.intToRGBA(_colorXY2);
                        if (this.constructor.colorDiff(rgba1, _rgba2) > tolerance) {
                          break south;
                        }
                      }
                      southPixelsToCrop++;
                    }
                  colorTarget = this.getPixelColor(w, h);
                  west:
                    for (var _x3 = w - 1; _x3 >= 0 + eastPixelsToCrop + minPixelsPerSide; _x3--) {
                      for (var _y3 = h - 1; _y3 >= 0 + northPixelsToCrop; _y3--) {
                        var _colorXY3 = this.getPixelColor(_x3, _y3);
                        var _rgba3 = this.constructor.intToRGBA(_colorXY3);
                        if (this.constructor.colorDiff(rgba1, _rgba3) > tolerance) {
                          break west;
                        }
                      }
                      westPixelsToCrop++;
                    }
                  var doCrop = false;
                  westPixelsToCrop -= leaveBorder;
                  eastPixelsToCrop -= leaveBorder;
                  northPixelsToCrop -= leaveBorder;
                  southPixelsToCrop -= leaveBorder;
                  if (cropSymmetric) {
                    var horizontal = Math.min(eastPixelsToCrop, westPixelsToCrop);
                    var vertical = Math.min(northPixelsToCrop, southPixelsToCrop);
                    westPixelsToCrop = horizontal;
                    eastPixelsToCrop = horizontal;
                    northPixelsToCrop = vertical;
                    southPixelsToCrop = vertical;
                  }
                  westPixelsToCrop = westPixelsToCrop >= 0 ? westPixelsToCrop : 0;
                  eastPixelsToCrop = eastPixelsToCrop >= 0 ? eastPixelsToCrop : 0;
                  northPixelsToCrop = northPixelsToCrop >= 0 ? northPixelsToCrop : 0;
                  southPixelsToCrop = southPixelsToCrop >= 0 ? southPixelsToCrop : 0;
                  var widthOfRemainingPixels = w - (westPixelsToCrop + eastPixelsToCrop);
                  var heightOfRemainingPixels = h - (southPixelsToCrop + northPixelsToCrop);
                  if (cropOnlyFrames) {
                    doCrop = eastPixelsToCrop !== 0 && northPixelsToCrop !== 0 && westPixelsToCrop !== 0 && southPixelsToCrop !== 0;
                  } else {
                    doCrop = eastPixelsToCrop !== 0 || northPixelsToCrop !== 0 || westPixelsToCrop !== 0 || southPixelsToCrop !== 0;
                  }
                  if (doCrop) {
                    this.crop(eastPixelsToCrop, northPixelsToCrop, widthOfRemainingPixels, heightOfRemainingPixels);
                  }
                  if ((0, _utils.isNodePattern)(cb)) {
                    cb.call(this, null, this);
                  }
                  return this;
                }
              }
            };
          }
          module3.exports = exports3.default;
        }).call(this, require2("buffer").Buffer);
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235, "buffer": 48 }], 209: [function(require2, module3, exports3) {
        "use strict";
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
        var _utils = require2("@jimp/utils");
        var _default = function _default2() {
          return {
            displace: function displace(map, offset, cb) {
              if ((0, _typeof2["default"])(map) !== "object" || map.constructor !== this.constructor) {
                return _utils.throwError.call(this, "The source must be a Jimp image", cb);
              }
              if (typeof offset !== "number") {
                return _utils.throwError.call(this, "factor must be a number", cb);
              }
              var source = this.cloneQuiet();
              this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
                var displacement = map.bitmap.data[idx] / 256 * offset;
                displacement = Math.round(displacement);
                var ids = this.getPixelIndex(x + displacement, y);
                this.bitmap.data[ids] = source.bitmap.data[idx];
                this.bitmap.data[ids + 1] = source.bitmap.data[idx + 1];
                this.bitmap.data[ids + 2] = source.bitmap.data[idx + 2];
              });
              if ((0, _utils.isNodePattern)(cb)) {
                cb.call(this, null, this);
              }
              return this;
            }
          };
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235 }], 210: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _utils = require2("@jimp/utils");
        function dither(cb) {
          var rgb565Matrix = [1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6];
          this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
            var thresholdId = ((y & 3) << 2) + x % 4;
            var dither2 = rgb565Matrix[thresholdId];
            this.bitmap.data[idx] = Math.min(this.bitmap.data[idx] + dither2, 255);
            this.bitmap.data[idx + 1] = Math.min(this.bitmap.data[idx + 1] + dither2, 255);
            this.bitmap.data[idx + 2] = Math.min(this.bitmap.data[idx + 2] + dither2, 255);
          });
          if ((0, _utils.isNodePattern)(cb)) {
            cb.call(this, null, this);
          }
          return this;
        }
        var _default = function _default2() {
          return {
            dither565: dither,
            dither16: dither
          };
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@jimp/utils": 235 }], 211: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _utils = require2("@jimp/utils");
        var _default = function _default2() {
          return {
            fisheye: function fisheye() {
              var _this = this;
              var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
                r: 2.5
              };
              var cb = arguments.length > 1 ? arguments[1] : void 0;
              if (typeof options === "function") {
                cb = options;
                options = {
                  r: 2.5
                };
              }
              var source = this.cloneQuiet();
              var _source$bitmap = source.bitmap, width = _source$bitmap.width, height = _source$bitmap.height;
              source.scanQuiet(0, 0, width, height, function(x, y) {
                var hx = x / width;
                var hy = y / height;
                var r = Math.sqrt(Math.pow(hx - 0.5, 2) + Math.pow(hy - 0.5, 2));
                var rn = 2 * Math.pow(r, options.r);
                var cosA = (hx - 0.5) / r;
                var sinA = (hy - 0.5) / r;
                var newX = Math.round((rn * cosA + 0.5) * width);
                var newY = Math.round((rn * sinA + 0.5) * height);
                var color = source.getPixelColor(newX, newY);
                _this.setPixelColor(color, x, y);
              });
              this.setPixelColor(source.getPixelColor(width / 2, height / 2), width / 2, height / 2);
              if ((0, _utils.isNodePattern)(cb)) {
                cb.call(this, null, this);
              }
              return this;
            }
          };
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@jimp/utils": 235 }], 212: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3["default"] = void 0;
          var _utils = require2("@jimp/utils");
          function flipFn(horizontal, vertical, cb) {
            if (typeof horizontal !== "boolean" || typeof vertical !== "boolean")
              return _utils.throwError.call(this, "horizontal and vertical must be Booleans", cb);
            var bitmap = Buffer.alloc(this.bitmap.data.length);
            this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
              var _x = horizontal ? this.bitmap.width - 1 - x : x;
              var _y = vertical ? this.bitmap.height - 1 - y : y;
              var _idx = this.bitmap.width * _y + _x << 2;
              var data = this.bitmap.data.readUInt32BE(idx);
              bitmap.writeUInt32BE(data, _idx);
            });
            this.bitmap.data = Buffer.from(bitmap);
            if ((0, _utils.isNodePattern)(cb)) {
              cb.call(this, null, this);
            }
            return this;
          }
          var _default = function _default2() {
            return {
              flip: flipFn,
              mirror: flipFn
            };
          };
          exports3["default"] = _default;
          module3.exports = exports3.default;
        }).call(this, require2("buffer").Buffer);
      }, { "@jimp/utils": 235, "buffer": 48 }], 213: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _utils = require2("@jimp/utils");
        var _default = function _default2() {
          return {
            gaussian: function gaussian(r, cb) {
              if (typeof r !== "number") {
                return _utils.throwError.call(this, "r must be a number", cb);
              }
              if (r < 1) {
                return _utils.throwError.call(this, "r must be greater than 0", cb);
              }
              var rs = Math.ceil(r * 2.57);
              var range = rs * 2 + 1;
              var rr2 = r * r * 2;
              var rr2pi = rr2 * Math.PI;
              var weights = [];
              for (var y = 0; y < range; y++) {
                weights[y] = [];
                for (var x = 0; x < range; x++) {
                  var dsq = Math.pow(x - rs, 2) + Math.pow(y - rs, 2);
                  weights[y][x] = Math.exp(-dsq / rr2) / rr2pi;
                }
              }
              for (var _y = 0; _y < this.bitmap.height; _y++) {
                for (var _x = 0; _x < this.bitmap.width; _x++) {
                  var red = 0;
                  var green = 0;
                  var blue = 0;
                  var alpha = 0;
                  var wsum = 0;
                  for (var iy = 0; iy < range; iy++) {
                    for (var ix = 0; ix < range; ix++) {
                      var x1 = Math.min(this.bitmap.width - 1, Math.max(0, ix + _x - rs));
                      var y1 = Math.min(this.bitmap.height - 1, Math.max(0, iy + _y - rs));
                      var weight = weights[iy][ix];
                      var _idx = y1 * this.bitmap.width + x1 << 2;
                      red += this.bitmap.data[_idx] * weight;
                      green += this.bitmap.data[_idx + 1] * weight;
                      blue += this.bitmap.data[_idx + 2] * weight;
                      alpha += this.bitmap.data[_idx + 3] * weight;
                      wsum += weight;
                    }
                    var idx = _y * this.bitmap.width + _x << 2;
                    this.bitmap.data[idx] = Math.round(red / wsum);
                    this.bitmap.data[idx + 1] = Math.round(green / wsum);
                    this.bitmap.data[idx + 2] = Math.round(blue / wsum);
                    this.bitmap.data[idx + 3] = Math.round(alpha / wsum);
                  }
                }
              }
              if ((0, _utils.isNodePattern)(cb)) {
                cb.call(this, null, this);
              }
              return this;
            }
          };
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@jimp/utils": 235 }], 214: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _utils = require2("@jimp/utils");
        var _default = function _default2() {
          return {
            invert: function invert(cb) {
              this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
                this.bitmap.data[idx] = 255 - this.bitmap.data[idx];
                this.bitmap.data[idx + 1] = 255 - this.bitmap.data[idx + 1];
                this.bitmap.data[idx + 2] = 255 - this.bitmap.data[idx + 2];
              });
              if ((0, _utils.isNodePattern)(cb)) {
                cb.call(this, null, this);
              }
              return this;
            }
          };
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@jimp/utils": 235 }], 215: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _utils = require2("@jimp/utils");
        var _default = function _default2() {
          return {
            mask: function mask(src) {
              var x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              var y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
              var cb = arguments.length > 3 ? arguments[3] : void 0;
              if (!(src instanceof this.constructor)) {
                return _utils.throwError.call(this, "The source must be a Jimp image", cb);
              }
              if (typeof x !== "number" || typeof y !== "number") {
                return _utils.throwError.call(this, "x and y must be numbers", cb);
              }
              x = Math.round(x);
              y = Math.round(y);
              var w = this.bitmap.width;
              var h = this.bitmap.height;
              var baseImage = this;
              src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, function(sx, sy, idx) {
                var destX = x + sx;
                var destY = y + sy;
                if (destX >= 0 && destY >= 0 && destX < w && destY < h) {
                  var dstIdx = baseImage.getPixelIndex(destX, destY);
                  var data = this.bitmap.data;
                  var avg = (data[idx + 0] + data[idx + 1] + data[idx + 2]) / 3;
                  baseImage.bitmap.data[dstIdx + 3] *= avg / 255;
                }
              });
              if ((0, _utils.isNodePattern)(cb)) {
                cb.call(this, null, this);
              }
              return this;
            }
          };
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@jimp/utils": 235 }], 216: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _utils = require2("@jimp/utils");
        function histogram() {
          var histogram2 = {
            r: new Array(256).fill(0),
            g: new Array(256).fill(0),
            b: new Array(256).fill(0)
          };
          this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, index) {
            histogram2.r[this.bitmap.data[index + 0]]++;
            histogram2.g[this.bitmap.data[index + 1]]++;
            histogram2.b[this.bitmap.data[index + 2]]++;
          });
          return histogram2;
        }
        var _normalize = function normalize(value, min, max) {
          return (value - min) * 255 / (max - min);
        };
        var getBounds = function getBounds2(histogramChannel) {
          return [histogramChannel.findIndex(function(value) {
            return value > 0;
          }), 255 - histogramChannel.slice().reverse().findIndex(function(value) {
            return value > 0;
          })];
        };
        var _default = function _default2() {
          return {
            normalize: function normalize(cb) {
              var h = histogram.call(this);
              var bounds = {
                r: getBounds(h.r),
                g: getBounds(h.g),
                b: getBounds(h.b)
              };
              this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
                var r = this.bitmap.data[idx + 0];
                var g = this.bitmap.data[idx + 1];
                var b = this.bitmap.data[idx + 2];
                this.bitmap.data[idx + 0] = _normalize(r, bounds.r[0], bounds.r[1]);
                this.bitmap.data[idx + 1] = _normalize(g, bounds.g[0], bounds.g[1]);
                this.bitmap.data[idx + 2] = _normalize(b, bounds.b[0], bounds.b[1]);
              });
              if ((0, _utils.isNodePattern)(cb)) {
                cb.call(this, null, this);
              }
              return this;
            }
          };
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@jimp/utils": 235 }], 217: [function(require2, module3, exports3) {
        (function(__dirname) {
          "use strict";
          var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3["default"] = void 0;
          var _typeof2 = _interopRequireDefault(require2("@babel/runtime/helpers/typeof"));
          var _toConsumableArray2 = _interopRequireDefault(require2("@babel/runtime/helpers/toConsumableArray"));
          var _path = _interopRequireDefault(require2("path"));
          var _loadBmfont = _interopRequireDefault(require2("load-bmfont"));
          var _utils = require2("@jimp/utils");
          var _measureText = require2("./measure-text");
          function xOffsetBasedOnAlignment(constants, font, line, maxWidth, alignment) {
            if (alignment === constants.HORIZONTAL_ALIGN_LEFT) {
              return 0;
            }
            if (alignment === constants.HORIZONTAL_ALIGN_CENTER) {
              return (maxWidth - (0, _measureText.measureText)(font, line)) / 2;
            }
            return maxWidth - (0, _measureText.measureText)(font, line);
          }
          function drawCharacter(image, font, x, y, _char) {
            if (_char.width > 0 && _char.height > 0) {
              var characterPage = font.pages[_char.page];
              image.blit(characterPage, x + _char.xoffset, y + _char.yoffset, _char.x, _char.y, _char.width, _char.height);
            }
            return image;
          }
          function printText(font, x, y, text, defaultCharWidth) {
            for (var i = 0; i < text.length; i++) {
              var _char2 = void 0;
              if (font.chars[text[i]]) {
                _char2 = text[i];
              } else if (/\s/.test(text[i])) {
                _char2 = "";
              } else {
                _char2 = "?";
              }
              var fontChar = font.chars[_char2] || {};
              var fontKerning = font.kernings[_char2];
              drawCharacter(this, font, x, y, fontChar || {});
              var kerning = fontKerning && fontKerning[text[i + 1]] ? fontKerning[text[i + 1]] : 0;
              x += kerning + (fontChar.xadvance || defaultCharWidth);
            }
          }
          function splitLines(font, text, maxWidth) {
            var words = text.split(" ");
            var lines = [];
            var currentLine = [];
            var longestLine = 0;
            words.forEach(function(word) {
              var line = [].concat((0, _toConsumableArray2["default"])(currentLine), [word]).join(" ");
              var length = (0, _measureText.measureText)(font, line);
              if (length <= maxWidth) {
                if (length > longestLine) {
                  longestLine = length;
                }
                currentLine.push(word);
              } else {
                lines.push(currentLine);
                currentLine = [word];
              }
            });
            lines.push(currentLine);
            return {
              lines,
              longestLine
            };
          }
          function loadPages(Jimp, dir2, pages) {
            var newPages = pages.map(function(page) {
              return Jimp.read(dir2 + "/" + page);
            });
            return Promise.all(newPages);
          }
          var dir = "browser/lib/";
          var _default = function _default2() {
            return {
              constants: {
                measureText: _measureText.measureText,
                measureTextHeight: _measureText.measureTextHeight,
                FONT_SANS_8_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt"),
                FONT_SANS_10_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-10-black/open-sans-10-black.fnt"),
                FONT_SANS_12_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-12-black/open-sans-12-black.fnt"),
                FONT_SANS_14_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-14-black/open-sans-14-black.fnt"),
                FONT_SANS_16_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt"),
                FONT_SANS_32_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt"),
                FONT_SANS_64_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt"),
                FONT_SANS_128_BLACK: _path["default"].join(dir, "fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt"),
                FONT_SANS_8_WHITE: _path["default"].join(dir, "fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt"),
                FONT_SANS_16_WHITE: _path["default"].join(dir, "fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt"),
                FONT_SANS_32_WHITE: _path["default"].join(dir, "fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt"),
                FONT_SANS_64_WHITE: _path["default"].join(dir, "fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt"),
                FONT_SANS_128_WHITE: _path["default"].join(dir, "fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt"),
                /**
                 * Loads a bitmap font from a file
                 * @param {string} file the file path of a .fnt file
                 * @param {function(Error, Jimp)} cb (optional) a function to call when the font is loaded
                 * @returns {Promise} a promise
                 */
                loadFont: function loadFont(file, cb) {
                  var _this = this;
                  if (typeof file !== "string")
                    return _utils.throwError.call(this, "file must be a string", cb);
                  return new Promise(function(resolve, reject) {
                    cb = cb || function(err, font) {
                      if (err)
                        reject(err);
                      else
                        resolve(font);
                    };
                    (0, _loadBmfont["default"])(file, function(err, font) {
                      var chars = {};
                      var kernings = {};
                      if (err) {
                        return _utils.throwError.call(_this, err, cb);
                      }
                      for (var i = 0; i < font.chars.length; i++) {
                        chars[String.fromCharCode(font.chars[i].id)] = font.chars[i];
                      }
                      for (var _i = 0; _i < font.kernings.length; _i++) {
                        var firstString = String.fromCharCode(font.kernings[_i].first);
                        kernings[firstString] = kernings[firstString] || {};
                        kernings[firstString][String.fromCharCode(font.kernings[_i].second)] = font.kernings[_i].amount;
                      }
                      loadPages(_this, _path["default"].dirname(file), font.pages).then(function(pages) {
                        cb(null, {
                          chars,
                          kernings,
                          pages,
                          common: font.common,
                          info: font.info
                        });
                      });
                    });
                  });
                }
              },
              "class": {
                /**
                 * Draws a text on a image on a given boundary
                 * @param {Jimp} font a bitmap font loaded from `Jimp.loadFont` command
                 * @param {number} x the x position to start drawing the text
                 * @param {number} y the y position to start drawing the text
                 * @param {any} text the text to draw (string or object with `text`, `alignmentX`, and/or `alignmentY`)
                 * @param {number} maxWidth (optional) the boundary width to draw in
                 * @param {number} maxHeight (optional) the boundary height to draw in
                 * @param {function(Error, Jimp)} cb (optional) a function to call when the text is written
                 * @returns {Jimp} this for chaining of methods
                 */
                print: function print(font, x, y, text, maxWidth, maxHeight, cb) {
                  var _this2 = this;
                  if (typeof maxWidth === "function" && typeof cb === "undefined") {
                    cb = maxWidth;
                    maxWidth = Infinity;
                  }
                  if (typeof maxWidth === "undefined") {
                    maxWidth = Infinity;
                  }
                  if (typeof maxHeight === "function" && typeof cb === "undefined") {
                    cb = maxHeight;
                    maxHeight = Infinity;
                  }
                  if (typeof maxHeight === "undefined") {
                    maxHeight = Infinity;
                  }
                  if ((0, _typeof2["default"])(font) !== "object") {
                    return _utils.throwError.call(this, "font must be a Jimp loadFont", cb);
                  }
                  if (typeof x !== "number" || typeof y !== "number" || typeof maxWidth !== "number") {
                    return _utils.throwError.call(this, "x, y and maxWidth must be numbers", cb);
                  }
                  if (typeof maxWidth !== "number") {
                    return _utils.throwError.call(this, "maxWidth must be a number", cb);
                  }
                  if (typeof maxHeight !== "number") {
                    return _utils.throwError.call(this, "maxHeight must be a number", cb);
                  }
                  var alignmentX;
                  var alignmentY;
                  if ((0, _typeof2["default"])(text) === "object" && text.text !== null && text.text !== void 0) {
                    alignmentX = text.alignmentX || this.constructor.HORIZONTAL_ALIGN_LEFT;
                    alignmentY = text.alignmentY || this.constructor.VERTICAL_ALIGN_TOP;
                    var _text = text;
                    text = _text.text;
                  } else {
                    alignmentX = this.constructor.HORIZONTAL_ALIGN_LEFT;
                    alignmentY = this.constructor.VERTICAL_ALIGN_TOP;
                    text = text.toString();
                  }
                  if (maxHeight !== Infinity && alignmentY === this.constructor.VERTICAL_ALIGN_BOTTOM) {
                    y += maxHeight - (0, _measureText.measureTextHeight)(font, text, maxWidth);
                  } else if (maxHeight !== Infinity && alignmentY === this.constructor.VERTICAL_ALIGN_MIDDLE) {
                    y += maxHeight / 2 - (0, _measureText.measureTextHeight)(font, text, maxWidth) / 2;
                  }
                  var defaultCharWidth = Object.entries(font.chars)[0][1].xadvance;
                  var _splitLines = splitLines(font, text, maxWidth), lines = _splitLines.lines, longestLine = _splitLines.longestLine;
                  lines.forEach(function(line) {
                    var lineString = line.join(" ");
                    var alignmentWidth = xOffsetBasedOnAlignment(_this2.constructor, font, lineString, maxWidth, alignmentX);
                    printText.call(_this2, font, x + alignmentWidth, y, lineString, defaultCharWidth);
                    y += font.common.lineHeight;
                  });
                  if ((0, _utils.isNodePattern)(cb)) {
                    cb.call(this, null, this, {
                      x: x + longestLine,
                      y
                    });
                  }
                  return this;
                }
              }
            };
          };
          exports3["default"] = _default;
          module3.exports = exports3.default;
        }).call(this, "/../../node_modules/@jimp/plugin-print/dist");
      }, { "./measure-text": 218, "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/toConsumableArray": 20, "@babel/runtime/helpers/typeof": 21, "@jimp/utils": 235, "load-bmfont": 219, "path": 107 }], 218: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.measureText = measureText;
        exports3.measureTextHeight = measureTextHeight;
        function measureText(font, text) {
          var x = 0;
          for (var i = 0; i < text.length; i++) {
            if (font.chars[text[i]]) {
              var kerning = font.kernings[text[i]] && font.kernings[text[i]][text[i + 1]] ? font.kernings[text[i]][text[i + 1]] : 0;
              x += (font.chars[text[i]].xadvance || 0) + kerning;
            }
          }
          return x;
        }
        function measureTextHeight(font, text, maxWidth) {
          var words = text.split(" ");
          var line = "";
          var textTotalHeight = font.common.lineHeight;
          for (var n = 0; n < words.length; n++) {
            var testLine = line + words[n] + " ";
            var testWidth = measureText(font, testLine);
            if (testWidth > maxWidth && n > 0) {
              textTotalHeight += font.common.lineHeight;
              line = words[n] + " ";
            } else {
              line = testLine;
            }
          }
          return textTotalHeight;
        }
      }, {}], 219: [function(require2, module3, exports3) {
        (function(Buffer) {
          var xhr = require2("xhr");
          var noop = function() {
          };
          var parseASCII = require2("parse-bmfont-ascii");
          var parseXML = require2("parse-bmfont-xml");
          var readBinary = require2("parse-bmfont-binary");
          var isBinaryFormat = require2("./lib/is-binary");
          var xtend = require2("xtend");
          var xml2 = function hasXML2() {
            return self.XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
          }();
          module3.exports = function(opt, cb) {
            cb = typeof cb === "function" ? cb : noop;
            if (typeof opt === "string")
              opt = { uri: opt };
            else if (!opt)
              opt = {};
            var expectBinary = opt.binary;
            if (expectBinary)
              opt = getBinaryOpts(opt);
            xhr(opt, function(err, res, body) {
              if (err)
                return cb(err);
              if (!/^2/.test(res.statusCode))
                return cb(new Error("http status code: " + res.statusCode));
              if (!body)
                return cb(new Error("no body result"));
              var binary = false;
              if (isArrayBuffer(body)) {
                var array = new Uint8Array(body);
                body = new Buffer(array, "binary");
              }
              if (isBinaryFormat(body)) {
                binary = true;
                if (typeof body === "string")
                  body = new Buffer(body, "binary");
              }
              if (!binary) {
                if (Buffer.isBuffer(body))
                  body = body.toString(opt.encoding);
                body = body.trim();
              }
              var result;
              try {
                var type = res.headers["content-type"];
                if (binary)
                  result = readBinary(body);
                else if (/json/.test(type) || body.charAt(0) === "{")
                  result = JSON.parse(body);
                else if (/xml/.test(type) || body.charAt(0) === "<")
                  result = parseXML(body);
                else
                  result = parseASCII(body);
              } catch (e) {
                cb(new Error("error parsing font " + e.message));
                cb = noop;
              }
              cb(null, result);
            });
          };
          function isArrayBuffer(arr) {
            var str = Object.prototype.toString;
            return str.call(arr) === "[object ArrayBuffer]";
          }
          function getBinaryOpts(opt) {
            if (xml2)
              return xtend(opt, { responseType: "arraybuffer" });
            if (typeof self.XMLHttpRequest === "undefined")
              throw new Error("your browser does not support XHR loading");
            var req = new self.XMLHttpRequest();
            req.overrideMimeType("text/plain; charset=x-user-defined");
            return xtend({
              xhr: req
            }, opt);
          }
        }).call(this, require2("buffer").Buffer);
      }, { "./lib/is-binary": 220, "buffer": 48, "parse-bmfont-ascii": 102, "parse-bmfont-binary": 103, "parse-bmfont-xml": 104, "xhr": 187, "xtend": 189 }], 220: [function(require2, module3, exports3) {
        (function(Buffer) {
          var equal = require2("buffer-equal");
          var HEADER = new Buffer([66, 77, 70, 3]);
          module3.exports = function(buf) {
            if (typeof buf === "string")
              return buf.substring(0, 3) === "BMF";
            return buf.length > 4 && equal(buf.slice(0, 4), HEADER);
          };
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 48, "buffer-equal": 49 }], 221: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3["default"] = void 0;
          var _utils = require2("@jimp/utils");
          var _resize = _interopRequireDefault(require2("./modules/resize"));
          var _resize2 = _interopRequireDefault(require2("./modules/resize2"));
          var _default = function _default2() {
            return {
              constants: {
                RESIZE_NEAREST_NEIGHBOR: "nearestNeighbor",
                RESIZE_BILINEAR: "bilinearInterpolation",
                RESIZE_BICUBIC: "bicubicInterpolation",
                RESIZE_HERMITE: "hermiteInterpolation",
                RESIZE_BEZIER: "bezierInterpolation"
              },
              "class": {
                /**
                 * Resizes the image to a set width and height using a 2-pass bilinear algorithm
                 * @param {number} w the width to resize the image to (or Jimp.AUTO)
                 * @param {number} h the height to resize the image to (or Jimp.AUTO)
                 * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
                 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
                 * @returns {Jimp} this for chaining of methods
                 */
                resize: function resize(w, h, mode, cb) {
                  if (typeof w !== "number" || typeof h !== "number") {
                    return _utils.throwError.call(this, "w and h must be numbers", cb);
                  }
                  if (typeof mode === "function" && typeof cb === "undefined") {
                    cb = mode;
                    mode = null;
                  }
                  if (w === this.constructor.AUTO && h === this.constructor.AUTO) {
                    return _utils.throwError.call(this, "w and h cannot both be set to auto", cb);
                  }
                  if (w === this.constructor.AUTO) {
                    w = this.bitmap.width * (h / this.bitmap.height);
                  }
                  if (h === this.constructor.AUTO) {
                    h = this.bitmap.height * (w / this.bitmap.width);
                  }
                  if (w < 0 || h < 0) {
                    return _utils.throwError.call(this, "w and h must be positive numbers", cb);
                  }
                  w = Math.round(w);
                  h = Math.round(h);
                  if (typeof _resize2["default"][mode] === "function") {
                    var dst = {
                      data: Buffer.alloc(w * h * 4),
                      width: w,
                      height: h
                    };
                    _resize2["default"][mode](this.bitmap, dst);
                    this.bitmap = dst;
                  } else {
                    var image = this;
                    var resize2 = new _resize["default"](this.bitmap.width, this.bitmap.height, w, h, true, true, function(buffer) {
                      image.bitmap.data = Buffer.from(buffer);
                      image.bitmap.width = w;
                      image.bitmap.height = h;
                    });
                    resize2.resize(this.bitmap.data);
                  }
                  if ((0, _utils.isNodePattern)(cb)) {
                    cb.call(this, null, this);
                  }
                  return this;
                }
              }
            };
          };
          exports3["default"] = _default;
          module3.exports = exports3.default;
        }).call(this, require2("buffer").Buffer);
      }, { "./modules/resize": 222, "./modules/resize2": 223, "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/utils": 235, "buffer": 48 }], 222: [function(require2, module3, exports3) {
        "use strict";
        function Resize(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {
          this.widthOriginal = Math.abs(Math.floor(widthOriginal) || 0);
          this.heightOriginal = Math.abs(Math.floor(heightOriginal) || 0);
          this.targetWidth = Math.abs(Math.floor(targetWidth) || 0);
          this.targetHeight = Math.abs(Math.floor(targetHeight) || 0);
          this.colorChannels = blendAlpha ? 4 : 3;
          this.interpolationPass = Boolean(interpolationPass);
          this.resizeCallback = typeof resizeCallback === "function" ? resizeCallback : function() {
          };
          this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels;
          this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels;
          this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels;
          this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal;
          this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight;
          this.initialize();
        }
        Resize.prototype.initialize = function() {
          if (this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0) {
            this.configurePasses();
          } else {
            throw new Error("Invalid settings specified for the resizer.");
          }
        };
        Resize.prototype.configurePasses = function() {
          if (this.widthOriginal === this.targetWidth) {
            this.resizeWidth = this.bypassResizer;
          } else {
            this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth;
            if (this.ratioWeightWidthPass < 1 && this.interpolationPass) {
              this.initializeFirstPassBuffers(true);
              this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB;
            } else {
              this.initializeFirstPassBuffers(false);
              this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB;
            }
          }
          if (this.heightOriginal === this.targetHeight) {
            this.resizeHeight = this.bypassResizer;
          } else {
            this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight;
            if (this.ratioWeightHeightPass < 1 && this.interpolationPass) {
              this.initializeSecondPassBuffers(true);
              this.resizeHeight = this.resizeHeightInterpolated;
            } else {
              this.initializeSecondPassBuffers(false);
              this.resizeHeight = this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB;
            }
          }
        };
        Resize.prototype._resizeWidthInterpolatedRGBChannels = function(buffer, fourthChannel) {
          var channelsNum = fourthChannel ? 4 : 3;
          var ratioWeight = this.ratioWeightWidthPass;
          var outputBuffer = this.widthBuffer;
          var weight = 0;
          var finalOffset = 0;
          var pixelOffset = 0;
          var firstWeight = 0;
          var secondWeight = 0;
          var targetPosition;
          for (targetPosition = 0; weight < 1 / 3; targetPosition += channelsNum, weight += ratioWeight) {
            for (finalOffset = targetPosition, pixelOffset = 0; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
              outputBuffer[finalOffset] = buffer[pixelOffset];
              outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
              outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
              if (fourthChannel)
                outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
            }
          }
          weight -= 1 / 3;
          var interpolationWidthSourceReadStop;
          for (interpolationWidthSourceReadStop = this.widthOriginal - 1; weight < interpolationWidthSourceReadStop; targetPosition += channelsNum, weight += ratioWeight) {
            secondWeight = weight % 1;
            firstWeight = 1 - secondWeight;
            for (finalOffset = targetPosition, pixelOffset = Math.floor(weight) * channelsNum; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
              outputBuffer[finalOffset + 0] = buffer[pixelOffset + 0] * firstWeight + buffer[pixelOffset + channelsNum + 0] * secondWeight;
              outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1] * firstWeight + buffer[pixelOffset + channelsNum + 1] * secondWeight;
              outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2] * firstWeight + buffer[pixelOffset + channelsNum + 2] * secondWeight;
              if (fourthChannel)
                outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3] * firstWeight + buffer[pixelOffset + channelsNum + 3] * secondWeight;
            }
          }
          for (interpolationWidthSourceReadStop = this.originalWidthMultipliedByChannels - channelsNum; targetPosition < this.targetWidthMultipliedByChannels; targetPosition += channelsNum) {
            for (finalOffset = targetPosition, pixelOffset = interpolationWidthSourceReadStop; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, finalOffset += this.targetWidthMultipliedByChannels) {
              outputBuffer[finalOffset] = buffer[pixelOffset];
              outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1];
              outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2];
              if (fourthChannel)
                outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3];
            }
          }
          return outputBuffer;
        };
        Resize.prototype._resizeWidthRGBChannels = function(buffer, fourthChannel) {
          var channelsNum = fourthChannel ? 4 : 3;
          var ratioWeight = this.ratioWeightWidthPass;
          var ratioWeightDivisor = 1 / ratioWeight;
          var nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - channelsNum + 1;
          var nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - channelsNum + 1;
          var output = this.outputWidthWorkBench;
          var outputBuffer = this.widthBuffer;
          var trustworthyColorsCount = this.outputWidthWorkBenchOpaquePixelsCount;
          var weight = 0;
          var amountToNext = 0;
          var actualPosition = 0;
          var currentPosition = 0;
          var line = 0;
          var pixelOffset = 0;
          var outputOffset = 0;
          var multiplier = 1;
          var r = 0;
          var g = 0;
          var b = 0;
          var a = 0;
          do {
            for (line = 0; line < this.originalHeightMultipliedByChannels; ) {
              output[line++] = 0;
              output[line++] = 0;
              output[line++] = 0;
              if (fourthChannel) {
                output[line++] = 0;
                trustworthyColorsCount[line / channelsNum - 1] = 0;
              }
            }
            weight = ratioWeight;
            do {
              amountToNext = 1 + actualPosition - currentPosition;
              multiplier = Math.min(weight, amountToNext);
              for (line = 0, pixelOffset = actualPosition; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) {
                r = buffer[pixelOffset];
                g = buffer[++pixelOffset];
                b = buffer[++pixelOffset];
                a = fourthChannel ? buffer[++pixelOffset] : 255;
                output[line++] += (a ? r : 0) * multiplier;
                output[line++] += (a ? g : 0) * multiplier;
                output[line++] += (a ? b : 0) * multiplier;
                if (fourthChannel) {
                  output[line++] += a * multiplier;
                  trustworthyColorsCount[line / channelsNum - 1] += a ? multiplier : 0;
                }
              }
              if (weight >= amountToNext) {
                actualPosition += channelsNum;
                currentPosition = actualPosition;
                weight -= amountToNext;
              } else {
                currentPosition += weight;
                break;
              }
            } while (weight > 0 && actualPosition < this.originalWidthMultipliedByChannels);
            for (line = 0, pixelOffset = outputOffset; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) {
              weight = fourthChannel ? trustworthyColorsCount[line / channelsNum] : 1;
              multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;
              outputBuffer[pixelOffset] = output[line++] * multiplier;
              outputBuffer[++pixelOffset] = output[line++] * multiplier;
              outputBuffer[++pixelOffset] = output[line++] * multiplier;
              if (fourthChannel)
                outputBuffer[++pixelOffset] = output[line++] * ratioWeightDivisor;
            }
            outputOffset += channelsNum;
          } while (outputOffset < this.targetWidthMultipliedByChannels);
          return outputBuffer;
        };
        Resize.prototype._resizeHeightRGBChannels = function(buffer, fourthChannel) {
          var ratioWeight = this.ratioWeightHeightPass;
          var ratioWeightDivisor = 1 / ratioWeight;
          var output = this.outputHeightWorkBench;
          var outputBuffer = this.heightBuffer;
          var trustworthyColorsCount = this.outputHeightWorkBenchOpaquePixelsCount;
          var weight = 0;
          var amountToNext = 0;
          var actualPosition = 0;
          var currentPosition = 0;
          var pixelOffset = 0;
          var outputOffset = 0;
          var caret = 0;
          var multiplier = 1;
          var r = 0;
          var g = 0;
          var b = 0;
          var a = 0;
          do {
            for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
              output[pixelOffset++] = 0;
              output[pixelOffset++] = 0;
              output[pixelOffset++] = 0;
              if (fourthChannel) {
                output[pixelOffset++] = 0;
                trustworthyColorsCount[pixelOffset / 4 - 1] = 0;
              }
            }
            weight = ratioWeight;
            do {
              amountToNext = 1 + actualPosition - currentPosition;
              multiplier = Math.min(weight, amountToNext);
              caret = actualPosition;
              for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
                r = buffer[caret++];
                g = buffer[caret++];
                b = buffer[caret++];
                a = fourthChannel ? buffer[caret++] : 255;
                output[pixelOffset++] += (a ? r : 0) * multiplier;
                output[pixelOffset++] += (a ? g : 0) * multiplier;
                output[pixelOffset++] += (a ? b : 0) * multiplier;
                if (fourthChannel) {
                  output[pixelOffset++] += a * multiplier;
                  trustworthyColorsCount[pixelOffset / 4 - 1] += a ? multiplier : 0;
                }
              }
              if (weight >= amountToNext) {
                actualPosition = caret;
                currentPosition = actualPosition;
                weight -= amountToNext;
              } else {
                currentPosition += weight;
                break;
              }
            } while (weight > 0 && actualPosition < this.widthPassResultSize);
            for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
              weight = fourthChannel ? trustworthyColorsCount[pixelOffset / 4] : 1;
              multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor;
              outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
              outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
              outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier);
              if (fourthChannel) {
                outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor);
              }
            }
          } while (outputOffset < this.finalResultSize);
          return outputBuffer;
        };
        Resize.prototype.resizeWidthInterpolatedRGB = function(buffer) {
          return this._resizeWidthInterpolatedRGBChannels(buffer, false);
        };
        Resize.prototype.resizeWidthInterpolatedRGBA = function(buffer) {
          return this._resizeWidthInterpolatedRGBChannels(buffer, true);
        };
        Resize.prototype.resizeWidthRGB = function(buffer) {
          return this._resizeWidthRGBChannels(buffer, false);
        };
        Resize.prototype.resizeWidthRGBA = function(buffer) {
          return this._resizeWidthRGBChannels(buffer, true);
        };
        Resize.prototype.resizeHeightInterpolated = function(buffer) {
          var ratioWeight = this.ratioWeightHeightPass;
          var outputBuffer = this.heightBuffer;
          var weight = 0;
          var finalOffset = 0;
          var pixelOffset = 0;
          var pixelOffsetAccumulated = 0;
          var pixelOffsetAccumulated2 = 0;
          var firstWeight = 0;
          var secondWeight = 0;
          var interpolationHeightSourceReadStop;
          for (; weight < 1 / 3; weight += ratioWeight) {
            for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) {
              outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);
            }
          }
          weight -= 1 / 3;
          for (interpolationHeightSourceReadStop = this.heightOriginal - 1; weight < interpolationHeightSourceReadStop; weight += ratioWeight) {
            secondWeight = weight % 1;
            firstWeight = 1 - secondWeight;
            pixelOffsetAccumulated = Math.floor(weight) * this.targetWidthMultipliedByChannels;
            pixelOffsetAccumulated2 = pixelOffsetAccumulated + this.targetWidthMultipliedByChannels;
            for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
              outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++] * firstWeight + buffer[pixelOffsetAccumulated2++] * secondWeight);
            }
          }
          while (finalOffset < this.finalResultSize) {
            for (pixelOffset = 0, pixelOffsetAccumulated = interpolationHeightSourceReadStop * this.targetWidthMultipliedByChannels; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) {
              outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++]);
            }
          }
          return outputBuffer;
        };
        Resize.prototype.resizeHeightRGB = function(buffer) {
          return this._resizeHeightRGBChannels(buffer, false);
        };
        Resize.prototype.resizeHeightRGBA = function(buffer) {
          return this._resizeHeightRGBChannels(buffer, true);
        };
        Resize.prototype.resize = function(buffer) {
          this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));
        };
        Resize.prototype.bypassResizer = function(buffer) {
          return buffer;
        };
        Resize.prototype.initializeFirstPassBuffers = function(BILINEARAlgo) {
          this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize);
          if (!BILINEARAlgo) {
            this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels);
            if (this.colorChannels > 3) {
              this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal);
            }
          }
        };
        Resize.prototype.initializeSecondPassBuffers = function(BILINEARAlgo) {
          this.heightBuffer = this.generateUint8Buffer(this.finalResultSize);
          if (!BILINEARAlgo) {
            this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels);
            if (this.colorChannels > 3) {
              this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth);
            }
          }
        };
        Resize.prototype.generateFloatBuffer = function(bufferLength) {
          try {
            return new Float32Array(bufferLength);
          } catch (error) {
            return [];
          }
        };
        Resize.prototype.generateFloat64Buffer = function(bufferLength) {
          try {
            return new Float64Array(bufferLength);
          } catch (error) {
            return [];
          }
        };
        Resize.prototype.generateUint8Buffer = function(bufferLength) {
          try {
            return new Uint8Array(bufferLength);
          } catch (error) {
            return [];
          }
        };
        module3.exports = Resize;
      }, {}], 223: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          module3.exports = {
            nearestNeighbor: function nearestNeighbor(src, dst) {
              var wSrc = src.width;
              var hSrc = src.height;
              var wDst = dst.width;
              var hDst = dst.height;
              var bufSrc = src.data;
              var bufDst = dst.data;
              for (var i = 0; i < hDst; i++) {
                for (var j = 0; j < wDst; j++) {
                  var posDst = (i * wDst + j) * 4;
                  var iSrc = Math.floor(i * hSrc / hDst);
                  var jSrc = Math.floor(j * wSrc / wDst);
                  var posSrc = (iSrc * wSrc + jSrc) * 4;
                  bufDst[posDst++] = bufSrc[posSrc++];
                  bufDst[posDst++] = bufSrc[posSrc++];
                  bufDst[posDst++] = bufSrc[posSrc++];
                  bufDst[posDst++] = bufSrc[posSrc++];
                }
              }
            },
            bilinearInterpolation: function bilinearInterpolation(src, dst) {
              var wSrc = src.width;
              var hSrc = src.height;
              var wDst = dst.width;
              var hDst = dst.height;
              var bufSrc = src.data;
              var bufDst = dst.data;
              var interpolate = function interpolate2(k, kMin, vMin, kMax, vMax) {
                if (kMin === kMax) {
                  return vMin;
                }
                return Math.round((k - kMin) * vMax + (kMax - k) * vMin);
              };
              var assign = function assign2(pos, offset, x2, xMin2, xMax2, y2, yMin2, yMax2) {
                var posMin = (yMin2 * wSrc + xMin2) * 4 + offset;
                var posMax = (yMin2 * wSrc + xMax2) * 4 + offset;
                var vMin = interpolate(x2, xMin2, bufSrc[posMin], xMax2, bufSrc[posMax]);
                if (yMax2 === yMin2) {
                  bufDst[pos + offset] = vMin;
                } else {
                  posMin = (yMax2 * wSrc + xMin2) * 4 + offset;
                  posMax = (yMax2 * wSrc + xMax2) * 4 + offset;
                  var vMax = interpolate(x2, xMin2, bufSrc[posMin], xMax2, bufSrc[posMax]);
                  bufDst[pos + offset] = interpolate(y2, yMin2, vMin, yMax2, vMax);
                }
              };
              for (var i = 0; i < hDst; i++) {
                for (var j = 0; j < wDst; j++) {
                  var posDst = (i * wDst + j) * 4;
                  var x = j * wSrc / wDst;
                  var xMin = Math.floor(x);
                  var xMax = Math.min(Math.ceil(x), wSrc - 1);
                  var y = i * hSrc / hDst;
                  var yMin = Math.floor(y);
                  var yMax = Math.min(Math.ceil(y), hSrc - 1);
                  assign(posDst, 0, x, xMin, xMax, y, yMin, yMax);
                  assign(posDst, 1, x, xMin, xMax, y, yMin, yMax);
                  assign(posDst, 2, x, xMin, xMax, y, yMin, yMax);
                  assign(posDst, 3, x, xMin, xMax, y, yMin, yMax);
                }
              }
            },
            _interpolate2D: function _interpolate2D(src, dst, options, interpolate) {
              var bufSrc = src.data;
              var bufDst = dst.data;
              var wSrc = src.width;
              var hSrc = src.height;
              var wDst = dst.width;
              var hDst = dst.height;
              var wM = Math.max(1, Math.floor(wSrc / wDst));
              var wDst2 = wDst * wM;
              var hM = Math.max(1, Math.floor(hSrc / hDst));
              var hDst2 = hDst * hM;
              var buf1 = Buffer.alloc(wDst2 * hSrc * 4);
              for (var i = 0; i < hSrc; i++) {
                for (var j = 0; j < wDst2; j++) {
                  var x = j * (wSrc - 1) / wDst2;
                  var xPos = Math.floor(x);
                  var t = x - xPos;
                  var srcPos = (i * wSrc + xPos) * 4;
                  var buf1Pos = (i * wDst2 + j) * 4;
                  for (var k = 0; k < 4; k++) {
                    var kPos = srcPos + k;
                    var x0 = xPos > 0 ? bufSrc[kPos - 4] : 2 * bufSrc[kPos] - bufSrc[kPos + 4];
                    var x1 = bufSrc[kPos];
                    var x2 = bufSrc[kPos + 4];
                    var x3 = xPos < wSrc - 2 ? bufSrc[kPos + 8] : 2 * bufSrc[kPos + 4] - bufSrc[kPos];
                    buf1[buf1Pos + k] = interpolate(x0, x1, x2, x3, t);
                  }
                }
              }
              var buf2 = Buffer.alloc(wDst2 * hDst2 * 4);
              for (var _i = 0; _i < hDst2; _i++) {
                for (var _j = 0; _j < wDst2; _j++) {
                  var y = _i * (hSrc - 1) / hDst2;
                  var yPos = Math.floor(y);
                  var _t = y - yPos;
                  var _buf1Pos = (yPos * wDst2 + _j) * 4;
                  var buf2Pos = (_i * wDst2 + _j) * 4;
                  for (var _k = 0; _k < 4; _k++) {
                    var _kPos = _buf1Pos + _k;
                    var y0 = yPos > 0 ? buf1[_kPos - wDst2 * 4] : 2 * buf1[_kPos] - buf1[_kPos + wDst2 * 4];
                    var y1 = buf1[_kPos];
                    var y2 = buf1[_kPos + wDst2 * 4];
                    var y3 = yPos < hSrc - 2 ? buf1[_kPos + wDst2 * 8] : 2 * buf1[_kPos + wDst2 * 4] - buf1[_kPos];
                    buf2[buf2Pos + _k] = interpolate(y0, y1, y2, y3, _t);
                  }
                }
              }
              var m = wM * hM;
              if (m > 1) {
                for (var _i2 = 0; _i2 < hDst; _i2++) {
                  for (var _j2 = 0; _j2 < wDst; _j2++) {
                    var r = 0;
                    var g = 0;
                    var b = 0;
                    var a = 0;
                    var realColors = 0;
                    for (var _y = 0; _y < hM; _y++) {
                      var _yPos = _i2 * hM + _y;
                      for (var _x = 0; _x < wM; _x++) {
                        var _xPos = _j2 * wM + _x;
                        var xyPos = (_yPos * wDst2 + _xPos) * 4;
                        var pixelAlpha = buf2[xyPos + 3];
                        if (pixelAlpha) {
                          r += buf2[xyPos];
                          g += buf2[xyPos + 1];
                          b += buf2[xyPos + 2];
                          realColors++;
                        }
                        a += pixelAlpha;
                      }
                    }
                    var pos = (_i2 * wDst + _j2) * 4;
                    bufDst[pos] = realColors ? Math.round(r / realColors) : 0;
                    bufDst[pos + 1] = realColors ? Math.round(g / realColors) : 0;
                    bufDst[pos + 2] = realColors ? Math.round(b / realColors) : 0;
                    bufDst[pos + 3] = Math.round(a / m);
                  }
                }
              } else {
                dst.data = buf2;
              }
            },
            bicubicInterpolation: function bicubicInterpolation(src, dst, options) {
              var interpolateCubic = function interpolateCubic2(x0, x1, x2, x3, t) {
                var a0 = x3 - x2 - x0 + x1;
                var a1 = x0 - x1 - a0;
                var a2 = x2 - x0;
                var a3 = x1;
                return Math.max(0, Math.min(255, a0 * (t * t * t) + a1 * (t * t) + a2 * t + a3));
              };
              return this._interpolate2D(src, dst, options, interpolateCubic);
            },
            hermiteInterpolation: function hermiteInterpolation(src, dst, options) {
              var interpolateHermite = function interpolateHermite2(x0, x1, x2, x3, t) {
                var c0 = x1;
                var c1 = 0.5 * (x2 - x0);
                var c2 = x0 - 2.5 * x1 + 2 * x2 - 0.5 * x3;
                var c3 = 0.5 * (x3 - x0) + 1.5 * (x1 - x2);
                return Math.max(0, Math.min(255, Math.round(((c3 * t + c2) * t + c1) * t + c0)));
              };
              return this._interpolate2D(src, dst, options, interpolateHermite);
            },
            bezierInterpolation: function bezierInterpolation(src, dst, options) {
              var interpolateBezier = function interpolateBezier2(x0, x1, x2, x3, t) {
                var cp1 = x1 + (x2 - x0) / 4;
                var cp2 = x2 - (x3 - x1) / 4;
                var nt = 1 - t;
                var c0 = x1 * nt * nt * nt;
                var c1 = 3 * cp1 * nt * nt * t;
                var c2 = 3 * cp2 * nt * t * t;
                var c3 = x2 * t * t * t;
                return Math.max(0, Math.min(255, Math.round(c0 + c1 + c2 + c3)));
              };
              return this._interpolate2D(src, dst, options, interpolateBezier);
            }
          };
        }).call(this, require2("buffer").Buffer);
      }, { "buffer": 48 }], 224: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3["default"] = void 0;
          var _utils = require2("@jimp/utils");
          function advancedRotate(deg, mode) {
            deg %= 360;
            var rad = deg * Math.PI / 180;
            var cosine = Math.cos(rad);
            var sine = Math.sin(rad);
            var w = this.bitmap.width;
            var h = this.bitmap.height;
            if (mode === true || typeof mode === "string") {
              w = Math.ceil(Math.abs(this.bitmap.width * cosine) + Math.abs(this.bitmap.height * sine)) + 1;
              h = Math.ceil(Math.abs(this.bitmap.width * sine) + Math.abs(this.bitmap.height * cosine)) + 1;
              if (w % 2 !== 0) {
                w++;
              }
              if (h % 2 !== 0) {
                h++;
              }
              var c = this.cloneQuiet();
              this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x2, y2, idx) {
                this.bitmap.data.writeUInt32BE(this._background, idx);
              });
              var max = Math.max(w, h, this.bitmap.width, this.bitmap.height);
              this.resize(max, max, mode);
              this.blit(c, this.bitmap.width / 2 - c.bitmap.width / 2, this.bitmap.height / 2 - c.bitmap.height / 2);
            }
            var bW = this.bitmap.width;
            var bH = this.bitmap.height;
            var dstBuffer = Buffer.alloc(this.bitmap.data.length);
            function createTranslationFunction(deltaX, deltaY) {
              return function(x2, y2) {
                return {
                  x: x2 + deltaX,
                  y: y2 + deltaY
                };
              };
            }
            var translate2Cartesian = createTranslationFunction(-(bW / 2), -(bH / 2));
            var translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5);
            for (var y = 1; y <= bH; y++) {
              for (var x = 1; x <= bW; x++) {
                var cartesian = translate2Cartesian(x, y);
                var source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x);
                var dstIdx = bW * (y - 1) + x - 1 << 2;
                if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {
                  var srcIdx = (bW * (source.y | 0) + source.x | 0) << 2;
                  var pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);
                  dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
                } else {
                  dstBuffer.writeUInt32BE(this._background, dstIdx);
                }
              }
            }
            this.bitmap.data = dstBuffer;
            if (mode === true || typeof mode === "string") {
              var _x = bW / 2 - w / 2;
              var _y = bH / 2 - h / 2;
              this.crop(_x, _y, w, h);
            }
          }
          var _default = function _default2() {
            return {
              /**
               * Rotates the image clockwise by a number of degrees. By default the width and height of the image will be resized appropriately.
               * @param {number} deg the number of degrees to rotate the image by
               * @param {string|boolean} mode (optional) resize mode or a boolean, if false then the width and height of the image will not be changed
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              rotate: function rotate(deg, mode, cb) {
                if (typeof mode === "undefined" || mode === null) {
                  mode = true;
                }
                if (typeof mode === "function" && typeof cb === "undefined") {
                  cb = mode;
                  mode = true;
                }
                if (typeof deg !== "number") {
                  return _utils.throwError.call(this, "deg must be a number", cb);
                }
                if (typeof mode !== "boolean" && typeof mode !== "string") {
                  return _utils.throwError.call(this, "mode must be a boolean or a string", cb);
                }
                advancedRotate.call(this, deg, mode, cb);
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, this);
                }
                return this;
              }
            };
          };
          exports3["default"] = _default;
          module3.exports = exports3.default;
        }).call(this, require2("buffer").Buffer);
      }, { "@jimp/utils": 235, "buffer": 48 }], 225: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _utils = require2("@jimp/utils");
        var _default = function _default2() {
          return {
            /**
             * Uniformly scales the image by a factor.
             * @param {number} f the factor to scale the image by
             * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
             * @param {function(Error, Jimp)} cb (optional) a callback for when complete
             * @returns {Jimp} this for chaining of methods
             */
            scale: function scale(f, mode, cb) {
              if (typeof f !== "number") {
                return _utils.throwError.call(this, "f must be a number", cb);
              }
              if (f < 0) {
                return _utils.throwError.call(this, "f must be a positive number", cb);
              }
              if (typeof mode === "function" && typeof cb === "undefined") {
                cb = mode;
                mode = null;
              }
              var w = this.bitmap.width * f;
              var h = this.bitmap.height * f;
              this.resize(w, h, mode);
              if ((0, _utils.isNodePattern)(cb)) {
                cb.call(this, null, this);
              }
              return this;
            },
            /**
             * Scale the image to the largest size that fits inside the rectangle that has the given width and height.
             * @param {number} w the width to resize the image to
             * @param {number} h the height to resize the image to
             * @param {string} mode (optional) a scaling method (e.g. Jimp.RESIZE_BEZIER)
             * @param {function(Error, Jimp)} cb (optional) a callback for when complete
             * @returns {Jimp} this for chaining of methods
             */
            scaleToFit: function scaleToFit(w, h, mode, cb) {
              if (typeof w !== "number" || typeof h !== "number") {
                return _utils.throwError.call(this, "w and h must be numbers", cb);
              }
              if (typeof mode === "function" && typeof cb === "undefined") {
                cb = mode;
                mode = null;
              }
              var f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;
              this.scale(f, mode);
              if ((0, _utils.isNodePattern)(cb)) {
                cb.call(this, null, this);
              }
              return this;
            }
          };
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@jimp/utils": 235 }], 226: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _utils = require2("@jimp/utils");
        var _default = function _default2() {
          return {
            shadow: function shadow() {
              var _this = this;
              var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              var cb = arguments.length > 1 ? arguments[1] : void 0;
              if (typeof options === "function") {
                cb = options;
                options = {};
              }
              var _options = options, _options$opacity = _options.opacity, opacity = _options$opacity === void 0 ? 0.7 : _options$opacity, _options$size = _options.size, size = _options$size === void 0 ? 1.1 : _options$size, _options$x = _options.x, x = _options$x === void 0 ? -25 : _options$x, _options$y = _options.y, y = _options$y === void 0 ? 25 : _options$y, _options$blur = _options.blur, blur = _options$blur === void 0 ? 5 : _options$blur;
              var orig = this.clone();
              var shadow2 = this.clone();
              shadow2.scan(0, 0, shadow2.bitmap.width, shadow2.bitmap.height, function(x2, y2, idx) {
                shadow2.bitmap.data[idx] = 0;
                shadow2.bitmap.data[idx + 1] = 0;
                shadow2.bitmap.data[idx + 2] = 0;
                shadow2.bitmap.data[idx + 3] = shadow2.constructor.limit255(shadow2.bitmap.data[idx + 3] * opacity);
                _this.bitmap.data[idx] = 0;
                _this.bitmap.data[idx + 1] = 0;
                _this.bitmap.data[idx + 2] = 0;
                _this.bitmap.data[idx + 3] = 0;
              });
              shadow2.resize(shadow2.bitmap.width * size, shadow2.bitmap.height * size).blur(blur);
              this.composite(shadow2, x, y);
              this.composite(orig, 0, 0);
              if ((0, _utils.isNodePattern)(cb)) {
                cb.call(this, null, this);
              }
              return this;
            }
          };
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@jimp/utils": 235 }], 227: [function(require2, module3, exports3) {
        "use strict";
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _utils = require2("@jimp/utils");
        var _default = function _default2() {
          return {
            threshold: function threshold(_ref, cb) {
              var _this = this;
              var max = _ref.max, _ref$replace = _ref.replace, replace = _ref$replace === void 0 ? 255 : _ref$replace, _ref$autoGreyscale = _ref.autoGreyscale, autoGreyscale = _ref$autoGreyscale === void 0 ? true : _ref$autoGreyscale;
              if (typeof max !== "number") {
                return _utils.throwError.call(this, "max must be a number", cb);
              }
              if (typeof replace !== "number") {
                return _utils.throwError.call(this, "replace must be a number", cb);
              }
              if (typeof autoGreyscale !== "boolean") {
                return _utils.throwError.call(this, "autoGreyscale must be a boolean", cb);
              }
              max = this.constructor.limit255(max);
              replace = this.constructor.limit255(replace);
              if (autoGreyscale) {
                this.greyscale();
              }
              this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(x, y, idx) {
                var grey = _this.bitmap.data[idx] < max ? _this.bitmap.data[idx] : replace;
                _this.bitmap.data[idx] = grey;
                _this.bitmap.data[idx + 1] = grey;
                _this.bitmap.data[idx + 2] = grey;
              });
              if ((0, _utils.isNodePattern)(cb)) {
                cb.call(this, null, this);
              }
              return this;
            }
          };
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@jimp/utils": 235 }], 228: [function(require2, module3, exports3) {
        "use strict";
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _toConsumableArray2 = _interopRequireDefault(require2("@babel/runtime/helpers/toConsumableArray"));
        var _timm = require2("timm");
        var _pluginBlit = _interopRequireDefault(require2("@jimp/plugin-blit"));
        var _pluginBlur = _interopRequireDefault(require2("@jimp/plugin-blur"));
        var _pluginCircle = _interopRequireDefault(require2("@jimp/plugin-circle"));
        var _pluginColor = _interopRequireDefault(require2("@jimp/plugin-color"));
        var _pluginContain = _interopRequireDefault(require2("@jimp/plugin-contain"));
        var _pluginCover = _interopRequireDefault(require2("@jimp/plugin-cover"));
        var _pluginCrop = _interopRequireDefault(require2("@jimp/plugin-crop"));
        var _pluginDisplace = _interopRequireDefault(require2("@jimp/plugin-displace"));
        var _pluginDither = _interopRequireDefault(require2("@jimp/plugin-dither"));
        var _pluginFisheye = _interopRequireDefault(require2("@jimp/plugin-fisheye"));
        var _pluginFlip = _interopRequireDefault(require2("@jimp/plugin-flip"));
        var _pluginGaussian = _interopRequireDefault(require2("@jimp/plugin-gaussian"));
        var _pluginInvert = _interopRequireDefault(require2("@jimp/plugin-invert"));
        var _pluginMask = _interopRequireDefault(require2("@jimp/plugin-mask"));
        var _pluginNormalize = _interopRequireDefault(require2("@jimp/plugin-normalize"));
        var _pluginPrint = _interopRequireDefault(require2("@jimp/plugin-print"));
        var _pluginResize = _interopRequireDefault(require2("@jimp/plugin-resize"));
        var _pluginRotate = _interopRequireDefault(require2("@jimp/plugin-rotate"));
        var _pluginScale = _interopRequireDefault(require2("@jimp/plugin-scale"));
        var _pluginShadow = _interopRequireDefault(require2("@jimp/plugin-shadow"));
        var _pluginThreshold = _interopRequireDefault(require2("@jimp/plugin-threshold"));
        var plugins = [_pluginBlit["default"], _pluginBlur["default"], _pluginCircle["default"], _pluginColor["default"], _pluginContain["default"], _pluginCover["default"], _pluginCrop["default"], _pluginDisplace["default"], _pluginDither["default"], _pluginFisheye["default"], _pluginFlip["default"], _pluginGaussian["default"], _pluginInvert["default"], _pluginMask["default"], _pluginNormalize["default"], _pluginPrint["default"], _pluginResize["default"], _pluginRotate["default"], _pluginScale["default"], _pluginShadow["default"], _pluginThreshold["default"]];
        var _default = function _default2(jimpEvChange) {
          var initializedPlugins = plugins.map(function(pluginModule) {
            var plugin = pluginModule(jimpEvChange) || {};
            if (!plugin["class"] && !plugin.constants) {
              plugin = {
                "class": plugin
              };
            }
            return plugin;
          });
          return _timm.mergeDeep.apply(void 0, (0, _toConsumableArray2["default"])(initializedPlugins));
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/helpers/toConsumableArray": 20, "@jimp/plugin-blit": 201, "@jimp/plugin-blur": 203, "@jimp/plugin-circle": 204, "@jimp/plugin-color": 205, "@jimp/plugin-contain": 206, "@jimp/plugin-cover": 207, "@jimp/plugin-crop": 208, "@jimp/plugin-displace": 209, "@jimp/plugin-dither": 210, "@jimp/plugin-fisheye": 211, "@jimp/plugin-flip": 212, "@jimp/plugin-gaussian": 213, "@jimp/plugin-invert": 214, "@jimp/plugin-mask": 215, "@jimp/plugin-normalize": 216, "@jimp/plugin-print": 217, "@jimp/plugin-resize": 221, "@jimp/plugin-rotate": 224, "@jimp/plugin-scale": 225, "@jimp/plugin-shadow": 226, "@jimp/plugin-threshold": 227, "timm": 177 }], 229: [function(require2, module3, exports3) {
        "use strict";
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _defineProperty2 = _interopRequireDefault(require2("@babel/runtime/helpers/defineProperty"));
        var _bmpJs = _interopRequireDefault(require2("bmp-js"));
        var _utils = require2("@jimp/utils");
        var MIME_TYPE = "image/bmp";
        var MIME_TYPE_SECOND = "image/x-ms-bmp";
        function toAGBR(image) {
          return (0, _utils.scan)(image, 0, 0, image.bitmap.width, image.bitmap.height, function(x, y, index) {
            var red = this.bitmap.data[index + 0];
            var green = this.bitmap.data[index + 1];
            var blue = this.bitmap.data[index + 2];
            var alpha = this.bitmap.data[index + 3];
            this.bitmap.data[index + 0] = alpha;
            this.bitmap.data[index + 1] = blue;
            this.bitmap.data[index + 2] = green;
            this.bitmap.data[index + 3] = red;
          }).bitmap;
        }
        function fromAGBR(bitmap) {
          return (0, _utils.scan)({
            bitmap
          }, 0, 0, bitmap.width, bitmap.height, function(x, y, index) {
            var alpha = this.bitmap.data[index + 0];
            var blue = this.bitmap.data[index + 1];
            var green = this.bitmap.data[index + 2];
            var red = this.bitmap.data[index + 3];
            this.bitmap.data[index + 0] = red;
            this.bitmap.data[index + 1] = green;
            this.bitmap.data[index + 2] = blue;
            this.bitmap.data[index + 3] = bitmap.is_with_alpha ? alpha : 255;
          }).bitmap;
        }
        var decode = function decode2(data) {
          return fromAGBR(_bmpJs["default"].decode(data));
        };
        var encode = function encode2(image) {
          return _bmpJs["default"].encode(toAGBR(image)).data;
        };
        var _default = function _default2() {
          var _decoders, _encoders;
          return {
            mime: (0, _defineProperty2["default"])({}, MIME_TYPE, ["bmp"]),
            constants: {
              MIME_BMP: MIME_TYPE,
              MIME_X_MS_BMP: MIME_TYPE_SECOND
            },
            decoders: (_decoders = {}, (0, _defineProperty2["default"])(_decoders, MIME_TYPE, decode), (0, _defineProperty2["default"])(_decoders, MIME_TYPE_SECOND, decode), _decoders),
            encoders: (_encoders = {}, (0, _defineProperty2["default"])(_encoders, MIME_TYPE, encode), (0, _defineProperty2["default"])(_encoders, MIME_TYPE_SECOND, encode), _encoders)
          };
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/utils": 235, "bmp-js": 30 }], 230: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3["default"] = void 0;
          var _defineProperty2 = _interopRequireDefault(require2("@babel/runtime/helpers/defineProperty"));
          var _omggif = _interopRequireDefault(require2("omggif"));
          var _gifwrap = require2("gifwrap");
          var MIME_TYPE = "image/gif";
          var _default = function _default2() {
            return {
              mime: (0, _defineProperty2["default"])({}, MIME_TYPE, ["gif"]),
              constants: {
                MIME_GIF: MIME_TYPE
              },
              decoders: (0, _defineProperty2["default"])({}, MIME_TYPE, function(data) {
                var gifObj = new _omggif["default"].GifReader(data);
                var gifData = Buffer.alloc(gifObj.width * gifObj.height * 4);
                gifObj.decodeAndBlitFrameRGBA(0, gifData);
                return {
                  data: gifData,
                  width: gifObj.width,
                  height: gifObj.height
                };
              }),
              encoders: (0, _defineProperty2["default"])({}, MIME_TYPE, function(data) {
                var bitmap = new _gifwrap.BitmapImage(data.bitmap);
                _gifwrap.GifUtil.quantizeDekker(bitmap, 256);
                var newFrame = new _gifwrap.GifFrame(bitmap);
                var gifCodec = new _gifwrap.GifCodec();
                return gifCodec.encodeGif([newFrame], {}).then(function(newGif) {
                  return newGif.buffer;
                });
              })
            };
          };
          exports3["default"] = _default;
          module3.exports = exports3.default;
        }).call(this, require2("buffer").Buffer);
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, "buffer": 48, "gifwrap": 70, "omggif": 85 }], 231: [function(require2, module3, exports3) {
        "use strict";
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _defineProperty2 = _interopRequireDefault(require2("@babel/runtime/helpers/defineProperty"));
        var _jpegJs = _interopRequireDefault(require2("jpeg-js"));
        var _utils = require2("@jimp/utils");
        var MIME_TYPE = "image/jpeg";
        var _default = function _default2() {
          return {
            mime: (0, _defineProperty2["default"])({}, MIME_TYPE, ["jpeg", "jpg", "jpe"]),
            constants: {
              MIME_JPEG: MIME_TYPE
            },
            decoders: (0, _defineProperty2["default"])({}, MIME_TYPE, _jpegJs["default"].decode),
            encoders: (0, _defineProperty2["default"])({}, MIME_TYPE, function(image) {
              return _jpegJs["default"].encode(image.bitmap, image._quality).data;
            }),
            "class": {
              // The quality to be used when saving JPEG images
              _quality: 100,
              /**
               * Sets the quality of the image when saving as JPEG format (default is 100)
               * @param {number} n The quality to use 0-100
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              quality: function quality(n, cb) {
                if (typeof n !== "number") {
                  return _utils.throwError.call(this, "n must be a number", cb);
                }
                if (n < 0 || n > 100) {
                  return _utils.throwError.call(this, "n must be a number 0 - 100", cb);
                }
                this._quality = Math.round(n);
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, this);
                }
                return this;
              }
            }
          };
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/utils": 235, "jpeg-js": 80 }], 232: [function(require2, module3, exports3) {
        "use strict";
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _defineProperty2 = _interopRequireDefault(require2("@babel/runtime/helpers/defineProperty"));
        var _pngjs = require2("pngjs");
        var _utils = require2("@jimp/utils");
        var MIME_TYPE = "image/png";
        var PNG_FILTER_AUTO = -1;
        var PNG_FILTER_NONE = 0;
        var PNG_FILTER_SUB = 1;
        var PNG_FILTER_UP = 2;
        var PNG_FILTER_AVERAGE = 3;
        var PNG_FILTER_PATH = 4;
        var _default = function _default2() {
          return {
            mime: (0, _defineProperty2["default"])({}, MIME_TYPE, ["png"]),
            constants: {
              MIME_PNG: MIME_TYPE,
              PNG_FILTER_AUTO,
              PNG_FILTER_NONE,
              PNG_FILTER_SUB,
              PNG_FILTER_UP,
              PNG_FILTER_AVERAGE,
              PNG_FILTER_PATH
            },
            hasAlpha: (0, _defineProperty2["default"])({}, MIME_TYPE, true),
            decoders: (0, _defineProperty2["default"])({}, MIME_TYPE, _pngjs.PNG.sync.read),
            encoders: (0, _defineProperty2["default"])({}, MIME_TYPE, function(data) {
              var png = new _pngjs.PNG({
                width: data.bitmap.width,
                height: data.bitmap.height
              });
              png.data = data.bitmap.data;
              return _pngjs.PNG.sync.write(png, {
                width: data.bitmap.width,
                height: data.bitmap.height,
                deflateLevel: data._deflateLevel,
                deflateStrategy: data._deflateStrategy,
                filterType: data._filterType,
                colorType: typeof data._colorType === "number" ? data._colorType : data._rgba ? 6 : 2,
                inputHasAlpha: data._rgba
              });
            }),
            "class": {
              _deflateLevel: 9,
              _deflateStrategy: 3,
              _filterType: PNG_FILTER_AUTO,
              _colorType: null,
              /**
               * Sets the deflate level used when saving as PNG format (default is 9)
               * @param {number} l Deflate level to use 0-9. 0 is no compression. 9 (default) is maximum compression.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              deflateLevel: function deflateLevel(l, cb) {
                if (typeof l !== "number") {
                  return _utils.throwError.call(this, "l must be a number", cb);
                }
                if (l < 0 || l > 9) {
                  return _utils.throwError.call(this, "l must be a number 0 - 9", cb);
                }
                this._deflateLevel = Math.round(l);
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, this);
                }
                return this;
              },
              /**
               * Sets the deflate strategy used when saving as PNG format (default is 3)
               * @param {number} s Deflate strategy to use 0-3.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              deflateStrategy: function deflateStrategy(s, cb) {
                if (typeof s !== "number") {
                  return _utils.throwError.call(this, "s must be a number", cb);
                }
                if (s < 0 || s > 3) {
                  return _utils.throwError.call(this, "s must be a number 0 - 3", cb);
                }
                this._deflateStrategy = Math.round(s);
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, this);
                }
                return this;
              },
              /**
               * Sets the filter type used when saving as PNG format (default is automatic filters)
               * @param {number} f The quality to use -1-4.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              filterType: function filterType(f, cb) {
                if (typeof f !== "number") {
                  return _utils.throwError.call(this, "n must be a number", cb);
                }
                if (f < -1 || f > 4) {
                  return _utils.throwError.call(this, "n must be -1 (auto) or a number 0 - 4", cb);
                }
                this._filterType = Math.round(f);
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, this);
                }
                return this;
              },
              /**
               * Sets the color type used when saving as PNG format
               * @param {number} s color type to use 0, 2, 4, 6.
               * @param {function(Error, Jimp)} cb (optional) a callback for when complete
               * @returns {Jimp} this for chaining of methods
               */
              colorType: function colorType(s, cb) {
                if (typeof s !== "number") {
                  return _utils.throwError.call(this, "s must be a number", cb);
                }
                if (s !== 0 && s !== 2 && s !== 4 && s !== 6) {
                  return _utils.throwError.call(this, "s must be a number 0, 2, 4, 6.", cb);
                }
                this._colorType = Math.round(s);
                if ((0, _utils.isNodePattern)(cb)) {
                  cb.call(this, null, this);
                }
                return this;
              }
            }
          };
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/utils": 235, "pngjs": 129 }], 233: [function(require2, module3, exports3) {
        (function(Buffer) {
          "use strict";
          var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
          Object.defineProperty(exports3, "__esModule", {
            value: true
          });
          exports3["default"] = void 0;
          var _defineProperty2 = _interopRequireDefault(require2("@babel/runtime/helpers/defineProperty"));
          var _utif = _interopRequireDefault(require2("utif"));
          var MIME_TYPE = "image/tiff";
          var _default = function _default2() {
            return {
              mime: (0, _defineProperty2["default"])({}, MIME_TYPE, ["tiff", "tif"]),
              constants: {
                MIME_TIFF: MIME_TYPE
              },
              decoders: (0, _defineProperty2["default"])({}, MIME_TYPE, function(data) {
                var ifds = _utif["default"].decode(data);
                var page = ifds[0];
                _utif["default"].decodeImages(data, ifds);
                var rgba = _utif["default"].toRGBA8(page);
                return {
                  data: Buffer.from(rgba),
                  width: page.t256[0],
                  height: page.t257[0]
                };
              }),
              encoders: (0, _defineProperty2["default"])({}, MIME_TYPE, function(image) {
                var tiff = _utif["default"].encodeImage(image.bitmap.data, image.bitmap.width, image.bitmap.height);
                return Buffer.from(tiff);
              })
            };
          };
          exports3["default"] = _default;
          module3.exports = exports3.default;
        }).call(this, require2("buffer").Buffer);
      }, { "@babel/runtime/helpers/defineProperty": 7, "@babel/runtime/helpers/interopRequireDefault": 11, "buffer": 48, "utif": 182 }], 234: [function(require2, module3, exports3) {
        "use strict";
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3["default"] = void 0;
        var _timm = require2("timm");
        var _jpeg = _interopRequireDefault(require2("@jimp/jpeg"));
        var _png = _interopRequireDefault(require2("@jimp/png"));
        var _bmp = _interopRequireDefault(require2("@jimp/bmp"));
        var _tiff = _interopRequireDefault(require2("@jimp/tiff"));
        var _gif = _interopRequireDefault(require2("@jimp/gif"));
        var _default = function _default2() {
          return (0, _timm.mergeDeep)((0, _jpeg["default"])(), (0, _png["default"])(), (0, _bmp["default"])(), (0, _tiff["default"])(), (0, _gif["default"])());
        };
        exports3["default"] = _default;
        module3.exports = exports3.default;
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@jimp/bmp": 229, "@jimp/gif": 230, "@jimp/jpeg": 231, "@jimp/png": 232, "@jimp/tiff": 233, "timm": 177 }], 235: [function(require2, module3, exports3) {
        "use strict";
        var _interopRequireDefault = require2("@babel/runtime/helpers/interopRequireDefault");
        Object.defineProperty(exports3, "__esModule", {
          value: true
        });
        exports3.isNodePattern = isNodePattern;
        exports3.throwError = throwError;
        exports3.scan = scan;
        exports3.scanIterator = scanIterator;
        var _regenerator = _interopRequireDefault(require2("@babel/runtime/regenerator"));
        var _marked = _regenerator["default"].mark(scanIterator);
        function isNodePattern(cb) {
          if (typeof cb === "undefined") {
            return false;
          }
          if (typeof cb !== "function") {
            throw new TypeError("Callback must be a function");
          }
          return true;
        }
        function throwError(error, cb) {
          if (typeof error === "string") {
            error = new Error(error);
          }
          if (typeof cb === "function") {
            return cb.call(this, error);
          }
          throw error;
        }
        function scan(image, x, y, w, h, f) {
          x = Math.round(x);
          y = Math.round(y);
          w = Math.round(w);
          h = Math.round(h);
          for (var _y = y; _y < y + h; _y++) {
            for (var _x = x; _x < x + w; _x++) {
              var idx = image.bitmap.width * _y + _x << 2;
              f.call(image, _x, _y, idx);
            }
          }
          return image;
        }
        function scanIterator(image, x, y, w, h) {
          var _y, _x, idx;
          return _regenerator["default"].wrap(function scanIterator$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  x = Math.round(x);
                  y = Math.round(y);
                  w = Math.round(w);
                  h = Math.round(h);
                  _y = y;
                case 5:
                  if (!(_y < y + h)) {
                    _context.next = 17;
                    break;
                  }
                  _x = x;
                case 7:
                  if (!(_x < x + w)) {
                    _context.next = 14;
                    break;
                  }
                  idx = image.bitmap.width * _y + _x << 2;
                  _context.next = 11;
                  return {
                    x: _x,
                    y: _y,
                    idx,
                    image
                  };
                case 11:
                  _x++;
                  _context.next = 7;
                  break;
                case 14:
                  _y++;
                  _context.next = 5;
                  break;
                case 17:
                case "end":
                  return _context.stop();
              }
            }
          }, _marked);
        }
      }, { "@babel/runtime/helpers/interopRequireDefault": 11, "@babel/runtime/regenerator": 22 }] }, {}, [200])(200);
    });
  }
});

// node_modules/potrace/lib/types/Point.js
var require_Point = __commonJS({
  "node_modules/potrace/lib/types/Point.js"(exports, module) {
    "use strict";
    function Point(x, y) {
      this.x = x || 0;
      this.y = y || 0;
    }
    Point.prototype = {
      copy: function() {
        return new Point(this.x, this.y);
      }
    };
    module.exports = Point;
  }
});

// node_modules/potrace/lib/utils.js
var require_utils = __commonJS({
  "node_modules/potrace/lib/utils.js"(exports, module) {
    "use strict";
    var Point = require_Point();
    var attrRegexps = {};
    function getAttrRegexp(attrName) {
      if (attrRegexps[attrName]) {
        return attrRegexps[attrName];
      }
      attrRegexps[attrName] = new RegExp(" " + attrName + '="((?:\\\\(?=")"|[^"])+)"', "i");
      return attrRegexps[attrName];
    }
    function setHtmlAttribute(html, attrName, value) {
      var attr = " " + attrName + '="' + value + '"';
      if (html.indexOf(" " + attrName + '="') === -1) {
        html = html.replace(/<[a-z]+/i, function(beginning) {
          return beginning + attr;
        });
      } else {
        html = html.replace(getAttrRegexp(attrName), attr);
      }
      return html;
    }
    function fixed(number) {
      return number.toFixed(3).replace(".000", "");
    }
    function mod(a, n) {
      return a >= n ? a % n : a >= 0 ? a : n - 1 - (-1 - a) % n;
    }
    function xprod(p1, p2) {
      return p1.x * p2.y - p1.y * p2.x;
    }
    function cyclic(a, b, c) {
      if (a <= c) {
        return a <= b && b < c;
      } else {
        return a <= b || b < c;
      }
    }
    function sign(i) {
      return i > 0 ? 1 : i < 0 ? -1 : 0;
    }
    function quadform(Q, w) {
      var v = new Array(3), i, j, sum;
      v[0] = w.x;
      v[1] = w.y;
      v[2] = 1;
      sum = 0;
      for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
          sum += v[i] * Q.at(i, j) * v[j];
        }
      }
      return sum;
    }
    function interval(lambda, a, b) {
      var res = new Point();
      res.x = a.x + lambda * (b.x - a.x);
      res.y = a.y + lambda * (b.y - a.y);
      return res;
    }
    function dorth_infty(p0, p2) {
      var r = new Point();
      r.y = sign(p2.x - p0.x);
      r.x = -sign(p2.y - p0.y);
      return r;
    }
    function ddenom(p0, p2) {
      var r = dorth_infty(p0, p2);
      return r.y * (p2.x - p0.x) - r.x * (p2.y - p0.y);
    }
    function dpara(p0, p1, p2) {
      var x1, y1, x2, y2;
      x1 = p1.x - p0.x;
      y1 = p1.y - p0.y;
      x2 = p2.x - p0.x;
      y2 = p2.y - p0.y;
      return x1 * y2 - x2 * y1;
    }
    function cprod(p0, p1, p2, p3) {
      var x1, y1, x2, y2;
      x1 = p1.x - p0.x;
      y1 = p1.y - p0.y;
      x2 = p3.x - p2.x;
      y2 = p3.y - p2.y;
      return x1 * y2 - x2 * y1;
    }
    function iprod(p0, p1, p2) {
      var x1, y1, x2, y2;
      x1 = p1.x - p0.x;
      y1 = p1.y - p0.y;
      x2 = p2.x - p0.x;
      y2 = p2.y - p0.y;
      return x1 * x2 + y1 * y2;
    }
    function iprod1(p0, p1, p2, p3) {
      var x1, y1, x2, y2;
      x1 = p1.x - p0.x;
      y1 = p1.y - p0.y;
      x2 = p3.x - p2.x;
      y2 = p3.y - p2.y;
      return x1 * x2 + y1 * y2;
    }
    function ddist(p, q) {
      return Math.sqrt((p.x - q.x) * (p.x - q.x) + (p.y - q.y) * (p.y - q.y));
    }
    module.exports = {
      luminance: function(r, g, b) {
        return Math.round(0.2126 * r + 0.7153 * g + 0.0721 * b);
      },
      between: function(val, min, max) {
        return val >= min && val <= max;
      },
      clamp: function(val, min, max) {
        return Math.min(max, Math.max(min, val));
      },
      isNumber: function(val) {
        return typeof val === "number";
      },
      setHtmlAttr: setHtmlAttribute,
      /**
       * Generates path instructions for given curve
       *
       * @param {Curve} curve
       * @param {Number} [scale]
       * @returns {string}
       */
      renderCurve: function(curve, scale) {
        scale = scale || { x: 1, y: 1 };
        var startingPoint = curve.c[(curve.n - 1) * 3 + 2];
        var path = [
          "M " + fixed(startingPoint.x * scale.x) + " " + fixed(startingPoint.y * scale.y)
        ];
        curve.tag.forEach(function(tag, i) {
          var i3 = i * 3;
          var p0 = curve.c[i3];
          var p1 = curve.c[i3 + 1];
          var p2 = curve.c[i3 + 2];
          if (tag === "CURVE") {
            path.push(
              "C " + fixed(p0.x * scale.x) + " " + fixed(p0.y * scale.y) + ", " + fixed(p1.x * scale.x) + " " + fixed(p1.y * scale.y) + ", " + fixed(p2.x * scale.x) + " " + fixed(p2.y * scale.y)
            );
          } else if (tag === "CORNER") {
            path.push(
              "L " + fixed(p1.x * scale.x) + " " + fixed(p1.y * scale.y) + " " + fixed(p2.x * scale.x) + " " + fixed(p2.y * scale.y)
            );
          }
        });
        return path.join(" ");
      },
      bezier: function bezier(t, p0, p1, p2, p3) {
        var s = 1 - t, res = new Point();
        res.x = s * s * s * p0.x + 3 * (s * s * t) * p1.x + 3 * (t * t * s) * p2.x + t * t * t * p3.x;
        res.y = s * s * s * p0.y + 3 * (s * s * t) * p1.y + 3 * (t * t * s) * p2.y + t * t * t * p3.y;
        return res;
      },
      tangent: function tangent(p0, p1, p2, p3, q0, q1) {
        var A, B, C, a, b, c, d, s, r1, r2;
        A = cprod(p0, p1, q0, q1);
        B = cprod(p1, p2, q0, q1);
        C = cprod(p2, p3, q0, q1);
        a = A - 2 * B + C;
        b = -2 * A + 2 * B;
        c = A;
        d = b * b - 4 * a * c;
        if (a === 0 || d < 0) {
          return -1;
        }
        s = Math.sqrt(d);
        r1 = (-b + s) / (2 * a);
        r2 = (-b - s) / (2 * a);
        if (r1 >= 0 && r1 <= 1) {
          return r1;
        } else if (r2 >= 0 && r2 <= 1) {
          return r2;
        } else {
          return -1;
        }
      },
      mod,
      xprod,
      cyclic,
      sign,
      quadform,
      interval,
      dorth_infty,
      ddenom,
      dpara,
      cprod,
      iprod,
      iprod1,
      ddist
    };
  }
});

// node_modules/potrace/lib/types/Histogram.js
var require_Histogram = __commonJS({
  "node_modules/potrace/lib/types/Histogram.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var Jimp = null;
    try {
      Jimp = require_jimp();
    } catch (e) {
    }
    var Bitmap = require_Bitmap();
    var COLOR_DEPTH = 256;
    var COLOR_RANGE_END = COLOR_DEPTH - 1;
    function index(x, y) {
      return COLOR_DEPTH * x + y;
    }
    function normalizeMinMax(levelMin, levelMax) {
      levelMin = typeof levelMin === "number" ? utils.clamp(Math.round(levelMin), 0, COLOR_RANGE_END) : 0;
      levelMax = typeof levelMax === "number" ? utils.clamp(Math.round(levelMax), 0, COLOR_RANGE_END) : COLOR_RANGE_END;
      if (levelMin > levelMax) {
        throw new Error('Invalid range "' + levelMin + "..." + levelMax + '"');
      }
      return [levelMin, levelMax];
    }
    function Histogram(imageSource, mode) {
      this.data = null;
      this.pixels = 0;
      this._sortedIndexes = null;
      this._cachedStats = {};
      this._lookupTableH = null;
      if (typeof imageSource === "number") {
        this._createArray(imageSource);
      } else if (imageSource instanceof Bitmap) {
        this._collectValuesBitmap(imageSource);
      } else if (Jimp && imageSource instanceof Jimp) {
        this._collectValuesJimp(imageSource, mode);
      } else {
        throw new Error("Unsupported image source");
      }
    }
    Histogram.MODE_LUMINANCE = "luminance";
    Histogram.MODE_R = "r";
    Histogram.MODE_G = "g";
    Histogram.MODE_B = "b";
    Histogram.prototype = {
      /**
       * Initializes data array for an image of given pixel size
       * @param imageSize
       * @returns {Uint8Array|Uint16Array|Uint32Array}
       * @private
       */
      _createArray: function(imageSize) {
        var ArrayType = imageSize <= Math.pow(2, 8) ? Uint8Array : imageSize <= Math.pow(2, 16) ? Uint16Array : Uint32Array;
        this.pixels = imageSize;
        return this.data = new ArrayType(COLOR_DEPTH);
      },
      /**
       * Aggregates color data from {@link Jimp} instance
       * @param {Jimp} source
       * @param mode
       * @private
       */
      _collectValuesJimp: function(source, mode) {
        var pixelData = source.bitmap.data;
        var data = this._createArray(source.bitmap.width * source.bitmap.height);
        source.scan(0, 0, source.bitmap.width, source.bitmap.height, function(x, y, idx) {
          var val = mode === Histogram.MODE_R ? pixelData[idx] : mode === Histogram.MODE_G ? pixelData[idx + 1] : mode === Histogram.MODE_B ? pixelData[idx + 2] : utils.luminance(pixelData[idx], pixelData[idx + 1], pixelData[idx + 2]);
          data[val]++;
        });
      },
      /**
       * Aggregates color data from {@link Bitmap} instance
       * @param {Bitmap} source
       * @private
       */
      _collectValuesBitmap: function(source) {
        var data = this._createArray(source.size);
        var len = source.data.length;
        var color;
        for (var i = 0; i < len; i++) {
          color = source.data[i];
          data[color]++;
        }
      },
      /**
       * Returns array of color indexes in ascending order
       * @param refresh
       * @returns {*}
       * @private
       */
      _getSortedIndexes: function(refresh) {
        if (!refresh && this._sortedIndexes) {
          return this._sortedIndexes;
        }
        var data = this.data;
        var indexes = new Array(COLOR_DEPTH);
        var i = 0;
        for (i; i < COLOR_DEPTH; i++) {
          indexes[i] = i;
        }
        indexes.sort(function(a, b) {
          return data[a] > data[b] ? 1 : data[a] < data[b] ? -1 : 0;
        });
        this._sortedIndexes = indexes;
        return indexes;
      },
      /**
       * Builds lookup table H from lookup tables P and S.
       * see {@link http://www.iis.sinica.edu.tw/page/jise/2001/200109_01.pdf|this paper} for more details
       *
       * @returns {Float64Array}
       * @private
       */
      _thresholdingBuildLookupTable: function() {
        var P = new Float64Array(COLOR_DEPTH * COLOR_DEPTH);
        var S = new Float64Array(COLOR_DEPTH * COLOR_DEPTH);
        var H = new Float64Array(COLOR_DEPTH * COLOR_DEPTH);
        var pixelsTotal = this.pixels;
        var i, j, idx, tmp;
        for (i = 1; i < COLOR_DEPTH; ++i) {
          idx = index(i, i);
          tmp = this.data[i] / pixelsTotal;
          P[idx] = tmp;
          S[idx] = i * tmp;
        }
        for (i = 1; i < COLOR_DEPTH - 1; ++i) {
          tmp = this.data[i + 1] / pixelsTotal;
          idx = index(1, i);
          P[idx + 1] = P[idx] + tmp;
          S[idx + 1] = S[idx] + (i + 1) * tmp;
        }
        for (i = 2; i < COLOR_DEPTH; i++) {
          for (j = i + 1; j < COLOR_DEPTH; j++) {
            P[index(i, j)] = P[index(1, j)] - P[index(1, i - 1)];
            S[index(i, j)] = S[index(1, j)] - S[index(1, i - 1)];
          }
        }
        for (i = 1; i < COLOR_DEPTH; ++i) {
          for (j = i + 1; j < COLOR_DEPTH; j++) {
            idx = index(i, j);
            H[idx] = P[idx] !== 0 ? S[idx] * S[idx] / P[idx] : 0;
          }
        }
        return this._lookupTableH = H;
      },
      /**
       * Implements Algorithm For Multilevel Thresholding
       * Receives desired number of color stops, returns array of said size. Could be limited to a range levelMin..levelMax
       *
       * Regardless of levelMin and levelMax values it still relies on between class variances for the entire histogram
       *
       * @param amount - how many thresholds should be calculated
       * @param [levelMin=0] - histogram segment start
       * @param [levelMax=255] - histogram segment end
       * @returns {number[]}
      */
      multilevelThresholding: function(amount, levelMin, levelMax) {
        levelMin = normalizeMinMax(levelMin, levelMax);
        levelMax = levelMin[1];
        levelMin = levelMin[0];
        amount = Math.min(levelMax - levelMin - 2, ~~amount);
        if (amount < 1) {
          return [];
        }
        if (!this._lookupTableH) {
          this._thresholdingBuildLookupTable();
        }
        var H = this._lookupTableH;
        var colorStops = null;
        var maxSig = 0;
        if (amount > 4) {
          console.log("[Warning]: Threshold computation for more than 5 levels may take a long time");
        }
        function iterateRecursive(startingPoint, prevVariance, indexes, previousDepth) {
          startingPoint = (startingPoint || 0) + 1;
          prevVariance = prevVariance || 0;
          indexes = indexes || new Array(amount);
          previousDepth = previousDepth || 0;
          var depth = previousDepth + 1;
          var variance;
          for (var i = startingPoint; i < levelMax - amount + previousDepth; i++) {
            variance = prevVariance + H[index(startingPoint, i)];
            indexes[depth - 1] = i;
            if (depth + 1 < amount + 1) {
              iterateRecursive(i, variance, indexes, depth);
            } else {
              variance += H[index(i + 1, levelMax)];
              if (maxSig < variance) {
                maxSig = variance;
                colorStops = indexes.slice();
              }
            }
          }
        }
        iterateRecursive(levelMin || 0);
        return colorStops ? colorStops : [];
      },
      /**
       * Automatically finds threshold value using Algorithm For Multilevel Thresholding
       *
       * @param {number} [levelMin]
       * @param {number} [levelMax]
       * @returns {null|number}
       */
      autoThreshold: function(levelMin, levelMax) {
        var value = this.multilevelThresholding(1, levelMin, levelMax);
        return value.length ? value[0] : null;
      },
      /**
       * Returns dominant color in given range. Returns -1 if not a single color from the range present on the image
       *
       * @param [levelMin=0]
       * @param [levelMax=255]
       * @param [tolerance=1]
       * @returns {number}
       */
      getDominantColor: function(levelMin, levelMax, tolerance) {
        levelMin = normalizeMinMax(levelMin, levelMax);
        levelMax = levelMin[1];
        levelMin = levelMin[0];
        tolerance = tolerance || 1;
        var colors = this.data, dominantIndex = -1, dominantValue = -1, i, j, tmp;
        if (levelMin === levelMax) {
          return colors[levelMin] ? levelMin : -1;
        }
        for (i = levelMin; i <= levelMax; i++) {
          tmp = 0;
          for (j = ~~(tolerance / -2); j < tolerance; j++) {
            tmp += utils.between(i + j, 0, COLOR_RANGE_END) ? colors[i + j] : 0;
          }
          var summIsBigger = tmp > dominantValue;
          var summEqualButMainColorIsBigger = dominantValue === tmp && (dominantIndex < 0 || colors[i] > colors[dominantIndex]);
          if (summIsBigger || summEqualButMainColorIsBigger) {
            dominantIndex = i;
            dominantValue = tmp;
          }
        }
        return dominantValue <= 0 ? -1 : dominantIndex;
      },
      /**
       * Returns stats for histogram or its segment.
       *
       * Returned object contains median, mean and standard deviation for pixel values;
       * peak, mean and median number of pixels per level and few other values
       *
       * If no pixels colors from specified range present on the image - most values will be NaN
       *
       * @param {Number} [levelMin=0] - histogram segment start
       * @param {Number} [levelMax=255] - histogram segment end
       * @param {Boolean} [refresh=false] - if cached result can be returned
       * @returns {{levels: {mean: (number|*), median: *, stdDev: number, unique: number}, pixelsPerLevel: {mean: (number|*), median: (number|*), peak: number}, pixels: number}}
       */
      getStats: function(levelMin, levelMax, refresh) {
        levelMin = normalizeMinMax(levelMin, levelMax);
        levelMax = levelMin[1];
        levelMin = levelMin[0];
        if (!refresh && this._cachedStats[levelMin + "-" + levelMax]) {
          return this._cachedStats[levelMin + "-" + levelMax];
        }
        var data = this.data;
        var sortedIndexes = this._getSortedIndexes();
        var pixelsTotal = 0;
        var medianValue = null;
        var meanValue;
        var medianPixelIndex;
        var pixelsPerLevelMean;
        var pixelsPerLevelMedian;
        var tmpSumOfDeviations = 0;
        var tmpPixelsIterated = 0;
        var allPixelValuesCombined = 0;
        var i, tmpPixels, tmpPixelValue;
        var uniqueValues = 0;
        var mostPixelsPerLevel = 0;
        for (i = levelMin; i <= levelMax; i++) {
          pixelsTotal += data[i];
          allPixelValuesCombined += data[i] * i;
          uniqueValues += data[i] === 0 ? 0 : 1;
          if (mostPixelsPerLevel < data[i]) {
            mostPixelsPerLevel = data[i];
          }
        }
        meanValue = allPixelValuesCombined / pixelsTotal;
        pixelsPerLevelMean = pixelsTotal / (levelMax - levelMin);
        pixelsPerLevelMedian = pixelsTotal / uniqueValues;
        medianPixelIndex = Math.floor(pixelsTotal / 2);
        for (i = 0; i < COLOR_DEPTH; i++) {
          tmpPixelValue = sortedIndexes[i];
          tmpPixels = data[tmpPixelValue];
          if (tmpPixelValue < levelMin || tmpPixelValue > levelMax) {
            continue;
          }
          tmpPixelsIterated += tmpPixels;
          tmpSumOfDeviations += Math.pow(tmpPixelValue - meanValue, 2) * tmpPixels;
          if (medianValue === null && tmpPixelsIterated >= medianPixelIndex) {
            medianValue = tmpPixelValue;
          }
        }
        return this._cachedStats[levelMin + "-" + levelMax] = {
          // various pixel counts for levels (0..255)
          levels: {
            mean: meanValue,
            median: medianValue,
            stdDev: Math.sqrt(tmpSumOfDeviations / pixelsTotal),
            unique: uniqueValues
          },
          // what's visually represented as bars
          pixelsPerLevel: {
            mean: pixelsPerLevelMean,
            median: pixelsPerLevelMedian,
            peak: mostPixelsPerLevel
          },
          pixels: pixelsTotal
        };
      }
    };
    module.exports = Histogram;
  }
});

// node_modules/potrace/lib/types/Bitmap.js
var require_Bitmap = __commonJS({
  "node_modules/potrace/lib/types/Bitmap.js"(exports, module) {
    "use strict";
    var Point = require_Point();
    var utils = require_utils();
    var Histogram;
    function Bitmap(w, h) {
      this._histogram = null;
      this.width = w;
      this.height = h;
      this.size = w * h;
      this.arrayBuffer = new ArrayBuffer(this.size);
      this.data = new Uint8Array(this.arrayBuffer);
    }
    module.exports = Bitmap;
    Histogram = require_Histogram();
    Bitmap.prototype = {
      /**
       * Returns pixel value
       *
       * @param {Number|Point} x - index, point or x
       * @param {Number} [y]
       */
      getValueAt: function(x, y) {
        var index = typeof x === "number" && typeof y !== "number" ? x : this.pointToIndex(x, y);
        return this.data[index];
      },
      /**
       * Converts {@link Point} to index value
       *
       * @param {Number} index
       * @returns {Point}
       */
      indexToPoint: function(index) {
        var point = new Point();
        if (utils.between(index, 0, this.size)) {
          point.y = Math.floor(index / this.width);
          point.x = index - point.y * this.width;
        } else {
          point.x = -1;
          point.y = -1;
        }
        return point;
      },
      /**
       * Calculates index for point or coordinate pair
       *
       * @param {Number|Point} pointOrX
       * @param {Number} [y]
       * @returns {Number}
       */
      pointToIndex: function(pointOrX, y) {
        var _x = pointOrX, _y = y;
        if (pointOrX instanceof Point) {
          _x = pointOrX.x;
          _y = pointOrX.y;
        }
        if (!utils.between(_x, 0, this.width) || !utils.between(_y, 0, this.height)) {
          return -1;
        }
        return this.width * _y + _x;
      },
      /**
       * Makes a copy of current bitmap
       *
       * @param {Function} [iterator] optional callback, used for processing pixel value. Accepted arguments: value, index
       * @returns {Bitmap}
       */
      copy: function(iterator) {
        var bm = new Bitmap(this.width, this.height), iteratorPresent = typeof iterator === "function", i;
        for (i = 0; i < this.size; i++) {
          bm.data[i] = iteratorPresent ? iterator(this.data[i], i) : this.data[i];
        }
        return bm;
      },
      histogram: function() {
        var Histogram2 = require_Histogram();
        if (this._histogram) {
          return this._histogram;
        }
        this._histogram = new Histogram2(this);
        return this._histogram;
      }
    };
  }
});

// node_modules/potrace/lib/types/Curve.js
var require_Curve = __commonJS({
  "node_modules/potrace/lib/types/Curve.js"(exports, module) {
    "use strict";
    function Curve(n) {
      this.n = n;
      this.tag = new Array(n);
      this.c = new Array(n * 3);
      this.alphaCurve = 0;
      this.vertex = new Array(n);
      this.alpha = new Array(n);
      this.alpha0 = new Array(n);
      this.beta = new Array(n);
    }
    module.exports = Curve;
  }
});

// node_modules/potrace/lib/types/Path.js
var require_Path = __commonJS({
  "node_modules/potrace/lib/types/Path.js"(exports, module) {
    "use strict";
    function Path() {
      this.area = 0;
      this.len = 0;
      this.curve = {};
      this.pt = [];
      this.minX = 1e5;
      this.minY = 1e5;
      this.maxX = -1;
      this.maxY = -1;
    }
    module.exports = Path;
  }
});

// node_modules/potrace/lib/types/Quad.js
var require_Quad = __commonJS({
  "node_modules/potrace/lib/types/Quad.js"(exports, module) {
    "use strict";
    function Quad() {
      this.data = [0, 0, 0, 0, 0, 0, 0, 0, 0];
    }
    Quad.prototype.at = function(x, y) {
      return this.data[x * 3 + y];
    };
    module.exports = Quad;
  }
});

// node_modules/potrace/lib/types/Sum.js
var require_Sum = __commonJS({
  "node_modules/potrace/lib/types/Sum.js"(exports, module) {
    "use strict";
    function Sum(x, y, xy, x2, y2) {
      this.x = x;
      this.y = y;
      this.xy = xy;
      this.x2 = x2;
      this.y2 = y2;
    }
    module.exports = Sum;
  }
});

// node_modules/potrace/lib/types/Opti.js
var require_Opti = __commonJS({
  "node_modules/potrace/lib/types/Opti.js"(exports, module) {
    "use strict";
    var Point = require_Point();
    function Opti() {
      this.pen = 0;
      this.c = [new Point(), new Point()];
      this.t = 0;
      this.s = 0;
      this.alpha = 0;
    }
    module.exports = Opti;
  }
});

// node_modules/potrace/lib/Potrace.js
var require_Potrace = __commonJS({
  "node_modules/potrace/lib/Potrace.js"(exports, module) {
    "use strict";
    var Jimp = require_jimp();
    var Bitmap = require_Bitmap();
    var Curve = require_Curve();
    var Point = require_Point();
    var Path = require_Path();
    var Quad = require_Quad();
    var Sum = require_Sum();
    var Opti = require_Opti();
    var utils = require_utils();
    function Potrace(options) {
      this._luminanceData = null;
      this._pathlist = [];
      this._imageLoadingIdentifier = null;
      this._imageLoaded = false;
      this._processed = false;
      this._params = {
        turnPolicy: Potrace.TURNPOLICY_MINORITY,
        turdSize: 2,
        alphaMax: 1,
        optCurve: true,
        optTolerance: 0.2,
        threshold: Potrace.THRESHOLD_AUTO,
        blackOnWhite: true,
        color: Potrace.COLOR_AUTO,
        background: Potrace.COLOR_TRANSPARENT,
        width: null,
        height: null
      };
      if (options) {
        this.setParameters(options);
      }
    }
    Potrace.COLOR_AUTO = "auto";
    Potrace.COLOR_TRANSPARENT = "transparent";
    Potrace.THRESHOLD_AUTO = -1;
    Potrace.TURNPOLICY_BLACK = "black";
    Potrace.TURNPOLICY_WHITE = "white";
    Potrace.TURNPOLICY_LEFT = "left";
    Potrace.TURNPOLICY_RIGHT = "right";
    Potrace.TURNPOLICY_MINORITY = "minority";
    Potrace.TURNPOLICY_MAJORITY = "majority";
    var SUPPORTED_TURNPOLICY_VALUES = [
      Potrace.TURNPOLICY_BLACK,
      Potrace.TURNPOLICY_WHITE,
      Potrace.TURNPOLICY_LEFT,
      Potrace.TURNPOLICY_RIGHT,
      Potrace.TURNPOLICY_MINORITY,
      Potrace.TURNPOLICY_MAJORITY
    ];
    Potrace.prototype = {
      /**
       * Creating a new {@link Path} for every group of black pixels.
       * @private
       */
      _bmToPathlist: function() {
        var self2 = this, threshold = this._params.threshold, blackOnWhite = this._params.blackOnWhite, blackMap, currentPoint = new Point(0, 0), path;
        if (threshold === Potrace.THRESHOLD_AUTO) {
          threshold = this._luminanceData.histogram().autoThreshold() || 128;
        }
        blackMap = this._luminanceData.copy(function(lum) {
          var pastTheThreshold = blackOnWhite ? lum > threshold : lum < threshold;
          return pastTheThreshold ? 0 : 1;
        });
        function findNext(point) {
          var i = blackMap.pointToIndex(point);
          while (i < blackMap.size && blackMap.data[i] !== 1) {
            i++;
          }
          return i < blackMap.size && blackMap.indexToPoint(i);
        }
        function majority(x, y) {
          var i, a, ct;
          for (i = 2; i < 5; i++) {
            ct = 0;
            for (a = -i + 1; a <= i - 1; a++) {
              ct += blackMap.getValueAt(x + a, y + i - 1) ? 1 : -1;
              ct += blackMap.getValueAt(x + i - 1, y + a - 1) ? 1 : -1;
              ct += blackMap.getValueAt(x + a - 1, y - i) ? 1 : -1;
              ct += blackMap.getValueAt(x - i, y + a) ? 1 : -1;
            }
            if (ct > 0) {
              return 1;
            } else if (ct < 0) {
              return 0;
            }
          }
          return 0;
        }
        function findPath(point) {
          var path2 = new Path(), x = point.x, y = point.y, dirx = 0, diry = 1, tmp;
          path2.sign = blackMap.getValueAt(point.x, point.y) ? "+" : "-";
          while (1) {
            path2.pt.push(new Point(x, y));
            if (x > path2.maxX)
              path2.maxX = x;
            if (x < path2.minX)
              path2.minX = x;
            if (y > path2.maxY)
              path2.maxY = y;
            if (y < path2.minY)
              path2.minY = y;
            path2.len++;
            x += dirx;
            y += diry;
            path2.area -= x * diry;
            if (x === point.x && y === point.y)
              break;
            var l = blackMap.getValueAt(x + (dirx + diry - 1) / 2, y + (diry - dirx - 1) / 2);
            var r = blackMap.getValueAt(x + (dirx - diry - 1) / 2, y + (diry + dirx - 1) / 2);
            if (r && !l) {
              if (self2._params.turnPolicy === "right" || self2._params.turnPolicy === "black" && path2.sign === "+" || self2._params.turnPolicy === "white" && path2.sign === "-" || self2._params.turnPolicy === "majority" && majority(x, y) || self2._params.turnPolicy === "minority" && !majority(x, y)) {
                tmp = dirx;
                dirx = -diry;
                diry = tmp;
              } else {
                tmp = dirx;
                dirx = diry;
                diry = -tmp;
              }
            } else if (r) {
              tmp = dirx;
              dirx = -diry;
              diry = tmp;
            } else if (!l) {
              tmp = dirx;
              dirx = diry;
              diry = -tmp;
            }
          }
          return path2;
        }
        function xorPath(path2) {
          var y1 = path2.pt[0].y, len = path2.len, x, y, maxX, minY, i, j, indx;
          for (i = 1; i < len; i++) {
            x = path2.pt[i].x;
            y = path2.pt[i].y;
            if (y !== y1) {
              minY = y1 < y ? y1 : y;
              maxX = path2.maxX;
              for (j = x; j < maxX; j++) {
                indx = blackMap.pointToIndex(j, minY);
                blackMap.data[indx] = blackMap.data[indx] ? 0 : 1;
              }
              y1 = y;
            }
          }
        }
        this._pathlist = [];
        while (currentPoint = findNext(currentPoint)) {
          path = findPath(currentPoint);
          xorPath(path);
          if (path.area > self2._params.turdSize) {
            this._pathlist.push(path);
          }
        }
      },
      /**
       * Processes path list created by _bmToPathlist method creating and optimizing {@link Curve}'s
       * @private
       */
      _processPath: function() {
        var self2 = this;
        function calcSums(path2) {
          var i2, x, y;
          path2.x0 = path2.pt[0].x;
          path2.y0 = path2.pt[0].y;
          path2.sums = [];
          var s = path2.sums;
          s.push(new Sum(0, 0, 0, 0, 0));
          for (i2 = 0; i2 < path2.len; i2++) {
            x = path2.pt[i2].x - path2.x0;
            y = path2.pt[i2].y - path2.y0;
            s.push(new Sum(
              s[i2].x + x,
              s[i2].y + y,
              s[i2].xy + x * y,
              s[i2].x2 + x * x,
              s[i2].y2 + y * y
            ));
          }
        }
        function calcLon(path2) {
          var n = path2.len, pt = path2.pt, dir, pivk = new Array(n), nc = new Array(n), ct = new Array(4);
          path2.lon = new Array(n);
          var constraint = [new Point(), new Point()], cur = new Point(), off = new Point(), dk = new Point(), foundk;
          var i2, j, k1, a, b, c, d, k = 0;
          for (i2 = n - 1; i2 >= 0; i2--) {
            if (pt[i2].x != pt[k].x && pt[i2].y != pt[k].y) {
              k = i2 + 1;
            }
            nc[i2] = k;
          }
          for (i2 = n - 1; i2 >= 0; i2--) {
            ct[0] = ct[1] = ct[2] = ct[3] = 0;
            dir = (3 + 3 * (pt[utils.mod(i2 + 1, n)].x - pt[i2].x) + (pt[utils.mod(i2 + 1, n)].y - pt[i2].y)) / 2;
            ct[dir]++;
            constraint[0].x = 0;
            constraint[0].y = 0;
            constraint[1].x = 0;
            constraint[1].y = 0;
            k = nc[i2];
            k1 = i2;
            while (1) {
              foundk = 0;
              dir = (3 + 3 * utils.sign(pt[k].x - pt[k1].x) + utils.sign(pt[k].y - pt[k1].y)) / 2;
              ct[dir]++;
              if (ct[0] && ct[1] && ct[2] && ct[3]) {
                pivk[i2] = k1;
                foundk = 1;
                break;
              }
              cur.x = pt[k].x - pt[i2].x;
              cur.y = pt[k].y - pt[i2].y;
              if (utils.xprod(constraint[0], cur) < 0 || utils.xprod(constraint[1], cur) > 0) {
                break;
              }
              if (Math.abs(cur.x) <= 1 && Math.abs(cur.y) <= 1) {
              } else {
                off.x = cur.x + (cur.y >= 0 && (cur.y > 0 || cur.x < 0) ? 1 : -1);
                off.y = cur.y + (cur.x <= 0 && (cur.x < 0 || cur.y < 0) ? 1 : -1);
                if (utils.xprod(constraint[0], off) >= 0) {
                  constraint[0].x = off.x;
                  constraint[0].y = off.y;
                }
                off.x = cur.x + (cur.y <= 0 && (cur.y < 0 || cur.x < 0) ? 1 : -1);
                off.y = cur.y + (cur.x >= 0 && (cur.x > 0 || cur.y < 0) ? 1 : -1);
                if (utils.xprod(constraint[1], off) <= 0) {
                  constraint[1].x = off.x;
                  constraint[1].y = off.y;
                }
              }
              k1 = k;
              k = nc[k1];
              if (!utils.cyclic(k, i2, k1)) {
                break;
              }
            }
            if (foundk === 0) {
              dk.x = utils.sign(pt[k].x - pt[k1].x);
              dk.y = utils.sign(pt[k].y - pt[k1].y);
              cur.x = pt[k1].x - pt[i2].x;
              cur.y = pt[k1].y - pt[i2].y;
              a = utils.xprod(constraint[0], cur);
              b = utils.xprod(constraint[0], dk);
              c = utils.xprod(constraint[1], cur);
              d = utils.xprod(constraint[1], dk);
              j = 1e7;
              if (b < 0) {
                j = Math.floor(a / -b);
              }
              if (d > 0) {
                j = Math.min(j, Math.floor(-c / d));
              }
              pivk[i2] = utils.mod(k1 + j, n);
            }
          }
          j = pivk[n - 1];
          path2.lon[n - 1] = j;
          for (i2 = n - 2; i2 >= 0; i2--) {
            if (utils.cyclic(i2 + 1, pivk[i2], j)) {
              j = pivk[i2];
            }
            path2.lon[i2] = j;
          }
          for (i2 = n - 1; utils.cyclic(utils.mod(i2 + 1, n), j, path2.lon[i2]); i2--) {
            path2.lon[i2] = j;
          }
        }
        function bestPolygon(path2) {
          function penalty3(path3, i3, j2) {
            var n2 = path3.len, pt = path3.pt, sums = path3.sums;
            var x, y, xy, x2, y2, k2, a, b, c2, s, px, py, ex, ey, r = 0;
            if (j2 >= n2) {
              j2 -= n2;
              r = 1;
            }
            if (r === 0) {
              x = sums[j2 + 1].x - sums[i3].x;
              y = sums[j2 + 1].y - sums[i3].y;
              x2 = sums[j2 + 1].x2 - sums[i3].x2;
              xy = sums[j2 + 1].xy - sums[i3].xy;
              y2 = sums[j2 + 1].y2 - sums[i3].y2;
              k2 = j2 + 1 - i3;
            } else {
              x = sums[j2 + 1].x - sums[i3].x + sums[n2].x;
              y = sums[j2 + 1].y - sums[i3].y + sums[n2].y;
              x2 = sums[j2 + 1].x2 - sums[i3].x2 + sums[n2].x2;
              xy = sums[j2 + 1].xy - sums[i3].xy + sums[n2].xy;
              y2 = sums[j2 + 1].y2 - sums[i3].y2 + sums[n2].y2;
              k2 = j2 + 1 - i3 + n2;
            }
            px = (pt[i3].x + pt[j2].x) / 2 - pt[0].x;
            py = (pt[i3].y + pt[j2].y) / 2 - pt[0].y;
            ey = pt[j2].x - pt[i3].x;
            ex = -(pt[j2].y - pt[i3].y);
            a = (x2 - 2 * x * px) / k2 + px * px;
            b = (xy - x * py - y * px) / k2 + px * py;
            c2 = (y2 - 2 * y * py) / k2 + py * py;
            s = ex * ex * a + 2 * ex * ey * b + ey * ey * c2;
            return Math.sqrt(s);
          }
          var i2, j, m, k, n = path2.len, pen = new Array(n + 1), prev = new Array(n + 1), clip0 = new Array(n), clip1 = new Array(n + 1), seg0 = new Array(n + 1), seg1 = new Array(n + 1), thispen, best, c;
          for (i2 = 0; i2 < n; i2++) {
            c = utils.mod(path2.lon[utils.mod(i2 - 1, n)] - 1, n);
            if (c == i2) {
              c = utils.mod(i2 + 1, n);
            }
            if (c < i2) {
              clip0[i2] = n;
            } else {
              clip0[i2] = c;
            }
          }
          j = 1;
          for (i2 = 0; i2 < n; i2++) {
            while (j <= clip0[i2]) {
              clip1[j] = i2;
              j++;
            }
          }
          i2 = 0;
          for (j = 0; i2 < n; j++) {
            seg0[j] = i2;
            i2 = clip0[i2];
          }
          seg0[j] = n;
          m = j;
          i2 = n;
          for (j = m; j > 0; j--) {
            seg1[j] = i2;
            i2 = clip1[i2];
          }
          seg1[0] = 0;
          pen[0] = 0;
          for (j = 1; j <= m; j++) {
            for (i2 = seg1[j]; i2 <= seg0[j]; i2++) {
              best = -1;
              for (k = seg0[j - 1]; k >= clip1[i2]; k--) {
                thispen = penalty3(path2, k, i2) + pen[k];
                if (best < 0 || thispen < best) {
                  prev[i2] = k;
                  best = thispen;
                }
              }
              pen[i2] = best;
            }
          }
          path2.m = m;
          path2.po = new Array(m);
          for (i2 = n, j = m - 1; i2 > 0; j--) {
            i2 = prev[i2];
            path2.po[j] = i2;
          }
        }
        function adjustVertices(path2) {
          function pointslope(path3, i3, j2, ctr2, dir2) {
            var n2 = path3.len, sums = path3.sums, x, y, x2, xy, y2, k2, a, b, c, lambda2, l2, r = 0;
            while (j2 >= n2) {
              j2 -= n2;
              r += 1;
            }
            while (i3 >= n2) {
              i3 -= n2;
              r -= 1;
            }
            while (j2 < 0) {
              j2 += n2;
              r -= 1;
            }
            while (i3 < 0) {
              i3 += n2;
              r += 1;
            }
            x = sums[j2 + 1].x - sums[i3].x + r * sums[n2].x;
            y = sums[j2 + 1].y - sums[i3].y + r * sums[n2].y;
            x2 = sums[j2 + 1].x2 - sums[i3].x2 + r * sums[n2].x2;
            xy = sums[j2 + 1].xy - sums[i3].xy + r * sums[n2].xy;
            y2 = sums[j2 + 1].y2 - sums[i3].y2 + r * sums[n2].y2;
            k2 = j2 + 1 - i3 + r * n2;
            ctr2.x = x / k2;
            ctr2.y = y / k2;
            a = (x2 - x * x / k2) / k2;
            b = (xy - x * y / k2) / k2;
            c = (y2 - y * y / k2) / k2;
            lambda2 = (a + c + Math.sqrt((a - c) * (a - c) + 4 * b * b)) / 2;
            a -= lambda2;
            c -= lambda2;
            if (Math.abs(a) >= Math.abs(c)) {
              l2 = Math.sqrt(a * a + b * b);
              if (l2 !== 0) {
                dir2.x = -b / l2;
                dir2.y = a / l2;
              }
            } else {
              l2 = Math.sqrt(c * c + b * b);
              if (l2 !== 0) {
                dir2.x = -c / l2;
                dir2.y = b / l2;
              }
            }
            if (l2 === 0) {
              dir2.x = dir2.y = 0;
            }
          }
          var m = path2.m, po = path2.po, n = path2.len, pt = path2.pt, x0 = path2.x0, y0 = path2.y0, ctr = new Array(m), dir = new Array(m), q = new Array(m), v = new Array(3), d, i2, j, k, l, s = new Point();
          path2.curve = new Curve(m);
          for (i2 = 0; i2 < m; i2++) {
            j = po[utils.mod(i2 + 1, m)];
            j = utils.mod(j - po[i2], n) + po[i2];
            ctr[i2] = new Point();
            dir[i2] = new Point();
            pointslope(path2, po[i2], j, ctr[i2], dir[i2]);
          }
          for (i2 = 0; i2 < m; i2++) {
            q[i2] = new Quad();
            d = dir[i2].x * dir[i2].x + dir[i2].y * dir[i2].y;
            if (d === 0) {
              for (j = 0; j < 3; j++) {
                for (k = 0; k < 3; k++) {
                  q[i2].data[j * 3 + k] = 0;
                }
              }
            } else {
              v[0] = dir[i2].y;
              v[1] = -dir[i2].x;
              v[2] = -v[1] * ctr[i2].y - v[0] * ctr[i2].x;
              for (l = 0; l < 3; l++) {
                for (k = 0; k < 3; k++) {
                  q[i2].data[l * 3 + k] = v[l] * v[k] / d;
                }
              }
            }
          }
          var Q, w, dx, dy, det, min, cand, xmin, ymin, z;
          for (i2 = 0; i2 < m; i2++) {
            Q = new Quad();
            w = new Point();
            s.x = pt[po[i2]].x - x0;
            s.y = pt[po[i2]].y - y0;
            j = utils.mod(i2 - 1, m);
            for (l = 0; l < 3; l++) {
              for (k = 0; k < 3; k++) {
                Q.data[l * 3 + k] = q[j].at(l, k) + q[i2].at(l, k);
              }
            }
            while (1) {
              det = Q.at(0, 0) * Q.at(1, 1) - Q.at(0, 1) * Q.at(1, 0);
              if (det !== 0) {
                w.x = (-Q.at(0, 2) * Q.at(1, 1) + Q.at(1, 2) * Q.at(0, 1)) / det;
                w.y = (Q.at(0, 2) * Q.at(1, 0) - Q.at(1, 2) * Q.at(0, 0)) / det;
                break;
              }
              if (Q.at(0, 0) > Q.at(1, 1)) {
                v[0] = -Q.at(0, 1);
                v[1] = Q.at(0, 0);
              } else if (Q.at(1, 1)) {
                v[0] = -Q.at(1, 1);
                v[1] = Q.at(1, 0);
              } else {
                v[0] = 1;
                v[1] = 0;
              }
              d = v[0] * v[0] + v[1] * v[1];
              v[2] = -v[1] * s.y - v[0] * s.x;
              for (l = 0; l < 3; l++) {
                for (k = 0; k < 3; k++) {
                  Q.data[l * 3 + k] += v[l] * v[k] / d;
                }
              }
            }
            dx = Math.abs(w.x - s.x);
            dy = Math.abs(w.y - s.y);
            if (dx <= 0.5 && dy <= 0.5) {
              path2.curve.vertex[i2] = new Point(w.x + x0, w.y + y0);
              continue;
            }
            min = utils.quadform(Q, s);
            xmin = s.x;
            ymin = s.y;
            if (Q.at(0, 0) !== 0) {
              for (z = 0; z < 2; z++) {
                w.y = s.y - 0.5 + z;
                w.x = -(Q.at(0, 1) * w.y + Q.at(0, 2)) / Q.at(0, 0);
                dx = Math.abs(w.x - s.x);
                cand = utils.quadform(Q, w);
                if (dx <= 0.5 && cand < min) {
                  min = cand;
                  xmin = w.x;
                  ymin = w.y;
                }
              }
            }
            if (Q.at(1, 1) !== 0) {
              for (z = 0; z < 2; z++) {
                w.x = s.x - 0.5 + z;
                w.y = -(Q.at(1, 0) * w.x + Q.at(1, 2)) / Q.at(1, 1);
                dy = Math.abs(w.y - s.y);
                cand = utils.quadform(Q, w);
                if (dy <= 0.5 && cand < min) {
                  min = cand;
                  xmin = w.x;
                  ymin = w.y;
                }
              }
            }
            for (l = 0; l < 2; l++) {
              for (k = 0; k < 2; k++) {
                w.x = s.x - 0.5 + l;
                w.y = s.y - 0.5 + k;
                cand = utils.quadform(Q, w);
                if (cand < min) {
                  min = cand;
                  xmin = w.x;
                  ymin = w.y;
                }
              }
            }
            path2.curve.vertex[i2] = new Point(xmin + x0, ymin + y0);
          }
        }
        function reverse(path2) {
          var curve = path2.curve, m = curve.n, v = curve.vertex, i2, j, tmp;
          for (i2 = 0, j = m - 1; i2 < j; i2++, j--) {
            tmp = v[i2];
            v[i2] = v[j];
            v[j] = tmp;
          }
        }
        function smooth(path2) {
          var m = path2.curve.n, curve = path2.curve;
          var i2, j, k, dd, denom, alpha, p2, p3, p4;
          for (i2 = 0; i2 < m; i2++) {
            j = utils.mod(i2 + 1, m);
            k = utils.mod(i2 + 2, m);
            p4 = utils.interval(1 / 2, curve.vertex[k], curve.vertex[j]);
            denom = utils.ddenom(curve.vertex[i2], curve.vertex[k]);
            if (denom !== 0) {
              dd = utils.dpara(curve.vertex[i2], curve.vertex[j], curve.vertex[k]) / denom;
              dd = Math.abs(dd);
              alpha = dd > 1 ? 1 - 1 / dd : 0;
              alpha = alpha / 0.75;
            } else {
              alpha = 4 / 3;
            }
            curve.alpha0[j] = alpha;
            if (alpha >= self2._params.alphaMax) {
              curve.tag[j] = "CORNER";
              curve.c[3 * j + 1] = curve.vertex[j];
              curve.c[3 * j + 2] = p4;
            } else {
              if (alpha < 0.55) {
                alpha = 0.55;
              } else if (alpha > 1) {
                alpha = 1;
              }
              p2 = utils.interval(0.5 + 0.5 * alpha, curve.vertex[i2], curve.vertex[j]);
              p3 = utils.interval(0.5 + 0.5 * alpha, curve.vertex[k], curve.vertex[j]);
              curve.tag[j] = "CURVE";
              curve.c[3 * j + 0] = p2;
              curve.c[3 * j + 1] = p3;
              curve.c[3 * j + 2] = p4;
            }
            curve.alpha[j] = alpha;
            curve.beta[j] = 0.5;
          }
          curve.alphaCurve = 1;
        }
        function optiCurve(path2) {
          function opti_penalty(path3, i3, j2, res, opttolerance, convc2, areac2) {
            var m2 = path3.curve.n, curve2 = path3.curve, vertex = curve2.vertex, k, k1, k2, conv, i12, area2, alpha2, d, d1, d2, p02, p1, p2, p3, pt2, A, R, A1, A2, A3, A4, s2, t2;
            if (i3 == j2) {
              return 1;
            }
            k = i3;
            i12 = utils.mod(i3 + 1, m2);
            k1 = utils.mod(k + 1, m2);
            conv = convc2[k1];
            if (conv === 0) {
              return 1;
            }
            d = utils.ddist(vertex[i3], vertex[i12]);
            for (k = k1; k != j2; k = k1) {
              k1 = utils.mod(k + 1, m2);
              k2 = utils.mod(k + 2, m2);
              if (convc2[k1] != conv) {
                return 1;
              }
              if (utils.sign(utils.cprod(vertex[i3], vertex[i12], vertex[k1], vertex[k2])) != conv) {
                return 1;
              }
              if (utils.iprod1(vertex[i3], vertex[i12], vertex[k1], vertex[k2]) < d * utils.ddist(vertex[k1], vertex[k2]) * -0.999847695156) {
                return 1;
              }
            }
            p02 = curve2.c[utils.mod(i3, m2) * 3 + 2].copy();
            p1 = vertex[utils.mod(i3 + 1, m2)].copy();
            p2 = vertex[utils.mod(j2, m2)].copy();
            p3 = curve2.c[utils.mod(j2, m2) * 3 + 2].copy();
            area2 = areac2[j2] - areac2[i3];
            area2 -= utils.dpara(vertex[0], curve2.c[i3 * 3 + 2], curve2.c[j2 * 3 + 2]) / 2;
            if (i3 >= j2) {
              area2 += areac2[m2];
            }
            A1 = utils.dpara(p02, p1, p2);
            A2 = utils.dpara(p02, p1, p3);
            A3 = utils.dpara(p02, p2, p3);
            A4 = A1 + A3 - A2;
            if (A2 == A1) {
              return 1;
            }
            t2 = A3 / (A3 - A4);
            s2 = A2 / (A2 - A1);
            A = A2 * t2 / 2;
            if (A === 0) {
              return 1;
            }
            R = area2 / A;
            alpha2 = 2 - Math.sqrt(4 - R / 0.3);
            res.c[0] = utils.interval(t2 * alpha2, p02, p1);
            res.c[1] = utils.interval(s2 * alpha2, p3, p2);
            res.alpha = alpha2;
            res.t = t2;
            res.s = s2;
            p1 = res.c[0].copy();
            p2 = res.c[1].copy();
            res.pen = 0;
            for (k = utils.mod(i3 + 1, m2); k != j2; k = k1) {
              k1 = utils.mod(k + 1, m2);
              t2 = utils.tangent(p02, p1, p2, p3, vertex[k], vertex[k1]);
              if (t2 < -0.5) {
                return 1;
              }
              pt2 = utils.bezier(t2, p02, p1, p2, p3);
              d = utils.ddist(vertex[k], vertex[k1]);
              if (d === 0) {
                return 1;
              }
              d1 = utils.dpara(vertex[k], vertex[k1], pt2) / d;
              if (Math.abs(d1) > opttolerance) {
                return 1;
              }
              if (utils.iprod(vertex[k], vertex[k1], pt2) < 0 || utils.iprod(vertex[k1], vertex[k], pt2) < 0) {
                return 1;
              }
              res.pen += d1 * d1;
            }
            for (k = i3; k != j2; k = k1) {
              k1 = utils.mod(k + 1, m2);
              t2 = utils.tangent(p02, p1, p2, p3, curve2.c[k * 3 + 2], curve2.c[k1 * 3 + 2]);
              if (t2 < -0.5) {
                return 1;
              }
              pt2 = utils.bezier(t2, p02, p1, p2, p3);
              d = utils.ddist(curve2.c[k * 3 + 2], curve2.c[k1 * 3 + 2]);
              if (d === 0) {
                return 1;
              }
              d1 = utils.dpara(curve2.c[k * 3 + 2], curve2.c[k1 * 3 + 2], pt2) / d;
              d2 = utils.dpara(curve2.c[k * 3 + 2], curve2.c[k1 * 3 + 2], vertex[k1]) / d;
              d2 *= 0.75 * curve2.alpha[k1];
              if (d2 < 0) {
                d1 = -d1;
                d2 = -d2;
              }
              if (d1 < d2 - opttolerance) {
                return 1;
              }
              if (d1 < d2) {
                res.pen += (d1 - d2) * (d1 - d2);
              }
            }
            return 0;
          }
          var curve = path2.curve, m = curve.n, vert = curve.vertex, pt = new Array(m + 1), pen = new Array(m + 1), len = new Array(m + 1), opt = new Array(m + 1), om, i2, j, r, o = new Opti(), p0, i1, area, alpha, ocurve, s, t;
          var convc = new Array(m), areac = new Array(m + 1);
          for (i2 = 0; i2 < m; i2++) {
            if (curve.tag[i2] == "CURVE") {
              convc[i2] = utils.sign(utils.dpara(vert[utils.mod(i2 - 1, m)], vert[i2], vert[utils.mod(i2 + 1, m)]));
            } else {
              convc[i2] = 0;
            }
          }
          area = 0;
          areac[0] = 0;
          p0 = curve.vertex[0];
          for (i2 = 0; i2 < m; i2++) {
            i1 = utils.mod(i2 + 1, m);
            if (curve.tag[i1] == "CURVE") {
              alpha = curve.alpha[i1];
              area += 0.3 * alpha * (4 - alpha) * utils.dpara(curve.c[i2 * 3 + 2], vert[i1], curve.c[i1 * 3 + 2]) / 2;
              area += utils.dpara(p0, curve.c[i2 * 3 + 2], curve.c[i1 * 3 + 2]) / 2;
            }
            areac[i2 + 1] = area;
          }
          pt[0] = -1;
          pen[0] = 0;
          len[0] = 0;
          for (j = 1; j <= m; j++) {
            pt[j] = j - 1;
            pen[j] = pen[j - 1];
            len[j] = len[j - 1] + 1;
            for (i2 = j - 2; i2 >= 0; i2--) {
              r = opti_penalty(
                path2,
                i2,
                utils.mod(j, m),
                o,
                self2._params.optTolerance,
                convc,
                areac
              );
              if (r) {
                break;
              }
              if (len[j] > len[i2] + 1 || len[j] == len[i2] + 1 && pen[j] > pen[i2] + o.pen) {
                pt[j] = i2;
                pen[j] = pen[i2] + o.pen;
                len[j] = len[i2] + 1;
                opt[j] = o;
                o = new Opti();
              }
            }
          }
          om = len[m];
          ocurve = new Curve(om);
          s = new Array(om);
          t = new Array(om);
          j = m;
          for (i2 = om - 1; i2 >= 0; i2--) {
            if (pt[j] == j - 1) {
              ocurve.tag[i2] = curve.tag[utils.mod(j, m)];
              ocurve.c[i2 * 3 + 0] = curve.c[utils.mod(j, m) * 3 + 0];
              ocurve.c[i2 * 3 + 1] = curve.c[utils.mod(j, m) * 3 + 1];
              ocurve.c[i2 * 3 + 2] = curve.c[utils.mod(j, m) * 3 + 2];
              ocurve.vertex[i2] = curve.vertex[utils.mod(j, m)];
              ocurve.alpha[i2] = curve.alpha[utils.mod(j, m)];
              ocurve.alpha0[i2] = curve.alpha0[utils.mod(j, m)];
              ocurve.beta[i2] = curve.beta[utils.mod(j, m)];
              s[i2] = t[i2] = 1;
            } else {
              ocurve.tag[i2] = "CURVE";
              ocurve.c[i2 * 3 + 0] = opt[j].c[0];
              ocurve.c[i2 * 3 + 1] = opt[j].c[1];
              ocurve.c[i2 * 3 + 2] = curve.c[utils.mod(j, m) * 3 + 2];
              ocurve.vertex[i2] = utils.interval(
                opt[j].s,
                curve.c[utils.mod(j, m) * 3 + 2],
                vert[utils.mod(j, m)]
              );
              ocurve.alpha[i2] = opt[j].alpha;
              ocurve.alpha0[i2] = opt[j].alpha;
              s[i2] = opt[j].s;
              t[i2] = opt[j].t;
            }
            j = pt[j];
          }
          for (i2 = 0; i2 < om; i2++) {
            i1 = utils.mod(i2 + 1, om);
            ocurve.beta[i2] = s[i2] / (s[i2] + t[i1]);
          }
          ocurve.alphaCurve = 1;
          path2.curve = ocurve;
        }
        for (var i = 0; i < this._pathlist.length; i++) {
          var path = this._pathlist[i];
          calcSums(path);
          calcLon(path);
          bestPolygon(path);
          adjustVertices(path);
          if (path.sign === "-") {
            reverse(path);
          }
          smooth(path);
          if (self2._params.optCurve) {
            optiCurve(path);
          }
        }
      },
      /**
       * Validates some of parameters
       * @param params
       * @private
       */
      _validateParameters: function(params) {
        if (params && params.turnPolicy && SUPPORTED_TURNPOLICY_VALUES.indexOf(params.turnPolicy) === -1) {
          var goodVals = "'" + SUPPORTED_TURNPOLICY_VALUES.join("', '") + "'";
          throw new Error("Bad turnPolicy value. Allowed values are: " + goodVals);
        }
        if (params && params.threshold != null && params.threshold !== Potrace.THRESHOLD_AUTO) {
          if (typeof params.threshold !== "number" || !utils.between(params.threshold, 0, 255)) {
            throw new Error("Bad threshold value. Expected to be an integer in range 0..255");
          }
        }
        if (params && params.optCurve != null && typeof params.optCurve !== "boolean") {
          throw new Error("'optCurve' must be Boolean");
        }
      },
      _processLoadedImage: function(image) {
        var bitmap = new Bitmap(image.bitmap.width, image.bitmap.height);
        var pixels = image.bitmap.data;
        image.scan(0, 0, image.bitmap.width, image.bitmap.height, function(x, y, idx) {
          var opacity = pixels[idx + 3] / 255, r = 255 + (pixels[idx + 0] - 255) * opacity, g = 255 + (pixels[idx + 1] - 255) * opacity, b = 255 + (pixels[idx + 2] - 255) * opacity;
          bitmap.data[idx / 4] = utils.luminance(r, g, b);
        });
        this._luminanceData = bitmap;
        this._imageLoaded = true;
      },
      /**
       * Reads given image. Uses {@link Jimp} under the hood, so target can be whatever Jimp can take
       *
       * @param {string|Buffer|Jimp} target Image source. Could be anything that {@link Jimp} can read (buffer, local path or url). Supported formats are: PNG, JPEG or BMP
       * @param {Function} callback
       */
      loadImage: function(target, callback) {
        var self2 = this;
        var jobId = {};
        this._imageLoadingIdentifier = jobId;
        this._imageLoaded = false;
        if (target instanceof Jimp) {
          this._imageLoadingIdentifier = null;
          this._imageLoaded = true;
          self2._processLoadedImage(target);
          callback.call(self2, null);
        } else {
          Jimp.read(target, function(err, img) {
            var sourceChanged = self2._imageLoadingIdentifier !== jobId;
            if (sourceChanged) {
              var error = err ? err : new Error("Another image was loaded instead");
              return callback.call(self2, error);
            }
            self2._imageLoadingIdentifier = null;
            self2._processLoadedImage(img);
            callback.call(self2, null);
          });
        }
      },
      /**
       * Sets algorithm parameters
       * @param {Potrace~Options} newParams
       */
      setParameters: function(newParams) {
        var key, tmpOldVal;
        this._validateParameters(newParams);
        for (key in this._params) {
          if (this._params.hasOwnProperty(key) && newParams.hasOwnProperty(key)) {
            tmpOldVal = this._params[key];
            this._params[key] = newParams[key];
            if (tmpOldVal !== this._params[key] && ["color", "background"].indexOf(key) === -1) {
              this._processed = false;
            }
          }
        }
      },
      /**
       * Generates just <path> tag without rest of the SVG file
       *
       * @param {String} [fillColor] - overrides color from parameters
       * @returns {String}
       */
      getPathTag: function(fillColor, scale) {
        fillColor = arguments.length === 0 ? this._params.color : fillColor;
        if (fillColor === Potrace.COLOR_AUTO) {
          fillColor = this._params.blackOnWhite ? "black" : "white";
        }
        if (!this._imageLoaded) {
          throw new Error("Image should be loaded first");
        }
        if (!this._processed) {
          this._bmToPathlist();
          this._processPath();
          this._processed = true;
        }
        var tag = '<path d="';
        tag += this._pathlist.map(function(path) {
          return utils.renderCurve(path.curve, scale);
        }).join(" ");
        tag += '" stroke="none" fill="' + fillColor + '" fill-rule="evenodd"/>';
        return tag;
      },
      /**
       * Returns <symbol> tag. Always has viewBox specified and comes with no fill color,
       * so it could be changed with <use> tag
       *
       * @param id
       * @returns {string}
       */
      getSymbol: function(id) {
        return '<symbol viewBox="0 0 ' + this._luminanceData.width + " " + this._luminanceData.height + '" id="' + id + '">' + this.getPathTag("") + "</symbol>";
      },
      /**
       * Generates SVG image
       * @returns {String}
       */
      getSVG: function() {
        var width = this._params.width || this._luminanceData.width;
        var height = this._params.height || this._luminanceData.height;
        var scale = {
          x: this._params.width ? this._params.width / this._luminanceData.width : 1,
          y: this._params.height ? this._params.height / this._luminanceData.height : 1
        };
        return '<svg xmlns="http://www.w3.org/2000/svg" width="' + width + '" height="' + height + '" viewBox="0 0 ' + width + " " + height + '" version="1.1">\n' + (this._params.background !== Potrace.COLOR_TRANSPARENT ? '	<rect x="0" y="0" width="100%" height="100%" fill="' + this._params.background + '" />\n' : "") + "	" + this.getPathTag(this._params.color, scale) + "\n</svg>";
      }
    };
    module.exports = Potrace;
  }
});

// node_modules/potrace/lib/Posterizer.js
var require_Posterizer = __commonJS({
  "node_modules/potrace/lib/Posterizer.js"(exports, module) {
    "use strict";
    var Potrace = require_Potrace();
    var utils = require_utils();
    function Posterizer(options) {
      this._potrace = new Potrace();
      this._calculatedThreshold = null;
      this._params = {
        threshold: Potrace.THRESHOLD_AUTO,
        blackOnWhite: true,
        steps: Posterizer.STEPS_AUTO,
        background: Potrace.COLOR_TRANSPARENT,
        fillStrategy: Posterizer.FILL_DOMINANT,
        rangeDistribution: Posterizer.RANGES_AUTO
      };
      if (options) {
        this.setParameters(options);
      }
    }
    for (key in Potrace) {
      if (Object.prototype.hasOwnProperty.call(Potrace, key) && key === key.toUpperCase()) {
        Posterizer[key] = Potrace[key];
      }
    }
    var key;
    Posterizer.STEPS_AUTO = -1;
    Posterizer.FILL_SPREAD = "spread";
    Posterizer.FILL_DOMINANT = "dominant";
    Posterizer.FILL_MEDIAN = "median";
    Posterizer.FILL_MEAN = "mean";
    Posterizer.RANGES_AUTO = "auto";
    Posterizer.RANGES_EQUAL = "equal";
    Posterizer.prototype = {
      /**
       * Fine tuning to color ranges.
       *
       * If last range (featuring most saturated color) is larger than 10% of color space (25 units)
       * then we want to add another color stop, that hopefully will include darkest pixels, improving presence of
       * shadows and line art
       *
       * @param ranges
       * @private
       */
      _addExtraColorStop: function(ranges) {
        var blackOnWhite = this._params.blackOnWhite;
        var lastColorStop = ranges[ranges.length - 1];
        var lastRangeFrom = blackOnWhite ? 0 : lastColorStop.value;
        var lastRangeTo = blackOnWhite ? lastColorStop.value : 255;
        if (lastRangeTo - lastRangeFrom > 25 && lastColorStop.colorIntensity !== 1) {
          var histogram = this._getImageHistogram();
          var levels = histogram.getStats(lastRangeFrom, lastRangeTo).levels;
          var newColorStop = levels.mean + levels.stdDev <= 25 ? levels.mean + levels.stdDev : levels.mean - levels.stdDev <= 25 ? levels.mean - levels.stdDev : 25;
          var newStats = blackOnWhite ? histogram.getStats(0, newColorStop) : histogram.getStats(newColorStop, 255);
          var color = newStats.levels.mean;
          ranges.push({
            value: Math.abs((blackOnWhite ? 0 : 255) - newColorStop),
            colorIntensity: isNaN(color) ? 0 : (blackOnWhite ? 255 - color : color) / 255
          });
        }
        return ranges;
      },
      /**
       * Calculates color intensity for each element of numeric array
       * 
       * @param {number[]} colorStops
       * @returns {{ levels: number, colorIntensity: number }[]}
       * @private
       */
      _calcColorIntensity: function(colorStops) {
        var blackOnWhite = this._params.blackOnWhite;
        var colorSelectionStrat = this._params.fillStrategy;
        var histogram = colorSelectionStrat !== Posterizer.FILL_SPREAD ? this._getImageHistogram() : null;
        var fullRange = Math.abs(this._paramThreshold() - (blackOnWhite ? 0 : 255));
        return colorStops.map(function(threshold, index) {
          var nextValue = index + 1 === colorStops.length ? blackOnWhite ? -1 : 256 : colorStops[index + 1];
          var rangeStart = Math.round(blackOnWhite ? nextValue + 1 : threshold);
          var rangeEnd = Math.round(blackOnWhite ? threshold : nextValue - 1);
          var factor = index / (colorStops.length - 1);
          var intervalSize = rangeEnd - rangeStart;
          var stats = histogram.getStats(rangeStart, rangeEnd);
          var color = -1;
          if (stats.pixels === 0) {
            return {
              value: threshold,
              colorIntensity: 0
            };
          }
          switch (colorSelectionStrat) {
            case Posterizer.FILL_SPREAD:
              color = (blackOnWhite ? rangeStart : rangeEnd) + (blackOnWhite ? 1 : -1) * intervalSize * Math.max(0.5, fullRange / 255) * factor;
              break;
            case Posterizer.FILL_DOMINANT:
              color = histogram.getDominantColor(rangeStart, rangeEnd, utils.clamp(intervalSize, 1, 5));
              break;
            case Posterizer.FILL_MEAN:
              color = stats.levels.mean;
              break;
            case Posterizer.FILL_MEDIAN:
              color = stats.levels.median;
              break;
          }
          if (index !== 0) {
            color = blackOnWhite ? utils.clamp(color, rangeStart, rangeEnd - Math.round(intervalSize * 0.1)) : utils.clamp(color, rangeStart + Math.round(intervalSize * 0.1), rangeEnd);
          }
          return {
            value: threshold,
            colorIntensity: color === -1 ? 0 : (blackOnWhite ? 255 - color : color) / 255
          };
        });
      },
      /**
       * @returns {Histogram}
       * @private
       */
      _getImageHistogram: function() {
        return this._potrace._luminanceData.histogram();
      },
      /**
       * Processes threshold, steps and rangeDistribution parameters and returns normalized array of color stops
       * @returns {*}
       * @private
       */
      _getRanges: function() {
        var steps = this._paramSteps();
        if (!Array.isArray(steps)) {
          return this._params.rangeDistribution === Posterizer.RANGES_AUTO ? this._getRangesAuto() : this._getRangesEquallyDistributed();
        }
        var colorStops = [];
        var threshold = this._paramThreshold();
        var lookingForDarkPixels = this._params.blackOnWhite;
        steps.forEach(function(item) {
          if (colorStops.indexOf(item) === -1 && utils.between(item, 0, 255)) {
            colorStops.push(item);
          }
        });
        if (!colorStops.length) {
          colorStops.push(threshold);
        }
        colorStops = colorStops.sort(function(a, b) {
          return a < b === lookingForDarkPixels ? 1 : -1;
        });
        if (lookingForDarkPixels && colorStops[0] < threshold) {
          colorStops.unshift(threshold);
        } else if (!lookingForDarkPixels && colorStops[colorStops.length - 1] < threshold) {
          colorStops.push(threshold);
        }
        return this._calcColorIntensity(colorStops);
      },
      /**
       * Calculates given (or lower) number of thresholds using automatic thresholding algorithm
       * @returns {*}
       * @private
       */
      _getRangesAuto: function() {
        var histogram = this._getImageHistogram();
        var steps = this._paramSteps(true);
        var colorStops;
        if (this._params.threshold === Potrace.THRESHOLD_AUTO) {
          colorStops = histogram.multilevelThresholding(steps);
        } else {
          var threshold = this._paramThreshold();
          colorStops = this._params.blackOnWhite ? histogram.multilevelThresholding(steps - 1, 0, threshold) : histogram.multilevelThresholding(steps - 1, threshold, 255);
          if (this._params.blackOnWhite) {
            colorStops.push(threshold);
          } else {
            colorStops.unshift(threshold);
          }
        }
        if (this._params.blackOnWhite) {
          colorStops = colorStops.reverse();
        }
        return this._calcColorIntensity(colorStops);
      },
      /**
       * Calculates color stops and color representing each segment, returning them
       * from least to most intense color (black or white, depending on blackOnWhite parameter)
       *
       * @private
       */
      _getRangesEquallyDistributed: function() {
        var blackOnWhite = this._params.blackOnWhite;
        var colorsToThreshold = blackOnWhite ? this._paramThreshold() : 255 - this._paramThreshold();
        var steps = this._paramSteps();
        var stepSize = colorsToThreshold / steps;
        var colorStops = [];
        var i = steps - 1, factor, threshold;
        while (i >= 0) {
          factor = i / (steps - 1);
          threshold = Math.min(colorsToThreshold, (i + 1) * stepSize);
          threshold = blackOnWhite ? threshold : 255 - threshold;
          i--;
          colorStops.push(threshold);
        }
        return this._calcColorIntensity(colorStops);
      },
      /**
       * Returns valid steps value
       * @param {Boolean} [count=false]
       * @returns {number|number[]}
       * @private
       */
      _paramSteps: function(count) {
        var steps = this._params.steps;
        if (Array.isArray(steps)) {
          return count ? steps.length : steps;
        }
        if (steps === Posterizer.STEPS_AUTO && this._params.threshold === Potrace.THRESHOLD_AUTO) {
          return 4;
        }
        var blackOnWhite = this._params.blackOnWhite;
        var colorsCount = blackOnWhite ? this._paramThreshold() : 255 - this._paramThreshold();
        return steps === Posterizer.STEPS_AUTO ? colorsCount > 200 ? 4 : 3 : Math.min(colorsCount, Math.max(2, steps));
      },
      /**
       * Returns valid threshold value
       * @returns {number}
       * @private
       */
      _paramThreshold: function() {
        if (this._calculatedThreshold !== null) {
          return this._calculatedThreshold;
        }
        if (this._params.threshold !== Potrace.THRESHOLD_AUTO) {
          this._calculatedThreshold = this._params.threshold;
          return this._calculatedThreshold;
        }
        var twoThresholds = this._getImageHistogram().multilevelThresholding(2);
        this._calculatedThreshold = this._params.blackOnWhite ? twoThresholds[1] : twoThresholds[0];
        this._calculatedThreshold = this._calculatedThreshold || 128;
        return this._calculatedThreshold;
      },
      /**
       * Running potrace on the image multiple times with different thresholds and returns an array
       * of path tags
       *
       * @param {Boolean} [noFillColor]
       * @returns {string[]}
       * @private
       */
      _pathTags: function(noFillColor) {
        var ranges = this._getRanges();
        var potrace = this._potrace;
        var blackOnWhite = this._params.blackOnWhite;
        if (ranges.length >= 10) {
          ranges = this._addExtraColorStop(ranges);
        }
        potrace.setParameters({ blackOnWhite });
        var actualPrevLayersOpacity = 0;
        return ranges.map(function(colorStop) {
          var thisLayerOpacity = colorStop.colorIntensity;
          if (thisLayerOpacity === 0) {
            return "";
          }
          var calculatedOpacity = !actualPrevLayersOpacity || thisLayerOpacity === 1 ? thisLayerOpacity : (actualPrevLayersOpacity - thisLayerOpacity) / (actualPrevLayersOpacity - 1);
          calculatedOpacity = utils.clamp(parseFloat(calculatedOpacity.toFixed(3)), 0, 1);
          actualPrevLayersOpacity = actualPrevLayersOpacity + (1 - actualPrevLayersOpacity) * calculatedOpacity;
          potrace.setParameters({ threshold: colorStop.value });
          var element = noFillColor ? potrace.getPathTag("") : potrace.getPathTag();
          element = utils.setHtmlAttr(element, "fill-opacity", calculatedOpacity.toFixed(3));
          var canBeIgnored = calculatedOpacity === 0 || element.indexOf(' d=""') !== -1;
          return canBeIgnored ? "" : element;
        });
      },
      /**
       * Loads image.
       *
       * @param {string|Buffer|Jimp} target Image source. Could be anything that {@link Jimp} can read (buffer, local path or url). Supported formats are: PNG, JPEG or BMP
       * @param {Function} callback
       */
      loadImage: function(target, callback) {
        var self2 = this;
        this._potrace.loadImage(target, function(err) {
          self2._calculatedThreshold = null;
          callback.call(self2, err);
        });
      },
      /**
       * Sets parameters. Accepts same object as {Potrace}
       *
       * @param {Posterizer~Options} params
       */
      setParameters: function(params) {
        if (!params) {
          return;
        }
        this._potrace.setParameters(params);
        if (params.steps && !Array.isArray(params.steps) && (!utils.isNumber(params.steps) || !utils.between(params.steps, 1, 255))) {
          throw new Error("Bad 'steps' value");
        }
        for (var key2 in this._params) {
          if (this._params.hasOwnProperty(key2) && params.hasOwnProperty(key2)) {
            this._params[key2] = params[key2];
          }
        }
        this._calculatedThreshold = null;
      },
      /**
       * Returns image as <symbol> tag. Always has viewBox specified
       *
       * @param {string} id
       */
      getSymbol: function(id) {
        var width = this._potrace._luminanceData.width;
        var height = this._potrace._luminanceData.height;
        var paths = this._pathTags(true);
        return '<symbol viewBox="0 0 ' + width + " " + height + '" id="' + id + '">' + paths.join("") + "</symbol>";
      },
      /**
       * Generates SVG image
       * @returns {String}
       */
      getSVG: function() {
        var width = this._potrace._luminanceData.width, height = this._potrace._luminanceData.height;
        var tags = this._pathTags(false);
        var svg = '<svg xmlns="http://www.w3.org/2000/svg" width="' + width + '" height="' + height + '" viewBox="0 0 ' + width + " " + height + '" version="1.1">\n	' + (this._params.background !== Potrace.COLOR_TRANSPARENT ? '<rect x="0" y="0" width="100%" height="100%" fill="' + this._params.background + '" />\n	' : "") + tags.join("\n	") + "\n</svg>";
        return svg.replace(/\n(?:\t*\n)+(\t*)/g, "\n$1");
      }
    };
    module.exports = Posterizer;
  }
});

// node_modules/potrace/lib/index.js
var require_lib = __commonJS({
  "node_modules/potrace/lib/index.js"(exports, module) {
    var Potrace = require_Potrace();
    var Posterizer = require_Posterizer();
    function trace(file, options, cb) {
      if (arguments.length === 2) {
        cb = options;
        options = {};
      }
      var potrace = new Potrace(options);
      potrace.loadImage(file, function(err) {
        if (err) {
          return cb(err);
        }
        cb(null, potrace.getSVG(), potrace);
      });
    }
    function posterize(file, options, cb) {
      if (arguments.length === 2) {
        cb = options;
        options = {};
      }
      var posterizer = new Posterizer(options);
      posterizer.loadImage(file, function(err) {
        if (err) {
          return cb(err);
        }
        cb(null, posterizer.getSVG(), posterizer);
      });
    }
    module.exports = {
      trace,
      posterize,
      Potrace,
      Posterizer
    };
  }
});
export default require_lib();
/*! Bundled license information:

jimp/browser/lib/jimp.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * iq.ts - Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * constants.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * rgb2xyz.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * rgb2hsl.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * rgb2lab.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * xyz2lab.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * lab2xyz.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * lab2rgb.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * xyz2rgb.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * cie94.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * ciede2000.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * cmetric.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * euclidean.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * manhattanNeuQuant.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * pngQuant.ts - part of Image Quantization Library
   *)
  (**
   * @preserve TypeScript port:
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * neuquant.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * palette.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * pointContainer.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * point.ts - part of Image Quantization Library
   *)
  (**
   * @preserve TypeScript port:
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * rgbquant.ts - part of Image Quantization Library
   *)
  (**
   * @preserve TypeScript port:
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * colorHistogram.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * hueStatistics.ts - part of Image Quantization Library
   *)
  (**
   * @preserve
   * Copyright 2015-2016 Igor Bezkrovnyi
   * All rights reserved. (MIT Licensed)
   *
   * wuQuant.ts - part of Image Quantization Library
   *)
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
  (*! https://mths.be/punycode v1.4.1 by @mathias *)
  (*!
   * Timm
   *
   * Immutability helpers with fast reads and acceptable writes.
   *
   * @copyright Guillermo Grau Panea 2016
   * @license MIT
   *)
*/
//# sourceMappingURL=potrace.js.map
