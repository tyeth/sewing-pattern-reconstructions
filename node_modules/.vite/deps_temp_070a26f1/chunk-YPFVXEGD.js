import {
  require_buffer
} from "./chunk-VHIB75KR.js";
import {
  require_path_browserify
} from "./chunk-E75FZHVX.js";
import {
  __commonJS
} from "./chunk-CQXHTUV2.js";

// node_modules/idb-wrapper/idbstore.js
var require_idbstore = __commonJS({
  "node_modules/idb-wrapper/idbstore.js"(exports, module) {
    (function(name, definition, global2) {
      "use strict";
      if (typeof define === "function") {
        define(definition);
      } else if (typeof module !== "undefined" && module.exports) {
        module.exports = definition();
      } else {
        global2[name] = definition();
      }
    })("IDBStore", function() {
      "use strict";
      var defaultErrorHandler = function(error) {
        throw error;
      };
      var defaultSuccessHandler = function() {
      };
      var defaults = {
        storeName: "Store",
        storePrefix: "IDBWrapper-",
        dbVersion: 1,
        keyPath: "id",
        autoIncrement: true,
        onStoreReady: function() {
        },
        onError: defaultErrorHandler,
        indexes: [],
        implementationPreference: [
          "indexedDB",
          "webkitIndexedDB",
          "mozIndexedDB",
          "shimIndexedDB"
        ]
      };
      var IDBStore = function(kwArgs, onStoreReady) {
        if (typeof onStoreReady == "undefined" && typeof kwArgs == "function") {
          onStoreReady = kwArgs;
        }
        if (Object.prototype.toString.call(kwArgs) != "[object Object]") {
          kwArgs = {};
        }
        for (var key in defaults) {
          this[key] = typeof kwArgs[key] != "undefined" ? kwArgs[key] : defaults[key];
        }
        this.dbName = this.storePrefix + this.storeName;
        this.dbVersion = parseInt(this.dbVersion, 10) || 1;
        onStoreReady && (this.onStoreReady = onStoreReady);
        var env = typeof window == "object" ? window : self;
        var availableImplementations = this.implementationPreference.filter(function(implName) {
          return implName in env;
        });
        this.implementation = availableImplementations[0];
        this.idb = env[this.implementation];
        this.keyRange = env.IDBKeyRange || env.webkitIDBKeyRange || env.mozIDBKeyRange;
        this.consts = {
          "READ_ONLY": "readonly",
          "READ_WRITE": "readwrite",
          "VERSION_CHANGE": "versionchange",
          "NEXT": "next",
          "NEXT_NO_DUPLICATE": "nextunique",
          "PREV": "prev",
          "PREV_NO_DUPLICATE": "prevunique"
        };
        this.openDB();
      };
      var proto = {
        /**
         * A pointer to the IDBStore ctor
         *
         * @private
         * @type {Function}
         * @constructs
         */
        constructor: IDBStore,
        /**
         * The version of IDBStore
         *
         * @type {String}
         */
        version: "1.7.2",
        /**
         * A reference to the IndexedDB object
         *
         * @type {IDBDatabase}
         */
        db: null,
        /**
         * The full name of the IndexedDB used by IDBStore, composed of
         * this.storePrefix + this.storeName
         *
         * @type {String}
         */
        dbName: null,
        /**
         * The version of the IndexedDB used by IDBStore
         *
         * @type {Number}
         */
        dbVersion: null,
        /**
         * A reference to the objectStore used by IDBStore
         *
         * @type {IDBObjectStore}
         */
        store: null,
        /**
         * The store name
         *
         * @type {String}
         */
        storeName: null,
        /**
         * The prefix to prepend to the store name
         *
         * @type {String}
         */
        storePrefix: null,
        /**
         * The key path
         *
         * @type {String}
         */
        keyPath: null,
        /**
         * Whether IDBStore uses autoIncrement
         *
         * @type {Boolean}
         */
        autoIncrement: null,
        /**
         * The indexes used by IDBStore
         *
         * @type {Array}
         */
        indexes: null,
        /**
         * The implemantations to try to use, in order of preference
         *
         * @type {Array}
         */
        implementationPreference: null,
        /**
         * The actual implementation being used
         *
         * @type {String}
         */
        implementation: "",
        /**
         * The callback to be called when the store is ready to be used
         *
         * @type {Function}
         */
        onStoreReady: null,
        /**
         * The callback to be called if an error occurred during instantiation
         * of the store
         *
         * @type {Function}
         */
        onError: null,
        /**
         * The internal insertID counter
         *
         * @type {Number}
         * @private
         */
        _insertIdCount: 0,
        /**
         * Opens an IndexedDB; called by the constructor.
         *
         * Will check if versions match and compare provided index configuration
         * with existing ones, and update indexes if necessary.
         *
         * Will call this.onStoreReady() if everything went well and the store
         * is ready to use, and this.onError() is something went wrong.
         *
         * @private
         *
         */
        openDB: function() {
          var openRequest = this.idb.open(this.dbName, this.dbVersion);
          var preventSuccessCallback = false;
          openRequest.onerror = (function(errorEvent) {
            if (hasVersionError(errorEvent)) {
              this.onError(new Error("The version number provided is lower than the existing one."));
            } else {
              var error;
              if (errorEvent.target.error) {
                error = errorEvent.target.error;
              } else {
                var errorMessage = "IndexedDB unknown error occurred when opening DB " + this.dbName + " version " + this.dbVersion;
                if ("errorCode" in errorEvent.target) {
                  errorMessage += " with error code " + errorEvent.target.errorCode;
                }
                error = new Error(errorMessage);
              }
              this.onError(error);
            }
          }).bind(this);
          openRequest.onsuccess = (function(event) {
            if (preventSuccessCallback) {
              return;
            }
            if (this.db) {
              this.onStoreReady();
              return;
            }
            this.db = event.target.result;
            if (typeof this.db.version == "string") {
              this.onError(new Error("The IndexedDB implementation in this browser is outdated. Please upgrade your browser."));
              return;
            }
            if (!this.db.objectStoreNames.contains(this.storeName)) {
              this.onError(new Error("Object store couldn't be created."));
              return;
            }
            var emptyTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);
            this.store = emptyTransaction.objectStore(this.storeName);
            var existingIndexes = Array.prototype.slice.call(this.getIndexList());
            this.indexes.forEach(function(indexData) {
              var indexName = indexData.name;
              if (!indexName) {
                preventSuccessCallback = true;
                this.onError(new Error("Cannot create index: No index name given."));
                return;
              }
              this.normalizeIndexData(indexData);
              if (this.hasIndex(indexName)) {
                var actualIndex = this.store.index(indexName);
                var complies = this.indexComplies(actualIndex, indexData);
                if (!complies) {
                  preventSuccessCallback = true;
                  this.onError(new Error('Cannot modify index "' + indexName + '" for current version. Please bump version number to ' + (this.dbVersion + 1) + "."));
                }
                existingIndexes.splice(existingIndexes.indexOf(indexName), 1);
              } else {
                preventSuccessCallback = true;
                this.onError(new Error('Cannot create new index "' + indexName + '" for current version. Please bump version number to ' + (this.dbVersion + 1) + "."));
              }
            }, this);
            if (existingIndexes.length) {
              preventSuccessCallback = true;
              this.onError(new Error('Cannot delete index(es) "' + existingIndexes.toString() + '" for current version. Please bump version number to ' + (this.dbVersion + 1) + "."));
            }
            preventSuccessCallback || this.onStoreReady();
          }).bind(this);
          openRequest.onupgradeneeded = (function(event) {
            this.db = event.target.result;
            if (this.db.objectStoreNames.contains(this.storeName)) {
              this.store = event.target.transaction.objectStore(this.storeName);
            } else {
              var optionalParameters = { autoIncrement: this.autoIncrement };
              if (this.keyPath !== null) {
                optionalParameters.keyPath = this.keyPath;
              }
              this.store = this.db.createObjectStore(this.storeName, optionalParameters);
            }
            var existingIndexes = Array.prototype.slice.call(this.getIndexList());
            this.indexes.forEach(function(indexData) {
              var indexName = indexData.name;
              if (!indexName) {
                preventSuccessCallback = true;
                this.onError(new Error("Cannot create index: No index name given."));
              }
              this.normalizeIndexData(indexData);
              if (this.hasIndex(indexName)) {
                var actualIndex = this.store.index(indexName);
                var complies = this.indexComplies(actualIndex, indexData);
                if (!complies) {
                  this.store.deleteIndex(indexName);
                  this.store.createIndex(indexName, indexData.keyPath, {
                    unique: indexData.unique,
                    multiEntry: indexData.multiEntry
                  });
                }
                existingIndexes.splice(existingIndexes.indexOf(indexName), 1);
              } else {
                this.store.createIndex(indexName, indexData.keyPath, {
                  unique: indexData.unique,
                  multiEntry: indexData.multiEntry
                });
              }
            }, this);
            if (existingIndexes.length) {
              existingIndexes.forEach(function(_indexName) {
                this.store.deleteIndex(_indexName);
              }, this);
            }
          }).bind(this);
        },
        /**
         * Deletes the database used for this store if the IDB implementations
         * provides that functionality.
         *
         * @param {Function} [onSuccess] A callback that is called if deletion
         *  was successful.
         * @param {Function} [onError] A callback that is called if deletion
         *  failed.
         */
        deleteDatabase: function(onSuccess, onError) {
          if (this.idb.deleteDatabase) {
            this.db.close();
            var deleteRequest = this.idb.deleteDatabase(this.dbName);
            deleteRequest.onsuccess = onSuccess;
            deleteRequest.onerror = onError;
          } else {
            onError(new Error("Browser does not support IndexedDB deleteDatabase!"));
          }
        },
        /*********************
         * data manipulation *
         *********************/
        /**
         * Puts an object into the store. If an entry with the given id exists,
         * it will be overwritten. This method has a different signature for inline
         * keys and out-of-line keys; please see the examples below.
         *
         * @param {*} [key] The key to store. This is only needed if IDBWrapper
         *  is set to use out-of-line keys. For inline keys - the default scenario -
         *  this can be omitted.
         * @param {Object} value The data object to store.
         * @param {Function} [onSuccess] A callback that is called if insertion
         *  was successful.
         * @param {Function} [onError] A callback that is called if insertion
         *  failed.
         * @returns {IDBTransaction} The transaction used for this operation.
         * @example
         // Storing an object, using inline keys (the default scenario):
         var myCustomer = {
             customerid: 2346223,
             lastname: 'Doe',
             firstname: 'John'
         };
         myCustomerStore.put(myCustomer, mySuccessHandler, myErrorHandler);
         // Note that passing success- and error-handlers is optional.
         * @example
         // Storing an object, using out-of-line keys:
         var myCustomer = {
             lastname: 'Doe',
             firstname: 'John'
         };
         myCustomerStore.put(2346223, myCustomer, mySuccessHandler, myErrorHandler);
         // Note that passing success- and error-handlers is optional.
         */
        put: function(key, value, onSuccess, onError) {
          if (this.keyPath !== null) {
            onError = onSuccess;
            onSuccess = value;
            value = key;
          }
          onError || (onError = defaultErrorHandler);
          onSuccess || (onSuccess = defaultSuccessHandler);
          var hasSuccess = false, result = null, putRequest;
          var putTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);
          putTransaction.oncomplete = function() {
            var callback = hasSuccess ? onSuccess : onError;
            callback(result);
          };
          putTransaction.onabort = onError;
          putTransaction.onerror = onError;
          if (this.keyPath !== null) {
            this._addIdPropertyIfNeeded(value);
            putRequest = putTransaction.objectStore(this.storeName).put(value);
          } else {
            putRequest = putTransaction.objectStore(this.storeName).put(value, key);
          }
          putRequest.onsuccess = function(event) {
            hasSuccess = true;
            result = event.target.result;
          };
          putRequest.onerror = onError;
          return putTransaction;
        },
        /**
         * Retrieves an object from the store. If no entry exists with the given id,
         * the success handler will be called with null as first and only argument.
         *
         * @param {*} key The id of the object to fetch.
         * @param {Function} [onSuccess] A callback that is called if fetching
         *  was successful. Will receive the object as only argument.
         * @param {Function} [onError] A callback that will be called if an error
         *  occurred during the operation.
         * @returns {IDBTransaction} The transaction used for this operation.
         */
        get: function(key, onSuccess, onError) {
          onError || (onError = defaultErrorHandler);
          onSuccess || (onSuccess = defaultSuccessHandler);
          var hasSuccess = false, result = null;
          var getTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);
          getTransaction.oncomplete = function() {
            var callback = hasSuccess ? onSuccess : onError;
            callback(result);
          };
          getTransaction.onabort = onError;
          getTransaction.onerror = onError;
          var getRequest = getTransaction.objectStore(this.storeName).get(key);
          getRequest.onsuccess = function(event) {
            hasSuccess = true;
            result = event.target.result;
          };
          getRequest.onerror = onError;
          return getTransaction;
        },
        /**
         * Removes an object from the store.
         *
         * @param {*} key The id of the object to remove.
         * @param {Function} [onSuccess] A callback that is called if the removal
         *  was successful.
         * @param {Function} [onError] A callback that will be called if an error
         *  occurred during the operation.
         * @returns {IDBTransaction} The transaction used for this operation.
         */
        remove: function(key, onSuccess, onError) {
          onError || (onError = defaultErrorHandler);
          onSuccess || (onSuccess = defaultSuccessHandler);
          var hasSuccess = false, result = null;
          var removeTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);
          removeTransaction.oncomplete = function() {
            var callback = hasSuccess ? onSuccess : onError;
            callback(result);
          };
          removeTransaction.onabort = onError;
          removeTransaction.onerror = onError;
          var deleteRequest = removeTransaction.objectStore(this.storeName)["delete"](key);
          deleteRequest.onsuccess = function(event) {
            hasSuccess = true;
            result = event.target.result;
          };
          deleteRequest.onerror = onError;
          return removeTransaction;
        },
        /**
         * Runs a batch of put and/or remove operations on the store.
         *
         * @param {Array} dataArray An array of objects containing the operation to run
         *  and the data object (for put operations).
         * @param {Function} [onSuccess] A callback that is called if all operations
         *  were successful.
         * @param {Function} [onError] A callback that is called if an error
         *  occurred during one of the operations.
         * @returns {IDBTransaction} The transaction used for this operation.
         */
        batch: function(dataArray, onSuccess, onError) {
          onError || (onError = defaultErrorHandler);
          onSuccess || (onSuccess = defaultSuccessHandler);
          if (Object.prototype.toString.call(dataArray) != "[object Array]") {
            onError(new Error("dataArray argument must be of type Array."));
          } else if (dataArray.length === 0) {
            return onSuccess(true);
          }
          var count = dataArray.length;
          var called = false;
          var hasSuccess = false;
          var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);
          batchTransaction.oncomplete = function() {
            var callback = hasSuccess ? onSuccess : onError;
            callback(hasSuccess);
          };
          batchTransaction.onabort = onError;
          batchTransaction.onerror = onError;
          var onItemSuccess = function() {
            count--;
            if (count === 0 && !called) {
              called = true;
              hasSuccess = true;
            }
          };
          dataArray.forEach(function(operation) {
            var type = operation.type;
            var key = operation.key;
            var value = operation.value;
            var onItemError = function(err) {
              batchTransaction.abort();
              if (!called) {
                called = true;
                onError(err, type, key);
              }
            };
            if (type == "remove") {
              var deleteRequest = batchTransaction.objectStore(this.storeName)["delete"](key);
              deleteRequest.onsuccess = onItemSuccess;
              deleteRequest.onerror = onItemError;
            } else if (type == "put") {
              var putRequest;
              if (this.keyPath !== null) {
                this._addIdPropertyIfNeeded(value);
                putRequest = batchTransaction.objectStore(this.storeName).put(value);
              } else {
                putRequest = batchTransaction.objectStore(this.storeName).put(value, key);
              }
              putRequest.onsuccess = onItemSuccess;
              putRequest.onerror = onItemError;
            }
          }, this);
          return batchTransaction;
        },
        /**
         * Takes an array of objects and stores them in a single transaction.
         *
         * @param {Array} dataArray An array of objects to store
         * @param {Function} [onSuccess] A callback that is called if all operations
         *  were successful.
         * @param {Function} [onError] A callback that is called if an error
         *  occurred during one of the operations.
         * @returns {IDBTransaction} The transaction used for this operation.
         */
        putBatch: function(dataArray, onSuccess, onError) {
          var batchData = dataArray.map(function(item) {
            return { type: "put", value: item };
          });
          return this.batch(batchData, onSuccess, onError);
        },
        /**
         * Like putBatch, takes an array of objects and stores them in a single
         * transaction, but allows processing of the result values.  Returns the
         * processed records containing the key for newly created records to the
         * onSuccess calllback instead of only returning true or false for success.
         * In addition, added the option for the caller to specify a key field that
         * should be set to the newly created key.
         *
         * @param {Array} dataArray An array of objects to store
         * @param {Object} [options] An object containing optional options
         * @param {String} [options.keyField=this.keyPath] Specifies a field in the record to update
         *  with the auto-incrementing key. Defaults to the store's keyPath.
         * @param {Function} [onSuccess] A callback that is called if all operations
         *  were successful.
         * @param {Function} [onError] A callback that is called if an error
         *  occurred during one of the operations.
         * @returns {IDBTransaction} The transaction used for this operation.
         *
         */
        upsertBatch: function(dataArray, options, onSuccess, onError) {
          if (typeof options == "function") {
            onSuccess = options;
            onError = onSuccess;
            options = {};
          }
          onError || (onError = defaultErrorHandler);
          onSuccess || (onSuccess = defaultSuccessHandler);
          options || (options = {});
          if (Object.prototype.toString.call(dataArray) != "[object Array]") {
            onError(new Error("dataArray argument must be of type Array."));
          }
          var keyField = options.keyField || this.keyPath;
          var count = dataArray.length;
          var called = false;
          var hasSuccess = false;
          var index = 0;
          var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);
          batchTransaction.oncomplete = function() {
            if (hasSuccess) {
              onSuccess(dataArray);
            } else {
              onError(false);
            }
          };
          batchTransaction.onabort = onError;
          batchTransaction.onerror = onError;
          var onItemSuccess = function(event) {
            var record = dataArray[index++];
            record[keyField] = event.target.result;
            count--;
            if (count === 0 && !called) {
              called = true;
              hasSuccess = true;
            }
          };
          dataArray.forEach(function(record) {
            var key = record.key;
            var onItemError = function(err) {
              batchTransaction.abort();
              if (!called) {
                called = true;
                onError(err);
              }
            };
            var putRequest;
            if (this.keyPath !== null) {
              this._addIdPropertyIfNeeded(record);
              putRequest = batchTransaction.objectStore(this.storeName).put(record);
            } else {
              putRequest = batchTransaction.objectStore(this.storeName).put(record, key);
            }
            putRequest.onsuccess = onItemSuccess;
            putRequest.onerror = onItemError;
          }, this);
          return batchTransaction;
        },
        /**
         * Takes an array of keys and removes matching objects in a single
         * transaction.
         *
         * @param {Array} keyArray An array of keys to remove
         * @param {Function} [onSuccess] A callback that is called if all operations
         *  were successful.
         * @param {Function} [onError] A callback that is called if an error
         *  occurred during one of the operations.
         * @returns {IDBTransaction} The transaction used for this operation.
         */
        removeBatch: function(keyArray, onSuccess, onError) {
          var batchData = keyArray.map(function(key) {
            return { type: "remove", key };
          });
          return this.batch(batchData, onSuccess, onError);
        },
        /**
                 * Takes an array of keys and fetches matching objects
                 *
                 * @param {Array} keyArray An array of keys identifying the objects to fetch
                 * @param {Function} [onSuccess] A callback that is called if all operations
                 *  were successful.
                 * @param {Function} [onError] A callback that is called if an error
                 *  occurred during one of the operations.
                 * @param {String} [arrayType='sparse'] The type of array to pass to the
                 *  success handler. May be one of 'sparse', 'dense' or 'skip'. Defaults to
                 *  'sparse'. This parameter specifies how to handle the situation if a get
                 *  operation did not throw an error, but there was no matching object in
                 *  the database. In most cases, 'sparse' provides the most desired
                 *  behavior. See the examples for details.
                 * @returns {IDBTransaction} The transaction used for this operation.
                 * @example
                 // given that there are two objects in the database with the keypath
                 // values 1 and 2, and the call looks like this:
                 myStore.getBatch([1, 5, 2], onError, function (data) { â€¦ }, arrayType);
        
                 // this is what the `data` array will be like:
        
                 // arrayType == 'sparse':
                 // data is a sparse array containing two entries and having a length of 3:
                 [Object, 2: Object]
                 0: Object
                 2: Object
                 length: 3
                 // calling forEach on data will result in the callback being called two
                 // times, with the index parameter matching the index of the key in the
                 // keyArray.
        
                 // arrayType == 'dense':
                 // data is a dense array containing three entries and having a length of 3,
                 // where data[1] is of type undefined:
                 [Object, undefined, Object]
                 0: Object
                 1: undefined
                 2: Object
                 length: 3
                 // calling forEach on data will result in the callback being called three
                 // times, with the index parameter matching the index of the key in the
                 // keyArray, but the second call will have undefined as first argument.
        
                 // arrayType == 'skip':
                 // data is a dense array containing two entries and having a length of 2:
                 [Object, Object]
                 0: Object
                 1: Object
                 length: 2
                 // calling forEach on data will result in the callback being called two
                 // times, with the index parameter not matching the index of the key in the
                 // keyArray.
                 */
        getBatch: function(keyArray, onSuccess, onError, arrayType) {
          onError || (onError = defaultErrorHandler);
          onSuccess || (onSuccess = defaultSuccessHandler);
          arrayType || (arrayType = "sparse");
          if (Object.prototype.toString.call(keyArray) != "[object Array]") {
            onError(new Error("keyArray argument must be of type Array."));
          } else if (keyArray.length === 0) {
            return onSuccess([]);
          }
          var data = [];
          var count = keyArray.length;
          var called = false;
          var hasSuccess = false;
          var result = null;
          var batchTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);
          batchTransaction.oncomplete = function() {
            var callback = hasSuccess ? onSuccess : onError;
            callback(result);
          };
          batchTransaction.onabort = onError;
          batchTransaction.onerror = onError;
          var onItemSuccess = function(event) {
            if (event.target.result || arrayType == "dense") {
              data.push(event.target.result);
            } else if (arrayType == "sparse") {
              data.length++;
            }
            count--;
            if (count === 0) {
              called = true;
              hasSuccess = true;
              result = data;
            }
          };
          keyArray.forEach(function(key) {
            var onItemError = function(err) {
              called = true;
              result = err;
              onError(err);
              batchTransaction.abort();
            };
            var getRequest = batchTransaction.objectStore(this.storeName).get(key);
            getRequest.onsuccess = onItemSuccess;
            getRequest.onerror = onItemError;
          }, this);
          return batchTransaction;
        },
        /**
         * Fetches all entries in the store.
         *
         * @param {Function} [onSuccess] A callback that is called if the operation
         *  was successful. Will receive an array of objects.
         * @param {Function} [onError] A callback that will be called if an error
         *  occurred during the operation.
         * @returns {IDBTransaction} The transaction used for this operation.
         */
        getAll: function(onSuccess, onError) {
          onError || (onError = defaultErrorHandler);
          onSuccess || (onSuccess = defaultSuccessHandler);
          var getAllTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);
          var store = getAllTransaction.objectStore(this.storeName);
          if (store.getAll) {
            this._getAllNative(getAllTransaction, store, onSuccess, onError);
          } else {
            this._getAllCursor(getAllTransaction, store, onSuccess, onError);
          }
          return getAllTransaction;
        },
        /**
         * Implements getAll for IDB implementations that have a non-standard
         * getAll() method.
         *
         * @param {IDBTransaction} getAllTransaction An open READ transaction.
         * @param {IDBObjectStore} store A reference to the store.
         * @param {Function} onSuccess A callback that will be called if the
         *  operation was successful.
         * @param {Function} onError A callback that will be called if an
         *  error occurred during the operation.
         * @private
         */
        _getAllNative: function(getAllTransaction, store, onSuccess, onError) {
          var hasSuccess = false, result = null;
          getAllTransaction.oncomplete = function() {
            var callback = hasSuccess ? onSuccess : onError;
            callback(result);
          };
          getAllTransaction.onabort = onError;
          getAllTransaction.onerror = onError;
          var getAllRequest = store.getAll();
          getAllRequest.onsuccess = function(event) {
            hasSuccess = true;
            result = event.target.result;
          };
          getAllRequest.onerror = onError;
        },
        /**
         * Implements getAll for IDB implementations that do not have a getAll()
         * method.
         *
         * @param {IDBTransaction} getAllTransaction An open READ transaction.
         * @param {IDBObjectStore} store A reference to the store.
         * @param {Function} onSuccess A callback that will be called if the
         *  operation was successful.
         * @param {Function} onError A callback that will be called if an
         *  error occurred during the operation.
         * @private
         */
        _getAllCursor: function(getAllTransaction, store, onSuccess, onError) {
          var all = [], hasSuccess = false, result = null;
          getAllTransaction.oncomplete = function() {
            var callback = hasSuccess ? onSuccess : onError;
            callback(result);
          };
          getAllTransaction.onabort = onError;
          getAllTransaction.onerror = onError;
          var cursorRequest = store.openCursor();
          cursorRequest.onsuccess = function(event) {
            var cursor = event.target.result;
            if (cursor) {
              all.push(cursor.value);
              cursor["continue"]();
            } else {
              hasSuccess = true;
              result = all;
            }
          };
          cursorRequest.onError = onError;
        },
        /**
         * Clears the store, i.e. deletes all entries in the store.
         *
         * @param {Function} [onSuccess] A callback that will be called if the
         *  operation was successful.
         * @param {Function} [onError] A callback that will be called if an
         *  error occurred during the operation.
         * @returns {IDBTransaction} The transaction used for this operation.
         */
        clear: function(onSuccess, onError) {
          onError || (onError = defaultErrorHandler);
          onSuccess || (onSuccess = defaultSuccessHandler);
          var hasSuccess = false, result = null;
          var clearTransaction = this.db.transaction([this.storeName], this.consts.READ_WRITE);
          clearTransaction.oncomplete = function() {
            var callback = hasSuccess ? onSuccess : onError;
            callback(result);
          };
          clearTransaction.onabort = onError;
          clearTransaction.onerror = onError;
          var clearRequest = clearTransaction.objectStore(this.storeName).clear();
          clearRequest.onsuccess = function(event) {
            hasSuccess = true;
            result = event.target.result;
          };
          clearRequest.onerror = onError;
          return clearTransaction;
        },
        /**
         * Checks if an id property needs to present on a object and adds one if
         * necessary.
         *
         * @param {Object} dataObj The data object that is about to be stored
         * @private
         */
        _addIdPropertyIfNeeded: function(dataObj) {
          if (typeof dataObj[this.keyPath] == "undefined") {
            dataObj[this.keyPath] = this._insertIdCount++ + Date.now();
          }
        },
        /************
         * indexing *
         ************/
        /**
         * Returns a DOMStringList of index names of the store.
         *
         * @return {DOMStringList} The list of index names
         */
        getIndexList: function() {
          return this.store.indexNames;
        },
        /**
         * Checks if an index with the given name exists in the store.
         *
         * @param {String} indexName The name of the index to look for
         * @return {Boolean} Whether the store contains an index with the given name
         */
        hasIndex: function(indexName) {
          return this.store.indexNames.contains(indexName);
        },
        /**
         * Normalizes an object containing index data and assures that all
         * properties are set.
         *
         * @param {Object} indexData The index data object to normalize
         * @param {String} indexData.name The name of the index
         * @param {String} [indexData.keyPath] The key path of the index
         * @param {Boolean} [indexData.unique] Whether the index is unique
         * @param {Boolean} [indexData.multiEntry] Whether the index is multi entry
         */
        normalizeIndexData: function(indexData) {
          indexData.keyPath = indexData.keyPath || indexData.name;
          indexData.unique = !!indexData.unique;
          indexData.multiEntry = !!indexData.multiEntry;
        },
        /**
         * Checks if an actual index complies with an expected index.
         *
         * @param {IDBIndex} actual The actual index found in the store
         * @param {Object} expected An Object describing an expected index
         * @return {Boolean} Whether both index definitions are identical
         */
        indexComplies: function(actual, expected) {
          var complies = ["keyPath", "unique", "multiEntry"].every(function(key) {
            if (key == "multiEntry" && actual[key] === void 0 && expected[key] === false) {
              return true;
            }
            if (key == "keyPath" && Object.prototype.toString.call(expected[key]) == "[object Array]") {
              var exp = expected.keyPath;
              var act = actual.keyPath;
              if (typeof act == "string") {
                return exp.toString() == act;
              }
              if (!(typeof act.contains == "function" || typeof act.indexOf == "function")) {
                return false;
              }
              if (act.length !== exp.length) {
                return false;
              }
              for (var i = 0, m = exp.length; i < m; i++) {
                if (!(act.contains && act.contains(exp[i]) || act.indexOf(exp[i] !== -1))) {
                  return false;
                }
              }
              return true;
            }
            return expected[key] == actual[key];
          });
          return complies;
        },
        /**********
         * cursor *
         **********/
        /**
         * Iterates over the store using the given options and calling onItem
         * for each entry matching the options.
         *
         * @param {Function} onItem A callback to be called for each match
         * @param {Object} [options] An object defining specific options
         * @param {String} [options.index=null] A name of an IDBIndex to operate on
         * @param {String} [options.order=ASC] The order in which to provide the
         *  results, can be 'DESC' or 'ASC'
         * @param {Boolean} [options.autoContinue=true] Whether to automatically
         *  iterate the cursor to the next result
         * @param {Boolean} [options.filterDuplicates=false] Whether to exclude
         *  duplicate matches
         * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use
         * @param {Boolean} [options.writeAccess=false] Whether grant write access
         *  to the store in the onItem callback
         * @param {Function} [options.onEnd=null] A callback to be called after
         *  iteration has ended
         * @param {Function} [options.onError=throw] A callback to be called
         *  if an error occurred during the operation.
         * @param {Number} [options.limit=Infinity] Limit the number of returned
         *  results to this number
         * @param {Number} [options.offset=0] Skip the provided number of results
         *  in the resultset
         * @param {Boolean} [options.allowItemRejection=false] Allows the onItem
         * function to return a Boolean to accept or reject the current item
         * @returns {IDBTransaction} The transaction used for this operation.
         */
        iterate: function(onItem, options) {
          options = mixin({
            index: null,
            order: "ASC",
            autoContinue: true,
            filterDuplicates: false,
            keyRange: null,
            writeAccess: false,
            onEnd: null,
            onError: defaultErrorHandler,
            limit: Infinity,
            offset: 0,
            allowItemRejection: false
          }, options || {});
          var directionType = options.order.toLowerCase() == "desc" ? "PREV" : "NEXT";
          if (options.filterDuplicates) {
            directionType += "_NO_DUPLICATE";
          }
          var hasSuccess = false;
          var cursorTransaction = this.db.transaction([this.storeName], this.consts[options.writeAccess ? "READ_WRITE" : "READ_ONLY"]);
          var cursorTarget = cursorTransaction.objectStore(this.storeName);
          if (options.index) {
            cursorTarget = cursorTarget.index(options.index);
          }
          var recordCount = 0;
          cursorTransaction.oncomplete = function() {
            if (!hasSuccess) {
              options.onError(null);
              return;
            }
            if (options.onEnd) {
              options.onEnd();
            } else {
              onItem(null);
            }
          };
          cursorTransaction.onabort = options.onError;
          cursorTransaction.onerror = options.onError;
          var cursorRequest = cursorTarget.openCursor(options.keyRange, this.consts[directionType]);
          cursorRequest.onerror = options.onError;
          cursorRequest.onsuccess = function(event) {
            var cursor = event.target.result;
            if (cursor) {
              if (options.offset) {
                cursor.advance(options.offset);
                options.offset = 0;
              } else {
                var onItemReturn = onItem(cursor.value, cursor, cursorTransaction);
                if (!options.allowItemRejection || onItemReturn !== false) {
                  recordCount++;
                }
                if (options.autoContinue) {
                  if (recordCount + options.offset < options.limit) {
                    cursor["continue"]();
                  } else {
                    hasSuccess = true;
                  }
                }
              }
            } else {
              hasSuccess = true;
            }
          };
          return cursorTransaction;
        },
        /**
         * Runs a query against the store and passes an array containing matched
         * objects to the success handler.
         *
         * @param {Function} onSuccess A callback to be called when the operation
         *  was successful.
         * @param {Object} [options] An object defining specific options
         * @param {String} [options.index=null] A name of an IDBIndex to operate on
         * @param {String} [options.order=ASC] The order in which to provide the
         *  results, can be 'DESC' or 'ASC'
         * @param {Boolean} [options.filterDuplicates=false] Whether to exclude
         *  duplicate matches
         * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use
         * @param {Function} [options.onError=throw] A callback to be called
         *  if an error occurred during the operation.
         * @param {Number} [options.limit=Infinity] Limit the number of returned
         *  results to this number
         * @param {Number} [options.offset=0] Skip the provided number of results
         *  in the resultset
         * @param {Function} [options.filter=null] A custom filter function to
         *  apply to query resuts before returning. Must return `false` to reject
         *  an item. Can be combined with keyRanges.
         * @returns {IDBTransaction} The transaction used for this operation.
         */
        query: function(onSuccess, options) {
          var result = [], processedItems = 0;
          options = options || {};
          options.autoContinue = true;
          options.writeAccess = false;
          options.allowItemRejection = !!options.filter;
          options.onEnd = function() {
            onSuccess(result, processedItems);
          };
          return this.iterate(function(item) {
            processedItems++;
            var accept = options.filter ? options.filter(item) : true;
            if (accept !== false) {
              result.push(item);
            }
            return accept;
          }, options);
        },
        /**
         *
         * Runs a query against the store, but only returns the number of matches
         * instead of the matches itself.
         *
         * @param {Function} onSuccess A callback to be called if the opration
         *  was successful.
         * @param {Object} [options] An object defining specific options
         * @param {String} [options.index=null] A name of an IDBIndex to operate on
         * @param {IDBKeyRange} [options.keyRange=null] An IDBKeyRange to use
         * @param {Function} [options.onError=throw] A callback to be called if an error
         *  occurred during the operation.
         * @returns {IDBTransaction} The transaction used for this operation.
         */
        count: function(onSuccess, options) {
          options = mixin({
            index: null,
            keyRange: null
          }, options || {});
          var onError = options.onError || defaultErrorHandler;
          var hasSuccess = false, result = null;
          var cursorTransaction = this.db.transaction([this.storeName], this.consts.READ_ONLY);
          cursorTransaction.oncomplete = function() {
            var callback = hasSuccess ? onSuccess : onError;
            callback(result);
          };
          cursorTransaction.onabort = onError;
          cursorTransaction.onerror = onError;
          var cursorTarget = cursorTransaction.objectStore(this.storeName);
          if (options.index) {
            cursorTarget = cursorTarget.index(options.index);
          }
          var countRequest = cursorTarget.count(options.keyRange);
          countRequest.onsuccess = function(evt) {
            hasSuccess = true;
            result = evt.target.result;
          };
          countRequest.onError = onError;
          return cursorTransaction;
        },
        /**************/
        /* key ranges */
        /**************/
        /**
         * Creates a key range using specified options. This key range can be
         * handed over to the count() and iterate() methods.
         *
         * Note: You must provide at least one or both of "lower" or "upper" value.
         *
         * @param {Object} options The options for the key range to create
         * @param {*} [options.lower] The lower bound
         * @param {Boolean} [options.excludeLower] Whether to exclude the lower
         *  bound passed in options.lower from the key range
         * @param {*} [options.upper] The upper bound
         * @param {Boolean} [options.excludeUpper] Whether to exclude the upper
         *  bound passed in options.upper from the key range
         * @param {*} [options.only] A single key value. Use this if you need a key
         *  range that only includes one value for a key. Providing this
         *  property invalidates all other properties.
         * @return {IDBKeyRange} The IDBKeyRange representing the specified options
         */
        makeKeyRange: function(options) {
          var keyRange, hasLower = typeof options.lower != "undefined", hasUpper = typeof options.upper != "undefined", isOnly = typeof options.only != "undefined";
          switch (true) {
            case isOnly:
              keyRange = this.keyRange.only(options.only);
              break;
            case (hasLower && hasUpper):
              keyRange = this.keyRange.bound(options.lower, options.upper, options.excludeLower, options.excludeUpper);
              break;
            case hasLower:
              keyRange = this.keyRange.lowerBound(options.lower, options.excludeLower);
              break;
            case hasUpper:
              keyRange = this.keyRange.upperBound(options.upper, options.excludeUpper);
              break;
            default:
              throw new Error('Cannot create KeyRange. Provide one or both of "lower" or "upper" value, or an "only" value.');
          }
          return keyRange;
        }
      };
      var empty = {};
      function mixin(target, source) {
        var name, s;
        for (name in source) {
          s = source[name];
          if (s !== empty[name] && s !== target[name]) {
            target[name] = s;
          }
        }
        return target;
      }
      function hasVersionError(errorEvent) {
        if ("error" in errorEvent.target) {
          return errorEvent.target.error.name == "VersionError";
        } else if ("errorCode" in errorEvent.target) {
          return errorEvent.target.errorCode == 12;
        }
        return false;
      }
      IDBStore.prototype = proto;
      IDBStore.version = proto.version;
      return IDBStore;
    }, exports);
  }
});

// node_modules/abstract-leveldown/node_modules/xtend/index.js
var require_xtend = __commonJS({
  "node_modules/abstract-leveldown/node_modules/xtend/index.js"(exports, module) {
    module.exports = extend;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/abstract-leveldown/abstract-iterator.js
var require_abstract_iterator = __commonJS({
  "node_modules/abstract-leveldown/abstract-iterator.js"(exports, module) {
    function AbstractIterator(db2) {
      this.db = db2;
      this._ended = false;
      this._nexting = false;
    }
    AbstractIterator.prototype.next = function(callback) {
      var self2 = this;
      if (typeof callback != "function")
        throw new Error("next() requires a callback argument");
      if (self2._ended)
        return callback(new Error("cannot call next() after end()"));
      if (self2._nexting)
        return callback(new Error("cannot call next() before previous next() has completed"));
      self2._nexting = true;
      if (typeof self2._next == "function") {
        return self2._next(function() {
          self2._nexting = false;
          callback.apply(null, arguments);
        });
      }
      process.nextTick(function() {
        self2._nexting = false;
        callback();
      });
    };
    AbstractIterator.prototype.end = function(callback) {
      if (typeof callback != "function")
        throw new Error("end() requires a callback argument");
      if (this._ended)
        return callback(new Error("end() already called on iterator"));
      this._ended = true;
      if (typeof this._end == "function")
        return this._end(callback);
      process.nextTick(callback);
    };
    module.exports = AbstractIterator;
  }
});

// node_modules/abstract-leveldown/abstract-chained-batch.js
var require_abstract_chained_batch = __commonJS({
  "node_modules/abstract-leveldown/abstract-chained-batch.js"(exports, module) {
    function AbstractChainedBatch(db2) {
      this._db = db2;
      this._operations = [];
      this._written = false;
    }
    AbstractChainedBatch.prototype._checkWritten = function() {
      if (this._written)
        throw new Error("write() already called on this batch");
    };
    AbstractChainedBatch.prototype.put = function(key, value) {
      this._checkWritten();
      var err = this._db._checkKeyValue(key, "key", this._db._isBuffer);
      if (err)
        throw err;
      err = this._db._checkKeyValue(value, "value", this._db._isBuffer);
      if (err)
        throw err;
      if (!this._db._isBuffer(key))
        key = String(key);
      if (!this._db._isBuffer(value))
        value = String(value);
      if (typeof this._put == "function")
        this._put(key, value);
      else
        this._operations.push({ type: "put", key, value });
      return this;
    };
    AbstractChainedBatch.prototype.del = function(key) {
      this._checkWritten();
      var err = this._db._checkKeyValue(key, "key", this._db._isBuffer);
      if (err)
        throw err;
      if (!this._db._isBuffer(key))
        key = String(key);
      if (typeof this._del == "function")
        this._del(key);
      else
        this._operations.push({ type: "del", key });
      return this;
    };
    AbstractChainedBatch.prototype.clear = function() {
      this._checkWritten();
      this._operations = [];
      if (typeof this._clear == "function")
        this._clear();
      return this;
    };
    AbstractChainedBatch.prototype.write = function(options, callback) {
      this._checkWritten();
      if (typeof options == "function")
        callback = options;
      if (typeof callback != "function")
        throw new Error("write() requires a callback argument");
      if (typeof options != "object")
        options = {};
      this._written = true;
      if (typeof this._write == "function")
        return this._write(callback);
      if (typeof this._db._batch == "function")
        return this._db._batch(this._operations, options, callback);
      process.nextTick(callback);
    };
    module.exports = AbstractChainedBatch;
  }
});

// node_modules/abstract-leveldown/abstract-leveldown.js
var require_abstract_leveldown = __commonJS({
  "node_modules/abstract-leveldown/abstract-leveldown.js"(exports, module) {
    var xtend = require_xtend();
    var AbstractIterator = require_abstract_iterator();
    var AbstractChainedBatch = require_abstract_chained_batch();
    function AbstractLevelDOWN(location) {
      if (!arguments.length || location === void 0)
        throw new Error("constructor requires at least a location argument");
      if (typeof location != "string")
        throw new Error("constructor requires a location string argument");
      this.location = location;
    }
    AbstractLevelDOWN.prototype.open = function(options, callback) {
      if (typeof options == "function")
        callback = options;
      if (typeof callback != "function")
        throw new Error("open() requires a callback argument");
      if (typeof options != "object")
        options = {};
      if (typeof this._open == "function")
        return this._open(options, callback);
      process.nextTick(callback);
    };
    AbstractLevelDOWN.prototype.close = function(callback) {
      if (typeof callback != "function")
        throw new Error("close() requires a callback argument");
      if (typeof this._close == "function")
        return this._close(callback);
      process.nextTick(callback);
    };
    AbstractLevelDOWN.prototype.get = function(key, options, callback) {
      var err;
      if (typeof options == "function")
        callback = options;
      if (typeof callback != "function")
        throw new Error("get() requires a callback argument");
      if (err = this._checkKeyValue(key, "key", this._isBuffer))
        return callback(err);
      if (!this._isBuffer(key))
        key = String(key);
      if (typeof options != "object")
        options = {};
      if (typeof this._get == "function")
        return this._get(key, options, callback);
      process.nextTick(function() {
        callback(new Error("NotFound"));
      });
    };
    AbstractLevelDOWN.prototype.put = function(key, value, options, callback) {
      var err;
      if (typeof options == "function")
        callback = options;
      if (typeof callback != "function")
        throw new Error("put() requires a callback argument");
      if (err = this._checkKeyValue(key, "key", this._isBuffer))
        return callback(err);
      if (err = this._checkKeyValue(value, "value", this._isBuffer))
        return callback(err);
      if (!this._isBuffer(key))
        key = String(key);
      if (!this._isBuffer(value) && !process.browser)
        value = String(value);
      if (typeof options != "object")
        options = {};
      if (typeof this._put == "function")
        return this._put(key, value, options, callback);
      process.nextTick(callback);
    };
    AbstractLevelDOWN.prototype.del = function(key, options, callback) {
      var err;
      if (typeof options == "function")
        callback = options;
      if (typeof callback != "function")
        throw new Error("del() requires a callback argument");
      if (err = this._checkKeyValue(key, "key", this._isBuffer))
        return callback(err);
      if (!this._isBuffer(key))
        key = String(key);
      if (typeof options != "object")
        options = {};
      if (typeof this._del == "function")
        return this._del(key, options, callback);
      process.nextTick(callback);
    };
    AbstractLevelDOWN.prototype.batch = function(array, options, callback) {
      if (!arguments.length)
        return this._chainedBatch();
      if (typeof options == "function")
        callback = options;
      if (typeof callback != "function")
        throw new Error("batch(array) requires a callback argument");
      if (!Array.isArray(array))
        return callback(new Error("batch(array) requires an array argument"));
      if (typeof options != "object")
        options = {};
      var i = 0, l = array.length, e, err;
      for (; i < l; i++) {
        e = array[i];
        if (typeof e != "object")
          continue;
        if (err = this._checkKeyValue(e.type, "type", this._isBuffer))
          return callback(err);
        if (err = this._checkKeyValue(e.key, "key", this._isBuffer))
          return callback(err);
        if (e.type == "put") {
          if (err = this._checkKeyValue(e.value, "value", this._isBuffer))
            return callback(err);
        }
      }
      if (typeof this._batch == "function")
        return this._batch(array, options, callback);
      process.nextTick(callback);
    };
    AbstractLevelDOWN.prototype.approximateSize = function(start, end, callback) {
      if (start == null || end == null || typeof start == "function" || typeof end == "function") {
        throw new Error("approximateSize() requires valid `start`, `end` and `callback` arguments");
      }
      if (typeof callback != "function")
        throw new Error("approximateSize() requires a callback argument");
      if (!this._isBuffer(start))
        start = String(start);
      if (!this._isBuffer(end))
        end = String(end);
      if (typeof this._approximateSize == "function")
        return this._approximateSize(start, end, callback);
      process.nextTick(function() {
        callback(null, 0);
      });
    };
    AbstractLevelDOWN.prototype._setupIteratorOptions = function(options) {
      var self2 = this;
      options = xtend(options);
      ["start", "end", "gt", "gte", "lt", "lte"].forEach(function(o) {
        if (options[o] && self2._isBuffer(options[o]) && options[o].length === 0)
          delete options[o];
      });
      options.reverse = !!options.reverse;
      if (options.reverse && options.lt)
        options.start = options.lt;
      if (options.reverse && options.lte)
        options.start = options.lte;
      if (!options.reverse && options.gt)
        options.start = options.gt;
      if (!options.reverse && options.gte)
        options.start = options.gte;
      if (options.reverse && options.lt && !options.lte || !options.reverse && options.gt && !options.gte)
        options.exclusiveStart = true;
      return options;
    };
    AbstractLevelDOWN.prototype.iterator = function(options) {
      if (typeof options != "object")
        options = {};
      options = this._setupIteratorOptions(options);
      if (typeof this._iterator == "function")
        return this._iterator(options);
      return new AbstractIterator(this);
    };
    AbstractLevelDOWN.prototype._chainedBatch = function() {
      return new AbstractChainedBatch(this);
    };
    AbstractLevelDOWN.prototype._isBuffer = function(obj) {
      return Buffer.isBuffer(obj);
    };
    AbstractLevelDOWN.prototype._checkKeyValue = function(obj, type) {
      if (obj === null || obj === void 0)
        return new Error(type + " cannot be `null` or `undefined`");
      if (this._isBuffer(obj)) {
        if (obj.length === 0)
          return new Error(type + " cannot be an empty Buffer");
      } else if (String(obj) === "")
        return new Error(type + " cannot be an empty String");
    };
    module.exports.AbstractLevelDOWN = AbstractLevelDOWN;
    module.exports.AbstractIterator = AbstractIterator;
    module.exports.AbstractChainedBatch = AbstractChainedBatch;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports, module) {
    "use strict";
    module.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    module.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    module.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    module.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    module.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    module.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    module.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    module.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports, module) {
    "use strict";
    module.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports, module) {
    "use strict";
    module.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports, module) {
    "use strict";
    module.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports, module) {
    "use strict";
    module.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports, module) {
    "use strict";
    module.exports = Math.pow;
  }
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/math-intrinsics/round.js"(exports, module) {
    "use strict";
    module.exports = Math.round;
  }
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/math-intrinsics/isNaN.js"(exports, module) {
    "use strict";
    module.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/math-intrinsics/sign.js"(exports, module) {
    "use strict";
    var $isNaN = require_isNaN();
    module.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports, module) {
    "use strict";
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module) {
    "use strict";
    module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Object.getPrototypeOf.js"(exports, module) {
    "use strict";
    var $Object = require_es_object_atoms();
    module.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module) {
    "use strict";
    module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports, module) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/get-proto/index.js"(exports, module) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  "node_modules/call-bound/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/is-arguments/index.js"(exports, module) {
    "use strict";
    var hasToStringTag = require_shams2()();
    var callBound = require_call_bound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && "length" in value && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && "callee" in value && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// node_modules/is-regex/index.js
var require_is_regex = __commonJS({
  "node_modules/is-regex/index.js"(exports, module) {
    "use strict";
    var callBound = require_call_bound();
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var gOPD = require_gopd();
    var fn;
    if (hasToStringTag) {
      $exec = callBound("RegExp.prototype.exec");
      isRegexMarker = {};
      throwRegexMarker = function() {
        throw isRegexMarker;
      };
      badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
      };
      if (typeof Symbol.toPrimitive === "symbol") {
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
      }
      fn = function isRegex(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        var descriptor = (
          /** @type {NonNullable<typeof gOPD>} */
          gOPD(
            /** @type {{ lastIndex?: unknown }} */
            value,
            "lastIndex"
          )
        );
        var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
        if (!hasLastIndexDataProperty) {
          return false;
        }
        try {
          $exec(
            value,
            /** @type {string} */
            /** @type {unknown} */
            badStringifier
          );
        } catch (e) {
          return e === isRegexMarker;
        }
      };
    } else {
      $toString = callBound("Object.prototype.toString");
      regexClass = "[object RegExp]";
      fn = function isRegex(value) {
        if (!value || typeof value !== "object" && typeof value !== "function") {
          return false;
        }
        return $toString(value) === regexClass;
      };
    }
    var $exec;
    var isRegexMarker;
    var throwRegexMarker;
    var badStringifier;
    var $toString;
    var regexClass;
    module.exports = fn;
  }
});

// node_modules/safe-regex-test/index.js
var require_safe_regex_test = __commonJS({
  "node_modules/safe-regex-test/index.js"(exports, module) {
    "use strict";
    var callBound = require_call_bound();
    var isRegex = require_is_regex();
    var $exec = callBound("RegExp.prototype.exec");
    var $TypeError = require_type();
    module.exports = function regexTester(regex) {
      if (!isRegex(regex)) {
        throw new $TypeError("`regex` must be a RegExp");
      }
      return function test(s) {
        return $exec(regex, s) !== null;
      };
    };
  }
});

// node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS({
  "node_modules/is-generator-function/index.js"(exports, module) {
    "use strict";
    var callBound = require_call_bound();
    var safeRegexTest = require_safe_regex_test();
    var isFnRegex = safeRegexTest(/^\s*(?:function)?\*/);
    var hasToStringTag = require_shams2()();
    var getProto = require_get_proto();
    var toStr = callBound("Object.prototype.toString");
    var fnToStr = callBound("Function.prototype.toString");
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e) {
      }
    };
    var GeneratorFunction;
    module.exports = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex(fnToStr(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? (
          /** @type {GeneratorFunctionConstructor} */
          getProto(generatorFunc)
        ) : false;
      }
      return getProto(fn) === GeneratorFunction;
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports, module) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// node_modules/for-each/index.js
var require_for_each = __commonJS({
  "node_modules/for-each/index.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
          if (receiver == null) {
            iterator(array[i], i, array);
          } else {
            iterator.call(receiver, array[i], i, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i = 0, len = string.length; i < len; i++) {
        if (receiver == null) {
          iterator(string.charAt(i), i, string);
        } else {
          iterator.call(receiver, string.charAt(i), i, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
          if (receiver == null) {
            iterator(object[k], k, object);
          } else {
            iterator.call(receiver, object[k], k, object);
          }
        }
      }
    };
    function isArray(x) {
      return toStr.call(x) === "[object Array]";
    }
    module.exports = function forEach(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (isArray(list)) {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
  }
});

// node_modules/possible-typed-array-names/index.js
var require_possible_typed_array_names = __commonJS({
  "node_modules/possible-typed-array-names/index.js"(exports, module) {
    "use strict";
    module.exports = [
      "Float16Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports, module) {
    "use strict";
    var possibleNames = require_possible_typed_array_names();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    module.exports = function availableTypedArrays() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    };
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// node_modules/call-bind-apply-helpers/applyBind.js
var require_applyBind = __commonJS({
  "node_modules/call-bind-apply-helpers/applyBind.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var actualApply = require_actualApply();
    module.exports = function applyBind() {
      return actualApply(bind, $apply, arguments);
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var setFunctionLength = require_set_function_length();
    var $defineProperty = require_es_define_property();
    var callBindBasic = require_call_bind_apply_helpers();
    var applyBind = require_applyBind();
    module.exports = function callBind(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports, module) {
    "use strict";
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBind = require_call_bind();
    var callBound = require_call_bound();
    var gOPD = require_gopd();
    var getProto = require_get_proto();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var cache = { __proto__: null };
    if (hasToStringTag && gOPD && getProto) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr && getProto) {
          var proto = getProto(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor && proto) {
            var superProto = getProto(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          cache["$" + typedArray] = callBind(descriptor.get);
        }
      });
    } else {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        var fn = arr.slice || arr.set;
        if (fn) {
          cache[
            /** @type {`$${import('.').TypedArrayName}`} */
            "$" + typedArray
          ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
          // @ts-expect-error TODO FIXME
          callBind(fn);
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var found = false;
      forEach(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, typedArray) {
          if (!found) {
            try {
              if ("$" + getter(value) === typedArray) {
                found = /** @type {import('.').TypedArrayName} */
                $slice(typedArray, 1);
              }
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    var trySlices = function tryAllSlices(value) {
      var found = false;
      forEach(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, name) {
          if (!found) {
            try {
              getter(value);
              found = /** @type {import('.').TypedArrayName} */
              $slice(name, 1);
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    module.exports = function whichTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
          return tag;
        }
        if (tag !== "Object") {
          return false;
        }
        return trySlices(value);
      }
      if (!gOPD) {
        return null;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports, module) {
    "use strict";
    var whichTypedArray = require_which_typed_array();
    module.exports = function isTypedArray(value) {
      return !!whichTypedArray(value);
    };
  }
});

// node_modules/util/support/types.js
var require_types = __commonJS({
  "node_modules/util/support/types.js"(exports) {
    "use strict";
    var isArgumentsObject = require_is_arguments();
    var isGeneratorFunction = require_is_generator_function();
    var whichTypedArray = require_which_typed_array();
    var isTypedArray = require_is_typed_array();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    var bigIntValue;
    if (SymbolSupported) {
      symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    var symbolValue;
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports.isArgumentsObject = isArgumentsObject;
    exports.isGeneratorFunction = isGeneratorFunction;
    exports.isTypedArray = isTypedArray;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray(value) || isDataView(value);
    }
    exports.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  }
});

// node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS({
  "node_modules/util/support/isBufferBrowser.js"(exports, module) {
    module.exports = function isBuffer(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/util/util.js
var require_util = __commonJS({
  "node_modules/util/util.js"(exports) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys.length; i++) {
        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%")
          return "%";
        if (i >= len)
          return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true) {
        return fn;
      }
      if (typeof process === "undefined") {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process.env.NODE_DEBUG) {
      debugEnv = process.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    var debugEnv;
    exports.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports.types = require_types();
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    exports.types.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    exports.types.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports.isError = isError;
    exports.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require_isBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = /* @__PURE__ */ new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports.log = function() {
      console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = require_inherits_browser();
    exports._extend = function(origin, add) {
      if (!add || !isObject(add))
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol)
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };
    exports.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports.callbackify = callbackify;
  }
});

// node_modules/ltgt/index.js
var require_ltgt = __commonJS({
  "node_modules/ltgt/index.js"(exports) {
    exports.compare = function(a, b) {
      if (Buffer.isBuffer(a)) {
        var l = Math.min(a.length, b.length);
        for (var i = 0; i < l; i++) {
          var cmp = a[i] - b[i];
          if (cmp)
            return cmp;
        }
        return a.length - b.length;
      }
      return a < b ? -1 : a > b ? 1 : 0;
    };
    function isDef(val) {
      return val !== void 0 && val !== "";
    }
    function has(range, name) {
      return Object.hasOwnProperty.call(range, name);
    }
    function hasKey(range, name) {
      return Object.hasOwnProperty.call(range, name) && name;
    }
    var lowerBoundKey = exports.lowerBoundKey = function(range) {
      return hasKey(range, "gt") || hasKey(range, "gte") || hasKey(range, "min") || (range.reverse ? hasKey(range, "end") : hasKey(range, "start")) || void 0;
    };
    var lowerBound = exports.lowerBound = function(range, def) {
      var k = lowerBoundKey(range);
      return k ? range[k] : def;
    };
    var lowerBoundInclusive = exports.lowerBoundInclusive = function(range) {
      return has(range, "gt") ? false : true;
    };
    var upperBoundInclusive = exports.upperBoundInclusive = function(range) {
      return has(range, "lt") ? false : true;
    };
    var lowerBoundExclusive = exports.lowerBoundExclusive = function(range) {
      return !lowerBoundInclusive(range);
    };
    var upperBoundExclusive = exports.upperBoundExclusive = function(range) {
      return !upperBoundInclusive(range);
    };
    var upperBoundKey = exports.upperBoundKey = function(range) {
      return hasKey(range, "lt") || hasKey(range, "lte") || hasKey(range, "max") || (range.reverse ? hasKey(range, "start") : hasKey(range, "end")) || void 0;
    };
    var upperBound = exports.upperBound = function(range, def) {
      var k = upperBoundKey(range);
      return k ? range[k] : def;
    };
    exports.start = function(range, def) {
      return range.reverse ? upperBound(range, def) : lowerBound(range, def);
    };
    exports.end = function(range, def) {
      return range.reverse ? lowerBound(range, def) : upperBound(range, def);
    };
    exports.startInclusive = function(range) {
      return range.reverse ? upperBoundInclusive(range) : lowerBoundInclusive(range);
    };
    exports.endInclusive = function(range) {
      return range.reverse ? lowerBoundInclusive(range) : upperBoundInclusive(range);
    };
    function id(e) {
      return e;
    }
    exports.toLtgt = function(range, _range, map, lower, upper) {
      _range = _range || {};
      map = map || id;
      var defaults = arguments.length > 3;
      var lb = exports.lowerBoundKey(range);
      var ub = exports.upperBoundKey(range);
      if (lb) {
        if (lb === "gt")
          _range.gt = map(range.gt, false);
        else
          _range.gte = map(range[lb], false);
      } else if (defaults)
        _range.gte = map(lower, false);
      if (ub) {
        if (ub === "lt")
          _range.lt = map(range.lt, true);
        else
          _range.lte = map(range[ub], true);
      } else if (defaults)
        _range.lte = map(upper, true);
      if (range.reverse != null)
        _range.reverse = !!range.reverse;
      if (has(_range, "max"))
        delete _range.max;
      if (has(_range, "min"))
        delete _range.min;
      if (has(_range, "start"))
        delete _range.start;
      if (has(_range, "end"))
        delete _range.end;
      return _range;
    };
    exports.contains = function(range, key, compare) {
      compare = compare || exports.compare;
      var lb = lowerBound(range);
      if (isDef(lb)) {
        var cmp = compare(key, lb);
        if (cmp < 0 || cmp === 0 && lowerBoundExclusive(range))
          return false;
      }
      var ub = upperBound(range);
      if (isDef(ub)) {
        var cmp = compare(key, ub);
        if (cmp > 0 || cmp === 0 && upperBoundExclusive(range))
          return false;
      }
      return true;
    };
    exports.filter = function(range, compare) {
      return function(key) {
        return exports.contains(range, key, compare);
      };
    };
  }
});

// node_modules/level-js/iterator.js
var require_iterator = __commonJS({
  "node_modules/level-js/iterator.js"(exports, module) {
    var util = require_util();
    var AbstractIterator = require_abstract_leveldown().AbstractIterator;
    var ltgt = require_ltgt();
    module.exports = Iterator;
    function Iterator(db2, options) {
      if (!options)
        options = {};
      this.options = options;
      AbstractIterator.call(this, db2);
      this._order = options.reverse ? "DESC" : "ASC";
      this._limit = options.limit;
      this._count = 0;
      this._done = false;
      var lower = ltgt.lowerBound(options);
      var upper = ltgt.upperBound(options);
      try {
        this._keyRange = lower || upper ? this.db.makeKeyRange({
          lower,
          upper,
          excludeLower: ltgt.lowerBoundExclusive(options),
          excludeUpper: ltgt.upperBoundExclusive(options)
        }) : null;
      } catch (e) {
        this._keyRangeError = true;
      }
      this.callback = null;
    }
    util.inherits(Iterator, AbstractIterator);
    Iterator.prototype.createIterator = function() {
      var self2 = this;
      self2.iterator = self2.db.iterate(function() {
        self2.onItem.apply(self2, arguments);
      }, {
        keyRange: self2._keyRange,
        autoContinue: false,
        order: self2._order,
        onError: function(err) {
          console.log("horrible error", err);
        }
      });
    };
    Iterator.prototype.onItem = function(value, cursor, cursorTransaction) {
      if (!cursor && this.callback) {
        this.callback();
        this.callback = false;
        return;
      }
      var shouldCall = true;
      if (!!this._limit && this._limit > 0 && this._count++ >= this._limit)
        shouldCall = false;
      if (shouldCall)
        this.callback(false, cursor.key, cursor.value);
      if (cursor)
        cursor["continue"]();
    };
    Iterator.prototype._next = function(callback) {
      if (!callback)
        return new Error("next() requires a callback argument");
      if (this._keyRangeError)
        return callback();
      if (!this._started) {
        this.createIterator();
        this._started = true;
      }
      this.callback = callback;
    };
  }
});

// node_modules/isbuffer/index.js
var require_isbuffer = __commonJS({
  "node_modules/isbuffer/index.js"(exports, module) {
    var Buffer2 = require_buffer().Buffer;
    module.exports = isBuffer;
    function isBuffer(o) {
      return Buffer2.isBuffer(o) || /\[object (.+Array|Array.+)\]/.test(Object.prototype.toString.call(o));
    }
  }
});

// node_modules/object-keys/foreach.js
var require_foreach = __commonJS({
  "node_modules/object-keys/foreach.js"(exports, module) {
    var hasOwn = Object.prototype.hasOwnProperty;
    var toString = Object.prototype.toString;
    var isFunction = function(fn) {
      var isFunc = typeof fn === "function" && !(fn instanceof RegExp) || toString.call(fn) === "[object Function]";
      if (!isFunc && typeof window !== "undefined") {
        isFunc = fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt;
      }
      return isFunc;
    };
    module.exports = function forEach(obj, fn) {
      if (!isFunction(fn)) {
        throw new TypeError("iterator must be a function");
      }
      var i, k, isString = typeof obj === "string", l = obj.length, context = arguments.length > 2 ? arguments[2] : null;
      if (l === +l) {
        for (i = 0; i < l; i++) {
          if (context === null) {
            fn(isString ? obj.charAt(i) : obj[i], i, obj);
          } else {
            fn.call(context, isString ? obj.charAt(i) : obj[i], i, obj);
          }
        }
      } else {
        for (k in obj) {
          if (hasOwn.call(obj, k)) {
            if (context === null) {
              fn(obj[k], k, obj);
            } else {
              fn.call(context, obj[k], k, obj);
            }
          }
        }
      }
    };
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports, module) {
    var toString = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toString.call(value);
      var isArguments2 = str === "[object Arguments]";
      if (!isArguments2) {
        isArguments2 = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toString.call(value.callee) === "[object Function]";
      }
      return isArguments2;
    };
  }
});

// node_modules/object-keys/shim.js
var require_shim = __commonJS({
  "node_modules/object-keys/shim.js"(exports, module) {
    (function() {
      "use strict";
      var has = Object.prototype.hasOwnProperty, toString = Object.prototype.toString, forEach = require_foreach(), isArgs = require_isArguments(), hasDontEnumBug = !{ "toString": null }.propertyIsEnumerable("toString"), hasProtoEnumBug = (function() {
      }).propertyIsEnumerable("prototype"), dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ], keysShim;
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object", isFunction = toString.call(object) === "[object Function]", isArguments = isArgs(object), theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        if (isArguments) {
          forEach(object, function(value) {
            theKeys.push(value);
          });
        } else {
          var name, skipProto = hasProtoEnumBug && isFunction;
          for (name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(name);
            }
          }
        }
        if (hasDontEnumBug) {
          var ctor = object.constructor, skipConstructor = ctor && ctor.prototype === object;
          forEach(dontEnums, function(dontEnum) {
            if (!(skipConstructor && dontEnum === "constructor") && has.call(object, dontEnum)) {
              theKeys.push(dontEnum);
            }
          });
        }
        return theKeys;
      };
      module.exports = keysShim;
    })();
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports, module) {
    module.exports = Object.keys || require_shim();
  }
});

// node_modules/level-js/node_modules/xtend/has-keys.js
var require_has_keys = __commonJS({
  "node_modules/level-js/node_modules/xtend/has-keys.js"(exports, module) {
    module.exports = hasKeys;
    function hasKeys(source) {
      return source !== null && (typeof source === "object" || typeof source === "function");
    }
  }
});

// node_modules/level-js/node_modules/xtend/index.js
var require_xtend2 = __commonJS({
  "node_modules/level-js/node_modules/xtend/index.js"(exports, module) {
    var Keys = require_object_keys();
    var hasKeys = require_has_keys();
    module.exports = extend;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        if (!hasKeys(source)) {
          continue;
        }
        var keys = Keys(source);
        for (var j = 0; j < keys.length; j++) {
          var name = keys[j];
          target[name] = source[name];
        }
      }
      return target;
    }
  }
});

// node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "node_modules/typedarray-to-buffer/index.js"(exports, module) {
    module.exports = function(arr) {
      if (typeof Buffer._augment === "function" && Buffer.TYPED_ARRAY_SUPPORT) {
        return Buffer._augment(arr);
      } else {
        return new Buffer(arr);
      }
    };
  }
});

// node_modules/level-js/index.js
var require_level_js = __commonJS({
  "node_modules/level-js/index.js"(exports, module) {
    module.exports = Level;
    var IDB = require_idbstore();
    var AbstractLevelDOWN = require_abstract_leveldown().AbstractLevelDOWN;
    var util = require_util();
    var Iterator = require_iterator();
    var isBuffer = require_isbuffer();
    var xtend = require_xtend2();
    var toBuffer = require_typedarray_to_buffer();
    function Level(location) {
      if (!(this instanceof Level))
        return new Level(location);
      if (!location)
        throw new Error("constructor requires at least a location argument");
      this.IDBOptions = {};
      this.location = location;
    }
    util.inherits(Level, AbstractLevelDOWN);
    Level.prototype._open = function(options, callback) {
      var self2 = this;
      var idbOpts = {
        storeName: this.location,
        autoIncrement: false,
        keyPath: null,
        onStoreReady: function() {
          callback && callback(null, self2.idb);
        },
        onError: function(err) {
          callback && callback(err);
        }
      };
      xtend(idbOpts, options);
      this.IDBOptions = idbOpts;
      this.idb = new IDB(idbOpts);
    };
    Level.prototype._get = function(key, options, callback) {
      this.idb.get(key, function(value) {
        if (value === void 0) {
          return callback(new Error("NotFound"));
        }
        var asBuffer = true;
        if (options.asBuffer === false)
          asBuffer = false;
        if (options.raw)
          asBuffer = false;
        if (asBuffer) {
          if (value instanceof Uint8Array)
            value = toBuffer(value);
          else
            value = new Buffer(String(value));
        }
        return callback(null, value, key);
      }, callback);
    };
    Level.prototype._del = function(id, options, callback) {
      this.idb.remove(id, callback, callback);
    };
    Level.prototype._put = function(key, value, options, callback) {
      if (value instanceof ArrayBuffer) {
        value = toBuffer(new Uint8Array(value));
      }
      var obj = this.convertEncoding(key, value, options);
      if (Buffer.isBuffer(obj.value)) {
        if (typeof value.toArrayBuffer === "function") {
          obj.value = new Uint8Array(value.toArrayBuffer());
        } else {
          obj.value = new Uint8Array(value);
        }
      }
      this.idb.put(obj.key, obj.value, function() {
        callback();
      }, callback);
    };
    Level.prototype.convertEncoding = function(key, value, options) {
      if (options.raw)
        return { key, value };
      if (value) {
        var stringed = value.toString();
        if (stringed === "NaN")
          value = "NaN";
      }
      var valEnc = options.valueEncoding;
      var obj = { key, value };
      if (value && (!valEnc || valEnc !== "binary")) {
        if (typeof obj.value !== "object") {
          obj.value = stringed;
        }
      }
      return obj;
    };
    Level.prototype.iterator = function(options) {
      if (typeof options !== "object")
        options = {};
      return new Iterator(this.idb, options);
    };
    Level.prototype._batch = function(array, options, callback) {
      var op;
      var i;
      var k;
      var copiedOp;
      var currentOp;
      var modified = [];
      if (array.length === 0)
        return setTimeout(callback, 0);
      for (i = 0; i < array.length; i++) {
        copiedOp = {};
        currentOp = array[i];
        modified[i] = copiedOp;
        var converted = this.convertEncoding(currentOp.key, currentOp.value, options);
        currentOp.key = converted.key;
        currentOp.value = converted.value;
        for (k in currentOp) {
          if (k === "type" && currentOp[k] == "del") {
            copiedOp[k] = "remove";
          } else {
            copiedOp[k] = currentOp[k];
          }
        }
      }
      return this.idb.batch(modified, function() {
        callback();
      }, callback);
    };
    Level.prototype._close = function(callback) {
      this.idb.db.close();
      callback();
    };
    Level.prototype._approximateSize = function(start, end, callback) {
      var err = new Error("Not implemented");
      if (callback)
        return callback(err);
      throw err;
    };
    Level.prototype._isBuffer = function(obj) {
      return Buffer.isBuffer(obj);
    };
    Level.destroy = function(db2, callback) {
      if (typeof db2 === "object") {
        var prefix = db2.IDBOptions.storePrefix || "IDBWrapper-";
        var dbname = db2.location;
      } else {
        var prefix = "IDBWrapper-";
        var dbname = db2;
      }
      var request = indexedDB.deleteDatabase(prefix + dbname);
      request.onsuccess = function() {
        callback();
      };
      request.onerror = function(err) {
        callback(err);
      };
    };
    var checkKeyValue = Level.prototype._checkKeyValue = function(obj, type) {
      if (obj === null || obj === void 0)
        return new Error(type + " cannot be `null` or `undefined`");
      if (obj === null || obj === void 0)
        return new Error(type + " cannot be `null` or `undefined`");
      if (isBuffer(obj) && obj.byteLength === 0)
        return new Error(type + " cannot be an empty ArrayBuffer");
      if (String(obj) === "")
        return new Error(type + " cannot be an empty String");
      if (obj.length === 0)
        return new Error(type + " cannot be an empty Array");
    };
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/levelup/node_modules/xtend/index.js
var require_xtend3 = __commonJS({
  "node_modules/levelup/node_modules/xtend/index.js"(exports, module) {
    module.exports = extend;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/levelup/node_modules/prr/prr.js
var require_prr = __commonJS({
  "node_modules/levelup/node_modules/prr/prr.js"(exports, module) {
    (function(name, context, definition) {
      if (typeof module != "undefined" && module.exports)
        module.exports = definition();
      else
        context[name] = definition();
    })("prr", exports, function() {
      var setProperty = typeof Object.defineProperty == "function" ? function(obj, key, options) {
        Object.defineProperty(obj, key, options);
        return obj;
      } : function(obj, key, options) {
        obj[key] = options.value;
        return obj;
      }, makeOptions = function(value, options) {
        var oo = typeof options == "object", os = !oo && typeof options == "string", op = function(p) {
          return oo ? !!options[p] : os ? options.indexOf(p[0]) > -1 : false;
        };
        return {
          enumerable: op("enumerable"),
          configurable: op("configurable"),
          writable: op("writable"),
          value
        };
      }, prr = function(obj, key, value, options) {
        var k;
        options = makeOptions(value, options);
        if (typeof key == "object") {
          for (k in key) {
            if (Object.hasOwnProperty.call(key, k)) {
              options.value = key[k];
              setProperty(obj, k, options);
            }
          }
          return obj;
        }
        return setProperty(obj, key, options);
      };
      return prr;
    });
  }
});

// node_modules/deferred-leveldown/deferred-leveldown.js
var require_deferred_leveldown = __commonJS({
  "node_modules/deferred-leveldown/deferred-leveldown.js"(exports, module) {
    var util = require_util();
    var AbstractLevelDOWN = require_abstract_leveldown().AbstractLevelDOWN;
    function DeferredLevelDOWN(location) {
      AbstractLevelDOWN.call(this, typeof location == "string" ? location : "");
      this._db = void 0;
      this._operations = [];
    }
    util.inherits(DeferredLevelDOWN, AbstractLevelDOWN);
    DeferredLevelDOWN.prototype.setDb = function(db2) {
      this._db = db2;
      this._operations.forEach(function(op) {
        db2[op.method].apply(db2, op.args);
      });
    };
    DeferredLevelDOWN.prototype._open = function(options, callback) {
      return process.nextTick(callback);
    };
    DeferredLevelDOWN.prototype._operation = function(method, args) {
      if (this._db)
        return this._db[method].apply(this._db, args);
      this._operations.push({ method, args });
    };
    "put get del batch approximateSize".split(" ").forEach(function(m) {
      DeferredLevelDOWN.prototype["_" + m] = function() {
        this._operation(m, arguments);
      };
    });
    DeferredLevelDOWN.prototype._isBuffer = function(obj) {
      return Buffer.isBuffer(obj);
    };
    DeferredLevelDOWN.prototype._iterator = function() {
      throw new TypeError("not implemented");
    };
    module.exports = DeferredLevelDOWN;
  }
});

// node_modules/prr/prr.js
var require_prr2 = __commonJS({
  "node_modules/prr/prr.js"(exports, module) {
    (function(name, context, definition) {
      if (typeof module != "undefined" && module.exports)
        module.exports = definition();
      else
        context[name] = definition();
    })("prr", exports, function() {
      var setProperty = typeof Object.defineProperty == "function" ? function(obj, key, options) {
        Object.defineProperty(obj, key, options);
        return obj;
      } : function(obj, key, options) {
        obj[key] = options.value;
        return obj;
      }, makeOptions = function(value, options) {
        var oo = typeof options == "object", os = !oo && typeof options == "string", op = function(p) {
          return oo ? !!options[p] : os ? options.indexOf(p[0]) > -1 : false;
        };
        return {
          enumerable: op("enumerable"),
          configurable: op("configurable"),
          writable: op("writable"),
          value
        };
      }, prr = function(obj, key, value, options) {
        var k;
        options = makeOptions(value, options);
        if (typeof key == "object") {
          for (k in key) {
            if (Object.hasOwnProperty.call(key, k)) {
              options.value = key[k];
              setProperty(obj, k, options);
            }
          }
          return obj;
        }
        return setProperty(obj, key, options);
      };
      return prr;
    });
  }
});

// node_modules/errno/custom.js
var require_custom = __commonJS({
  "node_modules/errno/custom.js"(exports, module) {
    var prr = require_prr2();
    function init(type, message, cause) {
      if (!!message && typeof message != "string") {
        message = message.message || message.name;
      }
      prr(this, {
        type,
        name: type,
        cause: typeof message != "string" ? message : cause,
        message
      }, "ewr");
    }
    function CustomError(message, cause) {
      Error.call(this);
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, this.constructor);
      init.call(this, "CustomError", message, cause);
    }
    CustomError.prototype = new Error();
    function createError(errno, type, proto) {
      var err = function(message, cause) {
        init.call(this, type, message, cause);
        if (type == "FilesystemError") {
          this.code = this.cause.code;
          this.path = this.cause.path;
          this.errno = this.cause.errno;
          this.message = (errno.errno[this.cause.errno] ? errno.errno[this.cause.errno].description : this.cause.message) + (this.cause.path ? " [" + this.cause.path + "]" : "");
        }
        Error.call(this);
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, err);
      };
      err.prototype = !!proto ? new proto() : new CustomError();
      return err;
    }
    module.exports = function(errno) {
      var ce = function(type, proto) {
        return createError(errno, type, proto);
      };
      return {
        CustomError,
        FilesystemError: ce("FilesystemError"),
        createError: ce
      };
    };
  }
});

// node_modules/errno/errno.js
var require_errno = __commonJS({
  "node_modules/errno/errno.js"(exports, module) {
    var all = module.exports.all = [
      {
        errno: -2,
        code: "ENOENT",
        description: "no such file or directory"
      },
      {
        errno: -1,
        code: "UNKNOWN",
        description: "unknown error"
      },
      {
        errno: 0,
        code: "OK",
        description: "success"
      },
      {
        errno: 1,
        code: "EOF",
        description: "end of file"
      },
      {
        errno: 2,
        code: "EADDRINFO",
        description: "getaddrinfo error"
      },
      {
        errno: 3,
        code: "EACCES",
        description: "permission denied"
      },
      {
        errno: 4,
        code: "EAGAIN",
        description: "resource temporarily unavailable"
      },
      {
        errno: 5,
        code: "EADDRINUSE",
        description: "address already in use"
      },
      {
        errno: 6,
        code: "EADDRNOTAVAIL",
        description: "address not available"
      },
      {
        errno: 7,
        code: "EAFNOSUPPORT",
        description: "address family not supported"
      },
      {
        errno: 8,
        code: "EALREADY",
        description: "connection already in progress"
      },
      {
        errno: 9,
        code: "EBADF",
        description: "bad file descriptor"
      },
      {
        errno: 10,
        code: "EBUSY",
        description: "resource busy or locked"
      },
      {
        errno: 11,
        code: "ECONNABORTED",
        description: "software caused connection abort"
      },
      {
        errno: 12,
        code: "ECONNREFUSED",
        description: "connection refused"
      },
      {
        errno: 13,
        code: "ECONNRESET",
        description: "connection reset by peer"
      },
      {
        errno: 14,
        code: "EDESTADDRREQ",
        description: "destination address required"
      },
      {
        errno: 15,
        code: "EFAULT",
        description: "bad address in system call argument"
      },
      {
        errno: 16,
        code: "EHOSTUNREACH",
        description: "host is unreachable"
      },
      {
        errno: 17,
        code: "EINTR",
        description: "interrupted system call"
      },
      {
        errno: 18,
        code: "EINVAL",
        description: "invalid argument"
      },
      {
        errno: 19,
        code: "EISCONN",
        description: "socket is already connected"
      },
      {
        errno: 20,
        code: "EMFILE",
        description: "too many open files"
      },
      {
        errno: 21,
        code: "EMSGSIZE",
        description: "message too long"
      },
      {
        errno: 22,
        code: "ENETDOWN",
        description: "network is down"
      },
      {
        errno: 23,
        code: "ENETUNREACH",
        description: "network is unreachable"
      },
      {
        errno: 24,
        code: "ENFILE",
        description: "file table overflow"
      },
      {
        errno: 25,
        code: "ENOBUFS",
        description: "no buffer space available"
      },
      {
        errno: 26,
        code: "ENOMEM",
        description: "not enough memory"
      },
      {
        errno: 27,
        code: "ENOTDIR",
        description: "not a directory"
      },
      {
        errno: 28,
        code: "EISDIR",
        description: "illegal operation on a directory"
      },
      {
        errno: 29,
        code: "ENONET",
        description: "machine is not on the network"
      },
      {
        errno: 31,
        code: "ENOTCONN",
        description: "socket is not connected"
      },
      {
        errno: 32,
        code: "ENOTSOCK",
        description: "socket operation on non-socket"
      },
      {
        errno: 33,
        code: "ENOTSUP",
        description: "operation not supported on socket"
      },
      {
        errno: 34,
        code: "ENOENT",
        description: "no such file or directory"
      },
      {
        errno: 35,
        code: "ENOSYS",
        description: "function not implemented"
      },
      {
        errno: 36,
        code: "EPIPE",
        description: "broken pipe"
      },
      {
        errno: 37,
        code: "EPROTO",
        description: "protocol error"
      },
      {
        errno: 38,
        code: "EPROTONOSUPPORT",
        description: "protocol not supported"
      },
      {
        errno: 39,
        code: "EPROTOTYPE",
        description: "protocol wrong type for socket"
      },
      {
        errno: 40,
        code: "ETIMEDOUT",
        description: "connection timed out"
      },
      {
        errno: 41,
        code: "ECHARSET",
        description: "invalid Unicode character"
      },
      {
        errno: 42,
        code: "EAIFAMNOSUPPORT",
        description: "address family for hostname not supported"
      },
      {
        errno: 44,
        code: "EAISERVICE",
        description: "servname not supported for ai_socktype"
      },
      {
        errno: 45,
        code: "EAISOCKTYPE",
        description: "ai_socktype not supported"
      },
      {
        errno: 46,
        code: "ESHUTDOWN",
        description: "cannot send after transport endpoint shutdown"
      },
      {
        errno: 47,
        code: "EEXIST",
        description: "file already exists"
      },
      {
        errno: 48,
        code: "ESRCH",
        description: "no such process"
      },
      {
        errno: 49,
        code: "ENAMETOOLONG",
        description: "name too long"
      },
      {
        errno: 50,
        code: "EPERM",
        description: "operation not permitted"
      },
      {
        errno: 51,
        code: "ELOOP",
        description: "too many symbolic links encountered"
      },
      {
        errno: 52,
        code: "EXDEV",
        description: "cross-device link not permitted"
      },
      {
        errno: 53,
        code: "ENOTEMPTY",
        description: "directory not empty"
      },
      {
        errno: 54,
        code: "ENOSPC",
        description: "no space left on device"
      },
      {
        errno: 55,
        code: "EIO",
        description: "i/o error"
      },
      {
        errno: 56,
        code: "EROFS",
        description: "read-only file system"
      },
      {
        errno: 57,
        code: "ENODEV",
        description: "no such device"
      },
      {
        errno: 58,
        code: "ESPIPE",
        description: "invalid seek"
      },
      {
        errno: 59,
        code: "ECANCELED",
        description: "operation canceled"
      }
    ];
    module.exports.errno = {};
    module.exports.code = {};
    all.forEach(function(error) {
      module.exports.errno[error.errno] = error;
      module.exports.code[error.code] = error;
    });
    module.exports.custom = require_custom()(module.exports);
    module.exports.create = module.exports.custom.createError;
  }
});

// node_modules/levelup/lib/errors.js
var require_errors = __commonJS({
  "node_modules/levelup/lib/errors.js"(exports, module) {
    var createError = require_errno().create;
    var LevelUPError = createError("LevelUPError");
    var NotFoundError = createError("NotFoundError", LevelUPError);
    NotFoundError.prototype.notFound = true;
    NotFoundError.prototype.status = 404;
    module.exports = {
      LevelUPError,
      InitializationError: createError("InitializationError", LevelUPError),
      OpenError: createError("OpenError", LevelUPError),
      ReadError: createError("ReadError", LevelUPError),
      WriteError: createError("WriteError", LevelUPError),
      NotFoundError,
      EncodingError: createError("EncodingError", LevelUPError)
    };
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/levelup/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/levelup/node_modules/isarray/index.js"(exports, module) {
    module.exports = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/core-util-is/lib/util.js
var require_util2 = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require_buffer().Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/levelup/node_modules/string_decoder/index.js
var require_string_decoder = __commonJS({
  "node_modules/levelup/node_modules/string_decoder/index.js"(exports) {
    var Buffer2 = require_buffer().Buffer;
    var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error("Unknown encoding: " + encoding);
      }
    }
    var StringDecoder = exports.StringDecoder = function(encoding) {
      this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
      assertEncoding(encoding);
      switch (this.encoding) {
        case "utf8":
          this.surrogateSize = 3;
          break;
        case "ucs2":
        case "utf16le":
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case "base64":
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
      this.charBuffer = new Buffer2(6);
      this.charReceived = 0;
      this.charLength = 0;
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
  }
});

// node_modules/levelup/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/levelup/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    module.exports = Readable;
    var isArray = require_isarray();
    var Buffer2 = require_buffer().Buffer;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    if (!EE.listenerCount)
      EE.listenerCount = function(emitter, type) {
        return emitter.listeners(type).length;
      };
    var Stream = require_stream();
    var util = require_util2();
    util.inherits = require_inherits_browser();
    var StringDecoder;
    util.inherits(Readable, Stream);
    function ReadableState(options, stream) {
      options = options || {};
      var hwm = options.highWaterMark;
      this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = false;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.calledRead = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.objectMode = !!options.objectMode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      Stream.call(this);
    }
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (typeof chunk === "string" && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer2(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (chunk === null || chunk === void 0) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error("stream.push() after EOF");
          stream.emit("error", e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error("stream.unshift() after end event");
          stream.emit("error", e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) {
            state.buffer.unshift(chunk);
          } else {
            state.reading = false;
            state.buffer.push(chunk);
          }
          if (state.needReadable)
            emitReadable(stream);
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
    };
    var MAX_HWM = 8388608;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        for (var p = 1; p < 32; p <<= 1)
          n |= n >> p;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return n === 0 ? 0 : 1;
      if (n === null || isNaN(n)) {
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
      if (n <= 0)
        return 0;
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
      return n;
    }
    Readable.prototype.read = function(n) {
      var state = this._readableState;
      state.calledRead = true;
      var nOrig = n;
      var ret;
      if (typeof n !== "number" || n > 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        ret = null;
        if (state.length > 0 && state.decoder) {
          ret = fromList(n, state);
          state.length -= ret.length;
        }
        if (state.length === 0)
          endReadable(this);
        return ret;
      }
      var doRead = state.needReadable;
      if (state.length - n <= state.highWaterMark)
        doRead = true;
      if (state.ended || state.reading)
        doRead = false;
      if (doRead) {
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
      }
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      }
      state.length -= n;
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
      if (state.ended && !state.endEmitted && state.length === 0)
        endReadable(this);
      return ret;
    };
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!Buffer2.isBuffer(chunk) && "string" !== typeof chunk && chunk !== null && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.length > 0)
        emitReadable(stream);
      else
        endReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (state.emittedReadable)
        return;
      state.emittedReadable = true;
      if (state.sync)
        process.nextTick(function() {
          emitReadable_(stream);
        });
      else
        emitReadable_(stream);
    }
    function emitReadable_(stream) {
      stream.emit("readable");
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        if (readable !== src)
          return;
        cleanup();
      }
      function onend() {
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      function cleanup() {
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", cleanup);
        if (!dest._writableState || dest._writableState.needDrain)
          ondrain();
      }
      function onerror(er) {
        unpipe();
        dest.removeListener("error", onerror);
        if (EE.listenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      if (!dest._events || !dest._events.error)
        dest.on("error", onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        this.on("readable", pipeOnReadable);
        state.flowing = true;
        process.nextTick(function() {
          flow(src);
        });
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var dest = this;
        var state = src._readableState;
        state.awaitDrain--;
        if (state.awaitDrain === 0)
          flow(src);
      };
    }
    function flow(src) {
      var state = src._readableState;
      var chunk;
      state.awaitDrain = 0;
      function write(dest, i, list) {
        var written = dest.write(chunk);
        if (false === written) {
          state.awaitDrain++;
        }
      }
      while (state.pipesCount && null !== (chunk = src.read())) {
        if (state.pipesCount === 1)
          write(state.pipes, 0, null);
        else
          forEach(state.pipes, write);
        src.emit("data", chunk);
        if (state.awaitDrain > 0)
          return;
      }
      if (state.pipesCount === 0) {
        state.flowing = false;
        if (EE.listenerCount(src, "data") > 0)
          emitDataEvents(src);
        return;
      }
      state.ranOut = true;
    }
    function pipeOnReadable() {
      if (this._readableState.ranOut) {
        this._readableState.ranOut = false;
        flow(this);
      }
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener("readable", pipeOnReadable);
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener("readable", pipeOnReadable);
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this);
        return this;
      }
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data" && !this._readableState.flowing)
        emitDataEvents(this);
      if (ev === "readable" && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            this.read(0);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      emitDataEvents(this);
      this.read(0);
      this.emit("resume");
    };
    Readable.prototype.pause = function() {
      emitDataEvents(this, true);
      this.emit("pause");
    };
    function emitDataEvents(stream, startPaused) {
      var state = stream._readableState;
      if (state.flowing) {
        throw new Error("Cannot switch to old mode now.");
      }
      var paused = startPaused || false;
      var readable = false;
      stream.readable = true;
      stream.pipe = Stream.prototype.pipe;
      stream.on = stream.addListener = Stream.prototype.on;
      stream.on("readable", function() {
        readable = true;
        var c;
        while (!paused && null !== (c = stream.read()))
          stream.emit("data", c);
        if (c === null) {
          readable = false;
          stream._readableState.needReadable = true;
        }
      });
      stream.pause = function() {
        paused = true;
        this.emit("pause");
      };
      stream.resume = function() {
        paused = false;
        if (readable)
          process.nextTick(function() {
            stream.emit("readable");
          });
        else
          this.read(0);
        this.emit("resume");
      };
      stream.emit("readable");
    }
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (typeof stream[i] === "function" && typeof this[i] === "undefined") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
      if (list.length === 0)
        return null;
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        if (stringMode)
          ret = list.join("");
        else
          ret = Buffer2.concat(list, length);
        list.length = 0;
      } else {
        if (n < list[0].length) {
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          ret = list.shift();
        } else {
          if (stringMode)
            ret = "";
          else
            ret = new Buffer2(n);
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
            c += cpy;
          }
        }
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error("endReadable called on non-empty stream");
      if (!state.endEmitted && state.calledRead) {
        state.ended = true;
        process.nextTick(function() {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit("end");
          }
        });
      }
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/levelup/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/levelup/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    module.exports = Duplex;
    var objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj)
        keys.push(key);
      return keys;
    };
    var util = require_util2();
    util.inherits = require_inherits_browser();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    forEach(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      process.nextTick(this.end.bind(this));
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
  }
});

// node_modules/levelup/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/levelup/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    module.exports = Writable;
    var Buffer2 = require_buffer().Buffer;
    Writable.WritableState = WritableState;
    var util = require_util2();
    util.inherits = require_inherits_browser();
    var Stream = require_stream();
    util.inherits(Writable, Stream);
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    function WritableState(options, stream) {
      options = options || {};
      var hwm = options.highWaterMark;
      this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024;
      this.objectMode = !!options.objectMode;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.buffer = [];
      this.errorEmitted = false;
    }
    function Writable(options) {
      var Duplex = require_stream_duplex();
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe. Not readable."));
    };
    function writeAfterEnd(stream, state, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      process.nextTick(function() {
        cb(er);
      });
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!Buffer2.isBuffer(chunk) && "string" !== typeof chunk && chunk !== null && chunk !== void 0 && !state.objectMode) {
        var er = new TypeError("Invalid non-string/buffer chunk");
        stream.emit("error", er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = function() {
        };
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb))
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      return ret;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = new Buffer2(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, len, chunk, encoding, cb);
      return ret;
    }
    function doWrite(stream, state, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          cb(er);
        });
      else
        cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(stream, state);
        if (!finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(stream, state);
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      cb();
      if (finished)
        finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      for (var c = 0; c < state.buffer.length; c++) {
        var entry = state.buffer[c];
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, len, chunk, encoding, cb);
        if (state.writing) {
          c++;
          break;
        }
      }
      state.bufferProcessing = false;
      if (c < state.buffer.length)
        state.buffer = state.buffer.slice(c);
      else
        state.buffer.length = 0;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (typeof chunk !== "undefined" && chunk !== null)
        this.write(chunk, encoding);
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(stream, state) {
      return state.ending && state.length === 0 && !state.finished && !state.writing;
    }
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        state.finished = true;
        stream.emit("finish");
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
    }
  }
});

// node_modules/levelup/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/levelup/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    module.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = require_util2();
    util.inherits = require_inherits_browser();
    util.inherits(Transform, Duplex);
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb)
        return stream.emit("error", new Error("no writecb in Transform class"));
      ts.writechunk = null;
      ts.writecb = null;
      if (data !== null && data !== void 0)
        stream.push(data);
      if (cb)
        cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      var ts = this._transformState = new TransformState(options, this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      this.once("finish", function() {
        if ("function" === typeof this._flush)
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er)
        return stream.emit("error", er);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var ts = stream._transformState;
      if (ws.length)
        throw new Error("calling transform done when ws.length != 0");
      if (ts.transforming)
        throw new Error("calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/levelup/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/levelup/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    module.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = require_util2();
    util.inherits = require_inherits_browser();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/levelup/node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/levelup/node_modules/readable-stream/readable.js"(exports, module) {
    var Stream = require_stream();
    exports = module.exports = require_stream_readable();
    exports.Stream = Stream;
    exports.Readable = exports;
    exports.Writable = require_stream_writable();
    exports.Duplex = require_stream_duplex();
    exports.Transform = require_stream_transform();
    exports.PassThrough = require_stream_passthrough();
    if (!process.browser && process.env.READABLE_STREAM === "disable") {
      module.exports = require_stream();
    }
  }
});

// node_modules/levelup/package.json
var require_package = __commonJS({
  "node_modules/levelup/package.json"(exports, module) {
    module.exports = {
      name: "levelup",
      description: "Fast & simple storage - a Node.js-style LevelDB wrapper",
      version: "0.18.6",
      contributors: [
        "Rod Vagg <r@va.gg> (https://github.com/rvagg)",
        "John Chesley <john@chesl.es> (https://github.com/chesles/)",
        "Jake Verbaten <raynos2@gmail.com> (https://github.com/raynos)",
        "Dominic Tarr <dominic.tarr@gmail.com> (https://github.com/dominictarr)",
        "Max Ogden <max@maxogden.com> (https://github.com/maxogden)",
        "Lars-Magnus Skog <lars.magnus.skog@gmail.com> (https://github.com/ralphtheninja)",
        "David BjÃ¶rklund <david.bjorklund@gmail.com> (https://github.com/kesla)",
        "Julian Gruber <julian@juliangruber.com> (https://github.com/juliangruber)",
        "Paolo Fragomeni <paolo@async.ly> (https://github.com/hij1nx)",
        "Anton Whalley <anton.whalley@nearform.com> (https://github.com/No9)",
        "Matteo Collina <matteo.collina@gmail.com> (https://github.com/mcollina)",
        "Pedro Teixeira <pedro.teixeira@gmail.com> (https://github.com/pgte)",
        "James Halliday <mail@substack.net> (https://github.com/substack)"
      ],
      repository: {
        type: "git",
        url: "https://github.com/rvagg/node-levelup.git"
      },
      homepage: "https://github.com/rvagg/node-levelup",
      keywords: [
        "leveldb",
        "stream",
        "database",
        "db",
        "store",
        "storage",
        "json"
      ],
      main: "lib/levelup.js",
      dependencies: {
        bl: "~0.8.1",
        "deferred-leveldown": "~0.2.0",
        errno: "~0.1.1",
        prr: "~0.0.0",
        "readable-stream": "~1.0.26",
        semver: "~2.3.1",
        xtend: "~3.0.0"
      },
      devDependencies: {
        leveldown: "~0.10.0",
        bustermove: "*",
        tap: "*",
        referee: "*",
        rimraf: "*",
        async: "*",
        fstream: "*",
        tar: "*",
        mkfiletree: "*",
        readfiletree: "*",
        "slow-stream": ">=0.0.4",
        delayed: "*",
        boganipsum: "*",
        du: "*",
        memdown: "*",
        "msgpack-js": "*"
      },
      browser: {
        leveldown: false,
        "leveldown/package": false,
        semver: false
      },
      scripts: {
        test: "tap test/*-test.js --stderr",
        functionaltests: "node ./test/functional/fstream-test.js && node ./test/functional/binary-data-test.js && node ./test/functional/compat-test.js",
        alltests: "npm test && npm run-script functionaltests"
      },
      license: "MIT"
    };
  }
});

// browser-external:leveldown/package
var require_package2 = __commonJS({
  "browser-external:leveldown/package"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "leveldown/package" has been externalized for browser compatibility. Cannot access "leveldown/package.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:semver
var require_semver = __commonJS({
  "browser-external:semver"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "semver" has been externalized for browser compatibility. Cannot access "semver.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:leveldown
var require_leveldown = __commonJS({
  "browser-external:leveldown"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "leveldown" has been externalized for browser compatibility. Cannot access "leveldown.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/levelup/lib/util.js
var require_util3 = __commonJS({
  "node_modules/levelup/lib/util.js"(exports, module) {
    var extend = require_xtend3();
    var LevelUPError = require_errors().LevelUPError;
    var encodingNames = [
      "hex",
      "utf8",
      "utf-8",
      "ascii",
      "binary",
      "base64",
      "ucs2",
      "ucs-2",
      "utf16le",
      "utf-16le"
    ];
    var defaultOptions = {
      createIfMissing: true,
      errorIfExists: false,
      keyEncoding: "utf8",
      valueEncoding: "utf8",
      compression: true
    };
    var leveldown;
    var encodings = function() {
      function isBinary(data) {
        return data === void 0 || data === null || Buffer.isBuffer(data);
      }
      var encodings2 = {};
      encodings2.utf8 = encodings2["utf-8"] = {
        encode: function(data) {
          return isBinary(data) ? data : String(data);
        },
        decode: function(data) {
          return data;
        },
        buffer: false,
        type: "utf8"
      };
      encodings2.json = {
        encode: JSON.stringify,
        decode: JSON.parse,
        buffer: false,
        type: "json"
      };
      encodingNames.forEach(function(type) {
        if (encodings2[type])
          return;
        encodings2[type] = {
          encode: function(data) {
            return isBinary(data) ? data : new Buffer(data, type);
          },
          decode: function(buffer) {
            return process.browser ? buffer.toString(type) : buffer;
          },
          buffer: true,
          type
          // useful for debugging purposes
        };
      });
      return encodings2;
    }();
    var encodingOpts = function() {
      var eo = {};
      encodingNames.forEach(function(e) {
        eo[e] = { valueEncoding: e };
      });
      return eo;
    }();
    function copy(srcdb, dstdb, callback) {
      srcdb.readStream().pipe(dstdb.writeStream()).on("close", callback ? callback : function() {
      }).on("error", callback ? callback : function(err) {
        throw err;
      });
    }
    function getOptions(levelup, options) {
      var s = typeof options == "string";
      if (!s && options && options.encoding && !options.valueEncoding)
        options.valueEncoding = options.encoding;
      return extend(
        levelup && levelup.options || {},
        s ? encodingOpts[options] || encodingOpts[defaultOptions.valueEncoding] : options
      );
    }
    function getLevelDOWN() {
      if (leveldown)
        return leveldown;
      var requiredVersion = require_package().devDependencies.leveldown, missingLevelDOWNError = "Could not locate LevelDOWN, try `npm install leveldown`", leveldownVersion;
      try {
        leveldownVersion = require_package2().version;
      } catch (e) {
        throw new LevelUPError(missingLevelDOWNError);
      }
      if (!require_semver().satisfies(leveldownVersion, requiredVersion)) {
        throw new LevelUPError(
          "Installed version of LevelDOWN (" + leveldownVersion + ") does not match required version (" + requiredVersion + ")"
        );
      }
      try {
        return leveldown = require_leveldown();
      } catch (e) {
        throw new LevelUPError(missingLevelDOWNError);
      }
    }
    function dispatchError(levelup, error, callback) {
      return typeof callback == "function" ? callback(error) : levelup.emit("error", error);
    }
    function getKeyEncoder(options, op) {
      var type = op && op.keyEncoding || options.keyEncoding || "utf8";
      return encodings[type] || type;
    }
    function getValueEncoder(options, op) {
      var type = op && (op.valueEncoding || op.encoding) || options.valueEncoding || options.encoding || "utf8";
      return encodings[type] || type;
    }
    function encodeKey(key, options, op) {
      return getKeyEncoder(options, op).encode(key);
    }
    function encodeValue(value, options, op) {
      return getValueEncoder(options, op).encode(value);
    }
    function decodeKey(key, options) {
      return getKeyEncoder(options).decode(key);
    }
    function decodeValue(value, options) {
      return getValueEncoder(options).decode(value);
    }
    function isValueAsBuffer(options, op) {
      return getValueEncoder(options, op).buffer;
    }
    function isKeyAsBuffer(options, op) {
      return getKeyEncoder(options, op).buffer;
    }
    module.exports = {
      defaultOptions,
      copy,
      getOptions,
      getLevelDOWN,
      dispatchError,
      encodeKey,
      encodeValue,
      isValueAsBuffer,
      isKeyAsBuffer,
      decodeValue,
      decodeKey
    };
  }
});

// node_modules/levelup/lib/read-stream.js
var require_read_stream = __commonJS({
  "node_modules/levelup/lib/read-stream.js"(exports, module) {
    var Readable = require_readable().Readable;
    var inherits = require_util().inherits;
    var extend = require_xtend3();
    var EncodingError = require_errors().EncodingError;
    var util = require_util3();
    var defaultOptions = { keys: true, values: true };
    var makeKeyValueData = function(key, value) {
      return {
        key: util.decodeKey(key, this._options),
        value: util.decodeValue(value, this._options)
      };
    };
    var makeKeyData = function(key) {
      return util.decodeKey(key, this._options);
    };
    var makeValueData = function(_, value) {
      return util.decodeValue(value, this._options);
    };
    var makeNoData = function() {
      return null;
    };
    function ReadStream(options, db2, iteratorFactory) {
      if (!(this instanceof ReadStream))
        return new ReadStream(options, db2, iteratorFactory);
      Readable.call(this, { objectMode: true, highWaterMark: options.highWaterMark });
      this._db = db2;
      options = this._options = extend(defaultOptions, options);
      this._keyEncoding = options.keyEncoding || options.encoding;
      this._valueEncoding = options.valueEncoding || options.encoding;
      if (typeof this._options.start != "undefined")
        this._options.start = util.encodeKey(this._options.start, this._options);
      if (typeof this._options.end != "undefined")
        this._options.end = util.encodeKey(this._options.end, this._options);
      if (typeof this._options.limit != "number")
        this._options.limit = -1;
      this._options.keyAsBuffer = util.isKeyAsBuffer(this._options);
      this._options.valueAsBuffer = util.isValueAsBuffer(this._options);
      this._makeData = this._options.keys && this._options.values ? makeKeyValueData : this._options.keys ? makeKeyData : this._options.values ? makeValueData : makeNoData;
      var self2 = this;
      if (!this._db.isOpen()) {
        this._db.once("ready", function() {
          if (!self2._destroyed) {
            self2._iterator = iteratorFactory(self2._options);
          }
        });
      } else
        this._iterator = iteratorFactory(this._options);
    }
    inherits(ReadStream, Readable);
    ReadStream.prototype._read = function read() {
      var self2 = this;
      if (!self2._db.isOpen()) {
        return self2._db.once("ready", function() {
          read.call(self2);
        });
      }
      if (self2._destroyed)
        return;
      self2._iterator.next(function(err, key, value) {
        if (err || key === void 0 && value === void 0) {
          if (!err && !self2._destroyed)
            self2.push(null);
          return self2._cleanup(err);
        }
        try {
          value = self2._makeData(key, value);
        } catch (e) {
          return self2._cleanup(new EncodingError(e));
        }
        if (!self2._destroyed)
          self2.push(value);
      });
    };
    ReadStream.prototype._cleanup = function(err) {
      if (this._destroyed)
        return;
      this._destroyed = true;
      var self2 = this;
      if (err)
        self2.emit("error", err);
      if (self2._iterator) {
        self2._iterator.end(function() {
          self2._iterator = null;
          self2.emit("close");
        });
      } else {
        self2.emit("close");
      }
    };
    ReadStream.prototype.destroy = function() {
      this._cleanup();
    };
    ReadStream.prototype.toString = function() {
      return "LevelUP.ReadStream";
    };
    module.exports = ReadStream;
  }
});

// node_modules/bl/node_modules/isarray/index.js
var require_isarray2 = __commonJS({
  "node_modules/bl/node_modules/isarray/index.js"(exports, module) {
    module.exports = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/bl/node_modules/string_decoder/index.js
var require_string_decoder2 = __commonJS({
  "node_modules/bl/node_modules/string_decoder/index.js"(exports) {
    var Buffer2 = require_buffer().Buffer;
    var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error("Unknown encoding: " + encoding);
      }
    }
    var StringDecoder = exports.StringDecoder = function(encoding) {
      this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
      assertEncoding(encoding);
      switch (this.encoding) {
        case "utf8":
          this.surrogateSize = 3;
          break;
        case "ucs2":
        case "utf16le":
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case "base64":
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
      this.charBuffer = new Buffer2(6);
      this.charReceived = 0;
      this.charLength = 0;
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
  }
});

// node_modules/bl/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    module.exports = Readable;
    var isArray = require_isarray2();
    var Buffer2 = require_buffer().Buffer;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    if (!EE.listenerCount)
      EE.listenerCount = function(emitter, type) {
        return emitter.listeners(type).length;
      };
    var Stream = require_stream();
    var util = require_util2();
    util.inherits = require_inherits_browser();
    var StringDecoder;
    util.inherits(Readable, Stream);
    function ReadableState(options, stream) {
      options = options || {};
      var hwm = options.highWaterMark;
      this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = false;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.calledRead = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.objectMode = !!options.objectMode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder2().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      Stream.call(this);
    }
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (typeof chunk === "string" && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer2(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (chunk === null || chunk === void 0) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error("stream.push() after EOF");
          stream.emit("error", e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error("stream.unshift() after end event");
          stream.emit("error", e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) {
            state.buffer.unshift(chunk);
          } else {
            state.reading = false;
            state.buffer.push(chunk);
          }
          if (state.needReadable)
            emitReadable(stream);
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder2().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
    };
    var MAX_HWM = 8388608;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        for (var p = 1; p < 32; p <<= 1)
          n |= n >> p;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return n === 0 ? 0 : 1;
      if (n === null || isNaN(n)) {
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
      if (n <= 0)
        return 0;
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
      return n;
    }
    Readable.prototype.read = function(n) {
      var state = this._readableState;
      state.calledRead = true;
      var nOrig = n;
      var ret;
      if (typeof n !== "number" || n > 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        ret = null;
        if (state.length > 0 && state.decoder) {
          ret = fromList(n, state);
          state.length -= ret.length;
        }
        if (state.length === 0)
          endReadable(this);
        return ret;
      }
      var doRead = state.needReadable;
      if (state.length - n <= state.highWaterMark)
        doRead = true;
      if (state.ended || state.reading)
        doRead = false;
      if (doRead) {
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
      }
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      }
      state.length -= n;
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
      if (state.ended && !state.endEmitted && state.length === 0)
        endReadable(this);
      return ret;
    };
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!Buffer2.isBuffer(chunk) && "string" !== typeof chunk && chunk !== null && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.length > 0)
        emitReadable(stream);
      else
        endReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (state.emittedReadable)
        return;
      state.emittedReadable = true;
      if (state.sync)
        process.nextTick(function() {
          emitReadable_(stream);
        });
      else
        emitReadable_(stream);
    }
    function emitReadable_(stream) {
      stream.emit("readable");
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        if (readable !== src)
          return;
        cleanup();
      }
      function onend() {
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      function cleanup() {
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", cleanup);
        if (!dest._writableState || dest._writableState.needDrain)
          ondrain();
      }
      function onerror(er) {
        unpipe();
        dest.removeListener("error", onerror);
        if (EE.listenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      if (!dest._events || !dest._events.error)
        dest.on("error", onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        this.on("readable", pipeOnReadable);
        state.flowing = true;
        process.nextTick(function() {
          flow(src);
        });
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var dest = this;
        var state = src._readableState;
        state.awaitDrain--;
        if (state.awaitDrain === 0)
          flow(src);
      };
    }
    function flow(src) {
      var state = src._readableState;
      var chunk;
      state.awaitDrain = 0;
      function write(dest, i, list) {
        var written = dest.write(chunk);
        if (false === written) {
          state.awaitDrain++;
        }
      }
      while (state.pipesCount && null !== (chunk = src.read())) {
        if (state.pipesCount === 1)
          write(state.pipes, 0, null);
        else
          forEach(state.pipes, write);
        src.emit("data", chunk);
        if (state.awaitDrain > 0)
          return;
      }
      if (state.pipesCount === 0) {
        state.flowing = false;
        if (EE.listenerCount(src, "data") > 0)
          emitDataEvents(src);
        return;
      }
      state.ranOut = true;
    }
    function pipeOnReadable() {
      if (this._readableState.ranOut) {
        this._readableState.ranOut = false;
        flow(this);
      }
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener("readable", pipeOnReadable);
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener("readable", pipeOnReadable);
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this);
        return this;
      }
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data" && !this._readableState.flowing)
        emitDataEvents(this);
      if (ev === "readable" && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            this.read(0);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      emitDataEvents(this);
      this.read(0);
      this.emit("resume");
    };
    Readable.prototype.pause = function() {
      emitDataEvents(this, true);
      this.emit("pause");
    };
    function emitDataEvents(stream, startPaused) {
      var state = stream._readableState;
      if (state.flowing) {
        throw new Error("Cannot switch to old mode now.");
      }
      var paused = startPaused || false;
      var readable = false;
      stream.readable = true;
      stream.pipe = Stream.prototype.pipe;
      stream.on = stream.addListener = Stream.prototype.on;
      stream.on("readable", function() {
        readable = true;
        var c;
        while (!paused && null !== (c = stream.read()))
          stream.emit("data", c);
        if (c === null) {
          readable = false;
          stream._readableState.needReadable = true;
        }
      });
      stream.pause = function() {
        paused = true;
        this.emit("pause");
      };
      stream.resume = function() {
        paused = false;
        if (readable)
          process.nextTick(function() {
            stream.emit("readable");
          });
        else
          this.read(0);
        this.emit("resume");
      };
      stream.emit("readable");
    }
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (typeof stream[i] === "function" && typeof this[i] === "undefined") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
      if (list.length === 0)
        return null;
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        if (stringMode)
          ret = list.join("");
        else
          ret = Buffer2.concat(list, length);
        list.length = 0;
      } else {
        if (n < list[0].length) {
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          ret = list.shift();
        } else {
          if (stringMode)
            ret = "";
          else
            ret = new Buffer2(n);
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
            c += cpy;
          }
        }
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error("endReadable called on non-empty stream");
      if (!state.endEmitted && state.calledRead) {
        state.ended = true;
        process.nextTick(function() {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit("end");
          }
        });
      }
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/bl/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    module.exports = Duplex;
    var objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj)
        keys.push(key);
      return keys;
    };
    var util = require_util2();
    util.inherits = require_inherits_browser();
    var Readable = require_stream_readable2();
    var Writable = require_stream_writable2();
    util.inherits(Duplex, Readable);
    forEach(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      process.nextTick(this.end.bind(this));
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
  }
});

// node_modules/bl/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    module.exports = Writable;
    var Buffer2 = require_buffer().Buffer;
    Writable.WritableState = WritableState;
    var util = require_util2();
    util.inherits = require_inherits_browser();
    var Stream = require_stream();
    util.inherits(Writable, Stream);
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    function WritableState(options, stream) {
      options = options || {};
      var hwm = options.highWaterMark;
      this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024;
      this.objectMode = !!options.objectMode;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.buffer = [];
      this.errorEmitted = false;
    }
    function Writable(options) {
      var Duplex = require_stream_duplex2();
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe. Not readable."));
    };
    function writeAfterEnd(stream, state, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      process.nextTick(function() {
        cb(er);
      });
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!Buffer2.isBuffer(chunk) && "string" !== typeof chunk && chunk !== null && chunk !== void 0 && !state.objectMode) {
        var er = new TypeError("Invalid non-string/buffer chunk");
        stream.emit("error", er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = function() {
        };
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb))
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      return ret;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = new Buffer2(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, len, chunk, encoding, cb);
      return ret;
    }
    function doWrite(stream, state, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          cb(er);
        });
      else
        cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(stream, state);
        if (!finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(stream, state);
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      cb();
      if (finished)
        finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      for (var c = 0; c < state.buffer.length; c++) {
        var entry = state.buffer[c];
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, len, chunk, encoding, cb);
        if (state.writing) {
          c++;
          break;
        }
      }
      state.bufferProcessing = false;
      if (c < state.buffer.length)
        state.buffer = state.buffer.slice(c);
      else
        state.buffer.length = 0;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (typeof chunk !== "undefined" && chunk !== null)
        this.write(chunk, encoding);
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(stream, state) {
      return state.ending && state.length === 0 && !state.finished && !state.writing;
    }
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        state.finished = true;
        stream.emit("finish");
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
    }
  }
});

// node_modules/bl/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    module.exports = Transform;
    var Duplex = require_stream_duplex2();
    var util = require_util2();
    util.inherits = require_inherits_browser();
    util.inherits(Transform, Duplex);
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb)
        return stream.emit("error", new Error("no writecb in Transform class"));
      ts.writechunk = null;
      ts.writecb = null;
      if (data !== null && data !== void 0)
        stream.push(data);
      if (cb)
        cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      var ts = this._transformState = new TransformState(options, this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      this.once("finish", function() {
        if ("function" === typeof this._flush)
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er)
        return stream.emit("error", er);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var ts = stream._transformState;
      if (ws.length)
        throw new Error("calling transform done when ws.length != 0");
      if (ts.transforming)
        throw new Error("calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/bl/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    module.exports = PassThrough;
    var Transform = require_stream_transform2();
    var util = require_util2();
    util.inherits = require_inherits_browser();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/bl/node_modules/readable-stream/readable.js
var require_readable2 = __commonJS({
  "node_modules/bl/node_modules/readable-stream/readable.js"(exports, module) {
    var Stream = require_stream();
    exports = module.exports = require_stream_readable2();
    exports.Stream = Stream;
    exports.Readable = exports;
    exports.Writable = require_stream_writable2();
    exports.Duplex = require_stream_duplex2();
    exports.Transform = require_stream_transform2();
    exports.PassThrough = require_stream_passthrough2();
    if (!process.browser && process.env.READABLE_STREAM === "disable") {
      module.exports = require_stream();
    }
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports, module) {
    var DuplexStream = require_readable2().Duplex;
    var util = require_util();
    function BufferList(callback) {
      if (!(this instanceof BufferList))
        return new BufferList(callback);
      this._bufs = [];
      this.length = 0;
      if (typeof callback == "function") {
        this._callback = callback;
        var piper = (function(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }).bind(this);
        this.on("pipe", function(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function(src) {
          src.removeListener("error", piper);
        });
      } else if (Buffer.isBuffer(callback))
        this.append(callback);
      else if (Array.isArray(callback)) {
        callback.forEach((function(b) {
          Buffer.isBuffer(b) && this.append(b);
        }).bind(this));
      }
      DuplexStream.call(this);
    }
    util.inherits(BufferList, DuplexStream);
    BufferList.prototype._offset = function(offset) {
      var tot = 0, i = 0, _t;
      for (; i < this._bufs.length; i++) {
        _t = tot + this._bufs[i].length;
        if (offset < _t)
          return [i, offset - tot];
        tot = _t;
      }
    };
    BufferList.prototype.append = function(buf) {
      this._bufs.push(Buffer.isBuffer(buf) ? buf : new Buffer(buf));
      this.length += buf.length;
      return this;
    };
    BufferList.prototype._write = function(buf, encoding, callback) {
      this.append(buf);
      if (callback)
        callback();
    };
    BufferList.prototype._read = function(size) {
      if (!this.length)
        return this.push(null);
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferList.prototype.end = function(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferList.prototype.get = function(index) {
      return this.slice(index, index + 1)[0];
    };
    BufferList.prototype.slice = function(start, end) {
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart != "number" || srcStart < 0)
        srcStart = 0;
      if (typeof srcEnd != "number" || srcEnd > this.length)
        srcEnd = this.length;
      if (srcStart >= this.length)
        return dst || new Buffer(0);
      if (srcEnd <= 0)
        return dst || new Buffer(0);
      var copy = !!dst, off = this._offset(srcStart), len = srcEnd - srcStart, bytes = len, bufoff = copy && dstStart || 0, start = off[1], l, i;
      if (srcStart === 0 && srcEnd == this.length) {
        if (!copy)
          return Buffer.concat(this._bufs);
        for (i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy)
        dst = new Buffer(len);
      for (i = off[0]; i < this._bufs.length; i++) {
        l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          break;
        }
        bufoff += l;
        bytes -= l;
        if (start)
          start = 0;
      }
      return dst;
    };
    BufferList.prototype.toString = function(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function(bytes) {
      while (this._bufs.length) {
        if (bytes > this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function() {
      var i = 0, copy = new BufferList();
      for (; i < this._bufs.length; i++)
        copy.append(this._bufs[i]);
      return copy;
    };
    BufferList.prototype.destroy = function() {
      this._bufs.length = 0;
      this.length = 0;
      this.push(null);
    };
    (function() {
      var methods = {
        "readDoubleBE": 8,
        "readDoubleLE": 8,
        "readFloatBE": 4,
        "readFloatLE": 4,
        "readInt32BE": 4,
        "readInt32LE": 4,
        "readUInt32BE": 4,
        "readUInt32LE": 4,
        "readInt16BE": 2,
        "readInt16LE": 2,
        "readUInt16BE": 2,
        "readUInt16LE": 2,
        "readInt8": 1,
        "readUInt8": 1
      };
      for (var m in methods) {
        (function(m2) {
          BufferList.prototype[m2] = function(offset) {
            return this.slice(offset, offset + methods[m2])[m2](0);
          };
        })(m);
      }
    })();
    module.exports = BufferList;
  }
});

// node_modules/levelup/lib/write-stream.js
var require_write_stream = __commonJS({
  "node_modules/levelup/lib/write-stream.js"(exports, module) {
    var Stream = require_stream().Stream;
    var inherits = require_util().inherits;
    var extend = require_xtend3();
    var bl = require_bl();
    var setImmediate2 = global.setImmediate || process.nextTick;
    var getOptions = require_util3().getOptions;
    var defaultOptions = { type: "put" };
    function WriteStream(options, db2) {
      if (!(this instanceof WriteStream))
        return new WriteStream(options, db2);
      Stream.call(this);
      this._options = extend(defaultOptions, getOptions(db2, options));
      this._db = db2;
      this._buffer = [];
      this._status = "init";
      this._end = false;
      this.writable = true;
      this.readable = false;
      var self2 = this, ready = function() {
        if (!self2.writable)
          return;
        self2._status = "ready";
        self2.emit("ready");
        self2._process();
      };
      if (db2.isOpen())
        setImmediate2(ready);
      else
        db2.once("ready", ready);
    }
    inherits(WriteStream, Stream);
    WriteStream.prototype.write = function(data) {
      if (!this.writable)
        return false;
      this._buffer.push(data);
      if (this._status != "init")
        this._processDelayed();
      if (this._options.maxBufferLength && this._buffer.length > this._options.maxBufferLength) {
        this._writeBlock = true;
        return false;
      }
      return true;
    };
    WriteStream.prototype.end = function(data) {
      var self2 = this;
      if (data)
        this.write(data);
      setImmediate2(function() {
        self2._end = true;
        self2._process();
      });
    };
    WriteStream.prototype.destroy = function() {
      this.writable = false;
      this.end();
    };
    WriteStream.prototype.destroySoon = function() {
      this.end();
    };
    WriteStream.prototype.add = function(entry) {
      if (!entry.props)
        return;
      if (entry.props.Directory)
        entry.pipe(this._db.writeStream(this._options));
      else if (entry.props.File || entry.File || entry.type == "File")
        this._write(entry);
      return true;
    };
    WriteStream.prototype._processDelayed = function() {
      var self2 = this;
      setImmediate2(function() {
        self2._process();
      });
    };
    WriteStream.prototype._process = function() {
      var buffer, self2 = this, cb = function(err) {
        if (!self2.writable)
          return;
        if (self2._status != "closed")
          self2._status = "ready";
        if (err) {
          self2.writable = false;
          return self2.emit("error", err);
        }
        self2._process();
      };
      if (self2._status != "ready" && self2.writable) {
        if (self2._buffer.length && self2._status != "closed")
          self2._processDelayed();
        return;
      }
      if (self2._buffer.length && self2.writable) {
        self2._status = "writing";
        buffer = self2._buffer;
        self2._buffer = [];
        self2._db.batch(buffer.map(function(d) {
          return {
            type: d.type || self2._options.type,
            key: d.key,
            value: d.value,
            keyEncoding: d.keyEncoding || self2._options.keyEncoding,
            valueEncoding: d.valueEncoding || d.encoding || self2._options.valueEncoding
          };
        }), cb);
        if (self2._writeBlock) {
          self2._writeBlock = false;
          self2.emit("drain");
        }
        return;
      }
      if (self2._end && self2._status != "closed") {
        self2._status = "closed";
        self2.writable = false;
        self2.emit("close");
      }
    };
    WriteStream.prototype._write = function(entry) {
      var key = entry.path || entry.props.path, self2 = this;
      if (!key)
        return;
      entry.pipe(bl(function(err, data) {
        if (err) {
          self2.writable = false;
          return self2.emit("error", err);
        }
        if (self2._options.fstreamRoot && key.indexOf(self2._options.fstreamRoot) > -1)
          key = key.substr(self2._options.fstreamRoot.length + 1);
        self2.write({ key, value: data.slice(0) });
      }));
    };
    WriteStream.prototype.toString = function() {
      return "LevelUP.WriteStream";
    };
    module.exports = WriteStream;
  }
});

// node_modules/levelup/lib/batch.js
var require_batch = __commonJS({
  "node_modules/levelup/lib/batch.js"(exports, module) {
    var util = require_util3();
    var WriteError = require_errors().WriteError;
    var getOptions = util.getOptions;
    var dispatchError = util.dispatchError;
    function Batch(levelup) {
      this._levelup = levelup;
      this.batch = levelup.db.batch();
      this.ops = [];
    }
    Batch.prototype.put = function(key_, value_, options) {
      options = getOptions(this._levelup, options);
      var key = util.encodeKey(key_, options), value = util.encodeValue(value_, options);
      try {
        this.batch.put(key, value);
      } catch (e) {
        throw new WriteError(e);
      }
      this.ops.push({ type: "put", key, value });
      return this;
    };
    Batch.prototype.del = function(key_, options) {
      options = getOptions(this._levelup, options);
      var key = util.encodeKey(key_, options);
      try {
        this.batch.del(key);
      } catch (err) {
        throw new WriteError(err);
      }
      this.ops.push({ type: "del", key });
      return this;
    };
    Batch.prototype.clear = function() {
      try {
        this.batch.clear();
      } catch (err) {
        throw new WriteError(err);
      }
      this.ops = [];
      return this;
    };
    Batch.prototype.write = function(callback) {
      var levelup = this._levelup, ops = this.ops;
      try {
        this.batch.write(function(err) {
          if (err)
            return dispatchError(levelup, new WriteError(err), callback);
          levelup.emit("batch", ops);
          if (callback)
            callback();
        });
      } catch (err) {
        throw new WriteError(err);
      }
    };
    module.exports = Batch;
  }
});

// node_modules/levelup/lib/levelup.js
var require_levelup = __commonJS({
  "node_modules/levelup/lib/levelup.js"(exports, module) {
    var EventEmitter = require_events().EventEmitter;
    var inherits = require_util().inherits;
    var extend = require_xtend3();
    var prr = require_prr();
    var DeferredLevelDOWN = require_deferred_leveldown();
    var WriteError = require_errors().WriteError;
    var ReadError = require_errors().ReadError;
    var NotFoundError = require_errors().NotFoundError;
    var OpenError = require_errors().OpenError;
    var EncodingError = require_errors().EncodingError;
    var InitializationError = require_errors().InitializationError;
    var ReadStream = require_read_stream();
    var WriteStream = require_write_stream();
    var util = require_util3();
    var Batch = require_batch();
    var getOptions = util.getOptions;
    var defaultOptions = util.defaultOptions;
    var getLevelDOWN = util.getLevelDOWN;
    var dispatchError = util.dispatchError;
    function getCallback(options, callback) {
      return typeof options == "function" ? options : callback;
    }
    function LevelUP(location, options, callback) {
      if (!(this instanceof LevelUP))
        return new LevelUP(location, options, callback);
      var error;
      EventEmitter.call(this);
      this.setMaxListeners(Infinity);
      if (typeof location == "function") {
        options = typeof options == "object" ? options : {};
        options.db = location;
        location = null;
      } else if (typeof location == "object" && typeof location.db == "function") {
        options = location;
        location = null;
      }
      if (typeof options == "function") {
        callback = options;
        options = {};
      }
      if ((!options || typeof options.db != "function") && typeof location != "string") {
        error = new InitializationError(
          "Must provide a location for the database"
        );
        if (callback) {
          return process.nextTick(function() {
            callback(error);
          });
        }
        throw error;
      }
      options = getOptions(this, options);
      this.options = extend(defaultOptions, options);
      this._status = "new";
      prr(this, "location", location, "e");
      this.open(callback);
    }
    inherits(LevelUP, EventEmitter);
    LevelUP.prototype.open = function(callback) {
      var self2 = this, dbFactory, db2;
      if (this.isOpen()) {
        if (callback)
          process.nextTick(function() {
            callback(null, self2);
          });
        return this;
      }
      if (this._isOpening()) {
        return callback && this.once(
          "open",
          function() {
            callback(null, self2);
          }
        );
      }
      this.emit("opening");
      this._status = "opening";
      this.db = new DeferredLevelDOWN(this.location);
      dbFactory = this.options.db || getLevelDOWN();
      db2 = dbFactory(this.location);
      db2.open(this.options, function(err) {
        if (err) {
          return dispatchError(self2, new OpenError(err), callback);
        } else {
          self2.db.setDb(db2);
          self2.db = db2;
          self2._status = "open";
          if (callback)
            callback(null, self2);
          self2.emit("open");
          self2.emit("ready");
        }
      });
    };
    LevelUP.prototype.close = function(callback) {
      var self2 = this;
      if (this.isOpen()) {
        this._status = "closing";
        this.db.close(function() {
          self2._status = "closed";
          self2.emit("closed");
          if (callback)
            callback.apply(null, arguments);
        });
        this.emit("closing");
        this.db = null;
      } else if (this._status == "closed" && callback) {
        return process.nextTick(callback);
      } else if (this._status == "closing" && callback) {
        this.once("closed", callback);
      } else if (this._isOpening()) {
        this.once("open", function() {
          self2.close(callback);
        });
      }
    };
    LevelUP.prototype.isOpen = function() {
      return this._status == "open";
    };
    LevelUP.prototype._isOpening = function() {
      return this._status == "opening";
    };
    LevelUP.prototype.isClosed = function() {
      return /^clos/.test(this._status);
    };
    LevelUP.prototype.get = function(key_, options, callback) {
      var self2 = this, key;
      callback = getCallback(options, callback);
      if (typeof callback != "function") {
        return dispatchError(
          this,
          new ReadError("get() requires key and callback arguments")
        );
      }
      if (!this._isOpening() && !this.isOpen()) {
        return dispatchError(
          this,
          new ReadError("Database is not open"),
          callback
        );
      }
      options = util.getOptions(this, options);
      key = util.encodeKey(key_, options);
      options.asBuffer = util.isValueAsBuffer(options);
      this.db.get(key, options, function(err, value) {
        if (err) {
          if (/notfound/i.test(err)) {
            err = new NotFoundError(
              "Key not found in database [" + key_ + "]",
              err
            );
          } else {
            err = new ReadError(err);
          }
          return dispatchError(self2, err, callback);
        }
        if (callback) {
          try {
            value = util.decodeValue(value, options);
          } catch (e) {
            return callback(new EncodingError(e));
          }
          callback(null, value);
        }
      });
    };
    LevelUP.prototype.put = function(key_, value_, options, callback) {
      var self2 = this, key, value;
      callback = getCallback(options, callback);
      if (key_ === null || key_ === void 0 || value_ === null || value_ === void 0) {
        return dispatchError(
          this,
          new WriteError("put() requires key and value arguments"),
          callback
        );
      }
      if (!this._isOpening() && !this.isOpen()) {
        return dispatchError(
          this,
          new WriteError("Database is not open"),
          callback
        );
      }
      options = getOptions(this, options);
      key = util.encodeKey(key_, options);
      value = util.encodeValue(value_, options);
      this.db.put(key, value, options, function(err) {
        if (err) {
          return dispatchError(self2, new WriteError(err), callback);
        } else {
          self2.emit("put", key_, value_);
          if (callback)
            callback();
        }
      });
    };
    LevelUP.prototype.del = function(key_, options, callback) {
      var self2 = this, key;
      callback = getCallback(options, callback);
      if (key_ === null || key_ === void 0) {
        return dispatchError(
          this,
          new WriteError("del() requires a key argument"),
          callback
        );
      }
      if (!this._isOpening() && !this.isOpen()) {
        return dispatchError(
          this,
          new WriteError("Database is not open"),
          callback
        );
      }
      options = getOptions(this, options);
      key = util.encodeKey(key_, options);
      this.db.del(key, options, function(err) {
        if (err) {
          return dispatchError(self2, new WriteError(err), callback);
        } else {
          self2.emit("del", key_);
          if (callback)
            callback();
        }
      });
    };
    LevelUP.prototype.batch = function(arr_, options, callback) {
      var self2 = this, keyEnc, valueEnc, arr;
      if (!arguments.length)
        return new Batch(this);
      callback = getCallback(options, callback);
      if (!Array.isArray(arr_)) {
        return dispatchError(
          this,
          new WriteError("batch() requires an array argument"),
          callback
        );
      }
      if (!this._isOpening() && !this.isOpen()) {
        return dispatchError(
          this,
          new WriteError("Database is not open"),
          callback
        );
      }
      options = getOptions(this, options);
      keyEnc = options.keyEncoding;
      valueEnc = options.valueEncoding;
      arr = arr_.map(function(e) {
        if (e.type === void 0 || e.key === void 0)
          return {};
        var kEnc = e.keyEncoding || keyEnc, vEnc = e.valueEncoding || e.encoding || valueEnc, o;
        if (kEnc != "utf8" && kEnc != "binary" || vEnc != "utf8" && vEnc != "binary") {
          o = {
            type: e.type,
            key: util.encodeKey(e.key, options, e)
          };
          if (e.value !== void 0)
            o.value = util.encodeValue(e.value, options, e);
          return o;
        } else {
          return e;
        }
      });
      this.db.batch(arr, options, function(err) {
        if (err) {
          return dispatchError(self2, new WriteError(err), callback);
        } else {
          self2.emit("batch", arr_);
          if (callback)
            callback();
        }
      });
    };
    LevelUP.prototype.approximateSize = function(start_, end_, callback) {
      var self2 = this, start, end;
      if (start_ === null || start_ === void 0 || end_ === null || end_ === void 0 || typeof callback != "function") {
        return dispatchError(
          this,
          new ReadError("approximateSize() requires start, end and callback arguments"),
          callback
        );
      }
      start = util.encodeKey(start_, this.options);
      end = util.encodeKey(end_, this.options);
      if (!this._isOpening() && !this.isOpen()) {
        return dispatchError(
          this,
          new WriteError("Database is not open"),
          callback
        );
      }
      this.db.approximateSize(start, end, function(err, size) {
        if (err) {
          return dispatchError(self2, new OpenError(err), callback);
        } else if (callback) {
          callback(null, size);
        }
      });
    };
    LevelUP.prototype.readStream = LevelUP.prototype.createReadStream = function(options) {
      var self2 = this;
      options = extend(this.options, options);
      return new ReadStream(
        options,
        this,
        function(options2) {
          return self2.db.iterator(options2);
        }
      );
    };
    LevelUP.prototype.keyStream = LevelUP.prototype.createKeyStream = function(options) {
      return this.createReadStream(extend(options, { keys: true, values: false }));
    };
    LevelUP.prototype.valueStream = LevelUP.prototype.createValueStream = function(options) {
      return this.createReadStream(extend(options, { keys: false, values: true }));
    };
    LevelUP.prototype.writeStream = LevelUP.prototype.createWriteStream = function(options) {
      return new WriteStream(extend(options), this);
    };
    LevelUP.prototype.toString = function() {
      return "LevelUP";
    };
    function utilStatic(name) {
      return function(location, callback) {
        getLevelDOWN()[name](location, callback || function() {
        });
      };
    }
    module.exports = LevelUP;
    module.exports.copy = util.copy;
    module.exports.destroy = utilStatic("destroy");
    module.exports.repair = utilStatic("repair");
  }
});

// node_modules/fwd-stream/node_modules/isarray/index.js
var require_isarray3 = __commonJS({
  "node_modules/fwd-stream/node_modules/isarray/index.js"(exports, module) {
    module.exports = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/fwd-stream/node_modules/string_decoder/index.js
var require_string_decoder3 = __commonJS({
  "node_modules/fwd-stream/node_modules/string_decoder/index.js"(exports) {
    var Buffer2 = require_buffer().Buffer;
    var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error("Unknown encoding: " + encoding);
      }
    }
    var StringDecoder = exports.StringDecoder = function(encoding) {
      this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
      assertEncoding(encoding);
      switch (this.encoding) {
        case "utf8":
          this.surrogateSize = 3;
          break;
        case "ucs2":
        case "utf16le":
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case "base64":
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
      this.charBuffer = new Buffer2(6);
      this.charReceived = 0;
      this.charLength = 0;
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
  }
});

// node_modules/fwd-stream/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable3 = __commonJS({
  "node_modules/fwd-stream/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    module.exports = Readable;
    var isArray = require_isarray3();
    var Buffer2 = require_buffer().Buffer;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    if (!EE.listenerCount)
      EE.listenerCount = function(emitter, type) {
        return emitter.listeners(type).length;
      };
    var Stream = require_stream();
    var util = require_util2();
    util.inherits = require_inherits_browser();
    var StringDecoder;
    util.inherits(Readable, Stream);
    function ReadableState(options, stream) {
      options = options || {};
      var hwm = options.highWaterMark;
      this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = false;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.calledRead = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.objectMode = !!options.objectMode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder3().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      Stream.call(this);
    }
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (typeof chunk === "string" && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer2(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (chunk === null || chunk === void 0) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error("stream.push() after EOF");
          stream.emit("error", e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error("stream.unshift() after end event");
          stream.emit("error", e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront) {
            state.buffer.unshift(chunk);
          } else {
            state.reading = false;
            state.buffer.push(chunk);
          }
          if (state.needReadable)
            emitReadable(stream);
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder3().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
    };
    var MAX_HWM = 8388608;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        for (var p = 1; p < 32; p <<= 1)
          n |= n >> p;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return n === 0 ? 0 : 1;
      if (n === null || isNaN(n)) {
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
      if (n <= 0)
        return 0;
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
      return n;
    }
    Readable.prototype.read = function(n) {
      var state = this._readableState;
      state.calledRead = true;
      var nOrig = n;
      var ret;
      if (typeof n !== "number" || n > 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        ret = null;
        if (state.length > 0 && state.decoder) {
          ret = fromList(n, state);
          state.length -= ret.length;
        }
        if (state.length === 0)
          endReadable(this);
        return ret;
      }
      var doRead = state.needReadable;
      if (state.length - n <= state.highWaterMark)
        doRead = true;
      if (state.ended || state.reading)
        doRead = false;
      if (doRead) {
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
      }
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      }
      state.length -= n;
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
      if (state.ended && !state.endEmitted && state.length === 0)
        endReadable(this);
      return ret;
    };
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!Buffer2.isBuffer(chunk) && "string" !== typeof chunk && chunk !== null && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.length > 0)
        emitReadable(stream);
      else
        endReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (state.emittedReadable)
        return;
      state.emittedReadable = true;
      if (state.sync)
        process.nextTick(function() {
          emitReadable_(stream);
        });
      else
        emitReadable_(stream);
    }
    function emitReadable_(stream) {
      stream.emit("readable");
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        if (readable !== src)
          return;
        cleanup();
      }
      function onend() {
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      function cleanup() {
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", cleanup);
        if (!dest._writableState || dest._writableState.needDrain)
          ondrain();
      }
      function onerror(er) {
        unpipe();
        dest.removeListener("error", onerror);
        if (EE.listenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      if (!dest._events || !dest._events.error)
        dest.on("error", onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        this.on("readable", pipeOnReadable);
        state.flowing = true;
        process.nextTick(function() {
          flow(src);
        });
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var dest = this;
        var state = src._readableState;
        state.awaitDrain--;
        if (state.awaitDrain === 0)
          flow(src);
      };
    }
    function flow(src) {
      var state = src._readableState;
      var chunk;
      state.awaitDrain = 0;
      function write(dest, i, list) {
        var written = dest.write(chunk);
        if (false === written) {
          state.awaitDrain++;
        }
      }
      while (state.pipesCount && null !== (chunk = src.read())) {
        if (state.pipesCount === 1)
          write(state.pipes, 0, null);
        else
          forEach(state.pipes, write);
        src.emit("data", chunk);
        if (state.awaitDrain > 0)
          return;
      }
      if (state.pipesCount === 0) {
        state.flowing = false;
        if (EE.listenerCount(src, "data") > 0)
          emitDataEvents(src);
        return;
      }
      state.ranOut = true;
    }
    function pipeOnReadable() {
      if (this._readableState.ranOut) {
        this._readableState.ranOut = false;
        flow(this);
      }
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener("readable", pipeOnReadable);
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        this.removeListener("readable", pipeOnReadable);
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this);
        return this;
      }
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data" && !this._readableState.flowing)
        emitDataEvents(this);
      if (ev === "readable" && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            this.read(0);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      emitDataEvents(this);
      this.read(0);
      this.emit("resume");
    };
    Readable.prototype.pause = function() {
      emitDataEvents(this, true);
      this.emit("pause");
    };
    function emitDataEvents(stream, startPaused) {
      var state = stream._readableState;
      if (state.flowing) {
        throw new Error("Cannot switch to old mode now.");
      }
      var paused = startPaused || false;
      var readable = false;
      stream.readable = true;
      stream.pipe = Stream.prototype.pipe;
      stream.on = stream.addListener = Stream.prototype.on;
      stream.on("readable", function() {
        readable = true;
        var c;
        while (!paused && null !== (c = stream.read()))
          stream.emit("data", c);
        if (c === null) {
          readable = false;
          stream._readableState.needReadable = true;
        }
      });
      stream.pause = function() {
        paused = true;
        this.emit("pause");
      };
      stream.resume = function() {
        paused = false;
        if (readable)
          process.nextTick(function() {
            stream.emit("readable");
          });
        else
          this.read(0);
        this.emit("resume");
      };
      stream.emit("readable");
    }
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (typeof stream[i] === "function" && typeof this[i] === "undefined") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
      if (list.length === 0)
        return null;
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        if (stringMode)
          ret = list.join("");
        else
          ret = Buffer2.concat(list, length);
        list.length = 0;
      } else {
        if (n < list[0].length) {
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          ret = list.shift();
        } else {
          if (stringMode)
            ret = "";
          else
            ret = new Buffer2(n);
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
            c += cpy;
          }
        }
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error("endReadable called on non-empty stream");
      if (!state.endEmitted && state.calledRead) {
        state.ended = true;
        process.nextTick(function() {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit("end");
          }
        });
      }
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/fwd-stream/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex3 = __commonJS({
  "node_modules/fwd-stream/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    module.exports = Duplex;
    var objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj)
        keys.push(key);
      return keys;
    };
    var util = require_util2();
    util.inherits = require_inherits_browser();
    var Readable = require_stream_readable3();
    var Writable = require_stream_writable3();
    util.inherits(Duplex, Readable);
    forEach(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      process.nextTick(this.end.bind(this));
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
  }
});

// node_modules/fwd-stream/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable3 = __commonJS({
  "node_modules/fwd-stream/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    module.exports = Writable;
    var Buffer2 = require_buffer().Buffer;
    Writable.WritableState = WritableState;
    var util = require_util2();
    util.inherits = require_inherits_browser();
    var Stream = require_stream();
    util.inherits(Writable, Stream);
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    function WritableState(options, stream) {
      options = options || {};
      var hwm = options.highWaterMark;
      this.highWaterMark = hwm || hwm === 0 ? hwm : 16 * 1024;
      this.objectMode = !!options.objectMode;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.buffer = [];
      this.errorEmitted = false;
    }
    function Writable(options) {
      var Duplex = require_stream_duplex3();
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe. Not readable."));
    };
    function writeAfterEnd(stream, state, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      process.nextTick(function() {
        cb(er);
      });
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!Buffer2.isBuffer(chunk) && "string" !== typeof chunk && chunk !== null && chunk !== void 0 && !state.objectMode) {
        var er = new TypeError("Invalid non-string/buffer chunk");
        stream.emit("error", er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = function() {
        };
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb))
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      return ret;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = new Buffer2(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, len, chunk, encoding, cb);
      return ret;
    }
    function doWrite(stream, state, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          cb(er);
        });
      else
        cb(er);
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(stream, state);
        if (!finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(stream, state);
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      cb();
      if (finished)
        finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      for (var c = 0; c < state.buffer.length; c++) {
        var entry = state.buffer[c];
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, len, chunk, encoding, cb);
        if (state.writing) {
          c++;
          break;
        }
      }
      state.bufferProcessing = false;
      if (c < state.buffer.length)
        state.buffer = state.buffer.slice(c);
      else
        state.buffer.length = 0;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (typeof chunk !== "undefined" && chunk !== null)
        this.write(chunk, encoding);
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(stream, state) {
      return state.ending && state.length === 0 && !state.finished && !state.writing;
    }
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        state.finished = true;
        stream.emit("finish");
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
    }
  }
});

// node_modules/fwd-stream/node_modules/readable-stream/writable.js
var require_writable = __commonJS({
  "node_modules/fwd-stream/node_modules/readable-stream/writable.js"(exports, module) {
    module.exports = require_stream_writable3();
  }
});

// node_modules/fwd-stream/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform3 = __commonJS({
  "node_modules/fwd-stream/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    module.exports = Transform;
    var Duplex = require_stream_duplex3();
    var util = require_util2();
    util.inherits = require_inherits_browser();
    util.inherits(Transform, Duplex);
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb)
        return stream.emit("error", new Error("no writecb in Transform class"));
      ts.writechunk = null;
      ts.writecb = null;
      if (data !== null && data !== void 0)
        stream.push(data);
      if (cb)
        cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      var ts = this._transformState = new TransformState(options, this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      this.once("finish", function() {
        if ("function" === typeof this._flush)
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er)
        return stream.emit("error", er);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var ts = stream._transformState;
      if (ws.length)
        throw new Error("calling transform done when ws.length != 0");
      if (ts.transforming)
        throw new Error("calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/fwd-stream/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough3 = __commonJS({
  "node_modules/fwd-stream/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    module.exports = PassThrough;
    var Transform = require_stream_transform3();
    var util = require_util2();
    util.inherits = require_inherits_browser();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/fwd-stream/node_modules/readable-stream/readable.js
var require_readable3 = __commonJS({
  "node_modules/fwd-stream/node_modules/readable-stream/readable.js"(exports, module) {
    var Stream = require_stream();
    exports = module.exports = require_stream_readable3();
    exports.Stream = Stream;
    exports.Readable = exports;
    exports.Writable = require_stream_writable3();
    exports.Duplex = require_stream_duplex3();
    exports.Transform = require_stream_transform3();
    exports.PassThrough = require_stream_passthrough3();
    if (!process.browser && process.env.READABLE_STREAM === "disable") {
      module.exports = require_stream();
    }
  }
});

// node_modules/fwd-stream/node_modules/readable-stream/duplex.js
var require_duplex = __commonJS({
  "node_modules/fwd-stream/node_modules/readable-stream/duplex.js"(exports, module) {
    module.exports = require_stream_duplex3();
  }
});

// node_modules/fwd-stream/index.js
var require_fwd_stream = __commonJS({
  "node_modules/fwd-stream/index.js"(exports) {
    var Writable = require_writable();
    var Readable = require_readable3();
    var Duplex = require_duplex();
    var DUMMY = new Buffer(0);
    var noop = function() {
    };
    var toFunction = function(fn) {
      if (typeof fn === "function")
        return fn;
      return function(cb) {
        cb(null, fn);
      };
    };
    var onreadable = function(rs, init) {
      var reading = false;
      var destroyed = false;
      rs._read = function() {
        reading = true;
      };
      rs.destroy = function() {
        destroyed = true;
      };
      init(function(err, source) {
        if (err)
          return rs.emit("error", err);
        var fwd = function() {
          var data;
          while ((data = source.read()) !== null) {
            reading = false;
            rs.push(data);
          }
        };
        source.on("readable", function() {
          if (reading)
            fwd();
        });
        source.on("end", function() {
          fwd();
          rs.push(null);
        });
        source.on("error", function(err2) {
          rs.emit("error", err2);
        });
        source.on("close", function() {
          fwd();
          process.nextTick(function() {
            rs.emit("close");
          });
        });
        rs._read = function() {
          reading = true;
          fwd();
        };
        rs.destroy = function() {
          if (destroyed)
            return;
          destroyed = true;
          if (source.destroy)
            source.destroy();
        };
        if (destroyed) {
          destroyed = false;
          rs.destroy();
          return;
        }
        if (reading)
          fwd();
      });
      return rs;
    };
    var onwritable = function(ws, init) {
      var ready = noop;
      var destroyed = false;
      ws._write = function(data, enc, cb) {
        ready = cb;
      };
      ws.destroy = function() {
        destroyed = true;
      };
      ws.write(DUMMY);
      init(function(err, source) {
        if (err)
          return ws.emit("error", err);
        source.on("close", function() {
          ws.emit("close");
        });
        source.on("error", function(err2) {
          ws.emit("error", err2);
        });
        ws._write = function(data, enc, cb) {
          if (data === DUMMY)
            return cb();
          source.write(data, enc, cb);
        };
        var emit = ws.emit;
        source.on("finish", function() {
          emit.call(ws, "finish");
        });
        ws.destroy = function() {
          if (destroyed)
            return;
          destroyed = true;
          if (source.destroy)
            source.destroy();
        };
        ws.emit = function(name) {
          if (name !== "finish")
            return emit.apply(ws, arguments);
          source.end();
        };
        if (destroyed) {
          destroyed = false;
          ws.destroy();
          return;
        }
        ready();
      });
      return ws;
    };
    exports.readable = function(opts, init) {
      if (arguments.length === 1)
        return exports.readable(null, opts);
      if (!opts)
        opts = {};
      return onreadable(new Readable(opts), toFunction(init));
    };
    exports.writable = function(opts, init) {
      if (arguments.length === 1)
        return exports.writable(null, opts);
      if (!opts)
        opts = {};
      return onwritable(new Writable(opts), toFunction(init));
    };
    exports.duplex = function(opts, initWritable, initReadable) {
      if (arguments.length === 2)
        return exports.duplex(null, opts, initWritable);
      if (!opts)
        opts = {};
      var dupl = new Duplex(opts);
      onwritable(dupl, toFunction(initWritable));
      onreadable(dupl, toFunction(initReadable));
      return dupl;
    };
  }
});

// node_modules/string-range/index.js
var require_string_range = __commonJS({
  "node_modules/string-range/index.js"(exports) {
    var range = exports.range = function(obj) {
      return null == obj ? {} : "string" === typeof range ? {
        min: range,
        max: range + "Ã¿"
      } : obj;
    };
    var prefix = exports.prefix = function(range2, within, term) {
      range2 = exports.range(range2);
      var _range = {};
      term = term || "Ã¿";
      if (range2 instanceof RegExp || "function" == typeof range2) {
        _range.min = within;
        _range.max = within + term, _range.inner = function(k) {
          var j = k.substring(within.length);
          if (range2.test)
            return range2.test(j);
          return range2(j);
        };
      } else if ("object" === typeof range2) {
        _range.min = within + (range2.min || range2.start || "");
        _range.max = within + (range2.max || range2.end || (term || "~"));
        _range.reverse = !!range2.reverse;
      }
      return _range;
    };
    var checker = exports.checker = function(range2) {
      if (!range2)
        range2 = {};
      if ("string" === typeof range2)
        return function(key) {
          return key.indexOf(range2) == 0;
        };
      else if (range2 instanceof RegExp)
        return function(key) {
          return range2.test(key);
        };
      else if ("object" === typeof range2)
        return function(key) {
          var min = range2.min || range2.start;
          var max = range2.max || range2.end;
          key = String(key);
          return (!min || key >= min) && (!max || key <= max) && (!range2.inner || (range2.inner.test ? range2.inner.test(key) : range2.inner(key)));
        };
      else if ("function" === typeof range2)
        return range2;
    };
    var satifies = exports.satisfies = function(key, range2) {
      return checker(range2)(key);
    };
  }
});

// node_modules/clone/clone.js
var require_clone = __commonJS({
  "node_modules/clone/clone.js"(exports, module) {
    "use strict";
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    var util = {
      isArray: function(ar) {
        return Array.isArray(ar) || typeof ar === "object" && objectToString(ar) === "[object Array]";
      },
      isDate: function(d) {
        return typeof d === "object" && objectToString(d) === "[object Date]";
      },
      isRegExp: function(re) {
        return typeof re === "object" && objectToString(re) === "[object RegExp]";
      },
      getRegExpFlags: function(re) {
        var flags = "";
        re.global && (flags += "g");
        re.ignoreCase && (flags += "i");
        re.multiline && (flags += "m");
        return flags;
      }
    };
    if (typeof module === "object")
      module.exports = clone;
    function clone(parent, circular, depth, prototype) {
      var allParents = [];
      var allChildren = [];
      var useBuffer = typeof Buffer != "undefined";
      if (typeof circular == "undefined")
        circular = true;
      if (typeof depth == "undefined")
        depth = Infinity;
      function _clone(parent2, depth2) {
        if (parent2 === null)
          return null;
        if (depth2 == 0)
          return parent2;
        var child;
        var proto;
        if (typeof parent2 != "object") {
          return parent2;
        }
        if (util.isArray(parent2)) {
          child = [];
        } else if (util.isRegExp(parent2)) {
          child = new RegExp(parent2.source, util.getRegExpFlags(parent2));
          if (parent2.lastIndex)
            child.lastIndex = parent2.lastIndex;
        } else if (util.isDate(parent2)) {
          child = new Date(parent2.getTime());
        } else if (useBuffer && Buffer.isBuffer(parent2)) {
          child = new Buffer(parent2.length);
          parent2.copy(child);
          return child;
        } else {
          if (typeof prototype == "undefined") {
            proto = Object.getPrototypeOf(parent2);
            child = Object.create(proto);
          } else {
            child = Object.create(prototype);
            proto = prototype;
          }
        }
        if (circular) {
          var index = allParents.indexOf(parent2);
          if (index != -1) {
            return allChildren[index];
          }
          allParents.push(parent2);
          allChildren.push(child);
        }
        for (var i in parent2) {
          var attrs;
          if (proto) {
            attrs = Object.getOwnPropertyDescriptor(proto, i);
          }
          if (attrs && attrs.set == null) {
            continue;
          }
          child[i] = _clone(parent2[i], depth2 - 1);
        }
        return child;
      }
      return _clone(parent, depth);
    }
    clone.clonePrototype = function(parent) {
      if (parent === null)
        return null;
      var c = function() {
      };
      c.prototype = parent;
      return new c();
    };
  }
});

// node_modules/level-sublevel/node_modules/level-fix-range/index.js
var require_level_fix_range = __commonJS({
  "node_modules/level-sublevel/node_modules/level-fix-range/index.js"(exports, module) {
    var clone = require_clone();
    module.exports = function fixRange(opts) {
      opts = clone(opts);
      var reverse = opts.reverse;
      var end = opts.max || opts.end;
      var start = opts.min || opts.start;
      var range = [start, end];
      if (start != null && end != null)
        range.sort();
      if (reverse)
        range = range.reverse();
      opts.start = range[0];
      opts.end = range[1];
      delete opts.min;
      delete opts.max;
      return opts;
    };
  }
});

// node_modules/is/index.js
var require_is = __commonJS({
  "node_modules/is/index.js"(exports, module) {
    var objProto = Object.prototype;
    var owns = objProto.hasOwnProperty;
    var toString = objProto.toString;
    var isActualNaN = function(value) {
      return value !== value;
    };
    var NON_HOST_TYPES = {
      "boolean": 1,
      "number": 1,
      "string": 1,
      "undefined": 1
    };
    var is = module.exports = {};
    is.a = is.type = function(value, type) {
      return typeof value === type;
    };
    is.defined = function(value) {
      return value !== void 0;
    };
    is.empty = function(value) {
      var type = toString.call(value);
      var key;
      if ("[object Array]" === type || "[object Arguments]" === type) {
        return value.length === 0;
      }
      if ("[object Object]" === type) {
        for (key in value)
          if (owns.call(value, key))
            return false;
        return true;
      }
      if ("[object String]" === type) {
        return "" === value;
      }
      return false;
    };
    is.equal = function(value, other) {
      var type = toString.call(value);
      var key;
      if (type !== toString.call(other)) {
        return false;
      }
      if ("[object Object]" === type) {
        for (key in value) {
          if (!is.equal(value[key], other[key])) {
            return false;
          }
        }
        return true;
      }
      if ("[object Array]" === type) {
        key = value.length;
        if (key !== other.length) {
          return false;
        }
        while (--key) {
          if (!is.equal(value[key], other[key])) {
            return false;
          }
        }
        return true;
      }
      if ("[object Function]" === type) {
        return value.prototype === other.prototype;
      }
      if ("[object Date]" === type) {
        return value.getTime() === other.getTime();
      }
      return value === other;
    };
    is.hosted = function(value, host) {
      var type = typeof host[value];
      return type === "object" ? !!host[value] : !NON_HOST_TYPES[type];
    };
    is.instance = is["instanceof"] = function(value, constructor) {
      return value instanceof constructor;
    };
    is["null"] = function(value) {
      return value === null;
    };
    is.undefined = function(value) {
      return value === void 0;
    };
    is.arguments = function(value) {
      var isStandardArguments = "[object Arguments]" === toString.call(value);
      var isOldArguments = !is.array(value) && is.arraylike(value) && is.object(value) && is.fn(value.callee);
      return isStandardArguments || isOldArguments;
    };
    is.array = function(value) {
      return "[object Array]" === toString.call(value);
    };
    is.arguments.empty = function(value) {
      return is.arguments(value) && value.length === 0;
    };
    is.array.empty = function(value) {
      return is.array(value) && value.length === 0;
    };
    is.arraylike = function(value) {
      return !!value && !is.boolean(value) && owns.call(value, "length") && isFinite(value.length) && is.number(value.length) && value.length >= 0;
    };
    is.boolean = function(value) {
      return "[object Boolean]" === toString.call(value);
    };
    is["false"] = function(value) {
      return is.boolean(value) && (value === false || value.valueOf() === false);
    };
    is["true"] = function(value) {
      return is.boolean(value) && (value === true || value.valueOf() === true);
    };
    is.date = function(value) {
      return "[object Date]" === toString.call(value);
    };
    is.element = function(value) {
      return value !== void 0 && typeof HTMLElement !== "undefined" && value instanceof HTMLElement && value.nodeType === 1;
    };
    is.error = function(value) {
      return "[object Error]" === toString.call(value);
    };
    is.fn = is["function"] = function(value) {
      var isAlert = typeof window !== "undefined" && value === window.alert;
      return isAlert || "[object Function]" === toString.call(value);
    };
    is.number = function(value) {
      return "[object Number]" === toString.call(value);
    };
    is.infinite = function(value) {
      return value === Infinity || value === -Infinity;
    };
    is.decimal = function(value) {
      return is.number(value) && !isActualNaN(value) && !is.infinite(value) && value % 1 !== 0;
    };
    is.divisibleBy = function(value, n) {
      var isDividendInfinite = is.infinite(value);
      var isDivisorInfinite = is.infinite(n);
      var isNonZeroNumber = is.number(value) && !isActualNaN(value) && is.number(n) && !isActualNaN(n) && n !== 0;
      return isDividendInfinite || isDivisorInfinite || isNonZeroNumber && value % n === 0;
    };
    is.int = function(value) {
      return is.number(value) && !isActualNaN(value) && value % 1 === 0;
    };
    is.maximum = function(value, others) {
      if (isActualNaN(value)) {
        throw new TypeError("NaN is not a valid value");
      } else if (!is.arraylike(others)) {
        throw new TypeError("second argument must be array-like");
      }
      var len = others.length;
      while (--len >= 0) {
        if (value < others[len]) {
          return false;
        }
      }
      return true;
    };
    is.minimum = function(value, others) {
      if (isActualNaN(value)) {
        throw new TypeError("NaN is not a valid value");
      } else if (!is.arraylike(others)) {
        throw new TypeError("second argument must be array-like");
      }
      var len = others.length;
      while (--len >= 0) {
        if (value > others[len]) {
          return false;
        }
      }
      return true;
    };
    is.nan = function(value) {
      return !is.number(value) || value !== value;
    };
    is.even = function(value) {
      return is.infinite(value) || is.number(value) && value === value && value % 2 === 0;
    };
    is.odd = function(value) {
      return is.infinite(value) || is.number(value) && value === value && value % 2 !== 0;
    };
    is.ge = function(value, other) {
      if (isActualNaN(value) || isActualNaN(other)) {
        throw new TypeError("NaN is not a valid value");
      }
      return !is.infinite(value) && !is.infinite(other) && value >= other;
    };
    is.gt = function(value, other) {
      if (isActualNaN(value) || isActualNaN(other)) {
        throw new TypeError("NaN is not a valid value");
      }
      return !is.infinite(value) && !is.infinite(other) && value > other;
    };
    is.le = function(value, other) {
      if (isActualNaN(value) || isActualNaN(other)) {
        throw new TypeError("NaN is not a valid value");
      }
      return !is.infinite(value) && !is.infinite(other) && value <= other;
    };
    is.lt = function(value, other) {
      if (isActualNaN(value) || isActualNaN(other)) {
        throw new TypeError("NaN is not a valid value");
      }
      return !is.infinite(value) && !is.infinite(other) && value < other;
    };
    is.within = function(value, start, finish) {
      if (isActualNaN(value) || isActualNaN(start) || isActualNaN(finish)) {
        throw new TypeError("NaN is not a valid value");
      } else if (!is.number(value) || !is.number(start) || !is.number(finish)) {
        throw new TypeError("all arguments must be numbers");
      }
      var isAnyInfinite = is.infinite(value) || is.infinite(start) || is.infinite(finish);
      return isAnyInfinite || value >= start && value <= finish;
    };
    is.object = function(value) {
      return value && "[object Object]" === toString.call(value);
    };
    is.hash = function(value) {
      return is.object(value) && value.constructor === Object && !value.nodeType && !value.setInterval;
    };
    is.regexp = function(value) {
      return "[object RegExp]" === toString.call(value);
    };
    is.string = function(value) {
      return "[object String]" === toString.call(value);
    };
  }
});

// node_modules/foreach/index.js
var require_foreach2 = __commonJS({
  "node_modules/foreach/index.js"(exports, module) {
    var hasOwn = Object.prototype.hasOwnProperty;
    var toString = Object.prototype.toString;
    module.exports = function forEach(obj, fn, ctx) {
      if (toString.call(fn) !== "[object Function]") {
        throw new TypeError("iterator must be a function");
      }
      var l = obj.length;
      if (l === +l) {
        for (var i = 0; i < l; i++) {
          fn.call(ctx, obj[i], i, obj);
        }
      } else {
        for (var k in obj) {
          if (hasOwn.call(obj, k)) {
            fn.call(ctx, obj[k], k, obj);
          }
        }
      }
    };
  }
});

// node_modules/level-sublevel/node_modules/object-keys/shim.js
var require_shim2 = __commonJS({
  "node_modules/level-sublevel/node_modules/object-keys/shim.js"(exports, module) {
    (function() {
      "use strict";
      var has = Object.prototype.hasOwnProperty, is = require_is(), forEach = require_foreach2(), hasDontEnumBug = !{ "toString": null }.propertyIsEnumerable("toString"), dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ], keysShim;
      keysShim = function keys(object) {
        if (!is.object(object) && !is.array(object)) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var name, theKeys = [];
        for (name in object) {
          if (has.call(object, name)) {
            theKeys.push(name);
          }
        }
        if (hasDontEnumBug) {
          forEach(dontEnums, function(dontEnum) {
            if (has.call(object, dontEnum)) {
              theKeys.push(dontEnum);
            }
          });
        }
        return theKeys;
      };
      module.exports = keysShim;
    })();
  }
});

// node_modules/level-sublevel/node_modules/object-keys/index.js
var require_object_keys2 = __commonJS({
  "node_modules/level-sublevel/node_modules/object-keys/index.js"(exports, module) {
    module.exports = Object.keys || require_shim2();
  }
});

// node_modules/level-sublevel/node_modules/xtend/has-keys.js
var require_has_keys2 = __commonJS({
  "node_modules/level-sublevel/node_modules/xtend/has-keys.js"(exports, module) {
    module.exports = hasKeys;
    function hasKeys(source) {
      return source !== null && (typeof source === "object" || typeof source === "function");
    }
  }
});

// node_modules/level-sublevel/node_modules/xtend/index.js
var require_xtend4 = __commonJS({
  "node_modules/level-sublevel/node_modules/xtend/index.js"(exports, module) {
    var Keys = require_object_keys2();
    var hasKeys = require_has_keys2();
    module.exports = extend;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        if (!hasKeys(source)) {
          continue;
        }
        var keys = Keys(source);
        for (var j = 0; j < keys.length; j++) {
          var name = keys[j];
          target[name] = source[name];
        }
      }
      return target;
    }
  }
});

// node_modules/level-sublevel/batch.js
var require_batch2 = __commonJS({
  "node_modules/level-sublevel/batch.js"(exports, module) {
    function addOperation(type, key, value, options) {
      var operation = {
        type,
        key,
        value,
        options
      };
      if (options && options.prefix) {
        operation.prefix = options.prefix;
        delete options.prefix;
      }
      this._operations.push(operation);
      return this;
    }
    function Batch(sdb) {
      this._operations = [];
      this._sdb = sdb;
      this.put = addOperation.bind(this, "put");
      this.del = addOperation.bind(this, "del");
    }
    var B = Batch.prototype;
    B.clear = function() {
      this._operations = [];
    };
    B.write = function(cb) {
      this._sdb.batch(this._operations, cb);
    };
    module.exports = Batch;
  }
});

// node_modules/level-sublevel/sub.js
var require_sub = __commonJS({
  "node_modules/level-sublevel/sub.js"(exports, module) {
    var EventEmitter = require_events().EventEmitter;
    var inherits = require_util().inherits;
    var ranges = require_string_range();
    var fixRange = require_level_fix_range();
    var xtend = require_xtend4();
    var Batch = require_batch2();
    inherits(SubDB, EventEmitter);
    function SubDB(db2, prefix, options) {
      if ("string" === typeof options) {
        console.error("db.sublevel(name, seperator<string>) is depreciated");
        console.error("use db.sublevel(name, {sep: separator})) if you must");
        options = { sep: options };
      }
      if (!(this instanceof SubDB))
        return new SubDB(db2, prefix, options);
      if (!db2)
        throw new Error("must provide db");
      if (!prefix)
        throw new Error("must provide prefix");
      options = options || {};
      options.sep = options.sep || "Ã¿";
      this._parent = db2;
      this._options = options;
      this.options = options;
      this._prefix = prefix;
      this._root = root(this);
      db2.sublevels[prefix] = this;
      this.sublevels = {};
      this.methods = {};
      var self2 = this;
      this.hooks = {
        pre: function() {
          return self2.pre.apply(self2, arguments);
        },
        post: function() {
          return self2.post.apply(self2, arguments);
        }
      };
    }
    var SDB = SubDB.prototype;
    SDB._key = function(key) {
      var sep = this._options.sep;
      return sep + this._prefix + sep + key;
    };
    SDB._getOptsAndCb = function(opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      return { opts: xtend(opts, this._options), cb };
    };
    SDB.sublevel = function(prefix, options) {
      if (this.sublevels[prefix])
        return this.sublevels[prefix];
      return new SubDB(this, prefix, options || this._options);
    };
    SDB.put = function(key, value, opts, cb) {
      var res = this._getOptsAndCb(opts, cb);
      this._root.put(this.prefix(key), value, res.opts, res.cb);
    };
    SDB.get = function(key, opts, cb) {
      var res = this._getOptsAndCb(opts, cb);
      this._root.get(this.prefix(key), res.opts, res.cb);
    };
    SDB.del = function(key, opts, cb) {
      var res = this._getOptsAndCb(opts, cb);
      this._root.del(this.prefix(key), res.opts, res.cb);
    };
    SDB.batch = function(changes, opts, cb) {
      if (!Array.isArray(changes))
        return new Batch(this);
      var self2 = this, res = this._getOptsAndCb(opts, cb);
      changes.forEach(function(ch) {
        if ("string" === typeof ch.prefix)
          ch.key = ch.prefix + ch.key;
        else
          ch.key = (ch.prefix || self2).prefix(ch.key);
        if (ch.prefix)
          ch.prefix = null;
      });
      this._root.batch(changes, res.opts, res.cb);
    };
    SDB._getKeyEncoding = function() {
      if (this.options.keyEncoding)
        return this.options.keyEncoding;
      if (this._parent && this._parent._getKeyEncoding)
        return this._parent._getKeyEncoding();
    };
    SDB._getValueEncoding = function() {
      if (this.options.valueEncoding)
        return this.options.valueEncoding;
      if (this._parent && this._parent._getValueEncoding)
        return this._parent._getValueEncoding();
    };
    SDB.prefix = function(key) {
      var sep = this._options.sep;
      return this._parent.prefix() + sep + this._prefix + sep + (key || "");
    };
    SDB.keyStream = SDB.createKeyStream = function(opts) {
      opts = opts || {};
      opts.keys = true;
      opts.values = false;
      return this.createReadStream(opts);
    };
    SDB.valueStream = SDB.createValueStream = function(opts) {
      opts = opts || {};
      opts.keys = false;
      opts.values = true;
      opts.keys = false;
      return this.createReadStream(opts);
    };
    function selectivelyMerge(_opts, opts) {
      [
        "valueEncoding",
        "encoding",
        "keyEncoding",
        "reverse",
        "values",
        "keys",
        "limit",
        "fillCache"
      ].forEach(function(k) {
        if (opts.hasOwnProperty(k))
          _opts[k] = opts[k];
      });
    }
    SDB.readStream = SDB.createReadStream = function(opts) {
      opts = opts || {};
      var r = root(this);
      var p = this.prefix();
      var _opts = ranges.prefix(opts, p);
      selectivelyMerge(_opts, xtend(opts, this._options));
      var s = r.createReadStream(_opts);
      if (_opts.values === false) {
        var read = s.read;
        if (read) {
          s.read = function(size) {
            var val = read.call(this, size);
            if (val)
              val = val.substring(p.length);
            return val;
          };
        } else {
          var emit = s.emit;
          s.emit = function(event, val) {
            if (event === "data") {
              emit.call(this, "data", val.substring(p.length));
            } else
              emit.call(this, event, val);
          };
        }
        return s;
      } else if (_opts.keys === false)
        return s;
      else {
        var read = s.read;
        if (read) {
          s.read = function(size) {
            var d = read.call(this, size);
            if (d)
              d.key = d.key.substring(p.length);
            return d;
          };
        } else {
          s.on("data", function(d) {
            d.key = d.key.substring(p.length);
          });
        }
        return s;
      }
    };
    SDB.writeStream = SDB.createWriteStream = function() {
      var r = root(this);
      var p = this.prefix();
      var ws = r.createWriteStream.apply(r, arguments);
      var write = ws.write;
      var encoding = this._options.encoding;
      var valueEncoding = this._options.valueEncoding;
      var keyEncoding = this._options.keyEncoding;
      var nocheck = !encoding && !valueEncoding && !keyEncoding;
      ws.write = nocheck ? function(data) {
        data.key = p + data.key;
        return write.call(ws, data);
      } : function(data) {
        data.key = p + data.key;
        if (encoding && typeof data.encoding === "undefined")
          data.encoding = encoding;
        if (valueEncoding && typeof data.valueEncoding === "undefined")
          data.valueEncoding = valueEncoding;
        if (keyEncoding && typeof data.keyEncoding === "undefined")
          data.keyEncoding = keyEncoding;
        return write.call(ws, data);
      };
      return ws;
    };
    SDB.approximateSize = function() {
      var r = root(db);
      return r.approximateSize.apply(r, arguments);
    };
    function root(db2) {
      if (!db2._parent)
        return db2;
      return root(db2._parent);
    }
    SDB.pre = function(range, hook) {
      if (!hook)
        hook = range, range = null;
      range = ranges.prefix(range, this.prefix(), this._options.sep);
      var r = root(this._parent);
      var p = this.prefix();
      return r.hooks.pre(fixRange(range), function(ch, add, batch) {
        hook({
          key: ch.key.substring(p.length),
          value: ch.value,
          type: ch.type
        }, function(ch2, _p) {
          add(ch2, ch2.prefix ? _p : _p || p);
        }, batch);
      });
    };
    SDB.post = function(range, hook) {
      if (!hook)
        hook = range, range = null;
      var r = root(this._parent);
      var p = this.prefix();
      range = ranges.prefix(range, p, this._options.sep);
      return r.hooks.post(fixRange(range), function(data) {
        hook({ key: data.key.substring(p.length), value: data.value, type: data.type });
      });
    };
    var exports = module.exports = SubDB;
  }
});

// node_modules/level-hooks/index.js
var require_level_hooks = __commonJS({
  "node_modules/level-hooks/index.js"(exports, module) {
    var ranges = require_string_range();
    module.exports = function(db2) {
      if (db2.hooks) {
        return;
      }
      var posthooks = [];
      var prehooks = [];
      function getPrefix(p) {
        return p && ("string" === typeof p ? p : "string" === typeof p.prefix ? p.prefix : "function" === typeof p.prefix ? p.prefix() : "");
      }
      function getKeyEncoding(db3) {
        if (db3 && db3._getKeyEncoding)
          return db3._getKeyEncoding(db3);
      }
      function getValueEncoding(db3) {
        if (db3 && db3._getValueEncoding)
          return db3._getValueEncoding(db3);
      }
      function remover(array, item) {
        return function() {
          var i = array.indexOf(item);
          if (!~i)
            return false;
          array.splice(i, 1);
          return true;
        };
      }
      db2.hooks = {
        post: function(prefix, hook) {
          if (!hook)
            hook = prefix, prefix = "";
          var h = { test: ranges.checker(prefix), hook };
          posthooks.push(h);
          return remover(posthooks, h);
        },
        pre: function(prefix, hook) {
          if (!hook)
            hook = prefix, prefix = "";
          var h = {
            test: ranges.checker(prefix),
            hook,
            safe: false !== prefix.safe
          };
          prehooks.push(h);
          return remover(prehooks, h);
        },
        posthooks,
        prehooks
      };
      function each(e) {
        if (e && e.type) {
          posthooks.forEach(function(h) {
            if (h.test(e.key))
              h.hook(e);
          });
        }
      }
      db2.on("put", function(key, val) {
        each({ type: "put", key, value: val });
      });
      db2.on("del", function(key, val) {
        each({ type: "del", key, value: val });
      });
      db2.on("batch", function onBatch(ary) {
        ary.forEach(each);
      });
      var put = db2.put;
      var del = db2.del;
      var batch = db2.batch;
      function callHooks(isBatch, b, opts, cb) {
        try {
          b.forEach(function hook(e, i) {
            prehooks.forEach(function(h) {
              if (h.test(String(e.key))) {
                var context = {
                  add: function(ch, db3) {
                    if (typeof ch === "undefined") {
                      return this;
                    }
                    if (ch === false)
                      return delete b[i];
                    var prefix = getPrefix(ch.prefix) || getPrefix(db3) || h.prefix || "";
                    if (prefix)
                      ch.prefix = prefix;
                    ch.key = prefix + ch.key;
                    if (h.safe && h.test(String(ch.key))) {
                      throw new Error("prehook cannot insert into own range");
                    }
                    var ke = ch.keyEncoding || getKeyEncoding(ch.prefix);
                    var ve = ch.valueEncoding || getValueEncoding(ch.prefix);
                    if (ke)
                      ch.keyEncoding = ke;
                    if (ve)
                      ch.valueEncoding = ve;
                    b.push(ch);
                    hook(ch, b.length - 1);
                    return this;
                  },
                  put: function(ch, db3) {
                    if ("object" === typeof ch)
                      ch.type = "put";
                    return this.add(ch, db3);
                  },
                  del: function(ch, db3) {
                    if ("object" === typeof ch)
                      ch.type = "del";
                    return this.add(ch, db3);
                  },
                  veto: function() {
                    return this.add(false);
                  }
                };
                h.hook.call(context, e, context.add, b);
              }
            });
          });
        } catch (err) {
          return (cb || opts)(err);
        }
        b = b.filter(function(e) {
          return e && e.type;
        });
        if (b.length == 1 && !isBatch) {
          var change = b[0];
          return change.type == "put" ? put.call(db2, change.key, change.value, opts, cb) : del.call(db2, change.key, opts, cb);
        }
        return batch.call(db2, b, opts, cb);
      }
      db2.put = function(key, value, opts, cb) {
        var batch2 = [{ key, value, type: "put" }];
        return callHooks(false, batch2, opts, cb);
      };
      db2.del = function(key, opts, cb) {
        var batch2 = [{ key, type: "del" }];
        return callHooks(false, batch2, opts, cb);
      };
      db2.batch = function(batch2, opts, cb) {
        return callHooks(true, batch2, opts, cb);
      };
    };
  }
});

// node_modules/level-sublevel/index.js
var require_level_sublevel = __commonJS({
  "node_modules/level-sublevel/index.js"(exports, module) {
    var EventEmitter = require_events().EventEmitter;
    var next = process.nextTick;
    var SubDb = require_sub();
    var Batch = require_batch2();
    var fixRange = require_level_fix_range();
    var Hooks = require_level_hooks();
    module.exports = function(_db, options) {
      function DB() {
      }
      DB.prototype = _db;
      var db2 = new DB();
      if (db2.sublevel)
        return db2;
      options = options || {};
      var sep = options.sep = options.sep || "Ã¿";
      db2._options = options;
      Hooks(db2);
      db2.sublevels = {};
      db2.sublevel = function(prefix, options2) {
        if (db2.sublevels[prefix])
          return db2.sublevels[prefix];
        return new SubDb(db2, prefix, options2 || this._options);
      };
      db2.methods = {};
      db2.prefix = function(key) {
        return "" + (key || "");
      };
      db2.pre = function(range, hook) {
        if (!hook)
          hook = range, range = {
            max: sep
          };
        return db2.hooks.pre(range, hook);
      };
      db2.post = function(range, hook) {
        if (!hook)
          hook = range, range = {
            max: sep
          };
        return db2.hooks.post(range, hook);
      };
      function safeRange(fun) {
        return function(opts) {
          opts = opts || {};
          opts = fixRange(opts);
          if (opts.reverse)
            opts.start = opts.start || sep;
          else
            opts.end = opts.end || sep;
          return fun.call(db2, opts);
        };
      }
      db2.readStream = db2.createReadStream = safeRange(db2.createReadStream);
      db2.keyStream = db2.createKeyStream = safeRange(db2.createKeyStream);
      db2.valuesStream = db2.createValueStream = safeRange(db2.createValueStream);
      var batch = db2.batch;
      db2.batch = function(changes, opts, cb) {
        if (!Array.isArray(changes))
          return new Batch(db2);
        changes.forEach(function(e) {
          if (e.prefix) {
            if ("function" === typeof e.prefix.prefix)
              e.key = e.prefix.prefix(e.key);
            else if ("string" === typeof e.prefix)
              e.key = e.prefix + e.key;
          }
        });
        batch.call(db2, changes, opts, cb);
      };
      return db2;
    };
  }
});

// node_modules/level-blobs/node_modules/isarray/index.js
var require_isarray4 = __commonJS({
  "node_modules/level-blobs/node_modules/isarray/index.js"(exports, module) {
    module.exports = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == "[object Array]";
    };
  }
});

// browser-external:util
var require_util4 = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/level-blobs/node_modules/string_decoder/index.js
var require_string_decoder4 = __commonJS({
  "node_modules/level-blobs/node_modules/string_decoder/index.js"(exports) {
    var Buffer2 = require_buffer().Buffer;
    var isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function assertEncoding(encoding) {
      if (encoding && !isBufferEncoding(encoding)) {
        throw new Error("Unknown encoding: " + encoding);
      }
    }
    var StringDecoder = exports.StringDecoder = function(encoding) {
      this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
      assertEncoding(encoding);
      switch (this.encoding) {
        case "utf8":
          this.surrogateSize = 3;
          break;
        case "ucs2":
        case "utf16le":
          this.surrogateSize = 2;
          this.detectIncompleteChar = utf16DetectIncompleteChar;
          break;
        case "base64":
          this.surrogateSize = 3;
          this.detectIncompleteChar = base64DetectIncompleteChar;
          break;
        default:
          this.write = passThroughWrite;
          return;
      }
      this.charBuffer = new Buffer2(6);
      this.charReceived = 0;
      this.charLength = 0;
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
    function passThroughWrite(buffer) {
      return buffer.toString(this.encoding);
    }
    function utf16DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 2;
      this.charLength = this.charReceived ? 2 : 0;
    }
    function base64DetectIncompleteChar(buffer) {
      this.charReceived = buffer.length % 3;
      this.charLength = this.charReceived ? 3 : 0;
    }
  }
});

// node_modules/level-blobs/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable4 = __commonJS({
  "node_modules/level-blobs/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    module.exports = Readable;
    var isArray = require_isarray4();
    var Buffer2 = require_buffer().Buffer;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    if (!EE.listenerCount)
      EE.listenerCount = function(emitter, type) {
        return emitter.listeners(type).length;
      };
    var Stream = require_stream();
    var util = require_util2();
    util.inherits = require_inherits_browser();
    var StringDecoder;
    var debug = require_util4();
    if (debug && debug.debuglog) {
      debug = debug.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    util.inherits(Readable, Stream);
    function ReadableState(options, stream) {
      var Duplex = require_stream_duplex4();
      options = options || {};
      var hwm = options.highWaterMark;
      var defaultHwm = options.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
      this.highWaterMark = ~~this.highWaterMark;
      this.buffer = [];
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.ranOut = false;
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder4().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      var Duplex = require_stream_duplex4();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      Stream.call(this);
    }
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (util.isString(chunk) && !state.objectMode) {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = new Buffer2(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
      var er = chunkInvalid(state, chunk);
      if (er) {
        stream.emit("error", er);
      } else if (util.isNullOrUndefined(chunk)) {
        state.reading = false;
        if (!state.ended)
          onEofChunk(stream, state);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (state.ended && !addToFront) {
          var e = new Error("stream.push() after EOF");
          stream.emit("error", e);
        } else if (state.endEmitted && addToFront) {
          var e = new Error("stream.unshift() after end event");
          stream.emit("error", e);
        } else {
          if (state.decoder && !addToFront && !encoding)
            chunk = state.decoder.write(chunk);
          if (!addToFront)
            state.reading = false;
          if (state.flowing && state.length === 0 && !state.sync) {
            stream.emit("data", chunk);
            stream.read(0);
          } else {
            state.length += state.objectMode ? 1 : chunk.length;
            if (addToFront)
              state.buffer.unshift(chunk);
            else
              state.buffer.push(chunk);
            if (state.needReadable)
              emitReadable(stream);
          }
          maybeReadMore(stream, state);
        }
      } else if (!addToFront) {
        state.reading = false;
      }
      return needMoreData(state);
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder4().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function roundUpToNextPowerOf2(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        for (var p = 1; p < 32; p <<= 1)
          n |= n >> p;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return n === 0 ? 0 : 1;
      if (isNaN(n) || util.isNull(n)) {
        if (state.flowing && state.buffer.length)
          return state.buffer[0].length;
        else
          return state.length;
      }
      if (n <= 0)
        return 0;
      if (n > state.highWaterMark)
        state.highWaterMark = roundUpToNextPowerOf2(n);
      if (n > state.length) {
        if (!state.ended) {
          state.needReadable = true;
          return 0;
        } else
          return state.length;
      }
      return n;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      var state = this._readableState;
      var nOrig = n;
      if (!util.isNumber(n) || n > 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      }
      if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
      }
      if (doRead && !state.reading)
        n = howMuchToRead(nOrig, state);
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (util.isNull(ret)) {
        state.needReadable = true;
        n = 0;
      }
      state.length -= n;
      if (state.length === 0 && !state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended && state.length === 0)
        endReadable(this);
      if (!util.isNull(ret))
        this.emit("data", ret);
      return ret;
    };
    function chunkInvalid(state, chunk) {
      var er = null;
      if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function onEofChunk(stream, state) {
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          process.nextTick(function() {
            emitReadable_(stream);
          });
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(function() {
          maybeReadMore_(stream, state);
        });
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : cleanup;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe");
        if (readable === src) {
          cleanup();
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", cleanup);
        src.removeListener("data", ondata);
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        if (false === ret) {
          debug(
            "false write response, pause",
            src._readableState.awaitDrain
          );
          src._readableState.awaitDrain++;
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EE.listenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      if (!dest._events || !dest._events.error)
        dest.on("error", onerror);
      else if (isArray(dest._events.error))
        dest._events.error.unshift(onerror);
      else
        dest._events.error = [onerror, dest._events.error];
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EE.listenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++)
          dests[i].emit("unpipe", this);
        return this;
      }
      var i = indexOf(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data" && false !== this._readableState.flowing) {
        this.resume();
      }
      if (ev === "readable" && this.readable) {
        var state = this._readableState;
        if (!state.readableListening) {
          state.readableListening = true;
          state.emittedReadable = false;
          state.needReadable = true;
          if (!state.reading) {
            var self2 = this;
            process.nextTick(function() {
              debug("readable nexttick read 0");
              self2.read(0);
            });
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        if (!state.reading) {
          debug("resume read 0");
          this.read(0);
        }
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(function() {
          resume_(stream, state);
        });
      }
    }
    function resume_(stream, state) {
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      if (state.flowing) {
        do {
          var chunk = stream.read();
        } while (null !== chunk && state.flowing);
      }
    }
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (!chunk || !state.objectMode && !chunk.length)
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
    function fromList(n, state) {
      var list = state.buffer;
      var length = state.length;
      var stringMode = !!state.decoder;
      var objectMode = !!state.objectMode;
      var ret;
      if (list.length === 0)
        return null;
      if (length === 0)
        ret = null;
      else if (objectMode)
        ret = list.shift();
      else if (!n || n >= length) {
        if (stringMode)
          ret = list.join("");
        else
          ret = Buffer2.concat(list, length);
        list.length = 0;
      } else {
        if (n < list[0].length) {
          var buf = list[0];
          ret = buf.slice(0, n);
          list[0] = buf.slice(n);
        } else if (n === list[0].length) {
          ret = list.shift();
        } else {
          if (stringMode)
            ret = "";
          else
            ret = new Buffer2(n);
          var c = 0;
          for (var i = 0, l = list.length; i < l && c < n; i++) {
            var buf = list[0];
            var cpy = Math.min(n - c, buf.length);
            if (stringMode)
              ret += buf.slice(0, cpy);
            else
              buf.copy(ret, c, 0, cpy);
            if (cpy < buf.length)
              list[0] = buf.slice(cpy);
            else
              list.shift();
            c += cpy;
          }
        }
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error("endReadable called on non-empty stream");
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(function() {
          if (!state.endEmitted && state.length === 0) {
            state.endEmitted = true;
            stream.readable = false;
            stream.emit("end");
          }
        });
      }
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/level-blobs/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex4 = __commonJS({
  "node_modules/level-blobs/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    module.exports = Duplex;
    var objectKeys = Object.keys || function(obj) {
      var keys = [];
      for (var key in obj)
        keys.push(key);
      return keys;
    };
    var util = require_util2();
    util.inherits = require_inherits_browser();
    var Readable = require_stream_readable4();
    var Writable = require_stream_writable4();
    util.inherits(Duplex, Readable);
    forEach(objectKeys(Writable.prototype), function(method) {
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    });
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      process.nextTick(this.end.bind(this));
    }
    function forEach(xs, f) {
      for (var i = 0, l = xs.length; i < l; i++) {
        f(xs[i], i);
      }
    }
  }
});

// node_modules/level-blobs/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable4 = __commonJS({
  "node_modules/level-blobs/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    module.exports = Writable;
    var Buffer2 = require_buffer().Buffer;
    Writable.WritableState = WritableState;
    var util = require_util2();
    util.inherits = require_inherits_browser();
    var Stream = require_stream();
    util.inherits(Writable, Stream);
    function WriteReq(chunk, encoding, cb) {
      this.chunk = chunk;
      this.encoding = encoding;
      this.callback = cb;
    }
    function WritableState(options, stream) {
      var Duplex = require_stream_duplex4();
      options = options || {};
      var hwm = options.highWaterMark;
      var defaultHwm = options.objectMode ? 16 : 16 * 1024;
      this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
      this.objectMode = !!options.objectMode;
      if (stream instanceof Duplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = ~~this.highWaterMark;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.buffer = [];
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
    }
    function Writable(options) {
      var Duplex = require_stream_duplex4();
      if (!(this instanceof Writable) && !(this instanceof Duplex))
        return new Writable(options);
      this._writableState = new WritableState(options, this);
      this.writable = true;
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe. Not readable."));
    };
    function writeAfterEnd(stream, state, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      process.nextTick(function() {
        cb(er);
      });
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      if (!util.isBuffer(chunk) && !util.isString(chunk) && !util.isNullOrUndefined(chunk) && !state.objectMode) {
        var er = new TypeError("Invalid non-string/buffer chunk");
        stream.emit("error", er);
        process.nextTick(function() {
          cb(er);
        });
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (util.isFunction(encoding)) {
        cb = encoding;
        encoding = null;
      }
      if (util.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (!util.isFunction(cb))
        cb = function() {
        };
      if (state.ended)
        writeAfterEnd(this, state, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.buffer.length)
          clearBuffer(this, state);
      }
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && util.isString(chunk)) {
        chunk = new Buffer2(chunk, encoding);
      }
      return chunk;
    }
    function writeOrBuffer(stream, state, chunk, encoding, cb) {
      chunk = decodeChunk(state, chunk, encoding);
      if (util.isBuffer(chunk))
        encoding = "buffer";
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked)
        state.buffer.push(new WriteReq(chunk, encoding, cb));
      else
        doWrite(stream, state, false, len, chunk, encoding, cb);
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      if (sync)
        process.nextTick(function() {
          state.pendingcb--;
          cb(er);
        });
      else {
        state.pendingcb--;
        cb(er);
      }
      stream._writableState.errorEmitted = true;
      stream.emit("error", er);
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(stream, state);
        if (!finished && !state.corked && !state.bufferProcessing && state.buffer.length) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(function() {
            afterWrite(stream, state, finished, cb);
          });
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      if (stream._writev && state.buffer.length > 1) {
        var cbs = [];
        for (var c = 0; c < state.buffer.length; c++)
          cbs.push(state.buffer[c].callback);
        state.pendingcb++;
        doWrite(stream, state, true, state.length, state.buffer, "", function(err) {
          for (var i = 0; i < cbs.length; i++) {
            state.pendingcb--;
            cbs[i](err);
          }
        });
        state.buffer = [];
      } else {
        for (var c = 0; c < state.buffer.length; c++) {
          var entry = state.buffer[c];
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          if (state.writing) {
            c++;
            break;
          }
        }
        if (c < state.buffer.length)
          state.buffer = state.buffer.slice(c);
        else
          state.buffer.length = 0;
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (util.isFunction(chunk)) {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (util.isFunction(encoding)) {
        cb = encoding;
        encoding = null;
      }
      if (!util.isNullOrUndefined(chunk))
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(stream, state) {
      return state.ending && state.length === 0 && !state.finished && !state.writing;
    }
    function prefinish(stream, state) {
      if (!state.prefinished) {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(stream, state);
      if (need) {
        if (state.pendingcb === 0) {
          prefinish(stream, state);
          state.finished = true;
          stream.emit("finish");
        } else
          prefinish(stream, state);
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
    }
  }
});

// node_modules/level-blobs/node_modules/readable-stream/writable.js
var require_writable2 = __commonJS({
  "node_modules/level-blobs/node_modules/readable-stream/writable.js"(exports, module) {
    module.exports = require_stream_writable4();
  }
});

// node_modules/level-blobs/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform4 = __commonJS({
  "node_modules/level-blobs/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    module.exports = Transform;
    var Duplex = require_stream_duplex4();
    var util = require_util2();
    util.inherits = require_inherits_browser();
    util.inherits(Transform, Duplex);
    function TransformState(options, stream) {
      this.afterTransform = function(er, data) {
        return afterTransform(stream, er, data);
      };
      this.needTransform = false;
      this.transforming = false;
      this.writecb = null;
      this.writechunk = null;
    }
    function afterTransform(stream, er, data) {
      var ts = stream._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb)
        return stream.emit("error", new Error("no writecb in Transform class"));
      ts.writechunk = null;
      ts.writecb = null;
      if (!util.isNullOrUndefined(data))
        stream.push(data);
      if (cb)
        cb(er);
      var rs = stream._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        stream._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = new TransformState(options, this);
      var stream = this;
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      this.once("prefinish", function() {
        if (util.isFunction(this._flush))
          this._flush(function(er) {
            done(stream, er);
          });
        else
          done(stream);
      });
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    function done(stream, er) {
      if (er)
        return stream.emit("error", er);
      var ws = stream._writableState;
      var ts = stream._transformState;
      if (ws.length)
        throw new Error("calling transform done when ws.length != 0");
      if (ts.transforming)
        throw new Error("calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/level-blobs/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough4 = __commonJS({
  "node_modules/level-blobs/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    module.exports = PassThrough;
    var Transform = require_stream_transform4();
    var util = require_util2();
    util.inherits = require_inherits_browser();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/level-blobs/node_modules/readable-stream/readable.js
var require_readable4 = __commonJS({
  "node_modules/level-blobs/node_modules/readable-stream/readable.js"(exports, module) {
    exports = module.exports = require_stream_readable4();
    exports.Stream = require_stream();
    exports.Readable = exports;
    exports.Writable = require_stream_writable4();
    exports.Duplex = require_stream_duplex4();
    exports.Transform = require_stream_transform4();
    exports.PassThrough = require_stream_passthrough4();
    if (!process.browser && process.env.READABLE_STREAM === "disable") {
      module.exports = require_stream();
    }
  }
});

// node_modules/level-fix-range/index.js
var require_level_fix_range2 = __commonJS({
  "node_modules/level-fix-range/index.js"(exports, module) {
    module.exports = function fixRange(opts) {
      var reverse = opts.reverse;
      var end = opts.end;
      var start = opts.start;
      var range = [start, end];
      if (start != null && end != null)
        range.sort();
      if (reverse)
        range = range.reverse();
      opts.start = range[0];
      opts.end = range[1];
      return opts;
    };
  }
});

// node_modules/level-peek/index.js
var require_level_peek = __commonJS({
  "node_modules/level-peek/index.js"(exports, module) {
    var fixRange = require_level_fix_range2();
    exports = module.exports = peek;
    exports.first = first;
    exports.last = last;
    function once(emitter, events, listener) {
      var remove = [];
      events.forEach(function(e) {
        function onEvent(arg) {
          if (listener(e, arg) === false)
            return;
          remove.forEach(function(r) {
            r();
          });
        }
        emitter.on(e, onEvent);
        remove.push(function() {
          emitter.removeListener(e, onEvent);
        });
      });
      return emitter;
    }
    function peek(db2, opts, cb) {
      opts.limit = opts.reverse ? 2 : 1;
      var stream = once(
        db2.createReadStream(opts),
        ["data", "error", "end"],
        function(event, data) {
          if (opts.reverse && data && opts.start && data.key.toString() > opts.start)
            return false;
          if (event == "error")
            cb(data);
          else if (event == "end")
            cb(new Error("range not found"), null, null);
          else
            cb(null, data.key, data.value);
        }
      );
    }
    function first(db2, opts, cb) {
      if (!cb) {
        cb = opts;
        opts = {};
      }
      opts.reverse = false;
      return peek(db2, fixRange(opts), cb);
    }
    function last(db2, opts, cb) {
      if (!cb) {
        cb = opts;
        opts = {};
      }
      var start = opts.start;
      opts.reverse = true;
      return peek(db2, fixRange(opts), function(err, key, value) {
        if (err) {
          var _start = opts.start;
          opts.start = null;
          peek(db2, opts, function(_, key2, value2) {
            if (!key2)
              return cb(err, null, null);
            var _key = key2.toString();
            if (_key <= _start && (!opts.end || _key >= opts.end))
              cb(_, key2, value2);
            else
              cb(err, null, null);
          });
        } else
          cb(err, key, value);
      });
    }
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module) {
    module.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module) {
    var wrappy = require_wrappy();
    module.exports = wrappy(once);
    module.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/level-blobs/index.js
var require_level_blobs = __commonJS({
  "node_modules/level-blobs/index.js"(exports, module) {
    var Writable = require_writable2();
    var Readable = require_readable4();
    var peek = require_level_peek();
    var util = require_util();
    var once = require_once();
    var EMPTY = new Buffer(0);
    var ENCODER = {
      encode: function(data) {
        return typeof data === "string" ? data = new Buffer(data) : data;
      },
      decode: function(data) {
        return Buffer.isBuffer(data) ? data : new Buffer(data);
      },
      buffer: true,
      type: "raw"
    };
    var noop = function() {
    };
    var pad = function(n) {
      n = n.toString(16);
      return "00000000".slice(0, -n.length) + n;
    };
    var expand = function(buf, len) {
      var tmp = new Buffer(len);
      buf.copy(tmp);
      return tmp;
    };
    module.exports = function(db2, opts) {
      if (!opts)
        opts = {};
      var blobs = {};
      var blockSize = opts.blockSize || 65536;
      var maxBatch = opts.batch || 100;
      var blank = new Buffer(blockSize);
      db2.put("\0", "ignore", noop);
      var reservations = {};
      var mutateBlock = function(key, offset, block, append, cb) {
        var release = function() {
          if (!--reservations[key].locks)
            delete reservations[key];
        };
        var onreservation = function(r) {
          r.locks++;
          if (!r.block && !offset) {
            r.block = block;
            cb(null, r.block, release);
            return;
          }
          if (!r.block)
            r.block = new Buffer(blockSize);
          if (r.block.length < offset + block.length)
            r.block = expand(r.block, offset + block.length);
          block.copy(r.block, offset);
          if (!append && offset + block.length < r.block.length)
            r.block = r.block.slice(0, offset + block.length);
          cb(null, r.block, release);
        };
        if (reservations[key])
          return onreservation(reservations[key]);
        db2.get(key, { valueEncoding: ENCODER }, function(err, block2) {
          if (err && !err.notFound)
            return cb(err);
          if (!reservations[key])
            reservations[key] = { locks: 0, block: block2 };
          onreservation(reservations[key]);
        });
      };
      var WriteStream = function(name, opts2) {
        if (!(this instanceof WriteStream))
          return new WriteStream(name, opts2);
        if (!opts2)
          opts2 = {};
        this.name = name;
        this.blocks = [];
        this.batch = [];
        this.bytesWritten = 0;
        this.truncate = !opts2.append;
        this.append = opts2.append;
        this._shouldInitAppend = this.append && opts2.start === void 0;
        this._destroyed = false;
        this._init(opts2.start || 0);
        Writable.call(this);
      };
      util.inherits(WriteStream, Writable);
      WriteStream.prototype._init = function(start) {
        this.blockIndex = start / blockSize | 0;
        this.blockOffset = start - this.blockIndex * blockSize;
        this.blockLength = this.blockOffset;
      };
      WriteStream.prototype._flush = function(cb) {
        if (!this.batch.length)
          return cb();
        var key = this.batch[this.batch.length - 1].key;
        var batch = this.batch;
        this.batch = [];
        if (!this.truncate)
          return db2.batch(batch, cb);
        this.truncate = false;
        this._truncate(batch, key, cb);
      };
      WriteStream.prototype._truncate = function(batch, key, cb) {
        cb = once(cb);
        var dels = [];
        var keys = db2.createKeyStream({
          start: key,
          end: this.name + "Ã¿Ã¿"
        });
        keys.on("error", cb);
        keys.on("data", function(key2) {
          dels.push({ type: "del", key: key2 });
        });
        keys.on("end", function() {
          dels.push.apply(dels, batch);
          db2.batch(dels, cb);
        });
      };
      WriteStream.prototype._writeBlock = function(cb) {
        var block = this.blocks.length === 1 ? this.blocks[0] : Buffer.concat(this.blocks, this.blockLength - this.blockOffset);
        var index = this.blockIndex;
        var offset = this.blockOffset;
        var self2 = this;
        this.blockOffset = 0;
        this.blockLength = 0;
        this.blockIndex++;
        this.blocks = [];
        var key = this.name + "Ã¿" + pad(index);
        var append = function(block2, force, cb2) {
          if (block2.length) {
            self2.batch.push({
              type: "put",
              key,
              value: block2,
              valueEncoding: ENCODER
            });
          }
          if (!force && self2.batch.length < maxBatch)
            return cb2();
          return self2._flush(cb2);
        };
        if (!offset && block.length === blockSize)
          return append(block, false, cb);
        if (!offset && !this.append)
          return append(block, false, cb);
        mutateBlock(key, offset, block, this.append, function(err, block2, release) {
          if (err)
            return cb(err);
          append(block2, true, function(err2) {
            release();
            cb(err2);
          });
        });
      };
      WriteStream.prototype._initAppend = function(data, enc, cb) {
        var self2 = this;
        this._shouldInitAppend = false;
        blobs.size(this.name, function(err, size) {
          if (err)
            return cb(err);
          self2._init(size);
          self2._write(data, enc, cb);
        });
      };
      WriteStream.prototype._write = function(data, enc, cb) {
        if (!data.length || this._destroyed)
          return cb();
        if (this._shouldInitAppend)
          return this._initAppend(data, enc, cb);
        var self2 = this;
        var overflow;
        var free = blockSize - this.blockLength;
        var done = function(err) {
          if (err)
            return cb(err);
          if (overflow)
            return self2._write(overflow, enc, cb);
          cb();
        };
        if (data.length > free) {
          overflow = data.slice(free);
          data = data.slice(0, free);
        }
        this.bytesWritten += data.length;
        this.blockLength += data.length;
        this.blocks.push(data);
        if (data.length < free)
          return done();
        this._writeBlock(done);
      };
      WriteStream.prototype.destroy = function() {
        if (this._destroyed)
          return;
        this._destroyed = true;
        process.nextTick(this.emit.bind(this, "close"));
      };
      WriteStream.prototype.end = function(data) {
        var self2 = this;
        var args = arguments;
        if (data && typeof data !== "function") {
          this.write(data);
          data = EMPTY;
        }
        this.write(EMPTY, function() {
          self2._writeBlock(function(err) {
            if (err)
              return self2.emit("error", err);
            self2._flush(function(err2) {
              if (err2)
                return self2.emit("error", err2);
              Writable.prototype.end.apply(self2, args);
            });
          });
        });
      };
      var ReadStream = function(name, opts2) {
        if (!opts2)
          opts2 = {};
        var self2 = this;
        var start = opts2.start || 0;
        var blockIndex = start / blockSize | 0;
        var blockOffset = start - blockIndex * blockSize;
        var key = name + "Ã¿" + pad(blockIndex);
        this.name = name;
        this._missing = (typeof opts2.end === "number" ? opts2.end : Infinity) - start + 1;
        this._paused = false;
        this._destroyed = false;
        this._reader = db2.createReadStream({
          start: key,
          end: name + "Ã¿Ã¿",
          valueEncoding: ENCODER
        });
        var onblock = function(val) {
          key = name + "Ã¿" + pad(++blockIndex);
          if (!self2._missing)
            return false;
          if (blockOffset) {
            val = val.slice(blockOffset);
            blockOffset = 0;
            if (!val.length)
              return true;
          }
          if (val.length > self2._missing)
            val = val.slice(0, self2._missing);
          self2._missing -= val.length;
          self2._pause(!self2.push(val));
          return !!self2._missing;
        };
        this._reader.on("data", function(data) {
          while (data.key > key) {
            if (!onblock(blank))
              return;
          }
          onblock(data.value);
        });
        this._reader.on("error", function(err) {
          self2.emit("error", err);
        });
        this._reader.on("end", function() {
          self2.push(null);
        });
        Readable.call(this);
      };
      util.inherits(ReadStream, Readable);
      ReadStream.prototype.destroy = function() {
        if (this._destroyed)
          return;
        this._destroyed = true;
        this._reader.destroy();
        process.nextTick(this.emit.bind(this, "close"));
      };
      ReadStream.prototype._pause = function(paused) {
        if (this._paused === paused)
          return;
        this._paused = paused;
        if (this._paused)
          this._reader.pause();
        else
          this._reader.resume();
      };
      ReadStream.prototype._read = function() {
        this._pause(false);
      };
      blobs.remove = function(name, cb) {
        cb = once(cb || noop);
        var batch = [];
        var keys = db2.createKeyStream({
          start: name + "Ã¿",
          end: name + "Ã¿Ã¿"
        });
        keys.on("error", cb);
        keys.on("data", function(key) {
          batch.push({ type: "del", key });
        });
        keys.on("end", function() {
          db2.batch(batch, cb);
        });
      };
      blobs.size = function(name, cb) {
        peek.last(db2, {
          start: name + "Ã¿",
          end: name + "Ã¿Ã¿",
          valueEncoding: ENCODER
        }, function(err, latest, val) {
          if (err && err.message === "range not found")
            return cb(null, 0);
          if (err)
            return cb(err);
          if (latest.slice(0, name.length + 1) !== name + "Ã¿")
            return cb(null, 0);
          cb(null, parseInt(latest.toString().slice(name.length + 1), 16) * blockSize + val.length);
        });
      };
      blobs.write = function(name, data, opts2, cb) {
        if (typeof opts2 === "function")
          return blobs.write(name, data, null, opts2);
        if (!opts2)
          opts2 = {};
        if (!cb)
          cb = noop;
        var ws = blobs.createWriteStream(name, opts2);
        ws.on("error", cb);
        ws.on("finish", function() {
          cb();
        });
        ws.write(data);
        ws.end();
      };
      blobs.read = function(name, opts2, cb) {
        if (typeof opts2 === "function")
          return blobs.read(name, null, opts2);
        if (!opts2)
          opts2 = {};
        var rs = blobs.createReadStream(name, opts2);
        var list = [];
        rs.on("error", cb);
        rs.on("data", function(data) {
          list.push(data);
        });
        rs.on("end", function() {
          cb(null, list.length === 1 ? list[0] : Buffer.concat(list));
        });
      };
      blobs.createReadStream = function(name, opts2) {
        return new ReadStream(name, opts2);
      };
      blobs.createWriteStream = function(name, opts2) {
        return new WriteStream(name, opts2);
      };
      return blobs;
    };
  }
});

// node_modules/octal/index.js
var require_octal = __commonJS({
  "node_modules/octal/index.js"(exports, module) {
    module.exports = function(num, base) {
      return parseInt(num.toString(), base || 8);
    };
  }
});

// node_modules/level-filesystem/errno.js
var require_errno2 = __commonJS({
  "node_modules/level-filesystem/errno.js"(exports) {
    var errno = require_errno();
    Object.keys(errno.code).forEach(function(code) {
      var e = errno.code[code];
      exports[code] = function(path) {
        var err = new Error(code + ", " + e.description + (path ? " '" + path + "'" : ""));
        err.errno = e.errno;
        err.code = code;
        err.path = path;
        return err;
      };
    });
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports, module) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module.exports = { nextTick };
    } else {
      module.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/isarray/index.js
var require_isarray5 = __commonJS({
  "node_modules/isarray/index.js"(exports, module) {
    var toString = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    module.exports = require_events().EventEmitter;
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports, module) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var util = require_util4();
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports, module) {
    module.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_) {
        return false;
      }
      var val = global.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable5 = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    module.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util2());
    util.inherits = require_inherits_browser();
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex5();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex5();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex5 = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module.exports = Duplex;
    var util = Object.create(require_util2());
    util.inherits = require_inherits_browser();
    var Readable = require_stream_readable5();
    var Writable = require_stream_writable5();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder5 = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "ï¿½";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "ï¿½";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "ï¿½";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "ï¿½";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable5 = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    module.exports = Readable;
    var isArray = require_isarray5();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util2());
    util.inherits = require_inherits_browser();
    var debugUtil = require_util4();
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex5();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder5().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex5();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder5().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform5 = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    module.exports = Transform;
    var Duplex = require_stream_duplex5();
    var util = Object.create(require_util2());
    util.inherits = require_inherits_browser();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough5 = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    module.exports = PassThrough;
    var Transform = require_stream_transform5();
    var util = Object.create(require_util2());
    util.inherits = require_inherits_browser();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/readable-stream/readable-browser.js"(exports, module) {
    exports = module.exports = require_stream_readable5();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable5();
    exports.Duplex = require_stream_duplex5();
    exports.Transform = require_stream_transform5();
    exports.PassThrough = require_stream_passthrough5();
  }
});

// node_modules/buffer-from/index.js
var require_buffer_from = __commonJS({
  "node_modules/buffer-from/index.js"(exports, module) {
    var toString = Object.prototype.toString;
    var isModern = typeof Buffer !== "undefined" && typeof Buffer.alloc === "function" && typeof Buffer.allocUnsafe === "function" && typeof Buffer.from === "function";
    function isArrayBuffer(input) {
      return toString.call(input).slice(8, -1) === "ArrayBuffer";
    }
    function fromArrayBuffer(obj, byteOffset, length) {
      byteOffset >>>= 0;
      var maxLength = obj.byteLength - byteOffset;
      if (maxLength < 0) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (length === void 0) {
        length = maxLength;
      } else {
        length >>>= 0;
        if (length > maxLength) {
          throw new RangeError("'length' is out of bounds");
        }
      }
      return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
    }
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
      }
      return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
    }
    function bufferFrom(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (isArrayBuffer(value)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      return isModern ? Buffer.from(value) : new Buffer(value);
    }
    module.exports = bufferFrom;
  }
});

// node_modules/typedarray/index.js
var require_typedarray = __commonJS({
  "node_modules/typedarray/index.js"(exports) {
    var undefined2 = void 0;
    var MAX_ARRAY_LENGTH = 1e5;
    var ECMAScript = function() {
      var opts = Object.prototype.toString, ophop = Object.prototype.hasOwnProperty;
      return {
        // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:
        Class: function(v) {
          return opts.call(v).replace(/^\[object *|\]$/g, "");
        },
        HasProperty: function(o, p) {
          return p in o;
        },
        HasOwnProperty: function(o, p) {
          return ophop.call(o, p);
        },
        IsCallable: function(o) {
          return typeof o === "function";
        },
        ToInt32: function(v) {
          return v >> 0;
        },
        ToUint32: function(v) {
          return v >>> 0;
        }
      };
    }();
    var LN2 = Math.LN2;
    var abs = Math.abs;
    var floor = Math.floor;
    var log = Math.log;
    var min = Math.min;
    var pow = Math.pow;
    var round = Math.round;
    function configureProperties(obj) {
      if (getOwnPropNames && defineProp) {
        var props = getOwnPropNames(obj), i;
        for (i = 0; i < props.length; i += 1) {
          defineProp(obj, props[i], {
            value: obj[props[i]],
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
      }
    }
    var defineProp;
    if (Object.defineProperty && function() {
      try {
        Object.defineProperty({}, "x", {});
        return true;
      } catch (e) {
        return false;
      }
    }()) {
      defineProp = Object.defineProperty;
    } else {
      defineProp = function(o, p, desc) {
        if (!o === Object(o))
          throw new TypeError("Object.defineProperty called on non-object");
        if (ECMAScript.HasProperty(desc, "get") && Object.prototype.__defineGetter__) {
          Object.prototype.__defineGetter__.call(o, p, desc.get);
        }
        if (ECMAScript.HasProperty(desc, "set") && Object.prototype.__defineSetter__) {
          Object.prototype.__defineSetter__.call(o, p, desc.set);
        }
        if (ECMAScript.HasProperty(desc, "value")) {
          o[p] = desc.value;
        }
        return o;
      };
    }
    var getOwnPropNames = Object.getOwnPropertyNames || function(o) {
      if (o !== Object(o))
        throw new TypeError("Object.getOwnPropertyNames called on non-object");
      var props = [], p;
      for (p in o) {
        if (ECMAScript.HasOwnProperty(o, p)) {
          props.push(p);
        }
      }
      return props;
    };
    function makeArrayAccessors(obj) {
      if (!defineProp) {
        return;
      }
      if (obj.length > MAX_ARRAY_LENGTH)
        throw new RangeError("Array too large for polyfill");
      function makeArrayAccessor(index) {
        defineProp(obj, index, {
          "get": function() {
            return obj._getter(index);
          },
          "set": function(v) {
            obj._setter(index, v);
          },
          enumerable: true,
          configurable: false
        });
      }
      var i;
      for (i = 0; i < obj.length; i += 1) {
        makeArrayAccessor(i);
      }
    }
    function as_signed(value, bits) {
      var s = 32 - bits;
      return value << s >> s;
    }
    function as_unsigned(value, bits) {
      var s = 32 - bits;
      return value << s >>> s;
    }
    function packI8(n) {
      return [n & 255];
    }
    function unpackI8(bytes) {
      return as_signed(bytes[0], 8);
    }
    function packU8(n) {
      return [n & 255];
    }
    function unpackU8(bytes) {
      return as_unsigned(bytes[0], 8);
    }
    function packU8Clamped(n) {
      n = round(Number(n));
      return [n < 0 ? 0 : n > 255 ? 255 : n & 255];
    }
    function packI16(n) {
      return [n >> 8 & 255, n & 255];
    }
    function unpackI16(bytes) {
      return as_signed(bytes[0] << 8 | bytes[1], 16);
    }
    function packU16(n) {
      return [n >> 8 & 255, n & 255];
    }
    function unpackU16(bytes) {
      return as_unsigned(bytes[0] << 8 | bytes[1], 16);
    }
    function packI32(n) {
      return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
    }
    function unpackI32(bytes) {
      return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
    }
    function packU32(n) {
      return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
    }
    function unpackU32(bytes) {
      return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
    }
    function packIEEE754(v, ebits, fbits) {
      var bias = (1 << ebits - 1) - 1, s, e, f, ln, i, bits, str, bytes;
      function roundToEven(n) {
        var w = floor(n), f2 = n - w;
        if (f2 < 0.5)
          return w;
        if (f2 > 0.5)
          return w + 1;
        return w % 2 ? w + 1 : w;
      }
      if (v !== v) {
        e = (1 << ebits) - 1;
        f = pow(2, fbits - 1);
        s = 0;
      } else if (v === Infinity || v === -Infinity) {
        e = (1 << ebits) - 1;
        f = 0;
        s = v < 0 ? 1 : 0;
      } else if (v === 0) {
        e = 0;
        f = 0;
        s = 1 / v === -Infinity ? 1 : 0;
      } else {
        s = v < 0;
        v = abs(v);
        if (v >= pow(2, 1 - bias)) {
          e = min(floor(log(v) / LN2), 1023);
          f = roundToEven(v / pow(2, e) * pow(2, fbits));
          if (f / pow(2, fbits) >= 2) {
            e = e + 1;
            f = 1;
          }
          if (e > bias) {
            e = (1 << ebits) - 1;
            f = 0;
          } else {
            e = e + bias;
            f = f - pow(2, fbits);
          }
        } else {
          e = 0;
          f = roundToEven(v / pow(2, 1 - bias - fbits));
        }
      }
      bits = [];
      for (i = fbits; i; i -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = floor(f / 2);
      }
      for (i = ebits; i; i -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = floor(e / 2);
      }
      bits.push(s ? 1 : 0);
      bits.reverse();
      str = bits.join("");
      bytes = [];
      while (str.length) {
        bytes.push(parseInt(str.substring(0, 8), 2));
        str = str.substring(8);
      }
      return bytes;
    }
    function unpackIEEE754(bytes, ebits, fbits) {
      var bits = [], i, j, b, str, bias, s, e, f;
      for (i = bytes.length; i; i -= 1) {
        b = bytes[i - 1];
        for (j = 8; j; j -= 1) {
          bits.push(b % 2 ? 1 : 0);
          b = b >> 1;
        }
      }
      bits.reverse();
      str = bits.join("");
      bias = (1 << ebits - 1) - 1;
      s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
      e = parseInt(str.substring(1, 1 + ebits), 2);
      f = parseInt(str.substring(1 + ebits), 2);
      if (e === (1 << ebits) - 1) {
        return f !== 0 ? NaN : s * Infinity;
      } else if (e > 0) {
        return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
      } else if (f !== 0) {
        return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
      } else {
        return s < 0 ? -0 : 0;
      }
    }
    function unpackF64(b) {
      return unpackIEEE754(b, 11, 52);
    }
    function packF64(v) {
      return packIEEE754(v, 11, 52);
    }
    function unpackF32(b) {
      return unpackIEEE754(b, 8, 23);
    }
    function packF32(v) {
      return packIEEE754(v, 8, 23);
    }
    (function() {
      var ArrayBuffer2 = function ArrayBuffer3(length) {
        length = ECMAScript.ToInt32(length);
        if (length < 0)
          throw new RangeError("ArrayBuffer size is not a small enough positive integer");
        this.byteLength = length;
        this._bytes = [];
        this._bytes.length = length;
        var i;
        for (i = 0; i < this.byteLength; i += 1) {
          this._bytes[i] = 0;
        }
        configureProperties(this);
      };
      exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer2;
      var ArrayBufferView = function ArrayBufferView2() {
      };
      function makeConstructor(bytesPerElement, pack, unpack) {
        var ctor;
        ctor = function(buffer, byteOffset, length) {
          var array, sequence, i, s;
          if (!arguments.length || typeof arguments[0] === "number") {
            this.length = ECMAScript.ToInt32(arguments[0]);
            if (length < 0)
              throw new RangeError("ArrayBufferView size is not a small enough positive integer");
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
          } else if (typeof arguments[0] === "object" && arguments[0].constructor === ctor) {
            array = arguments[0];
            this.length = array.length;
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
            for (i = 0; i < this.length; i += 1) {
              this._setter(i, array._getter(i));
            }
          } else if (typeof arguments[0] === "object" && !(arguments[0] instanceof ArrayBuffer2 || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
            sequence = arguments[0];
            this.length = ECMAScript.ToUint32(sequence.length);
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
            for (i = 0; i < this.length; i += 1) {
              s = sequence[i];
              this._setter(i, Number(s));
            }
          } else if (typeof arguments[0] === "object" && (arguments[0] instanceof ArrayBuffer2 || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
            this.buffer = buffer;
            this.byteOffset = ECMAScript.ToUint32(byteOffset);
            if (this.byteOffset > this.buffer.byteLength) {
              throw new RangeError("byteOffset out of range");
            }
            if (this.byteOffset % this.BYTES_PER_ELEMENT) {
              throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
            }
            if (arguments.length < 3) {
              this.byteLength = this.buffer.byteLength - this.byteOffset;
              if (this.byteLength % this.BYTES_PER_ELEMENT) {
                throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
              }
              this.length = this.byteLength / this.BYTES_PER_ELEMENT;
            } else {
              this.length = ECMAScript.ToUint32(length);
              this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            }
            if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
              throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
          this.constructor = ctor;
          configureProperties(this);
          makeArrayAccessors(this);
        };
        ctor.prototype = new ArrayBufferView();
        ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._pack = pack;
        ctor.prototype._unpack = unpack;
        ctor.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._getter = function(index) {
          if (arguments.length < 1)
            throw new SyntaxError("Not enough arguments");
          index = ECMAScript.ToUint32(index);
          if (index >= this.length) {
            return undefined2;
          }
          var bytes = [], i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1) {
            bytes.push(this.buffer._bytes[o]);
          }
          return this._unpack(bytes);
        };
        ctor.prototype.get = ctor.prototype._getter;
        ctor.prototype._setter = function(index, value) {
          if (arguments.length < 2)
            throw new SyntaxError("Not enough arguments");
          index = ECMAScript.ToUint32(index);
          if (index >= this.length) {
            return undefined2;
          }
          var bytes = this._pack(value), i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1) {
            this.buffer._bytes[o] = bytes[i];
          }
        };
        ctor.prototype.set = function(index, value) {
          if (arguments.length < 1)
            throw new SyntaxError("Not enough arguments");
          var array, sequence, offset, len, i, s, d, byteOffset, byteLength, tmp;
          if (typeof arguments[0] === "object" && arguments[0].constructor === this.constructor) {
            array = arguments[0];
            offset = ECMAScript.ToUint32(arguments[1]);
            if (offset + array.length > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
            byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
            byteLength = array.length * this.BYTES_PER_ELEMENT;
            if (array.buffer === this.buffer) {
              tmp = [];
              for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
                tmp[i] = array.buffer._bytes[s];
              }
              for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
                this.buffer._bytes[d] = tmp[i];
              }
            } else {
              for (i = 0, s = array.byteOffset, d = byteOffset; i < byteLength; i += 1, s += 1, d += 1) {
                this.buffer._bytes[d] = array.buffer._bytes[s];
              }
            }
          } else if (typeof arguments[0] === "object" && typeof arguments[0].length !== "undefined") {
            sequence = arguments[0];
            len = ECMAScript.ToUint32(sequence.length);
            offset = ECMAScript.ToUint32(arguments[1]);
            if (offset + len > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
            for (i = 0; i < len; i += 1) {
              s = sequence[i];
              this._setter(offset + i, Number(s));
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
        };
        ctor.prototype.subarray = function(start, end) {
          function clamp(v, min2, max) {
            return v < min2 ? min2 : v > max ? max : v;
          }
          start = ECMAScript.ToInt32(start);
          end = ECMAScript.ToInt32(end);
          if (arguments.length < 1) {
            start = 0;
          }
          if (arguments.length < 2) {
            end = this.length;
          }
          if (start < 0) {
            start = this.length + start;
          }
          if (end < 0) {
            end = this.length + end;
          }
          start = clamp(start, 0, this.length);
          end = clamp(end, 0, this.length);
          var len = end - start;
          if (len < 0) {
            len = 0;
          }
          return new this.constructor(
            this.buffer,
            this.byteOffset + start * this.BYTES_PER_ELEMENT,
            len
          );
        };
        return ctor;
      }
      var Int8Array2 = makeConstructor(1, packI8, unpackI8);
      var Uint8Array2 = makeConstructor(1, packU8, unpackU8);
      var Uint8ClampedArray2 = makeConstructor(1, packU8Clamped, unpackU8);
      var Int16Array2 = makeConstructor(2, packI16, unpackI16);
      var Uint16Array2 = makeConstructor(2, packU16, unpackU16);
      var Int32Array2 = makeConstructor(4, packI32, unpackI32);
      var Uint32Array2 = makeConstructor(4, packU32, unpackU32);
      var Float32Array2 = makeConstructor(4, packF32, unpackF32);
      var Float64Array2 = makeConstructor(8, packF64, unpackF64);
      exports.Int8Array = exports.Int8Array || Int8Array2;
      exports.Uint8Array = exports.Uint8Array || Uint8Array2;
      exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray2;
      exports.Int16Array = exports.Int16Array || Int16Array2;
      exports.Uint16Array = exports.Uint16Array || Uint16Array2;
      exports.Int32Array = exports.Int32Array || Int32Array2;
      exports.Uint32Array = exports.Uint32Array || Uint32Array2;
      exports.Float32Array = exports.Float32Array || Float32Array2;
      exports.Float64Array = exports.Float64Array || Float64Array2;
    })();
    (function() {
      function r(array, index) {
        return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
      }
      var IS_BIG_ENDIAN = function() {
        var u16array = new exports.Uint16Array([4660]), u8array = new exports.Uint8Array(u16array.buffer);
        return r(u8array, 0) === 18;
      }();
      var DataView2 = function DataView3(buffer, byteOffset, byteLength) {
        if (arguments.length === 0) {
          buffer = new exports.ArrayBuffer(0);
        } else if (!(buffer instanceof exports.ArrayBuffer || ECMAScript.Class(buffer) === "ArrayBuffer")) {
          throw new TypeError("TypeError");
        }
        this.buffer = buffer || new exports.ArrayBuffer(0);
        this.byteOffset = ECMAScript.ToUint32(byteOffset);
        if (this.byteOffset > this.buffer.byteLength) {
          throw new RangeError("byteOffset out of range");
        }
        if (arguments.length < 3) {
          this.byteLength = this.buffer.byteLength - this.byteOffset;
        } else {
          this.byteLength = ECMAScript.ToUint32(byteLength);
        }
        if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
        }
        configureProperties(this);
      };
      function makeGetter(arrayType) {
        return function(byteOffset, littleEndian) {
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          byteOffset += this.byteOffset;
          var uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT), bytes = [], i;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes.push(r(uint8Array, i));
          }
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes.reverse();
          }
          return r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);
        };
      }
      DataView2.prototype.getUint8 = makeGetter(exports.Uint8Array);
      DataView2.prototype.getInt8 = makeGetter(exports.Int8Array);
      DataView2.prototype.getUint16 = makeGetter(exports.Uint16Array);
      DataView2.prototype.getInt16 = makeGetter(exports.Int16Array);
      DataView2.prototype.getUint32 = makeGetter(exports.Uint32Array);
      DataView2.prototype.getInt32 = makeGetter(exports.Int32Array);
      DataView2.prototype.getFloat32 = makeGetter(exports.Float32Array);
      DataView2.prototype.getFloat64 = makeGetter(exports.Float64Array);
      function makeSetter(arrayType) {
        return function(byteOffset, value, littleEndian) {
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          var typeArray = new arrayType([value]), byteArray = new exports.Uint8Array(typeArray.buffer), bytes = [], i, byteView;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes.push(r(byteArray, i));
          }
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes.reverse();
          }
          byteView = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
          byteView.set(bytes);
        };
      }
      DataView2.prototype.setUint8 = makeSetter(exports.Uint8Array);
      DataView2.prototype.setInt8 = makeSetter(exports.Int8Array);
      DataView2.prototype.setUint16 = makeSetter(exports.Uint16Array);
      DataView2.prototype.setInt16 = makeSetter(exports.Int16Array);
      DataView2.prototype.setUint32 = makeSetter(exports.Uint32Array);
      DataView2.prototype.setInt32 = makeSetter(exports.Int32Array);
      DataView2.prototype.setFloat32 = makeSetter(exports.Float32Array);
      DataView2.prototype.setFloat64 = makeSetter(exports.Float64Array);
      exports.DataView = exports.DataView || DataView2;
    })();
  }
});

// node_modules/concat-stream/index.js
var require_concat_stream = __commonJS({
  "node_modules/concat-stream/index.js"(exports, module) {
    var Writable = require_readable_browser().Writable;
    var inherits = require_inherits_browser();
    var bufferFrom = require_buffer_from();
    if (typeof Uint8Array === "undefined") {
      U8 = require_typedarray().Uint8Array;
    } else {
      U8 = Uint8Array;
    }
    var U8;
    function ConcatStream(opts, cb) {
      if (!(this instanceof ConcatStream))
        return new ConcatStream(opts, cb);
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      if (!opts)
        opts = {};
      var encoding = opts.encoding;
      var shouldInferEncoding = false;
      if (!encoding) {
        shouldInferEncoding = true;
      } else {
        encoding = String(encoding).toLowerCase();
        if (encoding === "u8" || encoding === "uint8") {
          encoding = "uint8array";
        }
      }
      Writable.call(this, { objectMode: true });
      this.encoding = encoding;
      this.shouldInferEncoding = shouldInferEncoding;
      if (cb)
        this.on("finish", function() {
          cb(this.getBody());
        });
      this.body = [];
    }
    module.exports = ConcatStream;
    inherits(ConcatStream, Writable);
    ConcatStream.prototype._write = function(chunk, enc, next) {
      this.body.push(chunk);
      next();
    };
    ConcatStream.prototype.inferEncoding = function(buff) {
      var firstBuffer = buff === void 0 ? this.body[0] : buff;
      if (Buffer.isBuffer(firstBuffer))
        return "buffer";
      if (typeof Uint8Array !== "undefined" && firstBuffer instanceof Uint8Array)
        return "uint8array";
      if (Array.isArray(firstBuffer))
        return "array";
      if (typeof firstBuffer === "string")
        return "string";
      if (Object.prototype.toString.call(firstBuffer) === "[object Object]")
        return "object";
      return "buffer";
    };
    ConcatStream.prototype.getBody = function() {
      if (!this.encoding && this.body.length === 0)
        return [];
      if (this.shouldInferEncoding)
        this.encoding = this.inferEncoding();
      if (this.encoding === "array")
        return arrayConcat(this.body);
      if (this.encoding === "string")
        return stringConcat(this.body);
      if (this.encoding === "buffer")
        return bufferConcat(this.body);
      if (this.encoding === "uint8array")
        return u8Concat(this.body);
      return this.body;
    };
    var isArray = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == "[object Array]";
    };
    function isArrayish(arr) {
      return /Array\]$/.test(Object.prototype.toString.call(arr));
    }
    function isBufferish(p) {
      return typeof p === "string" || isArrayish(p) || p && typeof p.subarray === "function";
    }
    function stringConcat(parts) {
      var strings = [];
      var needsToString = false;
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i];
        if (typeof p === "string") {
          strings.push(p);
        } else if (Buffer.isBuffer(p)) {
          strings.push(p);
        } else if (isBufferish(p)) {
          strings.push(bufferFrom(p));
        } else {
          strings.push(bufferFrom(String(p)));
        }
      }
      if (Buffer.isBuffer(parts[0])) {
        strings = Buffer.concat(strings);
        strings = strings.toString("utf8");
      } else {
        strings = strings.join("");
      }
      return strings;
    }
    function bufferConcat(parts) {
      var bufs = [];
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i];
        if (Buffer.isBuffer(p)) {
          bufs.push(p);
        } else if (isBufferish(p)) {
          bufs.push(bufferFrom(p));
        } else {
          bufs.push(bufferFrom(String(p)));
        }
      }
      return Buffer.concat(bufs);
    }
    function arrayConcat(parts) {
      var res = [];
      for (var i = 0; i < parts.length; i++) {
        res.push.apply(res, parts[i]);
      }
      return res;
    }
    function u8Concat(parts) {
      var len = 0;
      for (var i = 0; i < parts.length; i++) {
        if (typeof parts[i] === "string") {
          parts[i] = bufferFrom(parts[i]);
        }
        len += parts[i].length;
      }
      var u8 = new U8(len);
      for (var i = 0, offset = 0; i < parts.length; i++) {
        var part = parts[i];
        for (var j = 0; j < part.length; j++) {
          u8[offset++] = part[j];
        }
      }
      return u8;
    }
  }
});

// node_modules/level-filesystem/stat.js
var require_stat = __commonJS({
  "node_modules/level-filesystem/stat.js"(exports, module) {
    var toDate = function(date) {
      if (!date)
        return /* @__PURE__ */ new Date();
      if (typeof date === "string")
        return new Date(date);
      return date;
    };
    var Stat = function(opts) {
      this.uid = opts.uid || 0;
      this.gid = opts.gid || 0;
      this.mode = opts.mode || 0;
      this.size = opts.size || 0;
      this.mtime = toDate(opts.mtime);
      this.atime = toDate(opts.atime);
      this.ctime = toDate(opts.ctime);
      this.type = opts.type;
      this.target = opts.target;
      this.link = opts.link;
      this.blob = opts.blob;
    };
    Stat.prototype.isDirectory = function() {
      return this.type === "directory";
    };
    Stat.prototype.isFile = function() {
      return this.type === "file";
    };
    Stat.prototype.isBlockDevice = function() {
      return false;
    };
    Stat.prototype.isCharacterDevice = function() {
      return false;
    };
    Stat.prototype.isSymbolicLink = function() {
      return this.type === "symlink";
    };
    Stat.prototype.isFIFO = function() {
      return false;
    };
    Stat.prototype.isSocket = function() {
      return false;
    };
    module.exports = function(opts) {
      return new Stat(opts);
    };
  }
});

// node_modules/level-filesystem/node_modules/xtend/has-keys.js
var require_has_keys3 = __commonJS({
  "node_modules/level-filesystem/node_modules/xtend/has-keys.js"(exports, module) {
    module.exports = hasKeys;
    function hasKeys(source) {
      return source !== null && (typeof source === "object" || typeof source === "function");
    }
  }
});

// node_modules/level-filesystem/node_modules/xtend/index.js
var require_xtend5 = __commonJS({
  "node_modules/level-filesystem/node_modules/xtend/index.js"(exports, module) {
    var hasKeys = require_has_keys3();
    module.exports = extend;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        if (!hasKeys(source)) {
          continue;
        }
        for (var key in source) {
          if (source.hasOwnProperty(key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/level-filesystem/paths.js
var require_paths = __commonJS({
  "node_modules/level-filesystem/paths.js"(exports, module) {
    var path = require_path_browserify();
    var once = require_once();
    var concat = require_concat_stream();
    var octal = require_octal();
    var stat = require_stat();
    var xtend = require_xtend5();
    var errno = require_errno2();
    var ROOT = stat({
      type: "directory",
      mode: octal(777),
      size: 4096
    });
    var normalize = function(key) {
      key = key[0] === "/" ? key : "/" + key;
      key = path.normalize(key);
      if (key === "/")
        return key;
      return key[key.length - 1] === "/" ? key.slice(0, -1) : key;
    };
    var prefix = function(key) {
      var depth = key.split("/").length.toString(36);
      return "0000000000".slice(depth.length) + depth + key;
    };
    module.exports = function(db2) {
      var that = {};
      that.normalize = normalize;
      that.get = function(key, cb) {
        key = normalize(key);
        if (key === "/")
          return process.nextTick(cb.bind(null, null, ROOT, "/"));
        db2.get(prefix(key), { valueEncoding: "json" }, function(err, doc) {
          if (err && err.notFound)
            return cb(errno.ENOENT(key), null, key);
          if (err)
            return cb(err, null, key);
          cb(null, stat(doc), key);
        });
      };
      that.writable = function(key, cb) {
        key = normalize(key);
        if (key === "/")
          return process.nextTick(cb.bind(null, errno.EPERM(key)));
        that.follow(path.dirname(key), function(err, parent) {
          if (err)
            return cb(err);
          if (!parent.isDirectory())
            return cb(errno.ENOTDIR(key));
          cb(null, key);
        });
      };
      that.list = function(key, cb) {
        key = normalize(key);
        var start = prefix(key === "/" ? key : key + "/");
        var keys = db2.createKeyStream({ start, end: start + "Ã¿" });
        cb = once(cb);
        keys.on("error", cb);
        keys.pipe(concat({ encoding: "object" }, function(files) {
          files = files.map(function(file) {
            return file.split("/").pop();
          });
          cb(null, files);
        }));
      };
      var resolve = function(dir, cb) {
        var root = "/";
        var parts = dir.split("/").slice(1);
        var loop = function() {
          that.get(path.join(root, parts.shift()), function(err, doc, key) {
            if (err)
              return cb(err, doc, dir);
            root = doc.target || key;
            if (!parts.length)
              return cb(null, doc, key);
            loop();
          });
        };
        loop();
      };
      that.follow = function(key, cb) {
        resolve(normalize(key), function loop(err, doc, key2) {
          if (err)
            return cb(err, null, key2);
          if (doc.target)
            return that.get(doc.target, loop);
          cb(null, stat(doc), key2);
        });
      };
      that.update = function(key, opts, cb) {
        that.get(key, function(err, doc, key2) {
          if (err)
            return cb(err);
          if (key2 === "/")
            return cb(errno.EPERM(key2));
          that.put(key2, xtend(doc, opts), cb);
        });
      };
      that.put = function(key, opts, cb) {
        that.writable(key, function(err, key2) {
          if (err)
            return cb(err);
          db2.put(prefix(key2), stat(opts), { valueEncoding: "json" }, cb);
        });
      };
      that.del = function(key, cb) {
        key = normalize(key);
        if (key === "/")
          return process.nextTick(cb.bind(null, errno.EPERM(key)));
        db2.del(prefix(key), cb);
      };
      return that;
    };
  }
});

// node_modules/level-filesystem/watchers.js
var require_watchers = __commonJS({
  "node_modules/level-filesystem/watchers.js"(exports, module) {
    var events = require_events();
    module.exports = function() {
      var listeners = {};
      var that = new events.EventEmitter();
      that.watch = function(key, cb) {
        if (!listeners[key]) {
          listeners[key] = new events.EventEmitter();
          listeners[key].setMaxListeners(0);
        }
        if (cb)
          listeners[key].on("change", cb);
        return listeners[key];
      };
      that.watcher = function(key, cb) {
        var watcher = new events.EventEmitter();
        var onchange = function() {
          watcher.emit("change", "change", key);
        };
        that.watch(key, onchange);
        if (cb)
          watcher.on("change", cb);
        watcher.close = function() {
          that.unwatch(key, onchange);
        };
        return watcher;
      };
      that.unwatch = function(key, cb) {
        if (!listeners[key])
          return;
        if (cb)
          listeners[key].removeListener("change", cb);
        else
          listeners[key].removeAllListeners("change");
        if (!listeners[key].listeners("change").length)
          delete listeners[key];
        ;
      };
      that.change = function(key) {
        if (listeners[key])
          listeners[key].emit("change");
        that.emit("change", key);
      };
      that.cb = function(key, cb) {
        return function(err, val) {
          if (key)
            that.change(key);
          if (cb)
            cb(err, val);
        };
      };
      return that;
    };
  }
});

// node_modules/level-filesystem/index.js
var require_level_filesystem = __commonJS({
  "node_modules/level-filesystem/index.js"(exports, module) {
    var fwd = require_fwd_stream();
    var sublevel = require_level_sublevel();
    var blobs = require_level_blobs();
    var peek = require_level_peek();
    var once = require_once();
    var octal = require_octal();
    var errno = require_errno2();
    var paths = require_paths();
    var watchers = require_watchers();
    var nextTick = function(cb, err, val) {
      process.nextTick(function() {
        cb(err, val);
      });
    };
    var noop = function() {
    };
    module.exports = function(db2, opts) {
      var fs = {};
      db2 = sublevel(db2);
      var bl = blobs(db2.sublevel("blobs"), opts);
      var ps = paths(db2.sublevel("stats"));
      var links = db2.sublevel("links");
      var listeners = watchers();
      var fds = [];
      var now = Date.now();
      var inc = function() {
        return ++now;
      };
      fs.mkdir = function(key, mode, cb) {
        if (typeof mode === "function")
          return fs.mkdir(key, null, mode);
        if (!mode)
          mode = octal(777);
        if (!cb)
          cb = noop;
        ps.follow(key, function(err, stat2, key2) {
          if (err && err.code !== "ENOENT")
            return cb(err);
          if (stat2)
            return cb(errno.EEXIST(key2));
          ps.put(key2, {
            type: "directory",
            mode,
            size: 4096
          }, listeners.cb(key2, cb));
        });
      };
      fs.rmdir = function(key, cb) {
        if (!cb)
          cb = noop;
        ps.follow(key, function(err, stat2, key2) {
          if (err)
            return cb(err);
          fs.readdir(key2, function(err2, files) {
            if (err2)
              return cb(err2);
            if (files.length)
              return cb(errno.ENOTEMPTY(key2));
            ps.del(key2, listeners.cb(key2, cb));
          });
        });
      };
      fs.readdir = function(key, cb) {
        ps.follow(key, function(err, stat2, key2) {
          if (err)
            return cb(err);
          if (!stat2)
            return cb(errno.ENOENT(key2));
          if (!stat2.isDirectory())
            return cb(errno.ENOTDIR(key2));
          ps.list(key2, cb);
        });
      };
      var stat = function(key, lookup, cb) {
        lookup(key, function(err, stat2, key2) {
          if (err)
            return cb(err);
          if (!stat2.isFile())
            return cb(null, stat2);
          var blob = stat2 && stat2.blob || key2;
          bl.size(blob, function(err2, size) {
            if (err2)
              return cb(err2);
            stat2.size = size;
            cb(null, stat2);
          });
        });
      };
      fs.stat = function(key, cb) {
        stat(key, ps.follow, cb);
      };
      fs.lstat = function(key, cb) {
        stat(key, ps.get, cb);
      };
      fs.exists = function(key, cb) {
        ps.follow(key, function(err) {
          cb(!err);
        });
      };
      var chmod = function(key, lookup, mode, cb) {
        if (!cb)
          cb = noop;
        lookup(key, function(err, stat2, key2) {
          if (err)
            return cb(err);
          ps.update(key2, { mode }, listeners.cb(key2, cb));
        });
      };
      fs.chmod = function(key, mode, cb) {
        chmod(key, ps.follow, mode, cb);
      };
      fs.lchmod = function(key, mode, cb) {
        chmod(key, ps.get, mode, cb);
      };
      var chown = function(key, lookup, uid, gid, cb) {
        if (!cb)
          cb = noop;
        lookup(key, function(err, stat2, key2) {
          if (err)
            return cb(err);
          ps.update(key2, { uid, gid }, listeners.cb(key2, cb));
        });
      };
      fs.chown = function(key, uid, gid, cb) {
        chown(key, ps.follow, uid, gid, cb);
      };
      fs.lchown = function(key, uid, gid, cb) {
        chown(key, ps.get, uid, gid, cb);
      };
      fs.utimes = function(key, atime, mtime, cb) {
        if (!cb)
          cb = noop;
        ps.follow(key, function(err, stat2, key2) {
          if (err)
            return cb(err);
          var upd = {};
          if (atime)
            upd.atime = atime;
          if (mtime)
            upd.mtime = mtime;
          ps.update(key2, upd, listeners.cb(key2, cb));
        });
      };
      fs.rename = function(from, to, cb) {
        if (!cb)
          cb = noop;
        ps.follow(from, function(err, statFrom, from2) {
          if (err)
            return cb(err);
          var rename = function() {
            cb = listeners.cb(to, listeners.cb(from2, cb));
            ps.put(to, statFrom, function(err2) {
              if (err2)
                return cb(err2);
              ps.del(from2, cb);
            });
          };
          ps.follow(to, function(err2, statTo, to2) {
            if (err2 && err2.code !== "ENOENT")
              return cb(err2);
            if (!statTo)
              return rename();
            if (statFrom.isDirectory() !== statTo.isDirectory())
              return cb(errno.EISDIR(from2));
            if (statTo.isDirectory()) {
              fs.readdir(to2, function(err3, list) {
                if (err3)
                  return cb(err3);
                if (list.length)
                  return cb(errno.ENOTEMPTY(from2));
                rename();
              });
              return;
            }
            rename();
          });
        });
      };
      fs.realpath = function(key, cache, cb) {
        if (typeof cache === "function")
          return fs.realpath(key, null, cache);
        ps.follow(key, function(err, stat2, key2) {
          if (err)
            return cb(err);
          cb(null, key2);
        });
      };
      fs.writeFile = function(key, data, opts2, cb) {
        if (typeof opts2 === "function")
          return fs.writeFile(key, data, null, opts2);
        if (typeof opts2 === "string")
          opts2 = { encoding: opts2 };
        if (!opts2)
          opts2 = {};
        if (!cb)
          cb = noop;
        if (!Buffer.isBuffer(data))
          data = new Buffer(data, opts2.encoding || "utf-8");
        var flags = opts2.flags || "w";
        opts2.append = flags[0] !== "w";
        ps.follow(key, function(err, stat2, key2) {
          if (err && err.code !== "ENOENT")
            return cb(err);
          if (stat2 && stat2.isDirectory())
            return cb(errno.EISDIR(key2));
          if (stat2 && flags[1] === "x")
            return cb(errno.EEXIST(key2));
          var blob = stat2 && stat2.blob || key2;
          ps.writable(key2, function(err2) {
            if (err2)
              return cb(err2);
            bl.write(blob, data, opts2, function(err3) {
              if (err3)
                return cb(err3);
              ps.put(key2, {
                ctime: stat2 && stat2.ctime,
                mtime: /* @__PURE__ */ new Date(),
                mode: opts2.mode || octal(666),
                type: "file"
              }, listeners.cb(key2, cb));
            });
          });
        });
      };
      fs.appendFile = function(key, data, opts2, cb) {
        if (typeof opts2 === "function")
          return fs.appendFile(key, data, null, opts2);
        if (typeof opts2 === "string")
          opts2 = { encoding: opts2 };
        if (!opts2)
          opts2 = {};
        opts2.flags = "a";
        fs.writeFile(key, data, opts2, cb);
      };
      fs.unlink = function(key, cb) {
        if (!cb)
          cb = noop;
        ps.get(key, function(err, stat2, key2) {
          if (err)
            return cb(err);
          if (stat2.isDirectory())
            return cb(errno.EISDIR(key2));
          var clean = function(target) {
            peek(links, { start: target + "Ã¿", end: target + "Ã¿Ã¿" }, function(err2) {
              if (err2)
                return bl.remove(target, cb);
              cb();
            });
          };
          var onlink = function() {
            var target = stat2.link.slice(0, stat2.link.indexOf("Ã¿"));
            links.del(stat2.link, function(err2) {
              if (err2)
                return cb(err2);
              clean(target);
            });
          };
          ps.del(key2, listeners.cb(key2, function(err2) {
            if (err2)
              return cb(err2);
            if (stat2.link)
              return onlink();
            links.del(key2 + "Ã¿", function(err3) {
              if (err3)
                return cb(err3);
              clean(key2);
            });
          }));
        });
      };
      fs.readFile = function(key, opts2, cb) {
        if (typeof opts2 === "function")
          return fs.readFile(key, null, opts2);
        if (typeof opts2 === "string")
          opts2 = { encoding: opts2 };
        if (!opts2)
          opts2 = {};
        var encoding = opts2.encoding || "binary";
        var flag = opts2.flag || "r";
        ps.follow(key, function(err, stat2, key2) {
          if (err)
            return cb(err);
          if (stat2.isDirectory())
            return cb(errno.EISDIR(key2));
          var blob = stat2 && stat2.blob || key2;
          bl.read(blob, function(err2, data) {
            if (err2)
              return cb(err2);
            cb(null, opts2.encoding ? data.toString(opts2.encoding) : data);
          });
        });
      };
      fs.createReadStream = function(key, opts2) {
        if (!opts2)
          opts2 = {};
        var closed = false;
        var rs = fwd.readable(function(cb) {
          ps.follow(key, function(err, stat2, key2) {
            if (err)
              return cb(err);
            if (stat2.isDirectory())
              return cb(errno.EISDIR(key2));
            var blob = stat2 && stat2.blob || key2;
            var r = bl.createReadStream(blob, opts2);
            rs.emit("open");
            r.on("end", function() {
              process.nextTick(function() {
                if (!closed)
                  rs.emit("close");
              });
            });
            cb(null, r);
          });
        });
        rs.on("close", function() {
          closed = true;
        });
        return rs;
      };
      fs.createWriteStream = function(key, opts2) {
        if (!opts2)
          opts2 = {};
        var flags = opts2.flags || "w";
        var closed = false;
        var mode = opts2.mode || octal(666);
        opts2.append = flags[0] === "a";
        var ws = fwd.writable(function(cb) {
          ps.follow(key, function(err, stat2, key2) {
            if (err && err.code !== "ENOENT")
              return cb(err);
            if (stat2 && stat2.isDirectory())
              return cb(errno.EISDIR(key2));
            if (stat2 && flags[1] === "x")
              return cb(errno.EEXIST(key2));
            var blob = stat2 && stat2.blob || key2;
            ps.writable(blob, function(err2) {
              if (err2)
                return cb(err2);
              var ctime = stat2 ? stat2.ctime : /* @__PURE__ */ new Date();
              var s = {
                ctime,
                mtime: /* @__PURE__ */ new Date(),
                mode,
                type: "file"
              };
              ps.put(key2, s, function(err3) {
                if (err3)
                  return cb(err3);
                var w = bl.createWriteStream(blob, opts2);
                ws.emit("open");
                w.on("finish", function() {
                  s.mtime = /* @__PURE__ */ new Date();
                  ps.put(key2, s, function() {
                    listeners.change(key2);
                    if (!closed)
                      ws.emit("close");
                  });
                });
                cb(null, w);
              });
            });
          });
        });
        ws.on("close", function() {
          closed = true;
        });
        return ws;
      };
      fs.truncate = function(key, len, cb) {
        ps.follow(key, function(err, stat2, key2) {
          if (err)
            return cb(err);
          var blob = stat2 && stat2.blob || key2;
          bl.size(blob, function(err2, size) {
            if (err2)
              return cb(err2);
            ps.writable(key2, function(err3) {
              if (err3)
                return cb(err3);
              cb = once(listeners.cb(key2, cb));
              if (!len)
                return bl.remove(blob, cb);
              var ws = bl.createWriteStream(blob, {
                start: size < len ? len - 1 : len
              });
              ws.on("error", cb);
              ws.on("finish", cb);
              if (size < len)
                ws.write(new Buffer([0]));
              ws.end();
            });
          });
        });
      };
      fs.watchFile = function(key, opts2, cb) {
        if (typeof opts2 === "function")
          return fs.watchFile(key, null, opts2);
        return listeners.watch(ps.normalize(key), cb);
      };
      fs.unwatchFile = function(key, cb) {
        listeners.unwatch(ps.normalize(key), cb);
      };
      fs.watch = function(key, opts2, cb) {
        if (typeof opts2 === "function")
          return fs.watch(key, null, opts2);
        return listeners.watcher(ps.normalize(key), cb);
      };
      fs.notify = function(cb) {
        listeners.on("change", cb);
      };
      fs.open = function(key, flags, mode, cb) {
        if (typeof mode === "function")
          return fs.open(key, flags, null, mode);
        ps.follow(key, function(err, stat2, key2) {
          if (err && err.code !== "ENOENT")
            return cb(err);
          var fl = flags[0];
          var plus = flags[1] === "+" || flags[2] === "+";
          var blob = stat2 && stat2.blob || key2;
          var f = {
            key: key2,
            blob,
            mode: mode || octal(666),
            readable: fl === "r" || (fl === "w" || fl === "a") && plus,
            writable: fl === "w" || fl === "a" || fl === "r" && plus,
            append: fl === "a"
          };
          if (fl === "r" && err)
            return cb(err);
          if (flags[1] === "x" && stat2)
            return cb(errno.EEXIST(key2));
          if (stat2 && stat2.isDirectory())
            return cb(errno.EISDIR(key2));
          bl.size(blob, function(err2, size) {
            if (err2)
              return cb(err2);
            if (f.append)
              f.writePos = size;
            ps.writable(key2, function(err3) {
              if (err3)
                return cb(err3);
              var onready = function(err4) {
                if (err4)
                  return cb(err4);
                var i = fds.indexOf(null);
                if (i === -1)
                  i = 10 + fds.push(fds.length + 10) - 1;
                f.fd = i;
                fds[i] = f;
                listeners.change(key2);
                cb(null, f.fd);
              };
              var ontruncate = function(err4) {
                if (err4)
                  return cb(err4);
                if (stat2)
                  return onready();
                ps.put(blob, { ctime: stat2 && stat2.ctime, type: "file" }, onready);
              };
              if (!f.append && f.writable)
                return bl.remove(blob, ontruncate);
              ontruncate();
            });
          });
        });
      };
      fs.close = function(fd, cb) {
        var f = fds[fd];
        if (!f)
          return nextTick(cb, errno.EBADF());
        fds[fd] = null;
        nextTick(listeners.cb(f.key, cb));
      };
      fs.write = function(fd, buf, off, len, pos, cb) {
        var f = fds[fd];
        if (!cb)
          cb = noop;
        if (!f || !f.writable)
          return nextTick(cb, errno.EBADF());
        if (pos === null)
          pos = f.writePos || 0;
        var slice = buf.slice(off, off + len);
        f.writePos = pos + slice.length;
        bl.write(f.blob, slice, { start: pos, append: true }, function(err) {
          if (err)
            return cb(err);
          cb(null, len, buf);
        });
      };
      fs.read = function(fd, buf, off, len, pos, cb) {
        var f = fds[fd];
        if (!cb)
          cb = noop;
        if (!f || !f.readable)
          return nextTick(cb, errno.EBADF());
        if (pos === null)
          pos = fs.readPos || 0;
        bl.read(f.blob, { start: pos, end: pos + len - 1 }, function(err, read) {
          if (err)
            return cb(err);
          var slice = read.slice(0, len);
          slice.copy(buf, off);
          fs.readPos = pos + slice.length;
          cb(null, slice.length, buf);
        });
      };
      fs.fsync = function(fd, cb) {
        var f = fds[fd];
        if (!cb)
          cb = noop;
        if (!f || !f.writable)
          return nextTick(cb, errno.EBADF());
        nextTick(cb);
      };
      fs.ftruncate = function(fd, len, cb) {
        var f = fds[fd];
        if (!cb)
          cb = noop;
        if (!f)
          return nextTick(cb, errno.EBADF());
        fs.truncate(f.blob, len, cb);
      };
      fs.fchown = function(fd, uid, gid, cb) {
        var f = fds[fd];
        if (!cb)
          cb = noop;
        if (!f)
          return nextTick(cb, errno.EBADF());
        fs.chown(f.key, uid, gid, cb);
      };
      fs.fchmod = function(fd, mode, cb) {
        var f = fds[fd];
        if (!cb)
          cb = noop;
        if (!f)
          return nextTick(cb, errno.EBADF());
        fs.chmod(f.key, mode, cb);
      };
      fs.futimes = function(fd, atime, mtime, cb) {
        var f = fds[fd];
        if (!cb)
          cb = noop;
        if (!f)
          return nextTick(cb, errno.EBADF());
        fs.utimes(f.key, atime, mtime, cb);
      };
      fs.fstat = function(fd, cb) {
        var f = fds[fd];
        if (!f)
          return nextTick(cb, errno.EBADF());
        fs.stat(f.key, cb);
      };
      fs.symlink = function(target, name, cb) {
        if (!cb)
          cb = noop;
        ps.follow(target, function(err, stat2, target2) {
          if (err)
            return cb(err);
          ps.get(name, function(err2, stat3) {
            if (err2 && err2.code !== "ENOENT")
              return cb(err2);
            if (stat3)
              return cb(errno.EEXIST(name));
            ps.put(name, { type: "symlink", target: target2, mode: octal(777) }, cb);
          });
        });
      };
      fs.readlink = function(key, cb) {
        ps.get(key, function(err, stat2) {
          if (err)
            return cb(err);
          if (!stat2.target)
            return cb(errno.EINVAL(key));
          cb(null, stat2.target);
        });
      };
      fs.link = function(target, name, cb) {
        if (!cb)
          cb = noop;
        ps.follow(target, function(err, stat2, target2) {
          if (err)
            return cb(err);
          if (!stat2.isFile())
            return cb(errno.EINVAL(target2));
          ps.get(name, function(err2, st) {
            if (err2 && err2.code !== "ENOENT")
              return cb(err2);
            if (st)
              return cb(errno.EEXIST(name));
            var link = target2 + "Ã¿" + inc();
            links.put(target2 + "Ã¿", target2, function(err3) {
              if (err3)
                return cb(err3);
              links.put(link, target2, function(err4) {
                if (err4)
                  return cb(err4);
                ps.put(name, { type: "file", link, blob: target2, mode: stat2.mode }, cb);
              });
            });
          });
        });
      };
      return fs;
    };
  }
});

// node_modules/browserify-fs/index.js
var require_browserify_fs = __commonJS({
  "node_modules/browserify-fs/index.js"(exports, module) {
    var leveljs = require_level_js();
    var levelup = require_levelup();
    var fs = require_level_filesystem();
    var db2 = levelup("level-filesystem", { db: leveljs });
    module.exports = fs(db2);
  }
});

export {
  require_browserify_fs
};
/*! Bundled license information:

idb-wrapper/idbstore.js:
  (**
   * @license IDBWrapper - A cross-browser wrapper for IndexedDB
   * Version 1.7.2
   * Copyright (c) 2011 - 2017 Jens Arps
   * http://jensarps.de/
   *
   * Licensed under the MIT license
   *)

prr/prr.js:
  (*!
    * prr
    * (c) 2013 Rod Vagg <rod@vagg.org>
    * https://github.com/rvagg/prr
    * License: MIT
    *)

prr/prr.js:
  (*!
    * prr
    * (c) 2013 Rod Vagg <rod@vagg.org>
    * https://github.com/rvagg/prr
    * License: MIT
    *)

is/index.js:
  (**!
   * is
   * the definitive JavaScript type testing library
   * 
   * @copyright 2013 Enrico Marino
   * @license MIT
   *)
*/
//# sourceMappingURL=chunk-YPFVXEGD.js.map
