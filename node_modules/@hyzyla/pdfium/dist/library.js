"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PDFiumLibrary = void 0;
const pdfium_1 = __importDefault(require("./vendor/pdfium"));
const constants_1 = require("./constants");
const document_1 = require("./document");
const emscripten_1 = require("./emscripten");
/**
 * Converts a JavaScript string to a null-terminated C string and returns
 * a pointer to the allocated memory.
 *
 * Remeber to free the allocated memory using the `free` function after
 * you're done with the string.
 */
function stringToCString(module, str) {
    // Get the length of the UTF-8 string including the null terminator
    const length = (0, emscripten_1.lengthBytesUTF8)(str) + 1;
    // Allocate memory for the string
    const passwordPtr = module.wasmExports.malloc(length);
    // Copy the string to the allocated memory
    (0, emscripten_1.stringToUTF8)(str, module.HEAPU8, passwordPtr, length);
    return passwordPtr;
}
class PDFiumLibrary {
    static init() {
        return __awaiter(this, void 0, void 0, function* () {
            const module = yield (0, pdfium_1.default)();
            module._FPDF_InitLibraryWithConfig({
                version: 2,
                m_pIsolate: null,
                m_pUserFontPaths: null,
                m_v8EmbedderSlot: 0,
                m_pPlatform: null,
            });
            return new PDFiumLibrary(module);
        });
    }
    constructor(module) {
        this.module = module;
    }
    loadDocument(buff, password = "") {
        return __awaiter(this, void 0, void 0, function* () {
            const size = buff.length;
            // This line allocates a block of memory of size bytes and returns a pointer to the first byte of the block.
            //  The malloc function is a standard C library function for memory allocation, and here it's exposed via
            // this.module.asm, which likely represents the compiled WebAssembly module. The returned pointer (ptr) is
            // an integer value representing the memory location within the WebAssembly module's memory space.
            const documentPtr = this.module.wasmExports.malloc(size);
            // This line copies the content of buff into the WebAssembly module's memory starting at the address specified by ptr.
            // Here HEAPU8 is a typed array that serves as a view into the WebAssembly memory, allowing JavaScript code to read
            // and write bytes directly. The set method is used to copy the contents of an array (buff in this case) into HEAPU8
            // starting at the index ptr.
            this.module.HEAPU8.set(buff, documentPtr);
            // This line converts the password string to a null-terminated C string and returns a pointer
            // to the allocated memory. Don't forget to free the allocated memory using the free function after you're
            // done with the string.
            let passwordPtr = 0;
            if (password) {
                passwordPtr = stringToCString(this.module, password);
            }
            // This line reads the PDF document from the memory block starting at documentPtr and of size bytes.
            // If the document is password-protected, the password should be provided as a null-terminated C string.
            // The function returns a document index (handle) that can be used to interact with the document.
            const documentIdx = this.module._FPDF_LoadMemDocument(documentPtr, size, passwordPtr);
            // Handle error if the document could not be loaded
            const lastError = this.module._FPDF_GetLastError();
            if (lastError !== constants_1.FPDFErrorCode.SUCCESS) {
                switch (lastError) {
                    case constants_1.FPDFErrorCode.UNKNOWN:
                        throw new Error("Unknown error");
                    case constants_1.FPDFErrorCode.FILE:
                        throw new Error("File not found or could not be opened");
                    case constants_1.FPDFErrorCode.FORMAT:
                        throw new Error("File not in PDF format or corrupted");
                    case constants_1.FPDFErrorCode.PASSWORD:
                        throw new Error("Password required or incorrect password");
                    case constants_1.FPDFErrorCode.SECURITY:
                        throw new Error("Unsupported security scheme");
                    case constants_1.FPDFErrorCode.PAGE:
                        throw new Error("Page not found or content error");
                    default:
                        throw new Error(`PDF Loading = ${lastError}`);
                }
            }
            const document = new document_1.PDFiumDocument({
                module: this.module,
                documentPtr: documentPtr,
                documentIdx: documentIdx,
            });
            // Free the allocated memory for the password string
            if (passwordPtr !== null) {
                this.module.wasmExports.free(passwordPtr);
            }
            return document;
        });
    }
    destroy() {
        this.module._FPDF_DestroyLibrary();
    }
}
exports.PDFiumLibrary = PDFiumLibrary;
